20161207
linux上使用EDBG:
	开发板 EDGB_USB 接到linux dmesg:	
[308172.946989] usb 2-1.2: new high-speed USB device number 4 using ehci-pci
[308173.039761] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x84 has invalid maxpacket 64
[308173.039771] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x5 has invalid maxpacket 64
[308173.040772] usb 2-1.2: New USB device found, idVendor=03eb, idProduct=2111
[308173.040780] usb 2-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[308173.040785] usb 2-1.2: Product: EDBG CMSIS-DAP
[308173.040790] usb 2-1.2: Manufacturer: Atmel Corp.
[308173.040793] usb 2-1.2: SerialNumber: ATML0000004141319438
[308173.044631] hid-generic 0003:03EB:2111.000E: hiddev0,hidraw1: USB HID v1.11 Device [Atmel Corp. EDBG CMSIS-DAP] on usb-0000:00:1d.0-1.2/input0
[308173.185664] cdc_acm 2-1.2:1.1: ttyACM0: USB ACM device
[308173.186015] usbcore: registered new interface driver cdc_acm
[308173.186019] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
	直接就连上了,不用手动去装驱动文件	
	用SecureCRT连接ttyACM0:115200,8,N,1可观察输出	
linux上使用sam-ba烧录:
	开发板 A5-USB-A 接到linux dmsg:
[310103.548967] usb 1-1.2: new high-speed USB device number 17 using ehci-pci
[310103.642544] usb 1-1.2: New USB device found, idVendor=0525, idProduct=a4a7
[310103.642554] usb 1-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[310103.642560] usb 1-1.2: Product: Gadget Serial v2.4
[310103.642564] usb 1-1.2: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
[310103.649274] cdc_acm 1-1.2:2.0: ttyACM1: USB ACM device
	安装sam-ba到linux,直接atmel下载sam-ba_3.1.4-linux_x86_64.tar.gz,解压即用(cd到samba目录,./sam-ba)
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 相当麻烦,暂时放弃linux烧录
	









20161208	
尝试编译:
	make ARCH=arm sama5_defconfig
	make ARCH=arm menuconfig	//只选 sama5d4 的板子
	make ARCH=arm CROSS_COMPILE=arm-linux-
	error:
	/tmp/ccnZ9dmH.s: Assembler messages:
	/tmp/ccybbHfr.s:176: Error: garbage following instruction -- `dsb nshst'
	/tmp/ccybbHfr.s:184: Error: garbage following instruction -- `dsb nsh'
	编译器版本不对:










20161220
重新安装 sam-ba_3.1.4到ubuntu
	sudo tar -zxvf sam-ba_3.1.4-linux_x86_64.tar.gz -C /opt		//解压到/opt
	到 /opt/sam-ba_3.1.4 目录下
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加,搜索库路径:
		LD_LIBRARY_PATH=/usr/local/lib64/:$LD_LIBRARY_PATH
		export LD_LIBRARY_PATH
	source ~/.bashrc 更新用户bashrc配置 
		(如果不添加搜索库路径会出现,
		sam-ba: symbol lookup error: sam-ba: undefined symbol: _ZN7QString18toLocal8Bit_helperEPK5QChari
		等没有找到相关lib参数的错误)
	sudo cp sam-ba /bin/sam-ba	拷贝执行文件到执行文件目录下,然后就可以使用sam-ba命令了
	sam-ba 输入命令,从输出中验证是否正确安装.
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 
		安装更新的gcc工具,从而更新 C++ 库文件
		sudo add-apt-repository ppa:ubuntu-toolchain-r/test
		sudo apt-get update
		sudo apt-get install gcc-4.9 g++-4.9
然后测试:
	sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel	//测试是否链接到开发板!!
	一直提示 unknown port:	
	发现原来:sam-ba_3.1.4 /sam-ba 本身也只是一个软连接,并不是真正的执行bin文件,这不是重点
	上述安装思路:拷贝lib到系统搜索库,把执行bin拷到环境变量下,但是由于sam-ba 本身也只是一个软连接,所以最后运行功能并不完全
	比如正确的sam-ba指令,却出现各种错误,如段错误,uknown port...开始怀疑是由于搜不到其他关键配置文件或者lib文件有关!!
最后选择另外一条安装思路:
	直接把这个 /opt/sam-ba_3.1.4 路径加入到环境变量里去!!!
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
		export PATH=$PATH:/opt/sam-ba_3.1.4
	source ~/.bashrc 更新用户bashrc配置
	这样,sam-ba需要搜索什么文件都可以直接在自身路径找到!!
	再次测试,一直提示:无权访问 serial ttyACM1,加sudo,表示找不到sam-ba命令
	把/opt/sam-ba_3.1.4 路径也加入到root用户的环境变量里去
	sudo gedit /root/.bashrc 修改 root用户的.bashrc,末尾添加:
		export PATH=$PATH:/opt/sam-ba_3.1.4
	sudo source /.bashrc 更新root用户bashrc配置
	su 到root用户
	再次测试,成功!
	然而,回到常用户,加sudo,依然表示找不到sam-ba命令!!
于是发现了 root用户 不等于 加sudo的常用户 !!
	加sudo, root用户, 常用户区别:
		root用户 和 常用户 都有自己的环境变量!!
		root用户一直以最高权限执行命令,都能执行
		常用户以常规权限执行命令,不一定能执行
		常用户加sudo,并没有转变当前用户,但是可以提高到最高权限执行命令
		但是加sudo时,常用户不再使用自己的环境变量,而是转到使用secure_path的环境变量上来,
		即不使用.bashrc里修改过的环境变量
	然而,secure_path的环境变量上没有我们的sam-ba命令,所以常用户加sudo后,并没有找到命令
	解决办法是:
		要求在常用户加sudo时,不自动转变到secure_path的环境变量上去
		sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
			alias sudo='sudo env PATH=$PATH'
		source ~/.bashrc 更新常用户bashrc配置
最后,通过测试,sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel
至此,sam-ba实现所用功能!!
烧录sama5d4步骤：(测试使用的demo来自许工的linux4sam_5.3,非自己下载的更新版本的5.3)
	套上 BOOT_DIS 帽,转到SAMS5D4芯片固化程序的位置
	插上 A5-USB-A 供电，usb成功连接为AT91 USB to Serial Converter （COMx）
	取出 BOOT_DIS 帽,转到 NANDFlash 位置
	检查连接：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel //然后会检测连接到usb串口的连接情况
	擦除nandflash：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase	
注意,先 cd 到 烧录文件所在目录!!
	烧写 bootloader_1：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c writeboot:at91bootstrap-sama5d4_xplained.bin
	烧写 bootloader_2：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-sama5d4-xplained.bin:0x40000
	烧写 env (包含commandline/bootargs)：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-env-sama5d4-xplained.bin:0xC0000
	烧写 device tree block 表：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:at91-sama5d4_xplained.dtb:0x180000
	烧写 kernel：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:zImage-sama5d4-xplained.bin:0x200000
	烧写 rootfs：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
镜像组合烧写命令:(注意,先 cd 到 烧录文件所在目录!!)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:u-boot-env-sama5d4-xplained.bin:0xC0000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage-sama5d4-xplained.bin:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000

开pr_debug
例子:打开 i2c模块的 pr_debug:
1,查看:
	drivers/i2c/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	drivers/i2c/busses/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	表示支持 debug
	(注意:ccflags-y  := -DDEBUG	//相当于给mfd目录下的所有文件都加上了 (#define DEBUG))
2,打开.config观察:
	# CONFIG_I2C_DEBUG_BUS is not set
	# CONFIG_I2C_DEBUG_BUS is not set
	表示之前编译的没有打开!!
3,make ARCH=arm menuconfig
	Device Drivers -> I2C support ->
		(*)I2C Core debugging message
		(*)I2C Bus debugging message
	打开重新生成的.config观察
		# CONFIG_I2C_DEBUG_BUS=y
		# CONFIG_I2C_DEBUG_BUS=y
	表示打开了!!
4,include/linux/printk.h中:修改:
	//#define CONSOLE_LOGLEVEL_DEFAULT 7 
	#define CONSOLE_LOGLEVEL_DEFAULT 8 
	由于这样设置的 pr_debug 使用printk(KERN_DEBUG...)
	而printk(KERN_DEBUG...)的级别是7,#define CONSOLE_LOGLEVEL_DEFAULT 7 表示,只打印 小于级别7的消息
	所以改为: #define CONSOLE_LOGLEVEL_DEFAULT 8
5,重新编译(烧录并测试成功!!)
6,补充:
	pr_debug()在include/linux/printk.h 定义,按道理驱动文件中加入(#incude <linux/kernel.h>)就可以使用
	pr_debug()其实可以设置为两种模式,上述只是设置成静态模式(kernel初始化时可以输出消息)










20161221
备份烧写命令:
组合烧写：(不烧写env ，这样可以使用默认的uboot命令，自编译 zImage + dtb + ubifs + uboot + at91bootstrap)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
只刷新 zImage + dtb
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只刷新 zImage
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000

编译完自动拷贝zImage到/demo
arch/arm/boot/Makefile:
$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
	$(call if_changed,uimage)
	@$(kecho) '  Image $@ is ready'
	cp $(obj)/uImage /home/infortech-ubuntu-1404/SAMA5D4/demo/		//编译完自动拷贝文件到demo

给 atmel_hlcdc 加入 pr_debug
1,先改 platform_driver_的注册
	原来:!!module_platform_driver(atmel_hlcdc_driver);
	先观察:
	printk.h
	/* If you are writing a driver, please use dev_dbg instead */
	#if defined(CONFIG_DYNAMIC_DEBUG)
	/* dynamic_pr_debug() uses pr_fmt() internally so we don't need it here */
	#define pr_debug(fmt, ...) \
		dynamic_pr_debug(fmt, ##__VA_ARGS__)
	#elif defined(DEBUG)
	#define pr_debug(fmt, ...) \
		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)	//静态模式的pr_debug
	#else
	#define pr_debug(fmt, ...) \
		no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
	#endif
	
	Platform_device.h
	#define module_platform_driver(__platform_driver) \
		module_driver(__platform_driver, platform_driver_register, \
				platform_driver_unregister)
	#define platform_driver_register(drv) \
		__platform_driver_register(drv, THIS_MODULE)
	void platform_driver_unregister(struct platform_driver *drv)
	{
		driver_unregister(&drv->driver);
	}
	
	device.h
	#define module_driver(__driver, __register, __unregister, ...) \
	static int __init __driver##_init(void) \
	{ \
		return __register(&(__driver) , ##__VA_ARGS__); \	//注意platform_driver_register只有一个参数,__VA_ARGS__不用管
	} \
	module_init(__driver##_init); \
	static void __exit __driver##_exit(void) \
	{ \
		__unregister(&(__driver) , ##__VA_ARGS__); \		//注意platform_driver_unregister只有一个参数,__VA_ARGS__不用管
	} \
	module_exit(__driver##_exit);
然后修改:!!
	atmel-hlcdc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int __init atmel_hlcdc_driver_init(void) 
	{
		pr_debug("atmel-hlcd platform-driver registered !!")	//添加打印项!!
		return platform_driver_register(&atmel_hlcdc_driver);	
	}
	module_init(atmel_hlcdc_driver_init);
	static void __exit atmel_hlcdc_driver_exit(void)
	{
		platform_driver_unregister(&atmel_hlcdc_driver);
	}
	module_exit(atmel_hlcdc_driver_exit);
	
	drivers/mfd/Ｍakefile加入:
	ccflags-y  := -DDEBUG		//相当于给mfd目录下的所有文件都加上了 (#define DEBUG)
	经测试成功启动打印!!

然后开启 hlcd 的 dts !!!
	atmel-hlcdc.c 添加
	static int atmel_hlcdc_probe(struct platform_device *pdev)
	{	
	....
		//by william
		pr_debug("atmel-hlcdc probe start !!\n ")	//添加probe打印项!!
		....
	at91-sama5d4_xplained.dts添加:
		...
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
				};
			.....
	编译dtb!! (直接使用make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 编译内核命令就可以自动更新stb了!!)
	只刷新 zImage + dtb 成功打印,即成功添加 hlcdc 的 platform_device!!

再给 atmel_hlcdc_dc 加入 pr_debug
	atmel-hlcdc_dc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int atmel_hlcdc_dc_drm_probe(struct platform_device *pdev)
	{
		//by william
		pr_debug("atmel-hlcdc-dc probe start !!\n");
		.......
	drivers/gpu/Makefile加入:	//失败操作
	ccflags-y  := -DDEBUG		//相当于给gpu目录下(不包括多级子目录下的文件)的所有文件都加上了 (#define DEBUG) 
					//所以这样并没有成功添加 pr_debug()
	drivers/gpu/drm/atmel-hlcdc/Makefile加入:	//正确操作
	ccflags-y  := -DDEBUG				//相当于给atmel-hlcdc目录下的所有文件都加上了 (#define DEBUG) 
	经测试成功启动打印!!	
				
分析 atmel-hlcdc_probe!!
	atmel_hlcdc 是一个mfd设备(复合设备),包含atmel-hlcdc-dc设备, 和pwm-atmel-hlcdc设备!!
	重点结构体:
	static const struct mfd_cell atmel_hlcdc_cells[] = {
		{
			.name = "atmel-hlcdc-pwm",
			.of_compatible = "atmel,hlcdc-pwm",
		},
		{
			.name = "atmel-hlcdc-dc",
			.of_compatible = "atmel,hlcdc-display-controller",
		},
	};
	struct atmel_hlcdc_regmap {
		void __iomem *regs;
	};
	struct atmel_hlcdc {
		struct regmap *regmap;
		struct clk *periph_clk;
		struct clk *sys_clk;
		struct clk *slow_clk;
		int irq;
	};
atmel-hlcdc_probe 流程:
	分配一个 struct atmel_hlcdc_regmap 空间内存 *hregmap	//devm_kzalloc
	分配一个 struct atmel_hlcdc 空间内存 *hlcdc
	初始化 atmel_hlcdc:
		获取resource,然后把得到指针给 hregmap->regs
			(补充:platform_get_resource(pdev, IORESOURCE_MEM, 0); IORESOURCE_MEM表示获取的就是dt节点node 的reg内容)
		获取中断号
		在操作clock前,先获取对应的 struct clk 指针:	//devm_clk_get
			periph_clk,
			sys_clk,
			slow_clk,
		初始化 atmel-hlcdc_regmap,返回指针		//devm_regmap_init
	把 atmel_hlcdc 这个数据的指针 挂入 dev->driver_data	//dev_set_drvdata, 
								//注意旧版kernel是挂入private_data的,4.1 kernel 的 struct device 变化了.
	hlcdc是一个复合设备,所以,接下来初始化子设备:		//mfd_add_devices -> mfd_add_device
		就是根据当前 struct mfd_cell 即atmel_hlcdc_cells[] 初始化 子设备的platform_device结构,
		然后通过 platform_device_add 注册到 platform_bus !!

注册了子设备atmel-hlcd-dc(display-control)的platform_device到platform_bus,自然就要执行对应的probe!!,分析:
	知识补充:	
	drm 是一个 GPU 显示框架!!,在内核级别提供内存管理，中断处理， DMA控; 为应用程序提供统一的操作接口
	重点结构体:
	static struct drm_driver atmel_hlcdc_dc_driver = {
		.driver_features = DRIVER_HAVE_IRQ | DRIVER_GEM |
				   DRIVER_MODESET | DRIVER_PRIME |
				   DRIVER_ATOMIC,
		.preclose = atmel_hlcdc_dc_preclose,
		.lastclose = atmel_hlcdc_dc_lastclose,
		.irq_handler = atmel_hlcdc_dc_irq_handler,
		.irq_preinstall = atmel_hlcdc_dc_irq_uninstall,
		.irq_postinstall = atmel_hlcdc_dc_irq_postinstall,
		.irq_uninstall = atmel_hlcdc_dc_irq_uninstall,
		.get_vblank_counter = drm_vblank_count,
		.enable_vblank = atmel_hlcdc_dc_enable_vblank,
		.disable_vblank = atmel_hlcdc_dc_disable_vblank,
		.gem_free_object = drm_gem_cma_free_object,
		.gem_vm_ops = &drm_gem_cma_vm_ops,
		.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
		.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
		.gem_prime_import = drm_gem_prime_import,
		.gem_prime_export = drm_gem_prime_export,
		.gem_prime_get_sg_table = drm_gem_cma_prime_get_sg_table,
		.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
		.gem_prime_vmap = drm_gem_cma_prime_vmap,
		.gem_prime_vunmap = drm_gem_cma_prime_vunmap,
		.gem_prime_mmap = drm_gem_cma_prime_mmap,
		.dumb_create = drm_gem_cma_dumb_create,
		.dumb_map_offset = drm_gem_cma_dumb_map_offset,
		.dumb_destroy = drm_gem_dumb_destroy,
		.ioctls	= atmel_ioctls,
		.num_ioctls= ARRAY_SIZE(atmel_ioctls),
		.fops = &fops,
		.name = "atmel-hlcdc",
		.desc = "Atmel HLCD Controller DRM",
		.date = "20141504",
		.major = 1,
		.minor = 0,
	};
	struct drm_device {
		....
		struct device *dev;
		char *unique;				/**< unique name of the device */
		/*
		 * At load time, disabling the vblank interrupt won't be allowed since
		 * old clients may not call the modeset ioctl and therefore misbehave.
		 * Once the modeset ioctl *has* been called though, we can safely
		 * disable them when unused.
		 */
		bool vblank_disable_allowed;
		/*
		 * If true, vblank interrupt will be disabled immediately when the
		 * refcount drops to zero, as opposed to via the vblank disable
		 * timer.
		 * This can be set to true it the hardware has a working vblank
		 * counter and the driver uses drm_vblank_on() and drm_vblank_off()
		 * appropriately.
		 */
		bool vblank_disable_immediate;
		/* array of size num_crtcs */
		struct drm_vblank_crtc *vblank;
		spinlock_t vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
		spinlock_t vbl_lock;
		u32 max_vblank_count;           /**< size of vblank counter register */
		/**
		 * List of events
		 */
		struct list_head vblank_event_list;
		spinlock_t event_lock;
		struct platform_device *platformdev; /**< Platform device struture */
		......
	};
	static const struct of_device_id atmel_hlcdc_of_match[] = {
		.........
		{
			.compatible = "atmel,sama5d4-hlcdc",
			.data = &atmel_hlcdc_dc_sama5d4,
		},
		{ /* sentinel */ },
	};
	static const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sama5d4 = {
		.min_width = 0,
		.max_width = 2048,
		...//详细见 atmel_hlcdc_dc.c
	};
	struct device {
		struct device *parent;
		struct device_private *p;
		struct device_node of_node;	//解压 dtb 后,存储device tree 节点的数据结构!!!
		.....
	};
	struct device_node {			//解压 dtb 后,存储device tree 节点的数据结构!!!
		const char *name;
		const char *type;
		phandle phandle;
		const char *full_name;
		struct fwnode_handle fwnode;
		struct	property *properties;
		struct	property *deadprops;	/* removed properties */
		struct	device_node *parent;
		struct	device_node *child;
		struct	device_node *sibling;
		struct	kobject kobj;
		unsigned long _flags;
		void	*data;
	#if defined(CONFIG_SPARC)
		const char *path_component_name;
		unsigned int unique_id;
		struct of_irq_controller *irq_trans;
	#endif
	};
	struct atmel_hlcdc_dc {
		const struct atmel_hlcdc_dc_desc *desc;
		struct atmel_hlcdc *hlcdc;
		struct drm_fbdev_cma *fbdev;
		struct drm_crtc *crtc;
		struct atmel_hlcdc_planes *planes;
		struct atmel_hlcdc_layer *layers[ATMEL_HLCDC_MAX_LAYERS];
		struct workqueue_struct *wq;
		struct {
			wait_queue_head_t wait;
			bool pending;
		} commit;
	};
atmel-hlcdc-dc_probe 流程:			//atmel_hlcdc_dc_drm_probe
	分配一个 drm_device 空间内存 *ddev	//drm_dev_alloc
	初始化 ddev
		设置这个drm设备的唯一设备名		//drm_dev_set_unique
		加载初始化 atmel-hlcdc-dc 到ddev	//atmel_hlcd_dc_load (包括了atmel-hlcdc-dc的platform_device注册?)
		注册ddev到 drm框架?		//drm_dev_register
		注册对应的用户空间接口到drm框架?	//atmel_hlcdc_dc_connector_plug_all -> drm_connector_register
atmel_hlcd_dc_load 分析!!!
	匹配 hlcdc 的 compatible (注意不是 hlcd_dc 的 compatible)!!
	分配一个 atmel_hlcd_dc 空间内存 *dc	//devm_kzalloc
	初始化 dc
		建立一个工作队列名为atmel-hlcdc-dc	//dc->wq = alloc_ordered_workqueue(...)
		初始化等待队列				//init_waitqueue_head()
		dc->desc = match->data;
		dc->hlcdc = dev_get_drvdata(dev->dev->parent);
		ddev->dev_private = dc;			//源码是dev->dev_private = dc;实际上dev对应上述分析的 ddev
		启动periph_clk				//clk_prepare-enable -> clk_enable( 奇怪是在不到clk_enable源码!!)
							//clk_enable 没个厂家都有自己的clk_enable,找不到at91架构的!!!
	启动 atmel_hlcd_dc 电源管理(PM)		//pm_runtime_enable
	drm_vblank初始化			//drm_vblank_init	vblank显示完前帧图案与开始显示下一帧团之间的中间过程!!
	设置 atmel_hlcd_dc			//atmel_hlcdc_dc_modeset_init (关于芯片硬件模块寄存器的初始化了???)
	重置 drm 模式 ???			//drm_mode_config_reset
	初始化 drm_irq ???			//drm_irq_install
	把驱动数据挂入ddev			//platform_set_drvdata
	初始化,使能 output polling???		//drm_kms_helper_poll_init	窗口显示激活
	检测 是否发现热插拔设备???			//drm_helper_hpd_irq_event		
	(未完待续,下一天的开发log讨论!!>>>) 	










20161223
先补充 linux drm(direct rending manager) 设备的框架知识!!
	过去.用户程旭,直接操显卡设备来显示图像,这样,用户程序含大量针对特定显卡的接口程序,不利于移植,
	现在,linux建议使用自身提供的 抽象出的 drm设备驱动 来做访问操作显卡的工作,而drm面向用户程序则提供统一的ioctl接口, 
		这样,就更方便用户程序的移植,也对各种厂商的显卡操作有统一的管理
	DRM提供两类 ioctl 行为:GEM(Graphics Execution Manager),KMS(Kernel Mode-Setting)
	GEM针对 Framebuffer(显存)管理,
		如显存的申请释放 (Framebuffer managing)，显存共享机制 (Memory sharing objects)，及显存同步机制 (Memory synchronization)
	KMS 主要是完成显卡配置 (Display mode setting)
	atmel-hlcdc文件中,哪些对应KMS, 哪些对应GEM?
		atmel_hlcdc_crtc.c atmel_hlcdc_dc.c atmel_hlcdc_layer.c atmel_hlcdc_output.c atmel_hlcdc_plane.c
	显卡主要是由三类设备组成：
		Processing logic 指的是神秘的 GPU 模块，
		Display controller 指的是 LCDC 控制器，
		Hardware video acceleration 指的就是具体的显示接口 HDMI / eDP / … 
	DRM KMS 对于显卡设备驱动有三个概念 CRTC / Encoder / Connector,
		CRTC 就是指 Display Controller,CRTC 的常用行为如下：
      			DPMS (Display Power Manage System) 电源状态管理 (crtc_funcs->dpms)
			将 Framebuffer 转换成标准的 LCDC Timing ，其实就是一帧图像刷新的过程（crtc_funs->mode_set）
			帧切换，即在 VBlank 消影期间，切换 Framebuffer（crtc_funcs->page_flip）
			Gamma 校正值调整（crtc_funcs->gamma_set）
		Encoder 就是指具体接口驱动 eDP / HDMI,Encoder 的常用行为如下：
			DPMS (Display Power Manage System) 电源状态管理 (encoder_funcs->dpms)
			将 VOP 输出的 lcdc Timing 打包转化为对应接口时序 HDMI TMDS / … (encoder_funcs->mode_set)
		Connector 指的是具体外接的屏幕 Monitor / Panel。Connector 的常用行为如下：
			获取上报 热拔插 Hotplug 状态
			读取并解析屏 (Panel) 的 EDID 信息
	drm 其他概念:
		pagefilp:帧刷屏
		plane:	(drm 的plane相当与,芯片上的图层,plane是drm软件架构上的图层,具有广泛意义!!,overlay是芯片硬件上的图层,)
			(由于实现的功能类似,所以这里的 plane 一般直接映射 硬件的overlay )
			(所以可以说,plane 是 芯片layer 与 linux-drm模块 的接口)
			A plane represents an image source that can be blended with 
			or overlayed on top of a CRTC during the scanout process
		CRTC:	A CRTC is an abstraction representing a part of the chip that contains a pointer to a scanout buffer
	简单以 HDMI Monitor 显示的过程为例，实例解析下 CRTC / Encoder / Connector 的行为：
		1. 首先 HDMI 驱动检测到电视 Plugin 信号，读出电视的 EDID 信号，获取电视的分辨率信息 (DRM Connector)。
		2. Userspace 将需要显示的数据填充在 framebuffer 里面，然后通过 libdrm 接口通知 VOP 设备开始显示。
		3. 接着 VOP 驱动将 framebuffer 里面的数据转换成标准的 LCDC Timing 时序 (DRM CRTC)。
		4. 同时 HDMI 驱动将 HDMI 硬件模块的 LCDC 时序配置与 VOP 输出时序一致，
		   准备将输入的 LCDC Timing 转化为电视识别的 HDMI TMDS 信号 (DRM Encoder)。
补充 linux runtime PM 框架知识!!
	(未完)
补充 sama5d4 lcdc 框架知识!!
	datasheet:page668 寄存器列表
	datasheet:page633表示:
		图像数据通过 DEAG: DMA Engine Address Generation 流入 各layer图层
		各layer图层再经过 GAB: Global Alpha Blender 混合成图片,
		然后通过硬件时序模块输出如rgb信号到lcd屏从而成像!!!
	The LCD module integrates the following digital blocks:(基本重点模块简介)
		DMA Engine Address Generation (DEAG)—This block performs data prefetch and requests access to the AHB interface.
		Input Overlay FIFO—Stores the stream of pixels
		Color Lookup Table (CLUT)—These 256 RAM-based lookup table entries are selected 
		 	when the color depth is set to 1, 2, 4 or 8 bpp.
		Chroma Upsampling Engine (CUE)—This block is selected when the input image sampling format is YUV (Y’CbCr) 4:2:0 
			and converts it to higher quality 4:4:4 image.
		Color Space Conversion (CSC)—changes the color space from YUV to RGB
		Two Dimension Scaler (2DSC)—Resizes the image
		Global Alpha Blender (GAB)—Performs programmable 256-level alpha blending
		Output FIFO—Stores the blended pixel prior to display
		LCD Timing Engine—Provides a fully programmable HSYNC-VSYNC interface
	The DMA controller reads the image through the AHB master interface. The LCD controller engine formats the
		display data, then the GAB performs alpha blending if required, and writes the final pixel into the output FIFO. The
		programmable timing engine drives a valid pixel onto the LCD_DAT[23:0] display bus.
	Input FIFO:	the LCD module includes one input FIFO per overlay. These input FIFOs are used to buffer the AHB burst and
		serialize the stream of pixels.
	Output FIFO:	The LCD module includes one output FIFO that stores the blended pixel.
	
	layer(图层),有如下几层: 
		overlay1(覆盖层1,即图层1)
		overlay2(覆盖层2,即图层2)
		base layer(基础层)
		high end Overlay(高端图层)
		每个图层都可以选择存放color lookup table 或者 RGB 编码的像素点pix图像
		而高端图层更可以选择 yuv 编码的像素点的图像
	GAB: Global Alpha Blender(alpha搅拌器,即图层混合器)
紧接之前分析:atmel_hlcd_dc_load 里对硬件的初始化应该集中在 atmel_hlcdc_dc_modeset_init:
	设置 drm 相关参数?		//drm_mode_config_init
		INIT_LIST_HEAD(&dev->mode_config.fb_list);
		INIT_LIST_HEAD(&dev->mode_config.crtc_list);
		INIT_LIST_HEAD(&dev->mode_config.connector_list);
		INIT_LIST_HEAD(&dev->mode_config.encoder_list);
		INIT_LIST_HEAD(&dev->mode_config.property_list);
		INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
		INIT_LIST_HEAD(&dev->mode_config.plane_list);
		idr_init(&dev->mode_config.crtc_idr);
		idr_init(&dev->mode_config.tile_idr);
	建立 outputs 设备??		//atmel_hlcdc_create_outputs(其实就是发现hlcd-display-controler的子设备节点 port 接口,并初始化!!)
	建立 planes ??			//atmel_hlcdc_create_planes
		设置layer
	建立 crtc ??			//atmel_hlcdc_crtc_create
	设置 mode_config_funcs		//ddev->mode_config.funcs = &mode_config_funcs;
		static const struct drm_mode_config_funcs mode_config_funcs = {
			.fb_create = atmel_hlcdc_fb_create,
			.output_poll_changed = atmel_hlcdc_fb_output_poll_changed,
			.atomic_check = drm_atomic_helper_check,
			.atomic_commit = atmel_hlcdc_dc_atomic_commit,
		};
快速查找出错处!! 对比输出错误码ret 与 errno.h里的数据
怀疑 hdmi 与 drm 有关系,于是查看了资料,发现:
	sama5d4并没有hdmi模块,而是通过外接 sil9022 芯片 把 rgb777 信号转为 hdmi信号输出,而sil9022也是通过i2c与sama5d4通讯
	也就是说,hdmi不是芯片自己实现的,还是需要类型\cd信号输出然后通过转换芯片转换
所以参考hdmi的dts,试写lcd信号的设备树信息
	出现错误!! failed to create HLCDC outputs: -517
	加 pr_debug 和对比 hdmi_dts发现是hdmi_dts的 of_drm_find_bridge 正确输出!! 











20161226
补充:裸屏参数!!
	800 X 480 pixel
	108(H) X 64.8(V) mm
	each pixel: 0.135(H) x 0.135(V) mm
	DotCLK: 33.36MHZ
	FRAME frequency: 60 hz
	lcd_power: 3.3V	  110mA   363mW
	backlight: 23.1V  40ma	  924mW 
继续挖掘 DRM 有用信息!!!

继承试写 lcd dts节点 ,
	发现,之前atmel_create_uotputs失败,是因为 atmel_hlcdc_check_endpoint失败!!,然而换作预装hdmi的dts时,却成功!!
	原来hdmi的dts里 的 sil9022节点模块,使用了 drm_bridge_add(),所以 atmel_hlcdc_check_endpoint->of_drm_find_bridge 正确输出 
	所所谓的 bridge 可以理解为 drm 的 encoder 
	不使用 sil9022模块的我们应该如何修改 ??
	从 check_endpoint 看到了,除了 bridge 匹配的方式外,还有 panel 匹配方式, 
	查看代码,发现drm/panel被编译了,也就说,可以尝试在这里添加 信息,用于匹配!!
先pannel 添加 pr_debug:
	panel/Makefile: 添加 ccflags-y := -DDEBUG
	panel-simple.c 添加:
	#include <linux/kernel.h>
	然后就可以在要检测的地方加pr_debug
再次改写dts!!
	panel-simple.c 添加:
	static const struct drm_display_mode atmel_lcd_display_control_mode = {
		.clock = 33260,
		.hdisplay = 800,
		.hsync_start = 800 + 168,
		.hsync_end = 800 + 168 + 64,
		.htotal= 800 + 168 + 64 + 88,
		.vdisplay = 480,
		.vsync_start = 480 + 37,
		.vsync_end = 480 + 37 + 2,
		.vtotal = 480 + 37 + 2 + 8,
		.vrefresh = 60,
	};
	
	static const struct panel_desc atmel_lcd_display_control = {
		.modes = &atmel_lcd_display_control_mode,
		.num_modes = 1,
		.bpc = 8,
		.size = {
			.width = 108,
			.height = 65,
		},
		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
	};

	static const struct of_device_id platform_of_match[] = {
		...
		{
		//by william
		.compatible = "atmel,lcd-display-control",
		.data = &atmel_lcd_display_control,
		},
		...
	}
	dts添加: (参考sama5d3xdm.dtsi)
	/{
		........
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
	
					hlcdc-display-controller {
						pinctrl-names = "default";
						pinctrl-0 = <&pinctrl_lcd_base &pinctrl_lcd_rgb888>;
	
						port@0 {
							hlcdc_panel_output: endpoint@0 {
								reg = <0>;
								remote-endpoint = <&panel_input>;
							};
						};
					};
				};
				........
			};
			......
		};
			....
		backlight: backlight {
			compatible = "pwm-backlight";
			pwms = <&hlcdc_pwm 0 50000 0>;
			brightness-levels = <0 4 8 16 32 64 128 255>;
			default-brightness-level = <6>;
			power-supply = <&bl_reg>;
			status = "okay";
		};
	
		bl_reg: backlight_regulator {
			compatible = "regulator-fixed";
			regulator-name = "backlight-power-supply";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			status = "okay";
		};
	
		panel: panel {
			compatible = "atmel,lcd-display-control", "simple-panel";
			backlight = <&backlight>;
			power-supply = <&panel_reg>;
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";
	
			port@0 {
				#address-cells = <1>;
				#size-cells = <0>;
	
				panel_input: endpoint@0 {
					reg = <0>;
					remote-endpoint = <&hlcdc_panel_output>;
				};
			};
		};
	
		panel_reg: panel_regulator {
			compatible = "regulator-fixed";
			regulator-name = "panel-power-supply";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			status = "okay";
		};
	};	
	成功跳过错误,并 DRM device successfully registered  
	但未接屏幕测试.
	发生了一次奇怪现象: panel-simple-probe 独立执行了两次!!!执行了两次atmel-hlcdc-dc_probe!!独立执行了三次
	多次调用直到把功能初始化了的机制是什么?
	为什么,第一次 panel-simple-probe 会运行到一般断掉后面也没有恢复,而下一次却重新panel-simple-probe却完整执行??
	没有时钟信号输出 !!
搭建tftp服务器,以便于日后往开发板烧录测试文件!!
	1.安装tftp的服务端和客户端：
		sudo apt-get install tftpd-hpa ；安装tftp服务端
		sudo apt-get install tftp-hpa   ；安装tftp客户端
	2.安装xinetd:	sudo apt-get install xinetd：支持对tcp、udp、RPC服务的东东
	3.mkdir ~/tftpboot
		释放权限：sudo chmod 777 ~/tftpboot
	4.配置TFTP服务器,编辑tftpd-hpa：	sudo gedit /etc/default/tftpd-hpa
	# /etc/default/tftpd-hpa
	TFTP_USERNAME="tftp"
	TFTP_DIRECTORY="/home/infortech-ubuntu-1404/tftpboot"
	TFTP_ADDRESS="0.0.0.0:69"
	TFTP_OPTIONS="--secure"
	5.重启xinetd服务:	sudo /etc/init.d/xinetd restart
	6.重启tftpd服务:	sudo /etc/init.d/tftpd-hpa restart
开发板tftp命令:
	tftp -gl 文件名 服务器ip	(tftp -gl text.txt 192.168.105.117)	//下载文件到开发板!!











20161227
昨日添加了panel后初始化驱动成功,但是示波器检测排口发现没有输出!!
	开了 bootup_logo 测试输出,发现没有输出!!
	网上发现还要开framebuffer console !! 开后 lcd排针有输出
	修改 panel-simple.c 的帧参数,发现相应改变了 vs hs clk 的输出频率,但是,并没有完全适配等同panel上设置的参数!!!!!!
测试fb设备功能!!!编写一个简单的显示程序!!!
	ubuntu jpg 转换 bmp :
		sudo apt-get install Imagemagick
		convert filename.jpg filename.bmp	//简单转换
		如果你使用JPEG等大小和图片质量有关的图形格式化，可以使用-quality参数。参数的数值在0至100之间，数值越大文件越大，
		通常情况下，60-80就可以了，譬如：convert -quality 80 filename.bmp filename.jpg
workqueue学习:
	关于workqueue 与 per-cpu的worker thread 的关系!!! (面向多核多线程的芯片,即多cpu芯片)
	struct workqueue_struct {
	    struct cpu_workqueue_struct *cpu_wq; －－－－－per-cpu work queue struct
	    struct list_head list; －－－workqueue list
	    const char *name;
	    int singlethread; －－－－single thread or multi thread
	    int freezeable;  －－－－和电源管理相关的一个flag
	}; 
	    struct cpu_workqueue_struct {
	
	        spinlock_t lock; －－－－用来保护worklist资源的访问
	
	        struct list_head worklist;
	        wait_queue_head_t more_work; －－－－－等待队列头
	        struct work_struct *current_work; －－－－当前正在处理的work
	
	        struct workqueue_struct *wq; －－－－－－指向work queue struct
	        struct task_struct *thread; －－－－－－－worker thread task
	
	        int run_depth;        /* Detect run_workqueue() recursion depth */
	    } ____cacheline_aligned;
	假如用户创建了一个 workqueue 就有一个 workqueue_struct !!
		workqueue_struct 里有一个 struct cpu_workqueue_struct 指针,
		这个指针应该是指向 一个 struct cpu_workqueue_struct[] 队列的,(per cpu分配的)
		每个struct cpu_workqueue_struct[] 队列成员面向对应的cpu,对应的worker thread,也只能被指定的cpu访问!! 
	一般而言，当创建一个workqueue的时候会为每一个系统内的processor创建一个内核线程，该线程处理本cpu调度的work。
	每个挂入workqueue的work都据实际情况在哪一个cpu上被调度，就挂入哪一个worker thread(即某个struct cpu_workqueue_struct队列成员)
	调度work执行有两个接口，
		一个是schedule_work，将work挂入系统默认workqueue（keventd_wq），
		另外一个是queue_work，可以将work挂入指定的workqueue
	到底插入workqueue的哪一个worker thread呢？这是由wq_per_cpu定义的：
		static struct cpu_workqueue_struct *wq_per_cpu(struct workqueue_struct *wq, int cpu)
		{
 	       	if (unlikely(is_single_threaded(wq)))
        		    cpu = singlethread_cpu;
        		return per_cpu_ptr(wq->cpu_wq, cpu);
		}
		普通情况下，都是根据当前的cpu id，通过per_cpu_ptr获取cpu_workqueue_struct的数据结构，对于single thread而言，cpu是固定的。 
	不管是否是single thread workqueue，worker thread（cpu_workqueue_struct）的数据结构总是per cpu分配的（稍显浪费），
		不过实际上对于single thread workqueue而言，
		只会使用其中的一个cpu,(其中的一个worker thread,其中的一个struct cpu_workqueue_struct[] 队列成员)
Concurrency Managed Workqueue 与 旧的workqueue 比较
	接口API
		1、初始化work的接口保持不变，可以静态或者动态创建work。
		2、调度work执行也保持和旧的workqueue一致。
		3、创建workqueue。和旧的create_workqueue接口不同，CMWQ采用了alloc_workqueue这样的接口符号，	
	旧:
		用户每建立一个 新workqueue 都会马上为每个cpu都新建一个新的work thread 线程
		所以每个workqueue 都有一组work thread,( 一个struct cpu_workqueue_struct[] 队列)
		并发处理问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个work thread 线程),
			四个work只能排队串行执行
	Concurrency Managed:
		workqueue 与work_thread 概念分开!!
		用户每建立一个 新workqueue 不会为每个cpu都新建一个新的work thread 线程
		但是 引入了woeker pool 概念,worker pool 独立于workqueue
		每个cpu都只有一个 worker pool,
		每个加入到 workqueue 的 work,都会动态随机第地挂入 其中一个worker pool ,work只是与workqueue有联系
		但是work到底安排到 那条线程里执行是不是分配一条新的线程执行,什么时候执行,由worker pool 自己执行决定!!
		解决并发问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个worker pool),
			四个work可行执行,
			例如,a运行过程中遇到阻塞,woker pool可以另外生成一条新线程执行b,c,d
			b遇阻塞时,同理另外建新线程执行c,d
grep 使用技巧:
	grep “字符串” *            如果要搜索的目录下没有目录的话，完全不用加参数
	grep -r “字符串” *        如果有目录，-r可以递归搜索，好像-R也可以，而且man手册还区分了，可能在符号链接上有什么区别，但是没有试验过
	grep -i “字符串” *        忽略字符串中的大小写
	grep -n "字符串" *       列出字符串所在文件的行号，结合vim 文件 +行号 打开文件很有用
	在grep实际使用中，可能还会结合转义字符\，比如带“->“的，就需要搜索时加转义”\->“不然搜不到的。反正有时候搜索带通用匹配符而又搜不到结果时， 
	例子:grep -rin "samsung" 
find命令:	
	find . | grep "vt.c"	//列出文件名含 vt.c 字符 文件路径 
终端中的复制/粘贴: Shift+Ctrl+C:复制 Shift+Ctrl+V:粘贴











20161228
昨日打开了framebuffer console 后信号针有输出,意味着应该能够看到bootup_logo
	昨日编译的zImage配上官方hdmi.dtb 接入大电视,过看到图片和图标,
	今天的lcd转接板也能正常工作!!!但偏暗!!! 开发板供电不足够? 开发板backlight 电路有问题?
网上下载显示bmp软件的用户程序,成功编译,输出信号!! 没有显示企鹅logo???
此外 lcd 过一段时间会自动熄灭,但是插入 鼠标键盘触发后,又重新显示!!
在 uboot 的默认 bootargs 里添加 console=tty0, 重刷uboot 有部分开机启动信息在lcd屏上输出!!!
依然没有显示 bootup logo !!!
屏幕 算作 成功显示!! 下一步,启动触摸模块!!!!
芯片adc知识,使用四线touchscreen模式!!
	ADC AD0/XP PC27 X1
	ADC AD1/XM PC28 X1
	ADC AD2/YP PC29 X1
	ADC AD3/YM PC30 X1  
初学 linux clock 子系统:
	系统启动过程中，什么时候开始有tick？
		多核系统，BSP首先启动，在其初始化过程中会调用time_init，这里会启动clocksource的初始化过程。
		这时候，周期性的tick就会开始了。在某个阶段，其他的processor会启动，然后会注册其自己的local timer，
		这样，各个cpu上的tick就都启动了。 
	所谓per cpu就是说每个cpu都会维护属于一个自己的对象。例如，对于tick device，每个CPU都会维护自己的tick device













20161229
启动adc-touchscreen
	有两个文件:at91_adc.c,和atmel-sama5d2_adc.c
	at91_adc.c针对通用芯片, atmel-sama5d2_adc.c只针对sama5d2这一款芯片
	sama5d4 使用 at91_adc.c
按dts指导txt修改dts,貌似成功初始化了触摸屏,但是:
	使用测试程序时,貌似 阻塞在读函数
	点击触摸屏什么也没发生!!!
	发现,触摸屏只对应逻辑设备文件是 /dev/input/touchscreen0
		因为打开 touchscreen0 时会调用: atmel_ts_open()
	发现重点:struct at91_adc_caps->has_tsmr //only at91sam9x5,sama5d3 有 TSMR reg 
		看datasheet: sama5d4 有!!!  
	还有一个关于pen的问题!!!未解决
恶补 input 设备 iio 设备 !!! 
	cat /dev/input/event1 | hexdump   //测试input设备命令  例如鼠标, 滑动就能有数据!!
	怀疑 input 逻辑设备文件 与 iio逻辑设备文件根本是两回事 read_raw 只给iio设备逻辑文件使用,而不是给input文件的
	看datasheet tsmr是touchscreen mode register 
		TSMOD四模式:非触摸屏模式,4线模式,4线带笔触压力模式,5线模式!!
		TSAV转换值获取4式: 1次转换取值, 2次转换取平均值,4次转换取平均值,8次转换取平均值
	Trigger Period: 前后两次转换间的最小间隔时间,一定要大于转换工作所用的时间!!
	Threshold: (比较用的)临界值,阀值.
	• EOCx: End of Conversion Interrupt Mask x
	• XRDY: Touchscreen Measure XPOS Ready Interrupt Mask
	• YRDY: Touchscreen Measure YPOS Ready Interrupt Mask
	ADC_LCDR: 存储最新一次得到的转换值及对应的通道
		adc-dma:的做法:(估计)测量得到一堆数据,然后这堆数据存到一个DMA-buffer,用户从ADC_LCDR寄存器入口取出这些数据
		每取出一个,buffer里就丢弃一个
	简单说sama5d4,可直接硬件把4adc电压值 转换成一个x坐标和y坐标值!!
	




20161230
先做一个小 input 驱动来
	设置外部中断 即设置gpio针 
	drivers/pinctrl/pinctrl-at91.c
	设置个gpio针!!
		根据dts pinctrl@ compatable 得知 使用 at91sam9x5_ops 设置!!!
	设置函数还不能随便调用,要通过设置dts来设备io口
第一步:做一个linux 模块,测试挂入系统功能,注意makefile编写,详见 /home/kingders/SAMA5D4/sources/driver_test/button
	测试命令:	tftp -gl button.ko 192.168.1.100
			insmod button.ko	//加载
			rmmod butto		//卸载
	成功!
第二步,修改pe8gpio脚, 上升下降沿触发中断!!
	readl_relaxed(reg)		//直接读取硬件寄存器reg地址内容!!
	writel_relaxed(value, reg);	//把内容value,写入硬件寄存器地址!!
	官方说明这样配置中断gpio的irq!!(可是已经没有这个函数了,玩野!!)	
	at91_set_gpio_input()then maybe enable its glitch filter
	request_irq()
	pioE的中断号是 26 !!
	似乎中断好是错的!!! linux里26不对应pioe 
	kernel里
		23对应 at91_tick
		26对应 aic5_set???
		52对应 ???		
		25对应 ehci_hcd:usb1
		41对应 aic5_set_type??
		44 refer atmel-sha
		明显,request 绑定irq也是有自己的一套规则的 起码中断号与芯片的硬件中断号不一致
		要恶补linux 的中断设置!!包括芯片和kernel的内容!!
回望adctouchscreen驱动
	初步认为,input设备是不提供read接口的,使用自身独有的read接口!!
		之所以read阻塞,极有可能是驱动逻辑设备文件里还没有数据!!adc转换中断没有真正开了!!
	读出注册中断处理程序request的前一刻 用到的 st->irq 号 居然是41!! 不是44!!
		乱改request里的 st->irq 号 为51 居然成功注册,启动且意外执行了中断处理程序
		dts的adc interrupt 号怎么改,最终 st->irq 还是41
		dts的adc interrupt 注释掉有提示irq初始化出去错!!
ubuntu使用sourceinsight:
	wine /home/kingders/smart210/tools/source_insight/SourceInsight/Insight3.exe 








20170103
geditor打不开文件时:(取消编码检测)
	gsettings set org.gnome.gedit.preferences.encodings auto-detected "['UTF-8', 'CURRENT', 'ISO-8859-15', 'UTF-16']"
重新解决中断问题!!
	request 使用IRQF_SHARED 后成功注册,但按键没有反应!!!
	怀疑是硬件中断号与linuxh中断号的转换问题!!
	查看中断是否产生,命令 
	# cat /proc/interrupts
		linux中断号  触发次数`类型??		??	触发		中断名字 
		186:         48      GPIO		8	Edge     	pb_user1	//原生加入的!!
		 26:          0      atmel-aic5		67 	Level     	button1		//自己刷入的!!1
		 41:          0	     atmel-aic5  	59 	Level     	at91_adc	//触摸对应的中断模块!!
	发现了 原来按键中断已经加入!!!
	按键后,源码自己触发次数成双增加,及上升下降沿都触发
	更改自己按键模块设置关闭pe8的寄存器操作,原生加入的中断将不再工作,证明自己操作寄存器的操作没有出错!!
	还有,发现触摸屏对应的adc中断模块未曾触发过!!
下一步分析原生按键的初始化过程:
	原来 event1 对应的是 pe8 的用户按键!!!
	cat /dev/input/event1 | hexdump	
	一些重点drivers/input/keyboard/gpio_keys.c	
		gpio_keys_resume() //虽然有向input/event1文件report数据,但不是中断处理函数!!
		注册了的中断处理bottom_half程序(在workqueue里的)是 gpio_keys_gpio_work_func()
	从gpio_keys_probe剖析一个platform_device/driver从dts_node里取出dts数据初始化驱动的过程!!
		对应dts_node:
		gpio_keys {
			compatible = "gpio-keys";
	
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_key_gpio>;
	
			pb_user1 {
				label = "pb_user1";	//关于 gpio_keys_button -> const char *desc;
				gpios = <&pioE 8 GPIO_ACTIVE_HIGH>;
				linux,code = <0x100>;	//关于 input event code (KEY_*, SW_*
				gpio-key,wakeup;
			};
		};
		重要的数据结构:
		struct gpio_keys_button {
			/* Configuration parameters */
			unsigned int code;	/* input event code (KEY_*, SW_*) */
			int gpio;		/* -1 if this key does not support gpio */
			int active_low;
			const char *desc;	
			unsigned int type;	/* input event type (EV_KEY, EV_SW, EV_ABS) */
			int wakeup;		/* configure the button as a wake-up source */
			int debounce_interval;	/* 去抖延时 */
			bool can_disable;
			int value;		/* axis value for EV_ABS */
			unsigned int irq;	/* Irq number in case of interrupt keys */
		};
		先分配一个空间存储平台设备数据
		pdata = gpio_keys_get_devtree_pdata(dev);	//从dts取出platdate
			dev->of_node 指的就是gpio_keys 这个node
			nbuttons = of_get_child_count(node);	//得到子node的数目,这里就只有 pb_user1 这个按键
			子节点的内容终要变成规范的设备数据
			//分配数据空间给平台设备数据 
			pdata = kzalloc(sizeof(*pdata) + nbuttons * (sizeof (*struct gpio_keys_button)),GFP_KERNEL);
			pdata->buttons = (struct gpio_keys_button *)(pdata + 1);//按键数据在平台设备数据里的开始地址
			pdata->nbuttons = nbuttons;	//按键数目
			for_each_child_of_node(node, pp)//for循环的宏定义,比那是遍历直接点
				of_find_property(pp, "gpios", NULL)	//找到字节点 gpios 这个 property 
				重点!!!!!!是of_get_gpio_flags:
					struct device_node *np = pp, int index = 0, enum of_gpio_flags *flags = &flags
					const char *propname = "gpios"
					gpio = of_get_gpio_flags(pp, 0, &flags);
					->of_get_named_gpio_flags(pp, "gpios", 0, &flags);	//只是分析了dts里,按钮子节点的内容
						->ret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index, &gg_data.gpiospec);
							const struct device_node *np = np, const char *list_name = "gpios":
							const char *cells_name = "#gpio-cells", int index = 0:
							struct of_phandle_args *out_args = &gg_data.gpiospec:
							应该是給 gg_data.gpiospec 初始化内容
						...	// 越来越混乱!!!
					//寻找对应芯片的的gpio模块,并转换成对应的linux设备数据内容 重点!!
					->gpiochip_find(&gg_data, of_gpiochip_find_and_xlate);
					找到了drivers/gpio/gpiolib.c 专们是at91的gpio模块

				...
		再分配一个空间存储平台设备驱动的数据空间
		然后把平台设备数据 和 input逻辑设备接口数据 的地址 挂入驱动数据里!!
		ddata = kzalloc(sizeof(struct gpio_keys_drvdata) + pdata->nbuttons * sizeof(struct gpio_button_data), GFP_KERNEL);
		ddata->pdata = pdata;
		ddata->input = input;	
		...
		然后重点之一,设置key: error = gpio_keys_setup_key(pdev, input, bdata, button);
		来到注册中断操作这个阶段,
		中断号的获取是通过探测得到:(重要 这里得到的中毒昂好是186)
			irq = gpio_to_irq(button->gpio);
		问题:知道linux_pE8的irq是186,但是,我自己编写时,直接写入186却有反应,
		而原声的,不通过gpio_to_irq,而是直接给予186,却通过!!,怀疑在gpio_to_irq之前存在一个中断号186生成和绑定过程,不能直接使用,
		而这个生成绑定过程不在 gpio_to_irq 里!!
		后面分析有发现 硬件中断号,与linux中断号已经绑定好,所以并不需要初始化时绑定,
		也就的说,可以直接使用对应中断号!!!呢么没有反应,应该是硬件初始化的问题!!
		果然 pull_up不能设置!!!设置pull_up还先清除设备可能设置了的pull_down
		完整代码见:
			/home/kingders/SAMA5D4/sources/driver_test/input_device/button :button.c







20170104
给button,c 套入input框架 注册成一个input设备!!!
	注意到,设置 keybit 不能乱来, 
		暂时只能设置为 BTN_0 设置其他会出错?例如,设KEY_1模块init阶段就执行了input设备的ops的open函数
		(但不科学啊,因为 KEY_1 也是默认值之一 )
		关于 keybit 的设定,可以查看: include/dt-bindings/input/input.h 或者 include/uapi/linux/input.h
	但是, 中断input_report_key函数似乎没有正常地把数据内容递交额 event1 设备逻辑文件!!
	cat /proc/bus/input/devices	//查看input设备属性数据
	按键 input驱动 基本完成,但是input_report 失败!!!
	最后手段,改input子系统源码 加入pr_debug!!










20170105
恶补input子系统知识:
	input 设备 是一个抽象出来的共性设备,可以看作是一个接口!!, 每一个输入类硬件设备初始化注册到linux时,
		都会另外注册一个虚拟的input设备,作为标准的接口与用户程序及其他驱动交互
	首先,kernel启动时会 注册 一个 input子系统 的主设备,为未来实际的input设备建立做好准备
	一些硬件设备驱动初始化时,注册到 input子系统 的次设备,实际就是建立了一个属于自己的 event字符设备, 
从一个按键驱动来分析!!! 	//详见 /home/kingders/SAMA5D4/sources/driver_test/input_device/button : inputdev0.c
	module_init初始化一个按键驱动的首先就是:	input_allocate_device 分配一个 struct input_dev 数据,得到这个数据的指针 *X
	然后初始话这个数据:
		X->name = "button"; 	//input子设备的名字
		X->phys = "william/PE8_button";		//物理途径???
		X->id.bustype = BUS_HOST;		//总线类型??
		X->dev.init_name = "input_key"; 	// /sys/devices/virtual/input/目录里这个设备的属性文件名
		X->keycodemax = KEY_NUM; 		//按键数目
	
		//自定义input,不要设置版本信息!!!
		//X->id.vendor = 0x0001;  
		//X->id.product = 0x0002;  
		//X->id.version = 0x0100; 
	
		// event事件类型 为 按键类型(EV_KEY)  
		set_bit(EV_KEY,X->evbit);	/*正确设法1*/
        	//X->evbit[BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY);/*正确设法2*/  
		//使用那一个编码的按键, 按国际标准,每一个键盘按键,鼠标事件,其他设备的功能广义按键都有一个唯一的ID (但是用code表示)
		//	例如 KEY_1 表示 键盘的数字 1 按键,有趣的是,后面注册设备时,如果检测到有键盘的按键编码时,认为插入了一个键盘,
		//					 注册时会自动执行 open 函数,因为键盘默认是插入注册到linux后便可以直接使用的
		//					 使用之前,当然要 open 设备, 所以就自动打开了设备
		//	     BTN_1 表示 广泛的通用的按键	1	
		//	     BTN_3 表示 广泛的通用的按键 3
		set_bit(BTN_3,X->keybit); /*正确设法1*/ 	//这里就是 设置按键ID为BTN_3
        	//X->keybit[BIT_WORD(BTN_3)] = BIT_MASK(BTN_3); /*正确设法2*/
		
		//初始化 key 值		这个对于不规范的按键驱动开发相当重要!!后面分析按钮问题分析到!!!
		set_bit(0,X->key);  
		//set_bit(BTN_3,key_dev->key);  
	
		X->open = PE8_open;  	//打开这个input次设备 (即是event逻辑设备文件),需要附加的私有的open函数,一般用于进一步硬件初始化
		key_dev->close = PE8_release;	//关闭这个input次设备, 需要附加用上的私有释放函数,释放占有的资源,硬件资源
 	然后就是往linux注册这个input子设备了:	input_register_device(X)
		然后就会自己自动建立自己的 eventx 逻辑设备文件到 /dev/input里了,
	打开 event 设备:
		首先我们使用的是 BTN_3 的一个通用按键的编码来标识 PE8 这个按键,所以input_register_device(X)时,不会误认为这是一个键盘硬件设备,
			只是一个通用的按钮硬件设备,所以,不会自动执行 open /dev/input/eventX 操作,
			所以第一步先打开 eventx 设备,打开操作经过通用的打开初始化操作后,最后会跑到 PE8_open 执行私有的硬件初始化!!
		PE8_open:	
			注册中断:
			首先:kernel启动时,已经生成了 硬件中断号 与 linux中断号irq.no 的对照表 
			//linux中断号irq.no:系统已经绑定给针 PE8 的中断号, 这里PE8 对应186
			//button_inter:中断处理函数, 
			//flags:IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING 表示上升下降沿触发中断,
			//button1:中断的名称, 
			//ID:中断号irq_desc里挂载关于这个中断的中断事件id号,从而区别使用同一个中断号里的各个中断事件(主要为共享中断服务,
			//	一般复用dev数据指针作为ID号)
			request_irq(key1.irq_no, button_inter, IRQF_TRIGGER_RISING, key1.name, (void *)(&key1)); //只有上升沿触发	
			//硬件初始化!!!
			hw_init();
		注意到:
			但是request 里, 我故意让只有山上升沿时才触发中断
			然后,硬件初始化里,我做的工作是当遇到 上升沿和下降沿时都会触发中断!!
			测试时发现,只有按下后抬起的时候才有中断时间发生(即上升沿才发生!! 因为按钮开路时接上拉电阻)
			两者都设置了中断触发条件,但却以request 的为准!!以软件设置为准,而不是硬件??当中有跟复杂的学问!!
	按下按钮后,触发 request 注册的 button_inter 中断处理函数:
		//repot函数!!辗转到input_event()事件	
		//X:这个按键时间对应的 struct input_dev 结构数据的指针
		//EV_KEY:表示,这个event事件为按键事件!!1
		//BTN_3:这个按键对应的编码ID , 
		//i:应该是规范的按键值才对,我就是这里出问题了!!!!	
		//这个函数就是往 event设备递交数据值的,然而实际上,提交的数据,一般暂存在自己的 struct input_dev 里的一个buffer
		//并不会马上投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		//但当buffer数据满了以后,会自动投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_report_key(X,BTN_3,i)
			->input_event(X, EV_KEY, BTN_3, i)
		//repot函数!!辗转到input_event()事件
		//这里不是传递数据,而是通知,把 buffer 里的数据 即时 投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_sync(X);	
			->input_event(X, EV_SYN, SYN_REPORT, 0);
	按键问题:
		按照上述设定,执行cat /dev/input/eventx | hexdump 时,按下按键应该有输出!!!	但没有
			cat /dev/input/eventx | hexdump 命令:打开eventx 阻塞方式读出数据,吧数据装换16进制形式然后输出!!
		窥探input_event时,发现,
			->input_handle_event
				disposition = input_get_disposition(dev, type, code, &value); //得到一个disposition
				//对于按键类型来说,这个disposition == INPUT_PASS_TO_HANDLERS == 1 时,才会把数值放入 buffer 或则投放到eventx
				//但是由于我的驱动 默认了 当前键值key值是0, 而每次按键interrupts,都赋值1,
				第一次按键时,input_get_disposition()关于EV_KEY的部分,会比较当前key值是不是不等于即将赋予的按键值,
					if (!!test_bit(code, dev->key) != !!value ) 只有不等于的情况下才会赋予 disposition = 1
					否则 disposition = 0, 0表示忽略这个信号,实际意义就是,当前键值已经等于即将的赋值,不用重新赋值
				X->key 就是保存当前键值数据的,
				按规范,	当按键按下时,按键interrupts应赋值1,X->key改为1
					当按键松开时,按键interrupts应赋值0,X->key然后改为0
					但现在我的驱动问题是,不管按键是否按下,按键interrupts,都赋值1,X->key被赋值前也是1,
						所以 disposition = 0 按键事件被忽略,所以,也不把内容放入 buffer
						最终,也没有内容投放到 /dev/input/deentx 对应的 逻辑设备文件里
网上下载了两个测试input设备的用户态程序!!!! evtest.c 和 getevent(但是getevent源码损坏,不能用) 
	详见:/home/kingders/SAMA5D4/sources/driver_test/input_device/button :evtest.c getevent.c getevent.h
最后手段,改input子系统源码 加入pr_debug!!	
	发现:
		input_report_key 调用一次 input_event
		input_sync 也调用一次 input_event
		终于发现,由于我的的button设备并不规范,所以,按键信息被忽略掉了!!!
		具体通过查看 input_event 源码得到










20170109
补充电阻触摸屏的知识!!!
其实触摸屏上有4层悬空透明导体!!当用尖锐的物体点击屏幕时,悬空的四层导体会接触!!!
至于触摸屏的原理是:
	空闲状态时,X+(Xp)点处于3.3V高电平,而且内部串联了一个100kΩ的电阻,其他层处于低电平
	当有尖物触摸时,X+(Xp)层与Y-(Ym)层接触时,X+会被拉低电压,从而得到一个接触中断信号!!
	接触中断信号也会诱发 中断号44的中断处理程序:
		中断程序关闭 接触中断 打开坐标数据预备好中断,和不再接触中断
		然后通知adc硬件模块便按照触摸屏的模式执行一个连续的转换模式:
			每个子工作都是是,先变更配置X+(Xp) Y+(Yp) X-(Xm) Y-(Ym) 脚,然后adc采样一种坐标数据
	当一连串的转换工作完成后,触发数据预备好中断,
	由于同样属于adc模块,所以同样诱发 中断号44的中断处理程序,但是执行程序其他部分的内容,
		即读出坐标数据,
	如果接触物不离开屏幕,触摸屏就处于不断转换坐标数据,并让 中断号44的中断处理程序 处理数据的过程
	当接触物离开屏,4层悬空透明导体再次悬空.触发 不再接触中断,同样诱发 中断号44的中断处理程序 执行第三步部分内容:
		关闭坐标数据预备好中断,和不再接触中断  重新开启接触中断 
	等待下次触摸接触!!!
adc的pin位
Instance 	Signal 	I/O Line 	Peripheral
ADC 		ADTRG 	PE31 		A
ADC 		AD0 	PC27 		X1
ADC 		AD1 	PC28 		X1
ADC 		AD2 	PC29 		X1
ADC 		AD3 	PC30 		X1
ADC 		AD4 	PC31 		X1

probe过程重要分析!!
	注意,channel设置哪里,官方代码at91_adc_channel_init 4线adcts只有初始化来两条idev-channel ????
	直到 at91_adc_channel_init 执行完 probe初始化函数也只是设置了 MR寄存器!!
	直到 at91_ts_register 只是初始化了 input 设备而已!!!
	直到 at91_ts_hw_init 才开始初始化 各个硬件寄存器!!
		发现 offset 为 0xc0 的 TSR 寄存器 要配置,但没有这个寄存器!!!
		at91_ts_hw_init 只是 配置了 ADC_MR ADC_TSR ADC_TSMR ADC_ACR
	整个过程并没有 开中断 或者 开始adc转换的操作!!!
分析 open 函数 !!
	关键就是 打开 了 中断控制寄存器的开关!! 打开 PEN,或者 NOPEN 这个开关!!!
分析 interrupt 函数!!
	检测到 EOCx 时,简单处理,就是丢弃数据!!!
	检测到 笔接触时,关闭笔接触中断!! 开启非笔接触和X,Y,P, 的RD中断!!
	检测到 非笔接触时, 设置软件触发adc转换, 关闭非笔接触和X,Y,P, 的RD中断 ,开启笔接触中断!! report 按钮事件
	检测到 X,Y,P, 的RD时,当笔触还在接触时,分析 report X,Y,P 事件, 当笔触没有接触时,直接读出寄存器数据(读出而不report,等于丢弃!!!)
不管怎么弄就是不触发中断!!!!,所以尝试从裸机adc入手,顺便学习裸机包的使用!!
	看了文档,比想象中麻烦,的放弃!!!不过学习!!纠缠adc初始化源码!!!!!
后面发现,adc里好像没有对GPIO做初始化,然后看了看寄存器状态!! 5针,都设了peripheral 都设了peripheral A 但都处于 低电平 level 0
	但是data sheet 里要求 peripheral X! 而不是 A !!!! 什么鬼!!!
	还有既然都设置为 adc 的话, 应该不全是level 0 的
	还有,PMC_ADC peripheral clock 是启动了的 
今天为了解构为什么不触发中断,特意扒了adc转换的裸机源码,分析初始化和工作执行的步骤!!! 本来想另外写一个linux模块测试!!
	详见:driver_test/adc_module/adc_裸机分析(特别重视 AIC中断管理器的使用!!)
终于找到原因了,开发板,与触摸屏相关的还有地方分开了,并没有用 0R 电阻连接上!!!!
	成功有反应了:
	注意:使用了evtest 用户程序来测试: ./evtest /dev/input/event0
	evtest 用户程序在: sources/driver_test/input_device/button











20170109
深入makefile编写!!!!
	简单多文件结构的 linux 驱动模块的 makefile 编写: 参考(已经调试好的) sources/driver_test/multifiles_make_test1
	特别注意:
		module license 'unspecified' taints kernel. Disabling lock debugging due to kernel taint
		这种错误是由于多文件 链接成一个统一单.o文件时, 这个统一.o文件,与其他一个,o文件重名了!!
	还有一种:集成到内核源码里的方式:
	将驱动源代码文件（夹）放置在Linux内核源码的driver/xxx/的相应路径中，修改本层和上层的Makefile和KConfig文件，
	并重新make menuconfig内核，可以在Menu中选中新加入的驱动模块，然后make module，就可以在驱动源码文件夹生成.ko文件。
  	1. 要编译的驱动所在文件夹里的Makefile (本地Makefile)
	    #CONFIG_ECAT_DRV为m时编译为模块，为y时编进内核  
	    obj-$(CONFIG_ECAT_DRV) += ecat.o  
	    #-objs指定依赖的多个.o文件  
	    ecat-objs := ecateoe.o eoeappl.o mcihw.o ecatslv.o mailbox.o ecatappl.o ecat2440.o  
	2. 本地Kconfig
	    #建立一个本地子目录。“”为显示的目录名字  
	    menu "ecat driver here"       
	        depends on NET  #依赖于上层的某个开关  
	    config ECAT_DRV  #配置变量名，必须和Makefile中的变量后半段一样   
	        bool "ecat driver" #bool量， 显示的名字  
	        ---help---  #下面为要显示的帮助文字  
	            This is test for ecat.  
	    endmenu  #本地子目录结束  
	3. 上层Makefile
	    *  
	    *#添加下面这一句  
	    obj-$(CONFIG_ECAT_DRV) += ecat/  #打开下一级目录编译  
	    *  
	    *  
	4. 上层Kconfig
	    *  
	    *#添加下面这一句  
	    source "driver/xxx/ecat/Kconfig"  
	    #导入子文件夹中的Kconfig文件，可以为相对路径  
	    *  
	    *  
解决了:lcd 10分钟自动关屏幕问题!!
	推荐使用一个用户程序处理:
	display.c:
	#include <fcntl.h>
	#include <stdio.h>
	#include <sys/ioctl.h>
	int main(int argc ,char *argv[])
	{
	 int f0;
	 f0 = open("/dev/tty0", O_RDWR);
	 write(f0, "\033[9;0]", 8);
	 close(f0);
	 return 0;
	}
	arm-linux-gnueabihf-gcc -o display display.c //编译
	然后下载执行, 然后lcd的显示就又打开了!!!!
	如果要开机自动启动，复制到根目录后，在/etc/init.d/rcS里加上一句  /display
	详细原因见:http://blog.csdn.net/dongliqiang2006/article/details/4262950
	与console 和 tty 有巨大关联!!!
开发板的中断号与linux中断号的兑换表
	相关文件:linux-at91-master/drivers/irqchip/irq-atmel-aic5.c
	发现中断号 应该都在提取devicetree_node成platform_device_data时转换了










20170112
console 与 terminal 与 tty 重点!!
TTY:
	tty历史上是电传打字机的意思,后来是终端的意思!!
	(TTY)终端的概念: 一个提供输入和输出功能的实体硬件设备, 而且可以连接到电脑主机,与主机信息交互
		例如一台电脑的显示屏和键盘组合对于电脑主机来说这个组合是一个 TTY终端的硬件设备部分,
	业界把tty终端 可以连接到电脑主机,与主机信息交互 的部分抽象出来,就是没有实体硬件设备的终端,只有一个抽象接口
		当绑到一个实体硬件设备上的时候,这两者就成为一个真正意义上的终端
		然后操作硬件设备就相当于使用 终端 与 linux与电脑主机实现信息交互!!!
		每个终端每一时刻只能操作一个需要交互的用户程序!!
		这些 抽象接口 不严格意义上都可以统称 tty终端
	对于一台启动了的电脑!!
		我们常以为是运行在一个图形界面,
		实际上是:运行在 tty7终端上,而在这个终端上我们运行着一个大型的操作界面GUI程序而已!!
		在这里我们如果执行了一个 terminal程序,实际上是执行了一个 软件终端,
		透过这个软件,相当于我们在 tty7终端运行的大型软件 嵌套运行一个新的tty终端!!!		
	每一时刻只能操作一个需要交互的用户程序的概念例如:
		我们常常使用打开的terminal实际上就是一个终端软件,terminal窗口相当于输出端,硬件键盘就是输入端,
		terminal窗口和硬件键盘被这个 终端软件 打包模拟成一个实体硬件设备
		而这个硬件输入和输出功能的机器或机器组合,自动绑到一个抽象接口,即/dev/ttyX, 共同组合成一个真正意义上的终端
		通过这个接口,这个实体硬件设备 实现了与主机信息交互 的工作,
		也就是说 这个真正意义上的终端 实现了与主机信息交互 的工作
		在我们往 terminal 里 写执行命令时, 就相当于 通过通过终端往主机输入信息,
		主机把处理后的信息通过 /dev/ttyX 往terminal窗口送,便显示出来了
		在这样的交互过程中,我们只能一条条命令地输入执行,
		这就是每一时刻只能操作一个需要交互的用户程序的概念	
	理论上,各种类型实体硬件设备挂入 linux 都是注册一个终端设备,并生成绑定到对应的一个唯一的/dev/ttyXXX的字符设备文件,
		共同组合成一个含有输入和输出功能的硬件机器或机器组合,一个真正意义的终端!!
		例如著名的串口终端设备:
			/dev/ttyS0(对应通用标平台硬件0号口的串口终端设备) 
			/dev/ttySAC1(对应三星平台硬件1号口的串口终端设备)
			/dev/ttyACM4(对应at91平台硬件4号口的串口终端设备)
			/dev/ttyUSB0(对应通用标平台硬件0号口的usb串口终端设备)
		以上是一个硬件设备对照一个字符设备文件接口!!
		这些字符设备文件接口 俗称 串口终端设备
	然而,还有一种叫 虚拟终端设备 的概念: 
		有时希望第一终端正在执行一条漫长工作的指令,但是,又需要现在执行另一条指令,又不能停掉现在执行的那条,
		那么,我们就只能使用另外一个终端执行就可以了!!!
		因为一般实体硬件就只有一套,例如我们地脑的显示屏和键盘,那么,我们只需要把这套硬件绑到另外一个抽象接口,即另一个/dev/ttyX
		便可以得到一个新的终端,在这个终端里执行新的命令,
		虽然从旧的/dev/ttyX解绑出来,但是旧的终端并没有被关闭,只是被卸下实体硬件设备,旧的终端正在工作的命令还是在继续工作着,
		当我们把这套硬件绑回原来的抽象接口,就相当于给旧的终端装回硬件,转回到原来的终端上去!!!!
		这些抽象接口 /dev/ttyX 相当于没有硬件设备的终端, 俗称 虚拟终端设备 
		因为他们共用 显示屏和键盘 这套硬件设备!!!! 不像串口终端设备那样一对一的关系!!
console:	
	控制台终端,实际上是一个特殊终端!实际上他是基于 tty终端的,当把/dev/console映射到/dev/ttyXXX(例ttySAC0,tty0等等)时,
		实际上就是给普通的 tty终端 赋予了控制台的属性!!!,这个tty终端也就成了控制台终端!!
		控制台比tty终端多出来的属性是:(日志输出功能)可以显示printk内容!!!
	在移植内核时,我们写的bootargs里 有 console=tty0,console=ttyACM0 的内容就是说,tty0和ttyACM0 俩个tty终端赋予了控制台属性!!!
		但控制台终端只有一个!!!!
		这两个tty终端,会同时输出日志消息!!,即在tty0执行命令输出pingtk消息时,ttyACM0也会输出同样pintk消息
		但是,最后配置上控制台属性的 ttyACM0 才是一个实现基础的人机交互 的控制终端!!! 
			即例如开发板看到lcd屏显示,串口输出也有显示,但是,只能使用串口输入执行命令
			能用于人机交互的控制台,还有一个专有属性 就是提供用户登陆的功能!!
	控制台终端 与 普通的tty终端也就以上那点区别!!那么为啥还要另外弄一个控制台终端的概念?
		Linux kernel有一个很强烈的隐性规则----内核空间的代码不应该直接利用用户空间接口访问某些资源
		所以kernel的代码（如printk），就不能直接使用TTY的接口访问TTY设备
		kernel代码不应该直接使用文件系统接口访问文件（虽然它可以）
			TTY框架通过字符设备（也即文件系统）向用户空间提供接口
		console 是为此 开凿出来的后门.
伪终端 Pseudo Terminal，简称pty:
	并不是所有硬件设备都是通过串口的方式接入计算机开发板什么的,所以他们也不能简单地作为一个终端的输入输出功能的硬件
	相反,他们需要把自己的通讯方式模拟成串口硬件设备一样的,于是就出现了伪终端 pty 一般成对出现 pts ptm
	一般的:
		 硬件设备 接入 ttyX, ttyx与主机交互
	特殊的:
		特殊通讯协议硬件设备 接向 ptm, ptm与pts交互,  pts类似ttyx一样与主机交互
软件终端:
	我们平时 使用的的terminal,SecureCRT就是软件终端,
	但是也有区别:
		terminal: 
			把键盘输入功能和自身软件窗口输出功能打包模拟成一个串口硬件设备,或者其他特殊通讯协议的硬件设备
			然后 接入 一般的 /dev/ttyx 接口, ttyx与主机交互 组成一个真正的终端 			 
			或者其他特殊通讯协议的硬件设备
			通过伪终端方式 接入 ptm ptm又与专有pts交互,  pts类似ttyx一样与主机交互
		SecureCRT:
			模拟一个串口硬件设备接入到 开发板的 ttyX, ttyx与主机交互
最后,有一些未曾解决的疑问!!!
	kernal里配置 framebuffer_console 后, 开发板的串口和lcd都同时输出!!这是有两个console??
	当前可以进行人机交互的 tty终端,等同于console(控制台终端)么??
	我知道 tty0 永远是当前执行的终端,即电脑开机后,我是执行着 tty7的终端,而此刻的tty0就是tty7,
		而开机bootargs 里console=tty0, 就是说,当前不论执行在哪个tty终端都是console终端?
		唯有通过 terminal 执行的tty终端才可以不是console中端??








20170113
尝试使用官网的 连续buildroot一条龙工具链看看,
	$ git clone git://git.buildroot.net/buildroot     /* 下载buildroot 一条龙工具链  */
	$ git tag	/* 查看版本 */
	$ git checkout  2016.11-rc3 -b buildroot-2016.11-rc3	/* 选择 2016.11-rc3 这一版本 */
	$ make atmel_sama5d2_xplained_defconfig 	/* 建立一个配置,配置文件 XXX_defconfig 在 configs 文件夹可查看 */
	$ make		/* 开始一条龙编译, 最终所用生成文件放在 output/images里*/
	//开始刷写 flash
	$ ./board/atmel/flasher.sh ./output /dev/ttyACM1 sama5d4_xplained
	出错:
		couldn't load file "/tmp/tcloqFb5D": libXss.so.1: cannot open shared object file: No such file or directory
		couldn't load file "/tmp/tcl1oGOVF": libXft.so.2: cannot open shared object file: No such file or directory
	解决:
		sudo apt-get install libxss1:i386
		sudo apt-get install libxss1:i386
	继续出错:
		-I- Waiting ...
		-I- TCL platform : Linux
		-I- SAM-BA CDC 2.16  on : linux
		-I- Retrieved arguments from command line :
		-I- argv 0 : /dev/ttyACM1
		-I- argv 1 : at91sama5d4x-ek
		-I- argv 2 : ./board/atmel/nandflash.tcl
		-I- Connection /dev/ttyACM1
		-E- Connection /dev/ttyACM1 not found		//明明已经插好!!!使用新的sam-ba 3 可以链接!!
		-E- Connection list : 
	未解决:先搁置!!
尝试移植官方版 yocto_project:
	git clone 了 poky 的前三个软件包


偷闲分析usb驱动!
	drivers/usb/gadget/udc/atmel_usba_udc.c usb从设备驱动?就是把 开发板看做usb设备,而不是主机!!!








20170116
所谓usb_gaget 就是一个搭载linux工作的硬件设备,作为其他PC主机的 usb从设备,而需要用到的模块!!
usb_gaget驱动:
	基于底层提供的资源， Gadget 驱动可以运行在各种硬件平台上。重要的驱动有：
	Gadget Zero, 类似于 dummy hcd, 该驱动用于测试 udc 驱动。它会帮助您通过 USB-IF 测试。
	Ethernet over USB， 该驱动模拟以太网网口，它支持多种运行方式：
	CDC Ethernet: usb 规范规定的 Communications Device Class “Ethernet Model” protocol。
	CDC Subset： 对硬件要求最低的一种方式，主要是 Linux 主机支持该方式。
	RNDIS： 微软公司对 CDC Ethernet 的变种实现。
	File-backed Storage Gadget最常见的 U 盘功能实现。
	Serial Gadget 实现，包括：
	Generic Serial 实现（只需要Bulk-in/Bulk-out端点+ep0）
	CDC ACM 规范实现。
	Gadget Filesystem, 将 Gadget API 接口暴露给应用层，以便在应用层实现user mode driver。
	MIDI: 暴露ALSA接口，提供 recording 以及 playback 功能。
常见的 usb device 有 U 盘， usb 鼠标、键盘，usb 蓝牙模块，usb 读卡器，等等。这些设备比较简单，通常不会运行Linux。
	运行Linux Gadget 的通常是一些集成 CPU 以及很多外设接口的 SOC （System-on-Chip）， 
	其中 CPU 通常为 32 bit 的 CPU, 并且 udc 也是该 SOC 的一部分（ 顺带还有 DMA 通道，FIFO）。
观察:
  │ │                               --- USB Gadget Support                                                                                
  │ │                               [ ]   Debugging messages (DEVELOPMENT)                                                                
  │ │                               [ ]   Debugging information files (DEVELOPMENT)                                                       
  │ │                               [ ]   Debugging information files in debugfs (DEVELOPMENT)                                            
  │ │                               (2)   Maximum VBUS Power usage (2-500 mA)                                                             
  │ │                               (2)   Number of storage pipeline buffers                                                              
  │ │                                     USB Peripheral Controller  --->                                                                 
  │ │                               <M>   USB Gadget Drivers                                                                              
  │ │                               <M>     USB functions configurable through configfs                                                   
  │ │                               [ ]       Generic serial bulk in/out                                                                  
  │ │                               [*]       Abstract Control Model (CDC ACM)                                                            
  │ │                               [ ]       Object Exchange Model (CDC OBEX)                                                            
  │ │                               [ ]       Network Control Model (CDC NCM)                                                             
  │ │                               [ ]       Ethernet Control Model (CDC ECM)                                                           
  │ │                               [ ]       Ethernet Control Model (CDC ECM) subset     
  │ |                               [ ]       RNDIS                                                                                     
  │ │                               [ ]       Ethernet Emulation Model (EEM)                                                              
  │ │                               [*]       Mass storage                                                                                
.........                                                                      
  │ │                               < >     Gadget Zero (DEVELOPMENT)                                                                     
  │ │                               < >     Audio Gadget                                                                                  
  │ │                               < >     Ethernet Gadget (with CDC Ethernet support)                                                   
.......                                                                    
  │ │                               <M>     Mass Storage Gadget 
  │ │                               <M>     Serial Gadget (with CDC ACM and CDC OBEX support) 
得到的模块(gaget模块):
	libcomposite.ko
	u_serial.ko
	g_serial.ko
	usb_f_acm.ko
	usb_f_obex.ko
	usb_f_serial.ko
	g_mass_storage.ko
	atmel_usba_udc.ko
	usb_f_mass_storage.ko
从 Makefile 里得知:
	在function里编译得到的ko都是 接口中间模块,而在 legacy 里得到的ko都是真正的有实质工作的 上层usb从设备驱动
	中间模块;
		usb_f_acm.ko
		usb_f_obex.ko
		usb_f_serial.ko	
		u_serial.ko
		usb_f_mass_storage.ko
	实质从设备驱动:
		g_serial.ko
		g_mass_storage.ko
	gaget:udc控制器驱动:
		atmel_usba_udc.ko
	与复合usb从设备功能有关的中间模块:
		libcomposite.ko
学习到:
	acm 和 obex 都是特殊的串口通讯协议,serial才是传统的串口通讯协议
	所以 g_serial.ko 注册时,会选择其中一个通讯协议执行,
	也就是说 usb_f_acm.ko,usb_f_obex.ko, usb_f_serial.ko 三个挂载的中间模块中,我们会选择使用其中一个,
	这里 我们使用了usb_f_acm.ko
	发现,f_serial.c里的函数暂时也就只有f_serial.c自己调用!!很奇怪,作为一个中间模块.里面的函数绝对被放到指针里被调用了
如果项测试开发板的gaget串口功能!!可以这样:
	把编译好的内核烧入开发板，加载生成的驱动文件，注意加载顺序，否则会出现错误。
	先insmod atmel_usba_udc.ko  //添加 udc控制器驱动
	insmod  u_serial.ko
	insmod  libcomposite.ko
	insmod   usb_f_serial.ko	//atmel 选用acm协议，所以不用加载这个也可以
	insmod  usb_f_obex.ko		//atmel 选用acm协议，所以不用加载这个也可以
	insmod  usb_f_acm.ko
	insmod  g_serial.ko
	出现内核信息如下：
	[   27.310000] --------file=composite.c-------usb_composite_probe------1830
	[   27.320000] ------------402
	[   27.320000] -----usb_gadget_probe_driver------411
	[   27.330000] -------udc_bind_to_driver-----342
	[   27.330000] g_serial gadget: Gadget Serial v2.4
	[   27.340000] g_serial gadget: g_serial ready
	[   18.960000] g_serial gadget: high-speed config #2: CDC ACM config
	说明加载成功。
	此时你打开 win7 设备管理器会发现多了一个串口设备，
	ELMO GMAS（COM10）
	(未测试!!)
测试:
	本想安装上述.ko 但发现其实都已经=安装,表示有一shell文件,自动把这些.ko都安装上了!!!!
	在这里,由于 usba 口 本来就接上电脑了
	所以,其实gaget 实际上已经工作了,
	然而,以下的初始化顺序还是很模糊!!!
		假如 insmod g_serial.ko 后,就认为gaget已工作?,就已经建立了 /dev/ttyGS0 ??,还是插线材后??
		pc(ubuntu)上,出现了 ttyACM1符号,显然是 由gaget 这方提供的信息,让pc机初始化的,但未见是gaget的哪部分初始化代码实现
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
	注意:g_serial.ko 是 gaget 串口上层模块,通俗是我们常叫做的 usb串口驱动 (从设备端的!!)
卸载串口驱动,重新加载	
	# rmmod g_serial.ko 
	# insmod g_serial.ko
	g_serial gadget: Gadget Serial v2.4
	g_serial gadget: g_serial ready
	插入usb线到 usba口
	g_serial gadget: high-speed config #2: CDC ACM config	//插入出现的log!!!
	然后又可以观察串口工作:
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
gaget作为u盘设备测试!!
	先安装两个模块:
		//libcomposite.ko, atmel_usba_udc.ko 两个模块 开示时已安装!!!
		# insmod usb_f_mass_storage.ko	//中间模块!!!
		# insmod g_mass_storage.ko	//u盘驱动 然而安装失败
		由于 gaget_usb控制器atmel_usba_udc 已经被作为串口占用了,出现这样错误!!
		insmod: ERROR: could not insert module g_mass_storage.ko: No such device
		# rmmod g_serial.ko //先卸载 usb 串口驱动
		//然而先不要 再次加载 u盘驱动!!
		//如果执行insmod g_mass_storage.ko还是会出错,从错误信息中发现,加载时需要写入参数的
		//Number of LUNs=8
		//Mass Storage Function, version: 2009/09/11
		//LUN: removable file: (no medium)
		//Number of LUNs=1
		//no file given for LUN0
		//g_mass_storage 400000.gadget: failed to start g_mass_storage: -22
	在加载u盘驱动前,先在 开发板 分配一个空间为u盘所用!!!! 
   		# dd if=/dev/zero of=vfat.img bs=1M count=20	//制作一个fat格式的镜像 1M*20=20M大小的 文件，
		20+0 records in
		20+0 records out
		20971520 bytes (21 MB) copied, 0.177479 s, 118 MB/s
   		# losetup /dev/loop0 vfat.img			//将镜像与loop0建立连接
    		# mkfs.vfat /dev/loop0				//格式化做出的镜像
		mkfs.fat 3.0.28 (2015-05-16)
		Loop device does not match a floppy size, using default hd params
    		# mkdir vfat_mount_point				//创建挂载点
    		# mount /dev/loop0 vfat_mount_point/   		//挂载挂载点
    		# insmod g_mass_storage.ko file=/dev/loop0 stall=0 removable=1     //这才是加载u盘驱动的真正方式
		g_mass_storage: unknown parameter 'removeble' ignored
		Number of LUNs=8
		Mass Storage Function, version: 2009/09/11
		LUN: removable file: (no medium)
		Number of LUNs=1
		LUN: file: /dev/loop0
		Number of LUNs=1
		g_mass_storage gadget: Mass Storage Gadget, version: 2009/09/11
		g_mass_storage gadget: userspace failed to provide iSerialNumber
		g_mass_storage gadget: g_mass_storage ready
		g_mass_storage gadget: high-speed config #1: Linux File-Backed Storage   //注意这句 是在usba口经usb线接到pc机时出现,
    		插上开发板的usb从接口，即可从PC机段看到vfat_mount_point下的内容,
		pc机可以刷写内容到里面!! 开发板来到vfat_mount_point 可以看到刷入数据
		开发板往里写内容,pc机可见!!!!!
测试总结:
	显然如果不加载 g_XXX.ko 插入usb线并没有信息输出,gaget功能并不会实现!!!!
	初步分析,当usb插入时,才会调用 struct usb_composite_driver里的 .bind 函数!!
gaget 串口例程分析:
	legacy: serial.c 将编译成上层实质从设备驱动模块 g_serial.ko:
	(感觉这不是一个热插拔自动加载的驱动,手动加载后,就自动存在 并存在建立好的 /dev逻辑设备文件,不管此刻是否接上usb!!)
	serial.c 初始化 :
		static struct usb_composite_driver gserial_driver = {
		.name		= "g_serial",
		.dev		= &device_desc,
		.strings	= dev_strings,
		.max_speed	= USB_SPEED_SUPER,
		.bind		= gs_bind,
		.unbind		= gs_unbind,
		};
		struct usb_configuration serial_config_driver;
		serial_config_driver.bmAttributes = USB_CONFIG_ATT_SELFPOWER;
		serial_config_driver.label = "Generic Serial config";
		serial_config_driver.bConfigurationValue = 1;
		struct usb_device_descriptor device_desc;
		device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
		device_desc.idProduct =	cpu_to_le16(GS_PRODUCT_ID);
		static struct usb_string strings_dev[];
		strings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;
		usb_composite_probe(&gserial_driver);			//composite.c
			struct usb_composite_driver *driver = &gserial_driver;
			struct usb_gadget_driver *gadget_driver;
			static const struct usb_gadget_driver composite_driver_template = {
				.bind		= composite_bind,
				.unbind		= composite_unbind,
				.setup		= composite_setup,
				.reset		= composite_disconnect,
				.disconnect	= composite_disconnect,
				.suspend	= composite_suspend,
				.resume		= composite_resume,
				.driver	= {
					.owner		= THIS_MODULE,
					},
				};	
			driver->gadget_driver = composite_driver_template;
			gadget_driver = &driver->gadget_driver;
			gadget_driver->function =  (char *) driver->name;
			gadget_driver->driver.name = driver->name;
			gadget_driver->max_speed = driver->max_speed;
			usb_gadget_probe_driver(gadget_driver);			//udc_core.c
				struct usb_gadget_driver *driver = gadget_driver
				list_for_each_entry(udc, &udc_list, list)
				(	if (!udc->driver)	//如果udc里没有驱动
						goto found;	//即udc_bind_to_driver(udc, driver);	
				}
				udc_bind_to_driver(udc, driver);			
					struct usb_udc *udc = udc 
					struct usb_gadget_driver *driver = driver
					struct usb_udc {		//udc_core.c
						struct usb_gadget_driver	*driver;
						struct usb_gadget		*gadget;
						struct device			dev;
						struct list_head		list;
						bool				vbus;
					};
 					udc->driver = driver;
					udc->dev.driver = &driver->driver;
					udc->gadget->dev.driver = &driver->driver;
					ret = driver->bind(udc->gadget, driver);//这里的bind是 composite_bind
						//然后转到 gs_bind 函数
					ret = usb_gadget_udc_start(udc);
						//这里执行的 ops.udc_start 应该就是 atmel_usba_udc 的这个udc驱动
					usb_udc_connect_control(udc);
						//Enables the D+ (or potentially D-) pullup
					kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
						//通知了用户空间,注意只是通知了 atmel_usba_udc 驱动得变化,
						//并不是通知发生了热插拔事件!!!
关于 uevent:
	uevent(user space event) 内核与用户空间的一种通信机制，基于netlink机制，主要用于设备驱动模型，例如热插拔
		也就是说在某个时刻触发某个事件并通知给用户空间。
	事件：
		enum kobject_action {
		 KOBJ_ADD,
		 KOBJ_REMOVE,
		 KOBJ_CHANGE,
		 KOBJ_MOVE,
		 KOBJ_ONLINE,
		 KOBJ_OFFLINE,
		 KOBJ_MAX
		};
	触发点 kobject_uevent() :
 		如device_add()中的触发：
			kobject_uevent(&dev->kobj, KOBJ_ADD);
 		在kobject_uevent()中会先执行集成在kset中的kset_uevent_ops, 之后再通过netlink传递给用户空间。
 		struct kset_uevent_ops {
		 int (* const filter)(struct kset *kset, struct kobject *kobj);
		 const char *(* const name)(struct kset *kset, struct kobject *kobj);
		 int (* const uevent)(struct kset *kset, struct kobject *kobj,
		        struct kobj_uevent_env *env);
		};
 		filter用于判断uevent是否要发出去，name用于得到subsystem的名字，uevent用于填充env变量。
 		我们可以看到kobject_uevent()中的代码： 
			 if (uevent_ops && uevent_ops->filter)
			  if (!uevent_ops->filter(kset, kobj)) {
			       ......
			  }
			 /* originating subsystem */
			 if (uevent_ops && uevent_ops->name) {
			  subsystem = uevent_ops->name(kset, kobj);
			  ......
			 }
			  ......
			 /* let the kset specific function add its stuff */
			 if (uevent_ops && uevent_ops->uevent) {
			  retval = uevent_ops->uevent(kset, kobj, env);
			    ......
			 }
 		最后调用netlink接口发送出去，用户层会根据所设置的env变量来启动相应操作，至于env变量设置内容暂时不深究。
	当 kobject_uevent() 把内容通知到了用户空间后,用户空间的处理!! 
 		uevent的用户空间程序有两个，一个是udev，一个是mdev。
 		udev通过netlink监听uevent消息，它能完成两个功能：
 		      1．自动加载模块
 		      2．根据uevent消息在dev目录下添加、删除设备节点。
		另一个是mdev，mdev在busybox的代码包中能找到，它通过上节提到的uevent_helper函数被调用。
		udev的模块自动加载过程：
 			etc目录下有一个uevent规则文件/etc/udev/rules.d/50-udev.rules
			udev程序收到uevent消息后，在这个规则文件里匹配，如果匹配成功，则执行这个匹配定义的shell命令。
			例如，规则文件里有这么一行：
			ACTION=="add", SUBSYSTEM=="?*", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"
			所以，当收到uevent的add事件后，shell能自动加载在MODALIAS中定义的模块。	
		mdev的模块自动加载过程与之类似，它的配置文件在/etc/mdev.conf中。例如：
			$MODALIAS=.* 0:0 660 @modprobe "$MODALIAS"
		git a	这条规则指的是：当收到的环境变量中含有MODALIAS，那么加载MODALIAS代表的模块。
			mdev的详细说明在busybox的docs/mdev.txt中。
关于 OTG
	OTG 是 usb 的一个通用标准功能!! USB硬件内部有一条 动态的ID线
	当我们配置使用 OTG 功能, usb控制器驱动就会多了一个工作,监测当前usb口连接的状态,
	当检测到 ID线接地 这个usb口会作为host口,这台设备工作在usb 的主机模式,并不会工作在usb 从机模式,即不会使用 gaget 的驱动
	当检测到 ID线悬空 这个usb口会作为slave口,这台设备作为usb从设备,会使用 gaget 的驱动 执行工作!!!
	这个动态id线 通过 刷写 寄存器 改变状态!!
github常用命令:
平时提交!!
git add -A	//把所有修改了的文件和新建的文件的痕迹加入暂存区,相当于全员备份
git add modules/*	// */  把modules整个文件夹及其内容载入暂存区
git commit -m "xxx"	//提交
git push origin master	//提交远程库
git rm --cached tools/qt/qt-everywhere-opensource-src-5.6.0-rc.tar.gz	//移除多余错误添加git add 到index缓存的文件
git reset --soft HEAD^	//软回溯到上个版版本,即上个版本还没有git commit 的状态














20170117
编译 yocto project:
先建立一个总文件夹 我直接设了一个poky文件夹 cd Poky
	git clone git://git.yoctoproject.org/poky -b krogoth	/* 下载 yocto project 总工具链 */
	git clone git://git.openembedded.org/meta-openembedded -b krogoth	/* 下载 meta-openembedded 包 */
	git clone git://github.com/meta-qt5/meta-qt5.git -b krogoth	/* 下载 meta-qt5 包 */
	git clone git://github.com/linux4sam/meta-atmel.git -b krogoth	/* 下载 meta-atmel 包 */
	备份!!4个包!! 出Poky文件夹, 另建 Poky_backup 保存git clone下来的四个工具包
然后继续: 
	cd poky
	source oe-init-build-env build-atmel	//建立了编译工作文件夹 bulid-atmel 拷贝了通用配置到里面,并自动 cd 到 build-atmel 文件夹
	gedit conf/bblayers.conf	//修改 ./build-amel/conf/bblayers.conf 文件	
/* build-amel/conf/bblayers.conf: start */
# POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf
# changes incompatibly
POKY_BBLAYERS_CONF_VERSION = "2"
BBPATH = "${TOPDIR}"
BBFILES ?= ""
# 官方建议的BSPDIR ,但使用时出现大量 checksum错误 ,和文件无法找到的错误
# BSPDIR := "${@os.path.abspath(os.path.dirname(d.getVar('FILE', True)) + '/../../..')}"
# by willam 所以最好改为静态路径
BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
BBLAYERS ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  ${BSPDIR}/poky/meta-yocto-bsp \
  ${BSPDIR}/meta-atmel \
  ${BSPDIR}/meta-openembedded/meta-oe \
  ${BSPDIR}/meta-openembedded/meta-networking \
  ${BSPDIR}/meta-openembedded/meta-python \
  ${BSPDIR}/meta-openembedded/meta-ruby \
  ${BSPDIR}/meta-openembedded/meta-multimedia \
  ${BSPDIR}/meta-qt5 \
  "
BBLAYERS_NON_REMOVABLE ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  "
/* build-amel/conf/bblayers.conf: end */

	gedit conf/local.conf //继续 修改 ./build-amel/conf/local.conf 文件

/* build-amel/conf/local.conf: start */
...
#by william	
MACHINE ?= "sama5d4-xplained"
...
# 还是用回 默认路径,因为这样,似乎不会出现 checksum 和 文件 not found 错误
# 这里是指定一个下载的库文件要寄放的文件夹!!
DL_DIR ?= "${TOPDIR}/downloads"		
#by william
# DL_DIR ?= "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
....
#by william 符合 atmel 官方的policy configure
DISTRO = "poky-atmel"
....
#
# Package Management configuration
#
# This variable lists which packaging formats to enable. Multiple package backends
# can be enabled at once and the first item listed in the variable will be used
# to generate the root filesystems.
# Options are:
#  - 'package_deb' for debian style deb files
#  - 'package_ipk' for ipk files are used by opkg (a debian style embedded package manager)
#  - 'package_rpm' for rpm style packages
# E.g.: PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
#by william Package Management configuration 使用默认使用 ipk 格式包 
PACKAGE_CLASSES ?= "package_ipk"
....
# We default to enabling the debugging tweaks.
EXTRA_IMAGE_FEATURES ?= "debug-tweaks"
....
#by william  未知有何用,,
USER_CLASSES ?= "buildstats image-mklibs"
....
# Runtime testing of images
PATCHRESOLVE = "noop"
....
# Disk Space Monitoring during the build
BB_DISKMON_DIRS = "\
    STOPTASKS,${TMPDIR},1G,100K \
    STOPTASKS,${DL_DIR},1G,100K \
    STOPTASKS,${SSTATE_DIR},1G,100K \
    STOPTASKS,/tmp,100M,100K \
    ABORT,${TMPDIR},100M,1K \
    ABORT,${DL_DIR},100M,1K \
    ABORT,${SSTATE_DIR},100M,1K \
    ABORT,/tmp,10M,1K"
.....
# Qemu configuration
PACKAGECONFIG_append_pn-qemu-native = " sdl"
PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
....
CONF_VERSION = "1"
/* build-amel/conf/local.conf: end */
	
	bitbake core-image-minimal
		ERROR:  OE-core's config sanity checker detected a potential misconfiguration.
		    Either fix the cause of this error or at your own risk disable the checker (see sanity.conf).
		    Following is the list of potential problems / advisories:

		    Please install the following missing utilities: makeinfo,gawk,chrpath

		Summary: There was 1 ERROR message shown, returning a non-zero exit code.
		解决1:
		sudo apt-get install makeinfo gawk chrpath
			没有makeinfo 其实装的是texinfo 非makeinfo
		解决2:
		sudo apt-get install texinfo gawk chrpath
	再次: bitbake core-image-minimal
		WARNING: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/grub/grub-efi_2.00.bb: 
		Unable to get checksum for grub-efi-native SRC_URI entry cfg: file could not be found
		...
		解决:
		之前的 bblayers.conf: BSPDIR 改为:
			BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
		仍然 warning
		把 local.conf:DL_DIR 改回与来的 :
			DL_DIR ?= "${TOPDIR}/downloads" 就是说说编译过程中要下载的文件放入 build-atmel/downloads
		居然好了
	再次: bitbake core-image-minimal 几乎用了15小时, 还从网上下载了 25 G 内容!!!!!
		但是还是有错!!!! 具体 log;
/* 编译log?: start */ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "Ubuntu-14.04"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING: libpcre-native-8.38-r0 do_fetch: Failed to fetch URL ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.bz2, attempting MIRRORS if available
WARNING: bash-4.3.30-r0 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-033;apply=yes;striplevel=0;name=patch033, attempting MIRRORS if available
WARNING: sysvinit-2.88dsf-r14 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/sysvinit/sysvinit-2.88dsf.tar.bz2, attempting MIRRORS if available
NOTE: Tasks Summary: Attempted 1843 tasks of which 9 didn't need to be rerun and all succeeded.

Summary: There were 6 WARNING messages shown.



infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/local.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. You may wish to edit it to, for
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ example, select a different MACHINE (target hardware). See conf/local.conf
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ for more information as common configuration options are commented.
bash: 未预期的符号 `information' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/bblayers.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. To add additional metadata layers
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ into your configuration please add entries to conf/bblayers.conf.
未找到 'into' 命令，您要输入的是否是：
 命令 'pinto' 来自于包 'pinto' (universe)
 命令 'info' 来自于包 'info' (main)
into：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ The Yocto Project has extensive documentation about OE including a reference
未找到 'The' 命令，您要输入的是否是：
 命令 'the' 来自于包 'the' (universe)
The：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ manual which can be found at:
manual：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://yoctoproject.org/documentation
bash: http://yoctoproject.org/documentation: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ For more information about OpenEmbedded see their website:
未找到 'For' 命令，您要输入的是否是：
 命令 'tor' 来自于包 'tor' (universe)
 命令 'sor' 来自于包 'pccts' (universe)
 命令 'vor' 来自于包 'vor' (universe)
For：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://www.openembedded.org/
bash: http://www.openembedded.org/: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ ### Shell environment set up for builds. ###
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can now run 'bitbake <target>'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Common targets are:
Common：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-minimal
core-image-minimal：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-sato
core-image-sato：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-toolchain
meta-toolchain：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-ide-support
meta-ide-support：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can also run generated qemu images with a command like 'runqemu qemux86'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
> Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Resolving any missing task queue dependencies
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Build Configuration:
未找到 'Build' 命令，您要输入的是否是：
 命令 'guild' 来自于包 'guile-2.0-libs' (main)
Build：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BB_VERSION        = "1.30.0"
BB_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BUILD_SYS         = "x86_64-linux"
BUILD_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NATIVELSBSTRING   = "Ubuntu-14.04"
NATIVELSBSTRING：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_SYS        = "arm-poky-linux-gnueabi"
TARGET_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ MACHINE           = "sama5d4-xplained"
MACHINE：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO            = "poky-atmel"
DISTRO：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO_VERSION    = "2.1.2"
DISTRO_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TUNE_FEATURES：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_FPU        = "hard"
TARGET_FPU：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta              
未找到 'meta' 命令，您要输入的是否是：
 命令 'metar' 来自于包 'flightgear' (universe)
 命令 'metar' 来自于包 'metar' (universe)
meta：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-poky         
meta-poky：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-yocto-bsp：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-atmel：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-oe           
meta-oe：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-networking   
meta-networking：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-python       
meta-python：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-ruby         
meta-ruby：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-multimedia：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"
meta-qt5：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Preparing RunQueue
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing SetScene Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing RunQueue Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Currently 8 running tasks (191 of 1843):
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 0: gcc-source-5.3.0-5.3.0-r0 do_fetch (pid 15030)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 1: ncurses-native-6.0+20160213-r0 do_fetch (pid 15046)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 2: binutils-cross-arm-2.26-r0 do_fetch (pid 15122)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 3: linux-libc-headers-4.4-r0 do_fetch (pid 15145)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 4: glibc-initial-2.23-r0 do_fetch (pid 15156)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 5: glibc-2.23-r0 do_fetch (pid 28211)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 6: openssl-native-1.0.2h-r0 do_compile (pid 20726)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 7: xproto-native-1_7.0.28-r0 do_fetch (pid 11955)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
/* 编译log: end*/
	过程中,有六个网上获取包失败!!!
	经过发现,后面的所谓命令找不到,极可能是以不正当的方式在输出一个报告文件,
	实际上已经全部编译完成!!!!!!镜像放在:
		/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/deploy/images/sama5d4-xplained
测试便以结果!!!!
只烧写了 dtb 和 zImage,成功!!! 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage 成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage fs成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
都烧写:(注意,at91bootstrap居然 链接到uboot,也是uboot?你妹,名字差点就坑死我了,注意是spl-uboot!!) 
/* 不成功!!!!!!! */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:at91bootstrap-sama5d4_xplained.bin:0x0 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
/* 成功 */  /* 注意,bootstrap 用 writeboot 指令 ,不用加地址 ":0x0" */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
	至此,全部生成镜像 通过!!
	把景象文件全考到:core-image-minimal_demo文件夹备份
	另外,如何 更改内核配置!!! 而bitbake 又可以通过????
处理好 core-image-minimal 后,开始搭载 QT界面镜像的编译!!!
	特别注意,由于重启电脑的关系!!!!等等情况
	回到 poky 文件夹!!!
	重新执行一次: source oe-init-build-env build-atmel 指令!!!
	自动转到build-atmel
	把备份了的 build-atmel/conf 覆盖当前conf
	gedit conf/local.conf	//最后添加两行
		......
		LICENSE_FLAGS_WHITELIST += "commercial"
		SYSVINIT_ENABLED_GETTYS = ""
	然后才:bitbake atmel-qt5-demo-image	
	如果不重新执行 source oe-init-build-env build-atmel:
		直接修改 conf/local.conf
		然后执行 bitbake atmel-qt5-demo-image 会出现 bitbake命令没找到的错误!!!!!!
/* 编译log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel

### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-sato
    meta-toolchain
    meta-ide-support

You can also run generated qemu images with a command like 'runqemu qemux86'
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:06
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: apr-native-1.5.2-r0 do_fetch: Failed to fetch URL http://archive.apache.org/dist/apr/apr-1.5.2.tar.bz2, attempting MIRRORS if available
WARNING: libcap-2.24-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.24.tar.xz, attempting MIRRORS if available
WARNING: iso-codes-3.65-r0 do_fetch: Failed to fetch URL https://pkg-isocodes.alioth.debian.org/downloads/iso-codes-3.65.tar.xz, attempting MIRRORS if available
WARNING: libtirpc-1.0.1-r0 do_fetch: Failed to fetch URL http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs, attempting MIRRORS if available
ERROR: libtirpc-1.0.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'distfiles.gentoo.org'

ERROR: libtirpc-1.0.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/libtirpc/1.0.1-r0/temp/log.do_fetch.9327
ERROR: Task 4195 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection reset by peer
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3732
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/qtbase/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3735
ERROR: Task 630 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 1498 tasks of which 1066 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch
Summary: There were 6 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* 编译log : end */
	log显示 qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 下载失败,感觉这个是关键!!
	测试生成的镜像,全部成功启动,就是不知道最终是否有图像帧输出!!!!
	感觉并没有QT界面demo程序的出现
感觉 bitbake atmel-qt5-demo-image 是失败了的,官网上 Build Atmel Poky Qt-Embedded SDK 是什么鬼??
	bitbake -c populate_sdk atmel-qt5-demo-image //先尝试,不管了,
	//这次鸣不需要重新执行一次: source oe-init-build-env build-atmel 指令!!! 估计是没有重启关系,配置文件没用删回原样!!
	//另外,观察是不是每次bitbake都要重新下载文件!!! 并没有重新下载文件!! 然而 qtbase包还是没有!!
/* log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake -C populate_sdk atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:36
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Tainting hash to force rebuild of task /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-atmel/qt5-layer/recipes-qt/images/atmel-qt5-demo-image.bb, do_populate_sdk
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: libproxy-0.4.11-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/libp/libproxy/libproxy_0.4.11.orig.tar.gz, attempting MIRRORS if available
WARNING: ethtool-4.2-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/software/network/ethtool/ethtool-4.2.tar.gz, attempting MIRRORS if available
WARNING: openssh-7.1p2-r0 do_fetch: Failed to fetch URL http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-7.1p2.tar.gz, attempting MIRRORS if available
WARNING: mpeg2dec-0.4.1-r2 do_fetch: Failed to fetch URL http://libmpeg2.sourceforge.net/files/mpeg2dec-0.4.1.tar.gz, attempting MIRRORS if available
WARNING: apmd-3.2.2-15-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball, attempting MIRRORS if available
WARNING: sysklogd-1.5.1-r0 do_fetch: Failed to fetch URL http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz, attempting MIRRORS if available
ERROR: apmd-3.2.2-15-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'snapshot.debian.org'

ERROR: apmd-3.2.2-15-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/apmd/3.2.2-15-r0/temp/log.do_fetch.15423
ERROR: Task 3283 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch) failed with exit code '1'
ERROR: sysklogd-1.5.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'www.infodrom.org'

ERROR: sysklogd-1.5.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/sysklogd/1.5.1-r0/temp/log.do_fetch.15450
ERROR: Task 3270 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch) failed with exit code '1'
WARNING: time-1.7-r2 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/time/time-1.7.tar.gz, attempting MIRRORS if available
WARNING: wpa-supplicant-2.5-r0 do_fetch: Failed to fetch URL http://w1.fi/releases/wpa_supplicant-2.5.tar.gz, attempting MIRRORS if available
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.12778
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 2348 tasks of which 1710 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
Summary: There were 9 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* log : end */
	











20170120
关于 yocto project  的学习!!
You can find log files for each task in the recipe's temp directory 
	(e.g. poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0/temp). 
	 Log files are named log.taskname (e.g. log.do_configure, log.do_fetch, and log.do_compile). 
To add a new machine, you need to add a new machine configuration file to the layer's conf/machine directory. 
	This configuration file provides details about the device you are adding. 	
	The most important variables you must set in your machine configuration file 	
	or include from a lower-level configuration file are as follows:
		TARGET_ARCH (e.g. "arm")
		PREFERRED_PROVIDER_virtual/kernel
		MACHINE_FEATURES (e.g. "apm screen wifi")
	You might also need these variables:
		SERIAL_CONSOLES (e.g. "115200;ttyS0 115200;ttyS1")
		KERNEL_IMAGETYPE (e.g. "zImage")
		IMAGE_FSTYPES (e.g. "tar.gz jffs2")
	You can find full details on these variables in the reference section. 
	You can leverage existing machine .conf files from meta-yocto-bsp/conf/machine/. 
Adding a Kernel for the Machine








20170203
/** 配置qt5.6.2 环境 **/
下载源码:
	http://download.qt.io/official_releases/qt/5.6/5.6.2/single/下载(官方发布非调试版本):
		qt-everywhere-opensource-src-5.6.2.zip
	然后解压
配置 qmake:
	qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf
	#
	# qmake configuration for building with arm-linux-gnueabi-g++
	#

	MAKEFILE_GENERATOR      = UNIX
	CONFIG                 += incremental
	QMAKE_INCREMENTAL_STYLE = sublib
	
	QT_QPA_DEFAULT_PLATFORM = linuxfb   
	#QMAKE_CFLAGS_RELEASE   +=-O2 -march=armv5te  
	QMAKE_CFLAGS_RELEASE	+= -O2 -march=armv7-a      	#选择armv7架构
	QMAKE_CXXFLAGS_RELEASE	+= -O2 -march=armv7-a  		#选择armv7架构
	
	include(../common/linux.conf)
	include(../common/gcc-base-unix.conf)
	include(../common/g++-unix.conf)
	
	# modifications to g++.conf
	QMAKE_CC                = arm-linux-gnueabihf-gcc	#把 arm-linux-gnueabi  换成arm-linux-gnueabihf
	QMAKE_CXX               = arm-linux-gnueabihf-g++
	QMAKE_LINK              = arm-linux-gnueabihf-g++
	QMAKE_LINK_SHLIB        = arm-linux-gnueabihf-g++
	
	# modifications to linux.conf
	QMAKE_AR                = arm-linux-gnueabihf-ar cqs
	QMAKE_OBJCOPY           = arm-linux-gnueabihf-objcopy
	QMAKE_NM                = arm-linux-gnueabihf-nm -P
	QMAKE_STRIP             = arm-linux-gnueabihf-strip
	load(qt_config)

配置 QT 工具链:
	cd 到 qt-everywhere-opensource-src-5.6.2 源码根目录
	..sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2$ ./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float
		//-xplatform linux-arm-gnueabi-g++ 说明 生成的QT工具包和库是面向arm架构的，表示这些工具和库要用对应的编译工具生成
		//-prefix home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a 表示 生成的QT工具包和库 都install到的目标文件夹
		//-no-c++11 表示不使用C++11标准来编译文件, 即使用旧版的 c++98 标准来编译工具链
	./configure出错:  bash: ./configure: /bin/sh^M: 解释器错误: 没有那个文件或目录
		由于configure文件本来面向win系统 以 \n\r表示行结尾, 而linux单纯以 \n表示行结尾,
		在linux里 \r 被显示为^M
		所以要把\r替换为空格
		注意使用gedit 去掉\r 不彻底,由于gedit自动识别到 configure是 win文件 所以 保存文件时又会重新添上 \r
		不然./configure还会出现像:/bin/sh: 0: Can't open  这样的错误!!
		所以使用命令替换\r为空格 : sed -i 's/\r$//' configure
		./configure 继续出错: ./configure: 49: exec: /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure: not found
		原因是: qtbase/configure 依然有 /r
			sed -i 's/\r$//' ./qtbase/configure
		./configure 继续出错: You don't seem to have 'make' or 'gmake' in your PATH.
			初步解决办法: sudo apt-get install build-essential(未执行)

发现: qt-everywhere-opensource-src-5.6.2.zip 是面向 win 的源码包,
	我们应该下载面向linux 的源码包 :qt-everywhere-opensource-src-5.6.2.tar.gz
	重新配置....
	然后 ./cofigure 一直通过,没有再出现之前遇到的错误
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.........................................................................................Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++98		//使用旧版的 c++98 标准来编译工具链
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)

Info: creating super cache file /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/.qmake.super

        NOTICE: The -no-c++11 / --c++-level=c++98 option is deprecated.

        Qt 5.7 will require C++11 support. The options are in effect for this
        Qt 5.6 build, but you should update your build scripts to remove the
        option and, if necessary, upgrade your compiler.

Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	./configure成功
编译:
	make
	出错:
	在编译plugins/canbus时:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbusdevice.h:98:46: error: ‘nullptr’ was not declared in this scope
In file included from main.cpp:37:0:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbus.h:60:31: error: ‘nullptr’ was not declared in this scope
	main.cpp:58:14: error: ‘device’ does not name a type
	main.cpp:59:16: error: ‘device’ was not declared in this scope
	初步认为是,编译时没有开启支持 C++11 的特性!! 而一些内容需要C++11的特性来编译
重新配置:
	./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float	//注意 -c++11 前面没有-no前缀 ,这里配置应该就表示使用C++11标准编译 qt工具链 
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for C++11...  yes.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend c++11 clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++11		//使用C++11标准来 编译
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)


Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	然后直接make
	之前用 c++98 编译的,不用再编译,之后未编译的用 c++11 标准继续编译!!
	出错!!
/* log : start */
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/src'
cd examples/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/examples.pro -o Makefile ) && make -f Makefile 
make[2]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
cd canvas3d/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/canvas3d.pro -o Makefile ) && make -f Makefile 
make[3]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
cd textureandlight/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/textureandlight/textureandlight.pro -o Makefile ) && make -f Makefile 
Project ERROR: Unknown module(s) in QT: quick
make[3]: *** [sub-textureandlight-make_first] 错误 3
make[3]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
make[2]: *** [sub-canvas3d-make_first] 错误 2
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
make[1]: *** [sub-examples-make_first] 错误 2
make[1]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d'
make: *** [module-qtcanvas3d-make_first] 错误 2
/* log : end */
	由于是未知错误,所以,无法追踪出错源头,初步怀疑是之前用C++98 编译的模块 与后面用 C++11 编译的模块 要组合时出错!!!
	make distclean	//把之前所有生成的东西都删掉!!!! 但make distclean 也有出错的!!!	加上 -j8 加快clean速度 
	make confclean	//恢复出厂配置 configure 和 qmake.conf
	
	编译 qtcanvas3d 失败 是因为 使用的 quick 模块 需要 opengl
	网上参考:
		在编译之前，还有个改动，额。。。qt3d和qtcanvas3d在编译的时候会报错，说是未识别模块，
		而且嵌入式的没有opengl，识别了也会报错，导致编译失败，而且编译配置参数里面也没有这两个模块的配置。
		我的解决方法简单粗暴，在配置时参数加-no-opengl，然后打开qt-everywhere-opensource-src-5.7.0/qt.pro文件，找到：
			addModule(qt3d, qtdeclarative qtimageformats)
			addModule(qtcanvas3d, qtdeclarative)
		这两行注释掉（#号注释），或者直接删掉。如果不注释掉，即使加了-no-opengl也会报错，编译失败。
	这就是说跳过 qtcanvas3d qt3d 的意思,如果我坚决要编译的话,就得加入 opengl
	重新./configure:
		./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -opengl -qreal float	//添加了opengl项
		出错:
			checking for OpenGL...  no.
			checking for OpenGL ES 2.0...  no.
			All the OpenGL functionality tests failed!
			You might need to modify the include and library search paths by editing
 			QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in
 			/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/mkspecs/linux-arm-gnueabi-g++.
	网上参考:
		编译安装Qt可能出现的问题及解决办法:
		以下模块，yes的是qt默认安装的。
		Debug ............... no
		Qt 3 compatibility .. yes
		QtDBus module ....... no
		QtScriptTools module  yes
		QtXmlPatterns module  yes
		Phonon module ....... no
		SVG module .......... yes
		WebKit module ....... yes
		STL support ......... yes
		PCH support ......... yes
		MMX/3DNOW/SSE/SSE2..  yes/yes/yes/yes
		Graphics System ..... default
		IPv6 support ........ yes
		IPv6 ifname support . yes
		getaddrinfo support . yes
		getifaddrs support .. yes
		Accessibility ....... yes
		NIS support ......... yes
		CUPS support ........ no
		Iconv support ....... yes
		Glib support ........ yes
		GStreamer support ... no
		Large File support .. yes
		GIF support ......... plugin
		TIFF support ........ plugin (qt)
		JPEG support ........ plugin (system)
		PNG support ......... yes (system)
		MNG support ......... plugin (system)
		zlib support ........ system
		Session management .. yes
		OpenGL support ...... yes (Desktop OpenGL)
		NAS sound support ... no
		XShape support ...... yes
		XSync support ....... yes
		Xinerama support .... runtime
		Xcursor support ..... runtime
		Xfixes support ...... runtime
		Xrandr support ...... runtime
		Xrender support ..... yes
		Xi support .......... runtime
		MIT-SHM support ..... yes
		FontConfig support .. yes
		XKB Support ......... yes
		immodule support .... yes
		GTK theme support ... no
		PostgreSQL support .. plugin
		SQLite 2 support .... plugin
		SQLite support ...... plugin (qt)
		OpenSSL support ..... yes (run-time)
		所以，但我们开始装qt之前没有编译显示no的那些模块，我们可以
		重新编译一次。
		#./configure -phonon
		但这时候，可能会提示以下内容，
		Phonon support cannot be enabled due to functionality tests 
		解决办法：
		先下载必要的包：
		sudo apt-get install libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev
		重新#./configure -phonon
		即可。。。

		如出现
		Basic XLib functionality test failed!
		则先安装libxext-dev
		sudo apt-get install libxext-dev

		mark时出现
		/usr/bin/ld: cannot find -lXext
		则需安装libxt-dev
		sudo apt-get install libxt-dev

		mark时出现
		/usr/bin/ld: cannot find -lXrender
		则需安装libxrender-dev
		sudo apt-get install libxrender-dev

		出现
		X11/extensions/Xdamage.h: No such file or directory
		则安装libxdamage-dev
		sudo apt-get install libxdamage-dev

		About QtOpenGL
		If try -opengl then: All the OpenGL functionality tests failed!
		sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev

		About QtDBus
		If try -dbus then:The QtDBus module cannot be enabled because libdbus-1 version 0.93 was not found
		sudo apt-get install libdbus-1-dev
		sudo apt-get install libedbus-dev

		gconf
		sudo apt-get install libgconf2-dev

		icu
		sudo apt-get install libicu-dev

	因此:先sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev
	然后qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf添加:
		QMAKE_INCDIR_OPENGL   = /usr/include/GL
		QMAKE_LIBDIR_OPENGL   = /usr/lib
		QMAKE_LIBS_OPENGL     = -lGLU -lGL	
	依然错误:	All the OpenGL functionality tests failed!
	网上参考:
		如果需要openGL，就需要用 -opengl选项指定opengl的api，对于嵌入式平台，一般使用 opengl ES2，配置选项中加入" -opengl es2 " 。
		不过想使用openGL可能会比较麻烦，因为openGL一般在有硬件图形加速的条件下才能高效运行，而这需要显卡或Soc厂家提供openGL的支持库，
		但并不是所有Soc都能找到对应的支持库，比如三星就没有提供S5PV210的openGL库，所以我这里编译的Qt也是没有opengl的。
		(openGL的替代方案：如果没有厂家提供的硬件图形库，可以考虑使用纯软件实现的opengl，这样的软件库有很多是开源的，如mesa3D库等，
		不过纯软件实现的opengl在效率方面肯定要比带硬件加速的低很多，而且要想在嵌入式平台上使用，必须将opengl的软件库也交叉编译出来，
		我在交叉编译mesa3D时遇到了些问题，所以目前还没能在开发板上用上openGL)；
	还是先放弃 opengl:
		








20170204
昨天编译QT 一直卡在qtcanvas3d编译失败,原因是需要用到opengl模块,但是并没有加载安装使用oepngl 所以试图先跳过qtcanvas与qt3d 
然而按晚上参考的 qt.pro里没有对应项给予更改!!!
不过知道了,虽然卡在了canvas3d上,但是qt的主体部分已经编译完成!!!
所以直接make install 输出生成文件!!!
现在的工作是拷到文件系统里,做测试!!!
由于没有使用nfs 所以,先学习制作 ubi文件系统!!!

以下实验基于yocto项目生成好文件系统镜像展开,并所有实验内容都放在:/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1 里
解压一个ubi镜像:
网上参考(走运,直接找到sama5d4_xpl的): http://blog.csdn.net/andylao62/article/details/50750404
	sudo apt-get install mtd-utils //安装mtd-utils
	//sama5d4ek or sama5d4_xplained board, the nand flash is different, 
	//so use following line to do the nandsim, change the page size to 4096.
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xdc third_id_byte=0x90 fourth_id_byte=0xa6	
	sudo modprobe ubi mtd=0
	sudo ubidetach /dev/ubi_ctrl -m 0
	sudo ubiformat /dev/mtd0 -s 4096 -f xxxx.ubi 	//2048 改为 4096
	sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096	//2048 改为 4096
	sudo mkdir /mnt/loop
	sudo mount -t ubifs ubi0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs 		//把内容全部拷到xxxfs文件夹里!! */
	//注意,不同的 nandflash 匹配不同的 nandsim 和 page size 以下nandsim 不是sama5d4开发板所用nandflash对应的nandsim 
要根据自己机器的情况来选择：
modprobe nandsim first_id_byte=0x20 second_id_byte=0x33 - 16MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x35 - 32MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x36 - 64MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x78 - 128MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x71 - 256MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00 fourth_id_byte=0x15 - 64MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00 fourth_id_byte=0x15 - 128MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00 fourth_id_byte=0x15 - 256MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00 fourth_id_byte=0x15 - 512MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95 - 1GiB, 2048 bytes page;我昨天解包的时候就是在这里搞错了（我的机器需要4096 bytes page），然后再最后mount的时候老是mount不上，记住这步至关重要！ 5，检查加入模块的环境

附加:解压JFFS2 images
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xda third_id_byte=0x00 fourth_id_byte=0x15
	sudo modprobe mtdblock
	sudo modprobe mtdchar
	sudo modprobe mtd mtd=0
	sudo dd if=xxxxxxxxjffs2 of=/dev/mtd0
	sudo mkdir /mnt/loop
	sudo mount -t jffs2 /dev/mtdblock0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs	//把内容全部拷到xxxfs文件夹里!! */

然后压缩成一个 ubi 镜像!!!
	//假如现在处于 rootfs1 ,把 rootfs1/minfs 整个文件夹制作成ubi文件系统
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -m 4KiB -e 248KiB -c 2048 -o minfs.ubifs
	//mkfs.ubifs 制作成 ubifs镜像
	//-r 要制作成镜像的文件夹路径
	//-m nandflash 的 page 大小
	//-e 逻辑擦除块大小 block 大小, 每个物理块有2个4KiB(2个page)是由系统管理不可被用户使用的,所以不可被擦除,所以大小是248KiB,非256KiB
	//-c 有多少个逻辑擦除块
	//-o 生成镜像的名字!!!
	sudo ubinize -o minfs.ubi -m 4KiB -p 256KiB -s 4096 -O 4096 ubinize.cfg
	//mkfs.ubifs 制作成 ubi 二进制镜像
	//-m nandflash 的 page 大小
	//-p 物理块大小(物理块就是 逻辑擦除块 + 由系统管理不可被用户使用的空间)
	//-s 给 ubi文件系统头信息所使用的空间 一般等于一个对应的 nandflash page大小
	//-O 逻辑擦除块 距物理块开始位置的偏移量,一般为一个 由系统管理不可被用户使用的空间
	ubinize.cfg : 配置文件
[rootfs-volume]  
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0
vol_size=520MiB  
vol_type=dynamic
vol_name=min-rootfs
vol_flags=autoresize
	//生成镜像加载失败!!!
	由于知道了 mkfs.ubifs 通过追踪 yocto项目此命令的使用途径就可以跟踪到具体出错处,
	最后挖掘到  成功生成镜像并执行  的命令集!!! (并且是把解压的 ubi文件 重新打包生成镜像执行,说明,解压的方法也是正确的!!)
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o minfs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
	//-e 0x3e000	即 248KiB 与上面的指令的参数及意义一样
	//-c 2082	2082 表示理论上有2082个逻辑块, 意味着2082个物理块,意味着理论上文件系统应管理的nandflash磁盘空间有520MiB
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-x lzo	强调 制作成 .ubifs 镜像是 lzo 压缩格式
	sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-p 0x40000	即 256KiB 与上面的指令的参数及意义一样
	//此外并没有设置 -s -O 参数,任其自动使用默认值
	ubinize.cfg : 配置文件
[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0		//内核会识别
vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
vol_type=dynamic
vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
vol_flags=autoresize
	//特别注意:vol_size=480MiB 这一项,对比yocto工程发现,yocto工程里对应的ubinize.cfg本身没有这一项!!
	//yocto工程使用工程自带封闭的 mkfs.ubifs 工具来编译生成 ubi文件系统镜像,与我使用的 mkfs.ubifs 工具 可能版本不一样
	//所以yocto工程里对应的ubinize.cfg可以没有这一项,但是我的没有这一项vol_size=.. 使用ubinize时便会报错:
ubinize: volume size was not specified in section "rootfs-volume", assume minimum to fit image "/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs"6602752 bytes (6.3 MiB)
	//而vol_size=480MiB 的值也有讲究:
	//上面曾设置为: vol_size=520MiB,而 mkfs.ubifs 参数-c 2082 也暗示这个文件系统将可以管理nandflash磁盘空间有520MiB
	//然而加载时出错:
ubi0 error: vtbl_check: too large reserved_pebs 2165, good PEBs 2012
	//这里表示内核运行时会扫描nandflash,会把坏的物理块标记,最后告知,只剩下2012个可用物理快,表明实际可被使用的空间 只有500MiB左右,
	//并没有520MiB那么多, 而且,对于文件系统说,内核 与 bootloader 与 dtb 占据的空间不可访问,
	//所以实际上 文件系统将可以管理nandflash磁盘空间或许只能是480MiB左右,文件系统不可能写入多于这个量的内容到磁盘上
	//所以 vol_size=520MiB 时会出错,提示,磁盘实际上没有这么多空间!!!!!

	成功运行 自己制作的ubi镜像的log信息
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1337189846
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
at91_rtc fc0686b0.rtc: setting system clock to 2017-01-16 21:01:12 UTC (1484600472)
panel-power-supply: disabling
ALSA device list:
  No soundcards found.
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 9B79CCE3-363E-40CB-9F39-03BF4EF7F87B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
Starting udev
udevd[692]: starting version 3.1.5
open_ts!
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 721
Populating dev cache
/* log : end */

通过学习制作ubi格式文件系统!!更深刻地了解了文件系统的运作!!!
	从 ubi 文件系统来分析!!!
	首先在打包成ubi镜像前的 根文件目录里的内容只不过是普通的文件内容而已,并不是文件系统本身!
	内核完成启动后,就开始访问既定的用户内容了,而这些内容就是我们知道的放在根文件目录里的各项内容,
	内核如何访问和执行这些内容?
		首先,从硬件低层看,文件内容是分割成各个部分 存放在各个 page 和物理块上,
		要有效率地取得内核想要的内容,我们就得及建立关于文件内容在底层硬件里存放的框架协议,例如 ubi 这种框架
		文件内容按照 ubi 这种框架规范,分布存放在磁盘各处,
		而对应地,内核本身就有内置了遵从 ubi 这种规格收集文件内容的api函数,内核就可以方便地访问自己想要的内容了
		就好像,图书按ubi规则放到图书馆每个角落,而相当于人的内核,因为知道书本摆放规则,遵从ubi规则,很快就可以找到书本一样,
		按规则分布摆放在磁盘的内容,磁盘,还有内核内置的遵从规则收集所需内容的api 共同组成的才叫文件系统!!!
	那么文件系统镜像又是什么一回事?
		一般,linux系统,很多重要的功能都不能直接内置到内核里,这样内核会变得很大,根本不能很好维护,甚至工作效率低下,
		于是吧他们制作成文件内容,让内核启动后再访问磁盘找到他们然后执行!!
		如果真有这么一个奇葩,就是喜欢吧所有功能都往内核塞,那么,的确,我们约定俗成的根文件目录里可以什么都没有!!
		正因为,这些文件内容是必须的,又不推荐内置到内核里,所以,这些内容得在内核甚至机子启动之前就放入磁盘里
		文件系统镜像的一部分内容就是,这些必要的文件内容 按照 ubi框架规矩,符合nandflash硬件属性 排布成二进制数据块,
		然后 原封不动地拷到 物理介质nandflash里,
		相当于 有一个按照ubi规则放好图书的大书柜,连柜带书直接搬进图书馆,人可以直接遵从ubi规则,找书.
		当内核启动后,内核就可以去找要找的内容直接执行了!!
		文件系统镜像的另一部分内容,就是关于ubi框架的内容了,
		nandflash空间几百M,然而文件系统镜像可能就几M,以前误认为,可用的磁盘空间等于文件系统镜像的大小,然而并不是这样!!!
		虽然文件系统镜像才几M,但是可用的磁盘空间可以是几百M
		内核启动时,使用ubi框架的文件系统时,会先,根据镜像里的 附加属性信息,把镜像外,属性标明里的其他nandflash空白空间
		也规范成 符合 ubi 框架的 文件管理空间.
		当有新文件写入到机子nandflash时, 内核便会管理分拆成符合ubi框架的数据块,然后分布写入这些空白空间.
		所以总的来说,镜像只有打包了的 已经符合ubi框架的数据块内容,还有一些关于ubi框架的附加信息外,一般并没有操作数据的api内容
		而操作的api一般都直接内置到内核内部,
		内核启动时会检测 镜像究竟是属于那一种 文件内容框架,是ubi的,还是其他,
		然后选择对应规则的api,然后按照规则初始化指定磁盘空间, 然后就可以遵从规则,搜集,读写,操作想要的文件或数据了
	以上是文件系统的通用认识,按转时代,需求不同,有更多新的特性出现!!!有些特性甚至有,有别于以上通识的改动,
	不过文件系统的角色不曾改变!!!









20170206
解压官方demo的ubi!!由于昨日已经解压实验时已做好了一些解压环境配置工作,今天不用重复做
新建 rootfs2文件夹,把工作内容都放进去:
cd /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2
拷贝 atmel-xplained-demo-image-sama5d4-xplained.ubi 到此文件夹
sudo ubidetach /dev/ubi_ctrl -m 0
sudo ubiformat /dev/mtd0 -s 4096 -f atmel-xplained-demo-image-sama5d4-xplained.ubi
sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096
sudo mount -t ubifs ubi0 /mnt/loop
sudo cp -R /mnt/loop/* ./demofs 	//把所有内容拷到 demofs 文件夹   */
官方 fs 的启动初始化log
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 3/0, WL threshold: 4096, image sequence number: 400630375
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 36
ubi0: background thread "ubi_bgt0d" started, PID 662
....
UBIFS (ubi0:0): recovery needed
UBIFS (ubi0:0): recovery deferred
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 498253824 bytes (475 MiB, 1962 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID D094325A-A0E6-490A-8A23-FAC662B80F50, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
Console: switching to colour frame buffer device 100x30
....
UBIFS (ubi0:0): completing deferred recovery
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 780
UBIFS (ubi0:0): deferred recovery completed
/* log : end */

重新压缩官方fs 成ubi镜像!!!!
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
ubinize.cfg : 配置文件
	[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
	mode=ubi
	image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
	vol_id=0		//内核会识别
	vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
	vol_type=dynamic
	vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
	vol_flags=autoresize
重新压缩后 启动初始化log:
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1392490045
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
.....
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 4F5D1854-E45F-4000-A706-55B47390EA4B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
.....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
/* log : end */

计划移植 QT 和 QT 库到 开发板去!!!
从demo的fs里 没有发现任何关于 gui 等相关的执行程序!!!
所以,不打算使用demofs 来移植qt,因为demofs现有的文件太多,再加上qt库的话,最后压缩的ubi镜像会很大!!!
所以选择移植到 minfs
之前 编译的qt库,虽然仍然卡在qtcanvas而还没有全部编译完,但是,主体库已经完成,可以进行移植:
之前,qt编译后,我设定是把所有编译生成文件都放在 rootfs1/armv7-a
1,
把 rootfs1/armv7-a 文件夹里所有内容 拷到 minfs/opt/qt
修改 minfs 的系统变量: minfs/etc/profile最后添加:
	PATH=$PATH:/sbin:/usr/sbin
	LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
	export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/qt/lib/		//添加qt库文件路径
	export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms	//qt的平台模式
	export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0			//显示设备 fb0 即lcd屏
	export QT_QPA_FONTDIR=/opt/qt/lib/fonts  			//字体库
	export QT_QPA_GENERIC_PLUGINS=/dev/input/event0			//输入设备 event0 即触摸屏
	export LD_PRELOAD=/lib/preloadable_libiconv.so			//qt程序需要 libiconv库
2,
QT程序在运行时需要依赖libiconv库
下载：http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz
解压并进入对应 libiconv-1.14 目录
编译步骤：
在libiconv目录下：
$./configure --prefix=$PWD/temp --host=arm-linux-gnueabihf   //我们的编译器厂商是 arm-linux-gnueabihf
//参数
//--prefix=$PWD/temp  生成文件放置的目标文件夹
$make
$make install
上述命令执行完成后会在libiconv目录下生成新的temp目录，该目录下存在4个目录分别是：
bin include lib share
在lib目录下为生成的库文件，其中一个为preloadable_libiconv.so，
把它下载到开发板的lib目录下，然后再设置开发板的系统环境变量即可： minfs/etc/profile最后添加:
	export LD_PRELOAD=/lib/preloadable_libiconv.so
最后，开发板执行qt程序时，不会提示 iconv_open failed
3,
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:minfs.ubi:0x800000
生产ubi镜像并烧入如开发板
4,
测试,执行 /opt/qt/examples 的qt demo程序测试
后来发现还是缺少各种库,先通过 arm-linux-gnueabihf-readelf -a xxxx|grep "lib" 查找xxxx执行文件的依赖库,
然后把所缺乏的库找到,或者编译好,然后拷到 minfs对应lib文件夹,
最后,
成功执行demo,但是显示界面和触摸屏问题多多!!!
	qtgui与log信息并行使用fb0,导致gui与log消息抢屏现象
	触摸位置不正确!!!
试图移植tslib改善,触摸位置问题!!!
编译安装 git clone 下来的新版本 tslib 並不是使用tslib-1.4
apt-get install autoconf
apt-get install automake
apt-get install libtool
git clone https://github.com/kergoth/tslib
cd tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/tslib/tslib/finish
//--prefix 一定要绝对路径!!!
make
//input_raw.c ts_uinput.c 都提示 没有 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
//mt是多点触控的内容
//但是在 input_raw.c 有define
//初步调查发现 这些定义应该在linux/input.h的,但是pc机撒谎嗯的linux/input.h没有
//修改 input_raw.c 和 ts_uinput.c 用input_raw.c上define的 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
make install
把--prefix 路径里的所有内容拷到 minfs/opt/tslib
修改 etc/profile 最后添加:
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0
PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
但是失败!!
显示 fopen ts_config 文件not found
使用tslib1.4 重新制作,可以执行,但是 lcd没有显示的情况!!!
readelf 发现 ts_calibrate 的 library_rpath 有问题,是一个固定绝对的路径!!!这个路径对于开发板的文件系统来说据对是错的!!!!
所以,按照以下内容重新编译!!!!










20170207
继续处理tslib问题:
修改uboot 使得lcd不再作为一个console
uboot/include/configs/at91-sama5_common.h:
#define CONFIG_BOOTARGS							\
	"console=tty0 "							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
改为:
#define CONFIG_BOOTARGS							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
编译
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
烧写:
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c write:u-boot.bin:0x40000
启动开发板:
发现,已经没有作为console的大部分输出,但是还是有 please wait 和闪烁的命令字符光标.说现在的lcd屏作为 tty1 设备
执行qt demo 完美显示,但是 触摸屏错位,不能正确控制!!!!
另外通过,arm-linux-gnueabihf-readelf -a ts_calibrate|grep "lib"查看依赖库时,发现 library_rpath 涉及--prefix 的绝对路径
自然之前的编译移植tslib的方法自然不对!!!
由于我们要把生成的文件放到开发板的 /opt/tslib 里,所以--prefix设置成pc机的 /opt/tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/opt/tslib
make
make install
然后把pc上/opt/tslib里所有东西拷到 minfs/opt/tslib里,
设置 minfs/etc/profile
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0

PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
设置 minfs/opt/tslib/etc/ts.conf
# Uncomment if you wish to use the linux input layer event interface
module_raw input
.......
重新编译,烧写,
还是出现相同错误,串口端表示成功执行,但是lcd没有任何显示!!
后来发现yocto 工程里下了个 tslib1.1版,
同样方法移植tslib1.1
成功lcd显示和执行,但是,触摸屏出现严重的误差问题!!!!








20170208
检查触摸屏的问题!!!
先修改触摸屏的压力值统一为 2000:
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		if(pres < 500)		//当笔尖离开触摸屏,即要发生key_up事件,要求压力值pres值等于0 来提示触犯key_up事件
			pres = 0;
		else
			pres = 2000;	//注意 有pres时,表示一直处于key_down 我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
重现编译内核,烧写!!!
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000
经检测发现:
关于 key_up key_down 的事件是 又input_event来判断的 !!
report pres = 2000 和 BTN_TOUCH 1 后 input_event 识别为key_down事件
report pres = 0 和 BTN_TOUCH 0 后 input_event 识别为key_up事件
key_up与key_down事件并不是 由at91_adc.c本身来生成的,而是由input_event 识别生成的!!!
触摸屏不可能只有key_up事件而没有key_down事件!!
所以把pres只设定为一个值,是不正确的,应该按上面的根据情况起码设置两个值!0和某值!!
但是这种改法还是不好,
不是每一次手离开触摸屏时,芯片能及时采样到一个pres低于500 的压力值,
于是 pres = 2000 和 BTN_TOUCH 0 report到 input_event ,input_event 并不能分析是处于key_up抑或是key_down事件,
虽然把今次事件强制认为是key_up事件,但会把这种奇怪的情况记录下来,
这是如果ctrl+c结束ts_test,再重新启动ts_test后,因为保存上次奇怪情况,而不在后续不能正常地分析触摸事件
所以,要压力值统一为 2000:的最佳做法!!
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		pres = 2000;	//我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
而
at91_adc.c:irqreturn_t at91_adc_9x5_interrupt()

	} else if (status & AT91_ADC_IER_NOPEN) {

		//by william
		pr_debug("nopen\n");	//表示笔尖离开触摸屏

		at91_adc_writel(st, st->registers->trigger_register, 0);
		at91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_NOPEN |
			ts_data_irq_mask);
		at91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);

		//by william	
		input_report_abs(st->ts_input, ABS_PRESSURE, 0);	//report BRN_TOUCH 0 之前,多加一步 report pres 0

		input_report_key(st->ts_input, BTN_TOUCH, 0);
		input_sync(st->ts_input);
	} 

使用一个节衷的方法解决了触摸屏的跳屏问题!!!
观察到,触摸屏的第一次采样几乎是正确的!!! 而第一次采样是 采样开关开始后的第一次采样!!!
于是,我们可以频繁打开关闭采样开关,只为取第一次采样,于是 at91_adc.c 修改如下:
at91_adc.c:at91_ts_sample()
........
	/* calculate the pressure */
	reg = at91_adc_readl(st, AT91_ADC_TSPRESSR);

	//by william
	at91_adc_writel(st, AT91_ADC_IDR, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));
.......
	//by william
	//ndelay(10000);
	at91_adc_readl(st, AT91_ADC_TSXPOSR);	//清空x y pres寄存器!!
	at91_adc_readl(st, AT91_ADC_TSYPOSR);
	at91_adc_readl(st, AT91_ADC_TSPRESSR);				
	at91_adc_writel(st, AT91_ADC_IER, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));

	return 0;
}
从中还挖出几个重点!!!
1,irq pen_detect后会修改 中断触发开关,先关闭pen_detect 并开启开启开关
2,当 累计 x,y,pres 3个采样都就绪时,才在at91_ts_sample 一次性读出采样!!
3,当第一次采样完成后会,把采样结果放到对应寄存器,触发中断,然后不管中断函数中什么时候读取采样结果,就已经开始下一次采样了
  如果第二次采样也结束了,但第一次采样结果还没有读出,第二次的结果并不会写入寄存器,第三次采样不会开始,
  也就说,第一次结果被读出,第二次的结果就可以马上写入寄存器,然后开始第三次采样!!!
4,所以以上改动中,清空x y pres 寄存器操作非常重要!!!
5,虽然我们在读取第一次结果前(或者后) 关闭采样开关,但是已经无法停下已经执行的第二次采样!!,
  第二次采样的结果会在在第一次的结果被读出后迅速刷入寄存器,第二次结果是错误的,
  关闭采样开关,虽然不能阻止第二次结果刷入寄存器,但不会诱发第二次采样完成的中断函数!!!
  这时的寄存器是放置了数据的!!
6,假如我们你清空寄存器,就打开采样开关,硬件因为检测到寄存器有数据,并不开始重新采样便触发了中断,让用户读出上次未读出的错误数据
7,如果先清空了寄存器再 打开采样开关,这样,硬件就会重新采样,再写入寄存器!!
  儿这次采样就是正确率较高的 打开采样后的第一次采样!!!!
最后,
跳屏现象很有规律, 是跳屏采样点在 实际采样点与原点的线性关系上的点!!
认识到,跳屏,可能真的是由于采样频率过密而诱发的电压跳变误差造成!!!
所以,正途是重新修改 adc_clk 等一系列采样时间参数!!

此外,当采样数据送到 寄存器时, ISR对应位会起flag,读取ISR清flag!!
读取ISR清flag后如果没有及时读出 寄存器里的采样数据, 寄存器里的采样数据并不会丢失,而ISR对应位会重新起flag!!
这样就可以同时筹齐 x y pres 三个采样flag后,再一次性 ts_sample 读取三个寄存器的数据!!!

调节采样时间!!!!!!
	ADC_TRGR TRGPER: Trigger Period : 
		AT91_ADC_TRGR_TRGPER_(x)	((x) << 16)
		AT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val)
		Trigger Period = (TRGPER + 1) / ADCCLK
		st->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US * adc_clk_khz / 1000) - 1, 1);
		adc_clk_khz = adc_clk / 1000
	ADC_TSMR:
		TSAV: Touchscreen Average 3: AVG8CONV : Averages 8 ADC conversions
		PENDBC: Pen Detect Debouncing Period
			Debouncing period = (2^PENDBC) / ADCCLK periods.
			st->ts_pendbc = round_up(TOUCH_PEN_DETECT_DEBOUNCE_US * adc_clk_khz / 1000, 1);
			adc_clk_khz = adc_clk / 1000











20170209
尝试修改 adc 的时钟来得到处理采样问题!!
追踪修改 adc_clk !!
sama5d4.dtsi
	periph32ck {
		compatible = "atmel,at91sam9x5-clk-peripheral";
		.....
		adc_clk: adc_clk {
			#clock-cells = <0>;
			reg = <44>;
		};

drivers/clk/at91/pmc.c:346:		.compatible = "atmel,at91sam9x5-clk-peripheral",
	........
	{
		.compatible = "atmel,at91sam9x5-clk-peripheral",
		.data = of_at91sam9x5_clk_periph_setup,
	},

drivers/clk/at91/clk-peripheral.c:414:void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
					   struct at91_pmc *pmc)
{
	of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
}
of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
	for_each_child_of_node(np, periphclknp) {
		of_property_read_u32(periphclknp, "reg", &id)
		...
...跟丢了
但是后来发现 dts 的 adc_clk 与 at91_adc.c里的 st->adc_clk 不是同一回事,
而 dts 的 adc_op_clk 与 at91_adc.c里的 st->adc_clk 才是同一回事,
at91_adc.c: at91_adc_probe()
	mstrclk = clk_get_rate(st->clk);
	adc_clk = clk_get_rate(st->adc_clk);
	adc_clk_khz = adc_clk / 1000;

第二种改法
本来
mstrclk = 100000000
adc_clk = 1000000
adc_clk_hhz = 1000
当改成 
mstrclk = 1000000
adc_clk = 1000000
adc_clk_hhz = 1000
居然采样也正常采样了,但是采样的时间周期太长,因为mstrclk太小!!!!

本来
tsmr:TRGPER = 1999
改为 2499 ,没用!!
改成 2999 ,没用!!
改成 999, 更加没戏!!

本来
tsmr:TRACKTIM = 10
改为 15 ,没用!!
改成 20 ,没用!!

本来
tsmr:TSFREQ: = 3
改为 5 ,成功!!!!!!!!!
改成 4 ,没用!!

并没有设置 TSSCTIM:

累计使用三个方法改,但是结果都是,触摸的延时严重!!! 
1,频繁开关 采样中断
2,改 mstrclk
3,改 tsmr:TSFREQ

补充,关于 adc clk 的一些知识点!!!!
关于 adc的时钟 有两个
	st->clk = devm_clk_get(&pdev->dev, "adc_clk");
	st->adc_clk = devm_clk_get(&pdev->dev, "adc_op_clk");
st->clk 即 dts 的 adc_clk :
st->adc_clk 即 dts 的 adc_op_clk :
st->clk.rate = mstrclk =100000000
st->adc_clk.rate = adc_clk = 1000000
这两个数据都是从 dts里得到的!!!!
然后我们来看 dts 这里的内容:
/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			adc0: adc@fc034000 {
				compatible = "atmel,at91sam9x5-adc";
				/* 相当于platform_device 里的 IORESOURCE_MEM 类型 resource */
				reg = <0xfc034000 0x100>;
				/* 相当于platform_device 里的 IORESOURCE_IRQ 类型 resource 这里 */
				interrupts = <44 IRQ_TYPE_LEVEL_HIGH 5>;
				clocks = <&adc_clk>,
					 <&adc_op_clk>;
				clock-names = "adc_clk", "adc_op_clk";
				.........
以上是引用 "adc_clk", "adc_op_clk" 的位置 !!

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;
	clocks {
		adc_op_clk: adc_op_clk{
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <1000000>;
		};
		.........
以上是 "adc_op_clk", 的定义位置 !!
在这里 就已经找到 adc_op_clk 的 参数,即 st->adc_clk.rate = clock-frequency = 1000000

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				periph32ck {
					compatible = "atmel,at91sam9x5-clk-peripheral";
					#address-cells = <1>;
					#size-cells = <0>;
					clocks = <&h32ck>;

					adc_clk: adc_clk {
						#clock-cells = <0>;
						reg = <44>;	//其实就是 pmc 里的 PID 44
					};
				.........
以上是 "adc_clk", 的定义位置 !!
但是,还没有找到 adc_clk 的 参数 即st->clk.rate 的位置
发现 adc_clk 的clock,又隶属于 &h32ck 节点,则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				h32ck: h32mxck {
					#clock-cells = <0>;
					compatible = "atmel,sama5d4-clk-h32mx";
					clocks = <&mck>;
				};
以上是 "h32ck", 的定义位置 !!上面又说了,它自己的 clock又属于 &mck 则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				mck: masterck {
					compatible = "atmel,at91sam9x5-clk-master";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MCKRDY>;
					clocks = <&clk32k>, <&main>, <&plladiv>, <&utmi>;
					atmel,clk-output-range = <125000000 200000000>;
					atmel,clk-divisors = <1 2 4 3>;
				};
				.......
以上是 "mck", 的定义位置 !!上面又说了,它自己的 clock 需要 <&clk32k>, <&main>, <&plladiv>, <&utmi> 一起参与, 则:
由于我们早知道st->clk.rate = mstrclk =100000000 而参数 100000000 就是 <&main>节点里参数!!

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main: mainck {
					compatible = "atmel,at91sam9x5-clk-main";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCSELS>;
					clocks = <&main_rc_osc &main_osc>;
				};
				........
以上是 "main", 的定义位置 !!上面又说了,它自己的 clock需要 <&main_rc_osc &main_osc> 参与,看情况, 则:

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main_rc_osc: main_rc_osc {
					compatible = "atmel,at91sam9x5-clk-main-rc-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCRCS>;
					clock-frequency = <12000000>;
					clock-accuracy = <100000000>;
				};

				main_osc: main_osc {
					compatible = "atmel,at91rm9200-clk-main-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCS>;
					clocks = <&main_xtal>;
				};
以上是 "main_rc_osc"和 "main_osc", 的定义位置 !!上面又说了,最终其实就是 main_rc_osc节点里的, 就不讨论main_osc 了
main_rc_osc 就是 "adc_clk" clock的最终使用参数的所在地!!
clock-frequency = <12000000>;	表示输入供main_rc_osc使用的clock频率 单位hz
clock-accuracy = <100000000>;	表示main_rc_osc 输出的clock频率 单位hz
而在这里 就已经找到 adc_clk 的 参数,即 st->adc_clk.rate = clock-accuracy = 100000000

触摸屏幕校对 ts_calibrate 只要多校对几次就好了!!









20170210
移植 window-manager 和 软键盘
软键盘 首选 syszuxpinyin 然而只是下载了源码,大概搜集了做法,却未实现
window-manager 先选 X-window 但是网上移植的教程不多
最后想到,还不如做 移植一个 ubuntu 的文件系统,里面就附带 window-manager
于是开始移植 ubuntu 文件系统!!
几经波折,居然勉强把ubuntu15 的文件系统给挂上!!!,但是容易死机,特便是 cloud-init什么初始化失败,login 时就死机!!
以下是一些移植 ubuntu 文件系统的 参考网页
https://www.ibm.com/developerworks/linux/tutorials/l-ubuntu/
http://blog.csdn.net/embbnux/article/details/12751465
http://www.arm9home.net/read.php?tid-81429.html
http://blog.csdn.net/kickxxx/article/details/15341079
http://cdimage.ubuntu.com/ubuntu-core/vivid/daily-preinstalled/20170104/
https://www.embbnux.com/category/embedded_linux/
http://cdimage.ubuntu.com/ubuntu-base/releases/12.04.4/release/









20170215
内核启动后,挂载根文件系统后的初始化有两种方式
1,传统的 System V initialization 需要先查询 /etc/inittab 文件, 
  init进程启动后第一时间找的就是inittab 文件！inittab负责初始化系统，设置系统runlevel及进 入各runlevel对应要执行的命令。
  假设当前inittab中设置的默认runlevle是5，则init会运行/etc/init.d/rc 5命令，该命令会依据系统服务的依赖关系遍历执行/etc/rc5.d中的脚本/程序。
  进入/etc/rc5.d目录可以发现里面的文件都是到/etc /init.d/下对应的脚本/程序的软链接。
  以S开头的为启动的意思，以K开头的为停止。并且S/K后面的两位数数字代表了服务的启动顺序（由服务依赖关系决定）
  传统的 System V initialization 是以 runlevel 为核心的,依据服务依赖关系初始化
  传统的 System V initialization 一般包含的主要文件有
  /etc/inittab
  /etc/init.d
  /etc/rc0.d
  /etc/rc1.d
  /etc/rc2.d
  /etc/rc3.d
  /etc/rc4.d
  /etc/rc5.d
  /etc/rc6.d
  /etc/rcS.d
2,新的方式是 Upstart job 模式!!
  就是事件驱动,才初始化启动对应的服务功能,严格上说只使用到 /etc/init 里的文件!!
  Upstart job 模式 把 分配 runlevel 也当做是一种事件!!
然而, ubuntu 使用的是合拼型的启动方式!!
ubuntu 的 /etc/init 有以下几个重点文件!!
rc.conf			//rc-sysinit在startup事件发生时被启动
rc-sysinit.conf		//rc在系统runlevel变化时被启动
rcS.conf		//rcS在系统runlevel为S时启动
ubuntu使用的合拼启动模式是,把 System V initialization 的后动当做是一个事件, 用Upstart init 来启动这个事件
在配置文件的注释中说明了，这几个文件，正是Upstart init处理System V-style服务的关键。
文件系统挂载后,startup 启动,然后启动 rc-sysinit.conf ,设置runlevel,然后转到 rc.conf 执行:
exec /etc/init.d/rc $RUNLEVEL  转到了对应的 /etc/rcx.d 开始对应内容的执行!! 即转到了 System V initialization 的内容!!

网上参考:(ubuntu初始化)
启动时会首先执行/etc/init目录中配置文件
配置文件中可以设置启动的时机与顺序，start on startup,start on runlevel [1234],stop on [!3453]
一般的Linux分8个级别:0-6和一个'S'级别。
	0代表关机(halt)，
	6代表重启(restart)；
	1-5分别是不同功能的级别，其中1级别是单用户模式(single)，2-5各有不同。但是在userlinux(包括ubuntu)中2-5级别是毫无差别的。
	最后'S'级别是一个比较特殊的级别，他应该是先于其他级别运行的级别。(这一点有待考证)。
	这里说明一下，0-6级别的运行是互斥的，而不是叠加运行，
	也就是说如果进入(move into)4级别，不是指0-3都要运行，而只是完成4级别里所规定的服务。
所有的运行服务的脚本存储在/etc/init.d/里面。而在/etc/中有rc'X'.d的文件夹，'X'代表0-6和S，也就对应了这8个启动级别，
	里面就都是指向/etc/init.d/里面运行服务的脚本的软连接(symbol link)，
会发现，软连接的数目少于运行脚本数，这就是说不是所有服务都要在一个级别中运行的。软连接的命名是有规则的：
	[K|S][0-90-9][name]，K代表kill，S代表start，后面是个二位数，最后是对应的运行服务的脚本文件名。
	这个name是在运行相应的脚本的时候传递的参数，
	K是传递stop(就是关闭服务),S是传递start(就是启动服务)，
	运行顺序：K小数->K大数->S小数->S大数。这里注意文件夹里的所有软连接都会被执行，
rc'x'.d里面的软连接是由/etc/init/rc.conf调用的 ("x"不包括S)
rcS.d里面的软连接是由/etc/init/rc.conf调用的
rcS.conf		//rcS在系统runlevel为S时启动
在ubuntu中，可以使用update-rc.d命令去维护rc，语法为：sudo update-rc.d servicename defaults 

然而发现 ubuntu12 符合以上ubuntu启动方式, 不可以启动,但是 ubuntu15不符合以上方式,不可启动!!

嵌入式桌面系统架构; gnome 和 kde 而真正的gui是建立在这些架构上的软件!!

简单的嵌入式桌面系统 qt-extended (旧时代手机桌面,已不再维护)
重点记录!!!
在configure时!!出错!!
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/qt-extended/qte1/build-pc$ echo yes | ../qt-extended-4.4.3/configure -ui-type home -release -clean -sound-system alsa -build-qt -no-sxe -no-ssl -no-v4l2 -no-vpn -no-phonon -no-libamr -mediaengines cruxus -remove-mediaengine gstreamer,helix -pictureflow -remove-module bluetooth,drm -no-dbus -no-dbusipc -add-displaysize 480x272 -extra-qt-embedded-config "-qt-freetype -no-webkit -no-dbus -qt-gfx-transformed -qt-gfx-linuxfb" -extra-qt-config "-no-webkit" 
/* log start */
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").

This is the Qt Extended Open Source Edition.

You are licensed to use this software under the terms of the GPL.
Please see the file LICENSE.GPL for the licensing terms.

Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept this license agreement? 
Testing the system Qt: OK (bootstrap only)
Found Qt 4.8 while expecting Qt 4.4.
Qt Extended will build Qt from source.
Qt Extended is using the following locations:
Qt          SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt          BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/host
Qt Embedded SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt Embedded BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/target
Qt Extended SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3
Qt Extended BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc
Qt Extended SDK    tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/sdk

Checking the compiler (host): OK (GCC 4, Little Endian)
Checking the compiler (target): OK (GCC 4, Little Endian)
Bootstrap QBuild: .. FAIL
In file included from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:37:0:
../../../qt-extended-4.4.3/qbuild/src/options.h: In constructor 'Options::Options()':
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: error: call of overloaded 'QString(int)' is ambiguous  //错误处
           traceFile(0) {}
                      ^
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: note: candidates are:
In file included from /usr/include/qt4/QtCore/QString:1:0,
                 from ../../../qt-extended-4.4.3/qbuild/src/qfastdir.h:23,
                 from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:21:
/usr/include/qt4/QtCore/qstring.h:421:43: note: QString::QString(const QByteArray&)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const QByteArray &a)
                                           ^
/usr/include/qt4/QtCore/qstring.h:419:43: note: QString::QString(const char*)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const char *ch) : d(fromAscii_helper(ch))
                                           ^
/usr/include/qt4/QtCore/qstring.h:725:8: note: QString::QString(const QString&)
 inline QString::QString(const QString &other) : d(other.d)
        ^
/usr/include/qt4/QtCore/qstring.h:89:5: note: QString::QString(QChar)
     QString(QChar c);
     ^
/usr/include/qt4/QtCore/qstring.h:88:14: note: QString::QString(const QChar*)
     explicit QString(const QChar *unicode); // Qt5: merge with the above
              ^
../../../qt-extended-4.4.3/qbuild/src/main.cpp: In function 'void createProject()':
../../../qt-extended-4.4.3/qbuild/src/main.cpp:49:33: warning: ignoring return value of 'int chdir(const char*)', declared with attribute warn_unused_result [-Wunused-result]
         ::chdir(pwd.constData());
                                 ^
make[1]: *** [main.o] Error 1
/* log end */
初步认为是冲突了 网上都说要把 QT creator 删掉, 实际上不止,应该把不知道什么时候装在pc上的qt4删掉或暂时屏蔽掉路径
还是失败,原来还是需要寻找QT库的,但是显然qt-extended4.4.3与pc机上的qt库版本冲突了!!
(所以搁置 qt-etended 的移植!!)

移植 minigui
(待续)










20170216
架设 ssh 登陆 远程电脑:
安装
	sudo apt-get install openssh-client
	sudo apt-get install openssh-server
启动ssh服务：
	sudo /etc/init.d/ssh start
停止ssh服务：
	sudo /etc/init.d/ssh stop
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh


申请免费域名并挂到路由器DNS
暴露pc主机的dmz 到公网
设置端口转送
ssh配置:
ssh -NfR 2284:localhost:22 infortechubuntu1404-HP-EliteDesk-880-G2-TWR@16r6d01795.iask.in  // ??反向代理
ssh -gNfR *:2222:localhost:22 root@16r6d01795.iask.in	//  ??或这样设置?
(未成功)!!









20170217
重新尝试 buildroot,事实上,发现,buildroot更适合,构造根文件系统和arm-gcc,g++ 编译工具!!
不推荐使用提供的sh脚本来烧录镜像!!因为,有很多与之前研究中不一样的配置和操作!!所以推荐手动烧录文件系统镜像到机器
编译记录:
使用之前 git clone 下来的 buildroot 即 buildroot1
先 make distclean
然后 make atmel_sama5d4_xplained_mmc_defconfig	做初步配置
然后 make menuconfig 修改配置!!!
	Target option 里的 默认不变
	Build option 里的 蓦然不变
	System configuration 里的 默认不变
	kernel 取消不选
	bootloader 取消不选
	Target package 根文件系统里预装的内容
		添加QT5的图形库!!
		Graphic libraries and applications (graphic/text)  --->  ->  [*] Qt5  --->
		--- Qt5       
		-*-   qt5base            
		[ ]     Approve free license    
		()      Config file         
		[*]     Compile and install examples (with code) 	//一定要examples 检验图像库是否移植成功!!
		[ ]     concurrent module       
		[ ]     MySQL Plugin          
		[ ]     PostgreSQL Plugin              
			SQLite 3 support (No sqlite support)  ---> 
		[*]     gui module            
		[*]       widgets module             
			  *** OpenGL support needs an OpenGL-capable backend ***  
		-*-       linuxfb support            
		          *** directfb backend available if directfb is enabled ***    
		          *** X.org XCB backend available if X.org is enabled ***   
			  *** eglfs backend available if OpenGL and EGL are enabled ***    
		(linuxfb) Default graphical platform  
		[*]       fontconfig support    
		[*]       GIF support            
		[*]       JPEG support          
		[*]       PNG support           
		[*]     DBus module             
		[*]     Enable ICU support       
		[*]     Enable Tslib support  
		......
	Filesystem images 根文件系统的镜像格式选取!!
		在这里我们要添加ubi选项,让根文件系统添加这个格式的镜像
		[*] ubifs root filesystem
		(0x3e000) logical eraseblock size	//逻辑擦除块大小 248kiB
		(0x1000) minimum I/O unit size 		//page的大小 4kiB
		(2082) maximum logical eraseblock count  //逻辑擦除块数量
		ubifs runtime compression (lzo)  ---> 	 //压缩格式 lzo
		Compression method (no compression)  ---> 
		()    Additional mkfs.ubifs options  
		[*]   Embed into an UBI image    	//生成 .ubi镜像
		(0x40000) physical eraseblock size  	//物理块大小 256kiB
		(4096)  sub-page size             	//page的大小 4kiB
	Toolchain  编译工具链,其实就是整套 arn-linux-gcc 工具链,
		注意,一定要把里面的功能全部使能,不然得到的 的工具链功能是有缺陷的,而且中途不能通过重新编译添加未添加的功能,
		只能把整套删掉 make distclean 然后再重新生成一整套!!
		我们这次用到的工具链的版本配置信息!!!
		Toolchain type (Buildroot toolchain)  ---> //使用Buildroot toolchain 即,自动下载gcc工具链源码包编译
							   //而 External toolchain 就是说使用已有的,用户现成的 gcc 工具包,即不用重新编译
		 *** Toolchain Buildroot Options ***		
	(buildroot) custom toolchain vendor name
		C library (glibc)  --->			   //这套gcc工具 使用 glibc库
		*** Kernel Header Options *** 
		Kernel Headers (Linux 4.1.x kernel headers)  ---> //是说明这套gcc是专门面向kernel4.1?
								  //还是说这套gcc是拥有kernel4,1的特征?? 
		glibc version (2.23)  ---> 		  //这套gcc工具 使用的 glibc库 版本!!
		*** Binutils Options ***
		Binutils Version (binutils 2.26.1)  --->  //这套gcc工具 使用的 binutils 版本!!
	    ()  Additional binutils options 
		*** GCC Options ***
		GCC compiler Version (gcc 4.8.x)  --->  
	    ()  Additional gcc options   
	    //添加这套gcc工具 的其他功能,使之成为完整的的一套工具!!!
	    [*] Enable C++ support   			
	    [*] Enable Fortran support 
	    [*] Enable compiler link-time-optimization support       
	    [*] Enable compiler OpenMP support    
	    [*] Enable libmudflap support 
	    [*] Enable graphite support  
		*** Host GDB Options ***  
	    [*] Build cross gdb for the host  
	    [*]   TUI support 
	    [*]   Python support     
	    [*]   Simulator support 
		  GDB debugger Version (gdb 7.10.x)  --->   
		*** Toolchain Generic Options *** 
	    [ ] Copy gconv libraries  
	    [*] Enable MMU support  
	    ()  Target Optimizations  
	    ()  Target linker options  
	    [ ] Register toolchain within Eclipse Buildroot plug-in                                                            │ │  

配置完就 make -j8 进行编译
	再次注意:如果 本来的toolchain里不包含Enable C++ support 那么得到的 gcc工具包里就没有 arm-linux-gnueabihf-g++,
	所以当builroot 编译rootfs要加入qt5的内容,会因为中找不到g++来编译cpp文件而出现以下错误,	 
	configure: error: You need a C++ compiler for C++ support  ubuntu
	这时,中途 make menuconfig 重新选上 Enable C++ support ,然后重新 make -j8并不会让toolchain 自动添加 arm-linux-gnueabihf-g++ 这个工具
	唯一办法是,把toolchain生成的全删后,重新 make -j8
编译成功好后:
buildroot/output/build 里是下载下来的函数库或者工具包的源码以及编译后的文件
buildroot/output/host/usr 里的是 生成的一整套完整 arm-linux-gcc 工具链, 可以直接拷出来自己使用!!
buildroot/output/images 里的是生成的镜像文件!!! 由于我们只使用buildroot构造文件系统,所以只有 rootfs相关的各个镜像,并没有zImage等其他镜像
buildroot/output/target 未打包成镜像前的根文件目录的内容!!
烧录:
cd到images
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:rootfs.ubi:0x800000
开机,成功加载系统!!!
测试ts_test,ts_calibrate, qt-example 成功!!
但是,qt-example的的触摸屏按键 依然出现 翻转错位现象
此外文件系统加载时,并没有自动初始化网络:
使用命令:
udhcpc 初始化网络!!
此外,想知道,qt程序是如何运用tslib的,所以希望查找 /etc/profile文件来查看qt配置!!
什么也没有发现!!
没有 TSLIB_**, QT_QPA_** 一类环境变量,grep搜索,没发现相关的配置文件,
却发现在内嵌在 libqt***.so.65.6.2XXX 之类的库文件里!! 
检查 tslib 与 qt图形库的关系,发现 qt图形库直接使用event0 压根没有使用tslib!!!
但是 grep 发现 qtbase 编译前的configure 是有添加 -tslib 选项的!!!











20170220
追查qt5.6.2 与 tslib1.1 的联系 
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
先把 buildroot生成的 rootfs 文件目录,拷贝到 rootfs3
使用组合命令 编译成 rootfs.ubi 镜像
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
烧录后,却被告知说 不能打开 /dev/console permittion denyed  
经过一番折腾发现,buildroot 生成的 rootfs 目录全部文件都被赋予了只读权限,
因此在 生成ubi镜像前,先把文件的所有权限开放
sudo chmod 777 rootfs/*			//  开发所有文件的权限 */
然后烧录运行正常!!
关于QT触摸屏错位的改正!!
直接怀疑 QT库并没有使用 tslib !!
发现profile内容没有 常规移植QT和tslib时要添加的 路径变量,所以怀疑 tslib 和 QT 一直在使用默认环境变量!!
于是 profile 末尾加上一项
export QT_QPA_GENERIC_PLUGINS=tslib
//注意,不是 export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
// :号 表示,要么使用tslib修正过的触摸屏设备,要么直接使用原生触摸屏设备
//为了避免 QT5 可能直接使用原生设备, 所以不要加入/dev/input/event0!!!!
执行 QT5 examples/widgets/desktop/screenshot 里的例程时,出现了 ts_open() faired with error (no such file or dictionary ) 
执行 QT5 examples/widgets/touch/fingerpaint 里的例程时,也出现了 ts_open() faired with error (no such file or dictionary ) 
这时因为要使用tslib修正过的触摸屏设备,就得使用tslib的 api ts_open
而 ts_open 要打开原生触摸屏设备,但是我们没有给出 这个设备的环境变量,所以要在 profile 加上
export TSLIB_TSDEVICE=/dev/input/event0
然后 screenshot 成功了!!!! 成功用上了 tslib矫正的触摸屏,但是出现一个新问题,按键并不是特别灵光!!
而 fingerpaint 虽然没有提示 ts_open() faired with error 但是似乎没有 用上矫正过的触摸屏,而还是用原生的,
QT 用原生出现的问题具体是 x轴正常, y轴是中点反对称地出现!!!

也就是虽然可以使用上 tslib 了 但是还有很多问题:
animation/easing 滑动条不能滑动!只能跳着过 没有tslib前可以拖着滑动!!
但是animation/states 可以拖动!!
按键不灵光
touch/fingerpaint(绘图) 好像没用上tslib
touch/dials(数字旋表,就像汽车转速表) 好像没用上tslib
qpa/windows 好像用上了,但是出现跳屏!!!

修改profile删掉
export QT_QPA_GENERIC_PLUGINS=tslib
export TSLIB_TSDEVICE=/dev/input/event0
只添加:
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
效果一样!!!










20170221
字符显示!!
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
之前的测试一直没有字符显示!!!
按网上方法!!
把pc机的 /usr/share/fonts/truetype/dejavu 文件夹拷到开发板的 /usr/share/fonts/dejavu
然后 开发板profile添加!!
export QT_QPA_FONTDIR=/usr/share/fonts/dejavu
(补充,未实现!!)
关于中文字符的显示,据搜索说是要,添加 /usr/share/fonts/truetype/arphic 然后,profile做同样修改!!
研究屏幕键盘!!!
安装 qtcreator4.2 ,及配置环境 
官网下载 qt-creator-opensource-linux-x86_64-4.2.0.run 安装包
直接指令安装 ./qt-creator-opensource-linux-x86_64-4.2.0.run
安装后,就要配置qtcreator的编译选项:工具tools -> build and run窗口
先配置 QT Version
	先了解qt的编译工作流程!!!例如我要编译一个面向 armmv7-a 的窗口程序,用到 qt5.6 的库
	首先,我使用 面向armv7-a 的 qt5.6 的 qmake 工具 编译这个窗口程序工程的.pro配置文件!!! 最后生成 指定Makefile
	然后, 使用makefile 编译出真正的执行文件
	QT Version配置,我们需要使用 哪个版本,面向那种机器的qt库, 我们就把他对应的qmake工具加进来!!
	我们添加了 面向armv7-a 的 qt5.6 的 qmake 工具
	然而报错说我们 缺乏指定的编译器!!
配置 编译器
	上述 面向armv7-a 的 qt5.6 的 qmake 工具 就指明了 他生成的 makefile 是使用我们之前指定的 arm-linux-gnueabihf-gcc 系列工具
	来编译成 执行文件 的, 所以我们要把 arm-linux-gnueabihf-gcc 系列工具 添加到这里来,
	分别独立添加 对应 gcc 和 g++
	然后回到 QT Version 发现刚刚添加的 面向armv7-a 的 qt5.6 的 qmake 工具 不再报错!!
配置 DEbuggers
	arm-linux-gnueabihf-gcc 系列工具 也有gdb 调试工具, 但是不会用,加不加无所谓
配置CMake
	不用管
构建套件(kit)
	不使用 QT creator 时,要生成一个窗口可执行文件,我们需要使用多条编译指令,使用多个编译器
	但是配置成一个套件后,使用 QT creator 生成一个窗口可执行文件,只是一个按键的事情,
	这里要用到的工具捆绑在一起
	添加一个套件:
	名称自选
	设备类型, 对于嵌入式触摸屏设备,推荐使用 桌面就可以,选择通用linux设备,需要自己定义一台设备,相当麻烦!!
	Sysroot 不管
	编译器C 选刚刚加入的 arm-linux-gnueabihf-gcc
	编译器C++ 选刚刚加入的 arm-linux-gnueabihf-g++
	调试器 选刚刚加入的 arm-linux-gnueabihf-gdb
	QT版本 选QT5.6.2 这是刚刚加的 qmake 识别出来的QT版本
配置好,弄个例程编译试试: example里的 screenshot
注意,要在项目那检查工程配置
	选择新构建的套件:
	它的qmake 里编译用到的 qmake命令
	它的make 里编译用到的 make 命令
编译时注意:
由于是使用arm架构的gcc编译工具,所以,并不能在pc机上做debug 所以,只需要按 build 按钮就好了,
最后烧录到开发板,测试通过!!!!

移植屏幕键盘到开发板!!
现实










20170222
搞好ssh 远程桌面!!!
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh

简单局域网相连:
ssh -X root@200.200.200.102	// 
sudo ssh -X 200.200.200.102	//这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的root用户!!
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的infortech-ubuntu-1404用户!!
出错:
Permission denied, please try again. 
解决:
要修改 ip为200.200.200.102的pc机 的root的ssh权限，即修改 /etc/ssh/sshd_config文件中
	PermitRootLogin no 改为 PermitRootLogin yes 
此外, -X 表示窗口界面,不是命令行终端,但没有成功使用窗口登陆!!

拷贝文件操作!!
kingders@kingders-ThinkPad-T420:~$ scp ./安川电机/report infortech-ubuntu-1404@200.200.200.102:./桌面
//把 本机的/home/kingders/安川电机/report 文件   拷贝到   ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面 文件夹 去
kingders@kingders-ThinkPad-T420:~$ scp infortech-ubuntu-1404@200.200.200.102:./桌面/temp_20170117 ./Desktop
//把 ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面/temp_20170117 文件   拷贝到   本机的/home/kingders/Desktop 文件夹 去 

挂载远程硬盘(未完待续)

最后还是脱离了ssh 使用上了基于vnc 的远程桌面
sudo apt-get install xrdp //安装 xrdp 多了一个 Desktop Sharing Preferences 的选项框
这样就装上了两款软件!!!
Desktop Sharing /桌面共享
Remmina Remote Desktop Client / Remmina远程桌面客户端!!
被远程控制的机子 在 桌面共享 里 选允许其他人查看/控制您的桌面,安全 不选"进行访问确认"
要远程控制的机子 打开 Remmina远程桌面客户端 新建->协议是VNC虚拟网络计算->填写:
	被远程控制的机子的ip
	其他的可以都不填(不知道为啥)
然后就可以connect过去了

还有一个更加傻瓜的方法就是使用 teamviewer
另外,安装google远程桌面 和 teamviewer 时 注入了一个bug 会启动 deja-dup-monitor 无限吃内存!!!卡死机器!!!
鉴于 deja-dup-monitor 并没有啥用 直接 重命名 让bug读取不到!!!
罪魁祸首还是 google-chrome, 删掉就好了!!!

最后关于 ubuntu 两种软件安装方式  apt-get 和 .deb包!!
主要用到apt-get dpkg两个命令：
1. 快速使用
安装软件 apt-get install softname1 softname2 softname3……
卸载软件 apt-get remove softname1 softname2 softname3……
卸载并清除配置 apt-get remove --purge softname1
更新软件信息数据库 apt-get update
进行系统升级 apt-get upgrade
搜索软件包 apt-cache search softname1 softname2 softname3……
修正（依赖关系）安装：apt-get -f install

安装deb软件包 dpkg -i xxx.deb
删除软件包 dpkg -r xxx		//不需要写deb包全名 xxx_版本_架构.deb
连同配置文件一起删除 dpkg -r --purge xxx.deb
查看软件包信息 dpkg -info xxx.deb
查看文件拷贝详情 dpkg -L xxx.deb
查看系统中已安装软件包信息 dpkg -l
重新配置软件包 dpkg-reconfigure xx
sudo dpkg -p package_name卸载软件包及其配置文件，但无法解决依赖关系！
sudo aptitude purge pkgname卸载软件包及其配置文件与依赖关系包！ 
清除所有已删除包的残馀配置文件
dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
如果报如下错误，证明你的系统中没有残留配置文件了，无须担心。








20170224
移植 摄像头!! 
首先,分别使用ov7670 和 ov3640 两款摄像头
使用两种协议工作: 
	ISI:传输图像数据
	I2C:控制摄像头
涉及文件 atmel-isi.c ov2640.c ov7670.c
采集原理:
	cmos硬件采集 -> isi协议传输数据 -> V4L2中间库 -> 应用程序
总的说,	ov2640.c是i2c从设备, 
	atmel-isi.c是isi的平台设备,
	那么对应ov2640的isi从设备是哪一个,难道 ov2640.c兼顾?
	make ARCH=arm menuconfig 里关于 isi i2c ov2640 v4l2 该选的都选上了 
纠错:上述热时错误是,直接把 xxx平台设备等同于 XXX协议总线!!!
	xxx平台设备是挂在 平台总线 上的一个设备而已,虽然大多数平台设备都可以操作硬件寄存器
	以一个例子为例
		i2c-core.c是 构成i2c协议总线
		i2c-at91.c是 挂载在 platform协议总线 上的i2c控制器驱动设备
		i2c协议总线 与 platform总线协议 本质上是同阶级的 都是抽象出来的总线
		i2c-at91.c(i2c控制器设备) 会给 i2c协议总线 一个接口,
		xxxx.c是 挂载在 i2c协议总线 上的 i2c从设备,
		操作 i2c从设备时,归根到底还是操作 主芯片i2c控制器,
		i2c从设备 通过 i2c协议总线 上公开的i2c控制器接口, 实现控制i2c控制器从而实现i2c从设备的功能!!!

dts的examples 写法也疑惑: 注意,以下是 ,txt的例子,并非.dts里的实例
设置isi的!!
Example: isi: isi@f0034000 { compatible = "atmel,at91sam9g45-isi";
		reg = <0xf0034000 0x4000>;
		interrupts = <37 IRQ_TYPE_LEVEL_HIGH 5>;
		clocks = <&isi_clk>;
		clock-names = "isi_clk";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_isi>;
		port { 
			#address-cells = <1>;
			#size-cells = <0>;
			isi_0: endpoint { 
				remote-endpoint = <&ov2640_0>;
				bus-width = <8>; 
			}; 
		}; 
	};
	i2c1: i2c@f0018000 { ov2640: camera@0x30 { compatible = "ovti,ov2640";
			reg = <0x30>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 
					}; 
				}; 
			}; 
		}; 
设置ov2640的!!
Example:
	i2c1: i2c@f0018000 { 
		ov2640: camera@0x30 { 
			compatible = "ovti,ov2640";
			reg = <0x30>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_pck1 &pinctrl_ov2640_pwdn &pinctrl_ov2640_resetb>;
			resetb-gpios = <&pioE 24 GPIO_ACTIVE_LOW>;
			pwdn-gpios = <&pioE 29 GPIO_ACTIVE_HIGH>;
			clocks = <&pck1>;
			clock-names = "xvclk";
			assigned-clocks = <&pck1>;
			assigned-clock-rates = <25000000>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 	//v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
				}; 				//video-interfaces.txt //设置信息参考文件!!!
			}; 
		}; 
	}; 

简阅atmel-isi.c 
isi_clk = isi->pclk	//分清两个时钟
iscclk = isi->iscck
probe:
atmel_isi_parse_dt() //分析endpoint的内容 其实就是把isi协议的所有设置上的内容!!
	v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
	video-interfaces.txt //设置信息参考文件!!!
申请dma framebuffer 缓存
申请irq
soc_camera_host_register //
分析发现驱动中, isc层是直接控制硬件的, isc接入isi层,isi层又是与v4l2层接轨的
而 isi 对应着 soc_camera 这层内容!!! //可以参考gpio_keys的做法









20170227
RGB 格式直接显示的, 
YCbCu 是编码的格式,使用于压缩MP4格式的文件
ov7670 cmos芯片的针脚!
	pclk: 像素输出时钟! 是由ov芯片输出的时钟 	senor发出
	D0-7: 图像并排数据针	senor发出
	xclk: 提供ov芯片运行的时钟信号脚 典型是 24Mhz
	scl: i2c时钟针
	sda: i2c数据针
	vsync: 帧起始信号	senor发出
	href: 行起始信号	senor发出
	reset: 重置针 ,正常状态下高电平 低电平触发
	pwdn: power down 针
	Fsin: frame synchronize input 	帧同步未知实际作用,但实际可不接!!	senor接收!!!!
就是说,除了 isi 和i2c 的接口外 还要自己定义 pwdn reset xclk针!!
pwdn reset 两gpio功能针的配置,要另外使用dts 自己做一个pinctrl出来!!//可以参考 at91-sama5d4_xplaint.dts gpio_keys的做法
xclk 输出时钟针的配置!! 		//xclk即 datasheet的 isi_mck 即 Programmable Clock output 1(PCK1)
xclk 指 pc4 或pc24 或pd31	//没有参考设置输出时钟的!!的例子
想起到 www.at91.com 找 camera
居然还真找到!!!我去, github 的linux源码里 有一个 at91-sama5d4ek_isi.dts 直接就是ov2640模块的!!

ov2640的针口配置:
	ov2640并口数据针共10位 D0-D9,   ov2640    默认使用   10针高位模式,
	但是买回来的 waveshare做的模块 只能使用8针高位模式,所以设置0xda寄存器为8针高位模式,
	8针高位指,工作针为D2-D9的模式 (0xdA的bit0 值为0, bit6 值为1),
	按道理 ov2640处于8针高位模式, 那么 D2-D9针 应接sama5d4 的 isi_D0 - isi_D7
	按道理 ov2640处于10针高位模式,那么 D0-D9针 应接sama5d4 的 isi_D0 - isi_D9
	而现在的奇怪情况是: ov2640处于10针高位模式
		但是 D2-D9针 接sama5d4 的 isi_D0 - isi_D7 并没有发现出现问题!!!
		还有的是,这时的linux设置的 isi 是 8位数据针模式

sama5d4对应的针口:
	AT91_PIOC 19 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D0 */
	AT91_PIOC 20 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D1 */
	AT91_PIOC 21 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D2 */
	AT91_PIOC 22 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D3 */
	AT91_PIOC 23 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D4 */
	AT91_PIOC 24 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D5 */
	AT91_PIOC 25 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D6 */
	AT91_PIOC 26 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D7 */
	AT91_PIOB  1 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_PCK, conflict with G0_RXCK */
	AT91_PIOB  3 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_VSYNC */
	AT91_PIOB  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_HSYNC */
	AT91_PIOA 30 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWD0 */
	AT91_PIOA 31 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWCK0 */
	AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* PC4 periph C ISI_MCK */ 与sd卡复用了pd8 所以要disable mmc0
	AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE /* PB5 power down */
	AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE	/* PB11 reset */ 







20170228
加载摄像头功能: (修改内核)
修改dts,给at91-sama5d4_xplained.dts插入,以下相关内容!!
/ {
	ahb {
		apb {
			pinctrl@fc06a000 {
				board {
					pinctrl_pck1_as_isi_mck: pck1_as_isi_mck-0 {
						atmel,pins =
							<AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE>; /* PC4 periph C ISI_MCK */
					};

					pinctrl_sensor_power: sensor_power {
						atmel,pins =
							<AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB5 gpio */
					};

					pinctrl_sensor_reset: sensor_reset {
						atmel,pins =
							<AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB11 gpio */
					};
				};
			};
		};
	};
};

&usart2 {
	status = "disabled";
};

&spi0 {
	status = "disabled";
};

&mmc00 {
	status = "disabled";
};

&isi {
	status = "okay";

	port {
		isi_0: endpoint@0 {
			remote-endpoint = <&ov2640_0>;
			bus-width = <8>;
			vsync-active = <1>;
			hsync-active = <1>;
		};
	};
};

&i2c0 {
	status = "okay";
	ov2640: camera@0x30 {
		compatible = "ovti,ov2640";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
		resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
		pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
		/* use pck1 for the master clock of ov2640 */
		clocks = <&pck1>;
		clock-names = "xvclk";
		assigned-clocks = <&pck1>;
		assigned-clock-rates = <25000000>;

		port {
			ov2640_0: endpoint {
				remote-endpoint = <&isi_0>;
				bus-width = <8>;
			};
		};
	};
};
menuconfig:添加
select the menu: "Device Drivers -> Multimedia support -> Sensors used on soc_camera driver -> ov2640 camera support"
select the menu: "Device Drivers -> Multimedia support -> Media Controller API"
select the menu: "Device Drivers -> Multimedia support -> V4L2 sub-device userspace API"
select the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
另外,如果要选择老版本摄像头芯片,例如 ov7670 等
	deselect the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
	find in the menu: "Device Drivers -> Multimedia support -> Encoders, decoders, sensors and other helper chips ->其他xxx芯片"
添加 pr_debug 到 atmel-isi.c 和 ov2640.c 调试!!! //参考之前的操作!!!
编译 缮写
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
开机,如果发现以下log内容,可以初步认为驱动已经成功运行了!!!
soc-camera-pdrv soc-camera-pdrv.0: Probing soc-camera-pdrv.0
ov2640 0-0030: ov2640 Product ID 26:42 Manufacturer ID 7f:a2
i2c i2c-0: OV2640 Probed

在尝试采集图片之前,先尝试显示jpg图片!!
先处理好网络功能!!
udhcpc 初始化网络环境
关于 tftp 传输文件的命令!!(在开发板上使用的 规范写法)
	tftp -g 200.200.200.102 -r ./aaa -l ./bbb	//取得ip200.200.200.102的tftp服务器路径下的aaa文件,拷贝到当前文件夹并改名为bbb
							//如果当前文件夹已存在 bbb 文件,则替换他!!!
	tftp -p 200.200.200.102 -r ./ccc -l ./ddd	//把当前文件夹的 ddd 文件,上传到ip200.200.200.102的tftp服务器路径上
							//直接替换掉 服务器上的 ccc 文件,
							//如果服务器本身没有 ccc 文件,那么命令就会出错不工作!!
那么我们把得到的图片回放上来就可以了!!!
然后,使用 atmel推荐的 fswebcam,最简单做法:使用 buildroot1 给文件系统添加这个内->置内容
make menuconfig 添加:
	Target packages -> Graphic libraries and applications (graphic/text) -> fswebcam
make -j8
测试命令:
fswebcam -S 20 -d /dev/video0 -p RGB565 -r 640x480 uio.jpg	//跳过开头20帧采样,在当前文件夹得到uio.jpg图片文件!!
tftp回电脑 成功显示!!!

下一步,移植 ov7670 到新架构!!!!!









20170301
移植 ov7670 到新架构
ov7670 和 ov2640 的reset 和 pwdn 针的控制方式一致
reset: 低电平触发,平时处于高电平
pwdn: 高电平触发 平时处于低电平
ov7670 和 ov2640 的 i2c协议控制参数一致
关于 ov7670 和 ov2640 的区别:
ov7670 30万像素,
ov2640 200万像素,
ov7670 控制的寄存器在同一个块里
ov2640 控制的寄存器分成两个块,sensor块 和 DSP块, 要范文相关控制寄存器,要先设置寄存器所处的块!!!
还有能支持的编码格式:
	都不一样,还有的是,ov7670多了 一个叫 matrix
	注意移植修改重点 ov2640_enum_mbus_code() -> ov7670_enum_mbus_code()
		忽略掉 matrix 的调整!!
		ov7670_supported_win_sizes 的内容及后续内容没有改!!!!!!!关于7670的采样格式规范问题!!!
			ov7670_get_fmt的 MEDIA_BUS_FMT 内容....

无意发现 出厂id与pdf 不一样!!
ov2640的 datasheet 是 26 41 7f a2  芯片读出的是 26 42 7f a2
ov7670的 datasheet 是 76 73 7f a2  芯片读出的是 87 87 87 87
还有真正的 i2c地址 与 datsheet 里的 i2c地址 也不一样!!
ov2640的 datasheet 是 0x60 芯片使用的是 0x30
ov7670的 datasheet 是 0x42 芯片使用的是 
使用ov7670时,发现出现了i2c不能访问的现象!!! 读出的pid和mid 都是87
ov7670的i2c并没有工作!!!
	一开始是怀疑地址 不对 因为出现了 nack
	后来地址改过来了,发现好像时钟也不对 ,出现了 control timed out
	两款芯片的i2c datasheet参数一样,所以跟i2c时钟没有问题
	最后发现 芯片可写,但不可读!!!读寄存器时,直接出错!!!









20170303
先搁置驱动移植细节,先做好移植架构!!
at91-sama5d4_xplained.dts i2c添加:
			isi: isi@f0008000 {
				status = "okay";
				port {
					isi_1: endpoint@1 {
						remote-endpoint = <&ov7670_0>;
						bus-width = <8>;
						vsync-active = <1>;
						hsync-active = <1>;
					};
				};
			};
			i2c0: i2c@f8014000 {
				status = "okay";
				/* have to set clock-frequency, otherwise use default-scl 100khz */
				clock-frequency = <100000>;	
				/* by william about ov7670 */
				ov7670: camera@0x21 {
					compatible = "ovti,ov7670";
					/* ov7670 i2c 8bits-addr 0x42w 0x43r 7bits-addr 0x21 */
					reg = <0x21>;	
					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
					resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
					pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
					/* use pck1 for the master clock of ov2640 */
					clocks = <&pck1>;
					clock-names = "xvclk";
					assigned-clocks = <&pck1>;
					/* assigned-clock-rates = <25000000>; */
					assigned-clock-rates = <24000000>;

					port {
						ov7670_0: endpoint {
							remote-endpoint = <&isi_1>;
							bus-width = <8>;
						};
					};
				};
			};

新添加 ov7670_dts.c 到/home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera
修改 ov7670_dts.c 基于ov2640.c修改的dts架构的驱动!,注意修改以下内容:
static const struct i2c_device_id ov7670_id[] = {
	{ "ov7670", 0 },	//看过源码,0这一项没有使用,所以填 0 !!
	{ }
};
MODULE_DEVICE_TABLE(i2c, ov7670_id);

static const struct of_device_id ov7670_of_match[] = {
	{.compatible = "ovti,ov7670", },
	{},
};
MODULE_DEVICE_TABLE(of, ov7670_of_match);

static struct i2c_driver ov7670_i2c_driver = {
	.driver = {
		.name = "ov7670",
		.of_match_table = of_match_ptr(ov7670_of_match),
	},
	.probe    = ov7670_probe,
	.remove   = ov7670_remove,
	.id_table = ov7670_id,
};

module_i2c_driver(ov7670_i2c_driver);

MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
MODULE_AUTHOR("william huang");
MODULE_LICENSE("GPL v2");

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Makefile 添加:
#by william
obj-$(CONFIG_SOC_CAMERA_OV7670DTS)	+= ov7670_dts.o

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Kconfig 添加:
# by william
config SOC_CAMERA_OV7670DTS
	tristate "ov7670 camera support in DTS"
	depends on SOC_CAMERA && I2C
	help
	  This is a ov2640 camera driver

make ARCH=arm menuconfig 就可以选择 ov7670 camera support in DTS 这项了
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 就会去编译 ov7670_dts.c这个文件了!!!
把多余的错误纠正后得到成功编译驱动文件,接下来就是调试编译文件了!!!
由于只是把框架改过来而已,还保留着ov2640的功能,可以利用ov2640模块 测试驱动是否成功运行!!!
	只需要,把ov7670 dts i2c 的addr与ov2640 的就换过来测试
	结果 i2c访问ov2640失败,因为i2c地址不对,
	但是访问"ov7670"成功,因为ov7670驱动保留着ov2640的内容未更改,由于i2c地址也对上了,所以 ov7670驱动 成功运行,还抓取了图片
	证明 ov7670 的驱动框架没有问题,成功运行

接下来,要分析分析像摄像头这样复合功能的设备的实现!!
以 ov2640为例
整体说, 这个摄像头主要涉及到两个功能!!一个是i2c 一个是isi
而只需要工程师编写的 的文件只有 ov2640.c
但是涉及的内容有 soc_camera i2c 等子系统,还有 v4l2 isi 等内容!!!!
先看soc_camera 
涉及 soc_camera.c 和 soc_camera_platform.c 两个关键文件
重新讨论 soc_camera v4l2 和 ov2640.c 的关系:
v4l2 是 上层软件和 设备驱动层的 接口
soc_camera 是一个规范的摄像头驱动规范,不同的摄像头都通过接入这个规范是大大减少开发程度
ov2640.c就是摄像头驱动最底层工作的具体实现,他符合soc_camera规范,跟soc_camera共同组合才形成一个完成可用的摄像头驱动,供v4l2调用
从初始化:分析关系:
	先初始化 i2c从设备 ov2640.c 里头也填充了一些 soc_camera 的结构体
	然后初始化 atmel-isi.c 这里提取构建好各种isi的具体操作后,便注册 soc_camera_host_register	
	soc_camera_host_register -> soc_camera_scan -> soc_camera_probe
	最后才是 soc_camera_pdr_probe!!!
	注意,并没有看错,soc_camera_pdr_probe作为platform设备驱动,居然后于 isi 和 ov2640  注册到linux









20170309
暂时不移植 ov7670
使用上层软件测试 ov2640摄像头!!
使用 gsteamer0.1 把摄像头的实时图像显示到lcd上去!!
参考:http://www.at91.com/linux4sam/bin/view/Linux4SAM/UsingIsi
同样,直接往之前的buildroot上塞东西 gsteamer0.1
make menuconfig	添加: 
	Target Packages -> Audio and video application -> gsteamer 0.10
	~ gst-plugins-base -> ffmpegcolorspace
	~ gst-plugins-good -> v4l2
	~ gst-plugins-bad -> fbdev
	~ gst-ffmpeg
make -j8
然后烧录,
然后测试:
gst-launch v4l2src device="/dev/video0" ! video/x-raw-yuv,width=640,height=480 ! ffmpegcolorspace ! fbdevsink
成功看到采集的图像实时显示在lcd上!!

使用 gsteamer1.0 把摄像头的实时图像显示到lcd上去!!
参考:http://www.at91.com/linux4sam/bin/view/Linux4SAM/UsingIsi
同样,直接往之前的buildroot上塞东西 gsteamer0.1
make menuconfig	添加: 
	Target Packages -> Audio and video application -> gsteamer 0.10
	~ gst-plugins-base -> videoconvert
	~ gst-plugins-good -> v4l2
	~ gst-plugins-bad -> fbdev
make -j8
然后烧录,
然后测试:
gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! fbdevsink
注意由于一开始,没有选上videoconvert 一直提示没有找到videoconvert模块,于是的重新make
重新make前先把 ~~output/build里的gstreamer1.0先关文件夹删掉,
只是重新加上gst-plugins-base -> videoconvert 并不会重新编译和添加videoconvert模块!!!
成功看到采集的图像实时显示在lcd上!!
提高 图像的fps 尝试提高时钟频率
这个摄像头驱动涉及 三个时钟 i2c通讯时钟, 提供摄像头芯片的主时钟 xvclk 还有摄像头芯片输出的图像时钟pclk
在dts里 i2c 时钟默认100khz 可以改到400khz
在dts里 xvclk 设置处后面的 assigned-clocks = <&pck1>; assigned-clock-rates = <25000000>;改的是时钟的参数,
	但是发现时钟的频率并不是  assigned-clock-rates = <25000000> 里的值,不轮怎么改都维持在 18Mhz
	一度以为这里并不是设置 xvclk的, 可一旦去掉 assigned-clock-rates = <25000000> 摄像头芯片就不工作!! i2c也启动不了
在dts里 pclk 最难发现现要在哪里修改!!! 不知道怎么改, 一直保持在 28mhz 

摄像像头采集窗口格式:
#define CIF_WIDTH	352	//10万像素
#define CIF_HEIGHT	288

#define QCIF_WIDTH	176
#define QCIF_HEIGHT	144

#define QQCIF_WIDTH	88
#define QQCIF_HEIGHT	72

#define QQVGA_WIDTH	160
#define QQVGA_HEIGHT	120

#define QVGA_WIDTH	320	
#define QVGA_HEIGHT	240

#define SVGA_WIDTH	800	//50万像素
#define SVGA_HEIGHT	600

#define SXGA_WIDTH	1280	//130万像素
#define SXGA_HEIGHT	1024

#define VGA_WIDTH	640	//30万像素
#define VGA_HEIGHT	480

#define UXGA_WIDTH	1600
#define UXGA_HEIGHT	1200

#define XGA_WIDTH	1024	//80万像素
#define XGA_HEIGHT	768
上述说明的 cif qcif qqcif qqvga qvga vga svga uxga xga 是典型的窗口格式
例如,cif窗口格式 典型是 352x288 分辨率的窗口!!!
ov2640 最大可以采集 1600X1200大小的图片, 但是,如果要采集一张 352x288 分辨率的图片,
	就要设置寄存器, 芯片就会处于一种设定的采集模式,通过选择采集矩阵排列上的特定点,最终组合成一张接近 352x288 分辨率 的图片!
	例如,ov2640 分析需求图片的分辨率,然后设置为 cif 的采集格式,然后采集出 一张400x296分辨率的图片,接近 352x288 分辨率
	不可能完全采集到完全等于 352x288 分辨率的图片,因为 采集是有规律选择cmos矩阵上的特定点!!,所以不可能完全符合需求的分辨率,只能接近.

关于 ov2640 的时钟频率的调节!!
	上述知道,dts设置的 xvclk 只是起到了一个开关的左右, 设置 25mhz 并未达到,事实上,不能设置多少mhz,输出还是18mhz
	然而xvclk 是sama5d4提供的时钟, 而不是ov2640真正工作的时钟
	查看ov2640的 datasheet 发现, 有两处修改时钟频率的的地方!!!
	clkrc: 对 xvclk 分频处理后 得到 ov2640芯片实际工作的时钟频率
	R_DVP_SP: ov2640 执行这个分频器处理后得到 输出时钟pclk 的时钟频率
	经测试,clkrc 分频系数为1,ov2640 已经处于最高速的工作时钟,
	R_DVP_SP 为2,也产生最高速的pclk输出时钟,不能为1,会失真,而且pclk频率相比起 R_DVP_SP 为2 的时候也没有变化!
	所以综合地说,提高 sama5d4提供的时钟, 或许是提高摄像头实时监测的唯一路径!!










20170314
注意 以后 未特殊说明!! mpu 直接代表 sama5d4 这芯片
关于 ov2640 的时钟频率的调节!! 续:
	无意间返现clkrc能够倍频 输入的xvclk信号,得到更高的芯片工作频率
	刚开始认为,芯片工作信号成倍增加,其他设置不变,输出的pclk也会成倍增加,输出的帧数就会成倍增加
	经足够测试`,发现pclk频率不能太高,不然输出图像明显不正常:
	mpu输出频率为18mhz clkrc倍频后 ov2640 的工作频率为36mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk从原来的28mhz 升到 56mhz,然而 输出严重失真!! 但是,每帧44ms左右 每秒22.7帧
		R_DVP_SP的pclk分频设置为4,此消彼长,pclk保持原来的28mhz,但是输出正常,而且 每帧44ms 每秒22.7帧
	mpu输出频率为18mhz clkrc不设置 ov2640 的工作频率为18mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk是原来的28mhz 但是输出正常,而且 每帧82.5ms 每秒12.1帧
	摄像头自带有源时钟 > 18Mhz, clkrc倍频后 ov2640 的工作频率为 > 36mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk上升了一倍,然而 输出严重失真!!
		R_DVP_SP的pclk分频设置为4,此消彼长,pclk保持原来,但是输出正常,而且 每帧34ms 每秒29.4帧
	从中还发现:
		pclk不能太高,输出会失真
		vsync 信号代表每帧图片传输需要的时间,采集320x240 与采集640x480 的帧传输时间不变
		更一层说,pclk的周期大小,不影响 vsync周期大小!!!!
		芯片的工作时钟越快, vsync信号周期越短,图片质量也越差,但是,pclk的改变,并不会影响vsync改变
改变pclk 并不会,因此改变vsync信号周期 而让输出图片帧速率发生改变,
	因为,相对应的 href信号里,亢余信号段会自动延长,使能信号段会自动减少,
	改变vsync FLL,FLH寄存器显著改变的的是vsync的启动信号(无效信号)长度,也稍微改变有效信号的长度
		原来 FLL 0x22, vsync周期44ms 启动信号 2ms 有效信号42ms
		后来 FLL 0xff, vsync周期 > 60ms, 启动信号 >10ms 有效信号41ms  
	改变vsync ADDVSH,ADDVSL寄存器 改变了vsync信号有效信号的电平,并没有改变vsync的周期
	改变REG2A,FRARL,HSDY,HEDY 可以用于改编 vsync HREF 信号,从而改编 帧数率,
		然而他们的修改帧速率的做法是增加vsync默认信号的周期!!!,而没有缩减vsync默认信号周期的做法!!
也就说,默认状态下,vsync信号周期是与 ov2640 的运行时钟频率有关系,例如 
	18mhz工作时钟下, vsync周期为 82mhz 输出帧速率就是11帧左右
	36mhz工作时钟下, vsync周期为 44mhz 输出帧速率就是22帧左右
	48mhz工作时钟下, vsync周期为 34mhz 输出帧速率接近30帧左右
	这些都是对应当前芯片工作频率所可以达到的最快帧速率,不论是输出640X480分辨率格式的图片,还是320x240格式
	href信号的亢余信号段分配会根据 vsync信号周期和pclk周期而自动分配
	而其他修改寄存器影响帧速率的操作,只会提高帧速率,而不会缩小帧速率
然而新的问题是datasheet说过 cif格式图片帧速率可以达到60fps,但是48mhz下的vsync说明最大也只是30fps,矛盾??
	驱动代码COM7寄存器说明,芯片时钟运行在 uxga模式(全像素点进行采集的模式)!!!(感觉不论是采集640x480,还是320x240
	
现在知道!!要改变芯片的延时问题,最根本还是要让 mpu 改变输出的xvclk时钟频率
添加内核追踪:
添加头文件:
    #include <linux/kprobes.h>
    #include <asm/traps.h> 
然后在需要向上跟踪函数调用关系里,添加 dump_stack();
int xxxx()
{
	...
	 dump_stack();
	...
}
发现 clk-sam9x5_peripheral_enable() 并不是开启 xvclk 输出时钟信号的开关,而是直接去启动i2c内部时钟准备与ov2640通讯
但是没有 xvclk 输出时钟信号 ov2640 并不工作,跟不用说 与 mpu i2c通讯了!!!!!
所以 xvclk 应该先于此设置并工作起来!!
从 ov2640_hw_power 开始追溯 priv->ssdd_dt.power = ov2640_hw_power
设置时钟! priv->clk 是 v4l2_clk
关于xvclk输出时钟:mpu的datasheet有写:The sensor master clock (ISI_MCK) can be generated either by the Advanced Power Management Controller
(APMC) through a Programmable Clock output
然后 dump_stack clk-programmer.c 的函数,发现,在ov2640真正probe之前,注册了一个i2cadapter,而这个adaptor又调用了clk-programer的函数
	怀疑 xvclk 是在这里初始化的,但是xvclk是 isi 的输出时钟,居然在 i2c adaptor 这里初始化?
	把dts xvclk的设置的频率去掉了,然后就不出现调用 clk-programer的函数 是不是意味着没有初始化xvclk?
	使用自带时钟源的ov2640模块, 发现 把dts xvclk的设置的频率去掉的情况下 可以工作!!! 可以通i2c!!!!
	使用无自带时钟源ov2640模块, 发现 把dts xvclk的设置的频率去掉的情况下 不能工作!!!
	也就说,clk-programer设置了xvclk
但是设置xvclk的地方太诡异了,居然放在i2c注册adaptor时设置,而不是在 ov2640_probe 那里设置!!!
上述是设置了xvclk 的时钟频率,和输出管脚的设置,而真正打开时钟输出开关的在后面
还有一处:
	在之前,ov2640_video_probe 看到 ov2640_s_power 在 i2c_smbus_write_byte_data 之前!!
	就是说, ov2640_s_power 里的 v4l2_clk_enable -> clk_prepare_enable()
		->clk_enale->clk_core_enable 是xvclk时钟的输出开关!!! 
		而 clk_core_enable 里的 clk->ops.enable() 应该就是 真正的时钟源输出开关!!!
		但是并不知道 clk->ops.enable 所指向,于是尝试寻找了所有关于at91 的enable函数,发现都说不是!!
		然后在 clk->ops.enable() 旁加上了dump_stack, 发现原来这里的clk->ops.enable() 并没有执行!!
		后来想想,enable应该是让时钟运作起来,但是打开输出开关的事应该不是他干的!!!
		而且在之前的 clk-programmer已经使时钟运作起来!!!
		后来怀疑并没有执行 clk_enable 没做什么实质的事情, 所有启动输出的开关在 clk_prepare_enable() ->clk_prepare 就做了,果然!!
		在 clk_prepare_enable() ->clk_prepare ->clk_core_prepare -> clk->ops->prepare 即 at91的 clk_system_prepare 给做了!!
		而且很奇怪:
			pmc_write(pmc,AT91_PMC_SCER,mask);和 is_pck(sys->id),一起组合后, 才输出xvclk时钟
			单单 pmc_write(pmc,AT91_PMC_SCER,mask) 并不会触发时钟输出!!
			后来发现,pmc_write 打开了programmable-clk-output的开关,才输出时钟信号的,
			但是从打开开关,到有信号输出,需要一段时间,才有输出,如果打开了开关就马上进入while(1);死循环的话,信号也不会输出
			所以,就有连同is_pck一起执行后 再进入死循环,才看到输出的xvclk时钟!!!
几经波折终于找到了 xvclk信号输出开关!! 
	原来是在 clk_prepare里给做了,而不是 clk_enable 
	具体是clk-system.c 的 clk_system_prepare 的 pmc_write(pmc,AT91_PMC_SCER,mask) 打开的!!!
	之前一直找错了方向,你妹,驱动写成这样乱!!









20170316
开始设置时钟频率!!
注意 ov2640_video_probe 设置了 while(1);堵塞调试!! 
分析了clk-programmable.c
	recalc_rate () 检查时钟频率
	determine_rate() 获取要设置的信息
	set_parent 设置xvclk的父时钟源!!
	set_rate 设置时钟频率
经分析,的确输出 25mhz 时钟!!! 
	是通过 200mhz-masterclock 经过8分频得到的
	在linux启动初始化摄像头设置阶段也是设置好的25mhz, 
	但是为什么执行gst视频流时会降到18mhz??
更诡异的是 如果我设置输出 12.5mhz 时钟
	执行gst视频流时还是保持12.5mhz
	vsync信号周期65ms,输出15fps, 图片质量还贼好
如果我dts写20mhz 系统会设置最近20mhz的一个可设置频率 18.75mhz
	执行gst视频流时还是保持18.75mhz
如果我dts写30mhz 系统会设置最近20mhz的一个可设置频率 30mhz
	但是执行gst视频流时还是变回18.75mhz
终于找到了问题症结, 因为 ov2640 和 ov7670 都使用了 pck1 输出作为xvclk 但是ov2640设置频率25mhz,系统能设置为25mhz
	而ov7670 设置为24mhz,但是系统只能设置自认为最好的18.75mhz,于是pck1本来是25mhz又改回18.75mhz..我去
	也就说如果开发板要挂两个摄像头,要么分别用pck1 和pck2, 要么只用pck1 输出统一时钟频率
	另外,如果ov2640之所以我设置了12.5mhz 为什么后面ov7670没有改回到18.75mhz?是因为我是强制填参数得到12.5mhz,
		后面设置18mhz也用回了12.5mhz的硬参数,
	pck 是programmable clock 的缩写!!!
 
最后尝试设置 48mhz 系统默认最多只能得到37.5mhz 
	对于37.5mhz高频,ov2640 的clcrc 不倍频,R_DVP_SP 改回2 , 图像轻微失真
	默认帧速率是由 ov2640 的芯片的工作频率决定的, 至少暂时认识到的并不是由 pclk 和 采集图像的分辨率大小决定和修改的!!
		所以不管什么分辨率和pclk 默认输出的帧速率为 24fps
还有当芯片运行的时钟频率是 30mhz时 ,可输出15fps 而且感觉图片质量和速度都相当好

至此关于ov2640 的大体调试已经完成!!
小结:
	在linux上加载一个摄像头,其实加载多个驱动!!!
	首先是 摄像头由 i2c控制,所以加载一个i2c的从设备驱动 和一个isi的图像流接受设备驱动
	此外,涉嫌头芯片需要的有时钟源才能工作,然而这个设置时钟源的事情并不是让isi驱动做,
		而是让12c从设备驱动加载时,间接加载上,关系写得有点乱,
		而且加载时调用的函数名字意义与实际操作意义不一致,造成很多误会和追溯难题







20170317
重新移植 ov7670 ,取到了一块原厂的模块!!!
我去,原厂的模块也不能i2c读取!!!
好吧,接下来就是不强求读内容了,只完成写内容调试
	调试过程中不要在执行任何读操作!!!
	(搁置待续)








20170321
今天做一个qt摄像头嵌入式程序!!!
而且确认只使用qt5来做,而非qt4.7
qt5摄像头使用qtmultimedia 模块, 所以根文件系统要添加这个模块!!
buildroot 添加这个模块,在make menuconfig 的qt5 里有这个选项!!!
在qt5.6.2 使用的编译库也要添加这个模块
都加载后 ,执行一例子显示:
defaultServiceProvider::requestService(): no service found for - "org.qt-project.qt.camera"
据网络, 给profile文件添加qtdebug项得到调试信息
	export QT_DEBUG_PLUGINS=1
后来发现 程序好像这的是在找什么库似的,.没找到!!
网上说要添加 gstreamer补丁!! 
	root@wandboard-quad:/usr/local/Qt-5.1.1/plugins/mediaservice# ls
	libgstaudiodecoder.so  libgstmediacapture.so
	libgstcamerabin.so     libgstmediaplayer.so
首先,我们要建立的使用qt5 的摄像头程序,而国内多数是qt4.7的摄像头程序!!!
使用qt5 写摄像头,需要 使用qtmultimedia
还需要gstreamer补丁,补丁与gstreamer原程序不一样,
我们使用buildroot来集成qt到文件系统,buildroot默认集成qt5.6
我们查看 qtmultimedia.pro 发现是有编译gstreamer补丁的情况的 如果读取到 GST_VERSION 的信息!!
查看 /home/infortech-ubuntu-1404/SAMA5D4/sources/buildroot/buildroot1/buildroot/package/qt5/qt5multimedia/qt5multimedia.mk
发现builroot集成的qt5.6只支持 gstreamer1.0 ?? 不支持0.1???
所以还是要线测试 gstreamer1.0可用(暂时不可用,先不管)
出现问题:
ERROR: from element /GstPipeline:pipeline0/GstVov2640 0-0030: ov2640_hw_power: DISABLE the camera
4atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
l2soc-camera-pdrv soc-camera-pdrv.0: camera device close
Src:v4l2src0: Internal data flow error.
Additional debug info:
gstbasesrc.c(2948): gst_base_src_loop (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
streaming task paused, reason not-negotiated (-4)
Execution ended after 0:00:00.511633760
Setting pipeline to PAUSED ...
Setting pipeline to READY ...
Setting pipeline to NULL ...
Freeing pipeline ...

gstreamer1.0 已经编译好,先假设可用,然后重新编译集成的qt5.6.2
先把 ouput/build里关于qt5的删掉,再重新make,不然却显示缺东西的错误
例如:libqgsttools 就是qtbase生成的,而不是qtmultimedia这个模块生成
	而libqgsttools 是否生成,还得跟 buildroot 是否集成编译了gstreamer1.0 有关系...
总之,编译通过了, 测试qt5 的camera 例程 可以打开dev/video0了可以执行i2c传输了!!!!
qt里也有gstreamer 的补丁了:libgstcamerabin.so 

接下来就是解决 gstreamer1.0 与摄像头的接口问题!!!!
先看回以前 gstreamer0.1 正常启动,正常输出log:
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd40a14a8
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb68a4000, size=614400, ret=0
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd40a1500
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb680e000, size=614400, ret=0
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock

另外,
意外地找到了一个鼠标应用examples 官方可用,插入usb鼠标可以看到鼠标移动的实现!!!









20170322
研究gstreamer1.0 为何不行!!!
网络一参考调试gstreamer1.0的:
If you see a "streaming task paused, reason not-negotiated (-4)" then you've tried to link incompatible elements or some of the involved elements is not handling the caps correctly.
When using gst-launch, I would just do:
GST_DEBUG_DUMP_DOT_DIR=$PWD gst-launch-1.0 ...
and when it failed take the last generated *.dot file and render it
dot -Tsvg xxx.dot -o graph.svg
Open the svg and look at the connections and check where the caps are not negotiated. In your case I would get it is "fbdevsink".
Finally when posting logs, use GST_DEBUG_NO_COLOR=1 to have logs without color codes.
的确得到调试信息文件dot,但是暂时不会看
usb摄像头刚到,先尝试在 pc端上实现qt摄像头!!!再移植到开发板
	先安装gstreamer1.0到机子上:
	sudo apt-get install gstreamer1.0  gstreamer1.0-plugins-base gstreamer1.0-plugins-bad gstreamer1.0-plugins-good
	遇到失效的地址,使用
	sudo apt-get install ubuntu-restricted-extras
	安装了,也也成功代替和跳过一些失效的链接和包
	然而命令行的测试是失败的!!!!
	后来发现,输出端的设备不能是fbdevsink 因为fb0设备已经用作做桌面操作系统了,所以是ximagesink会模拟出一个图片窗口供显示!!
	gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! ximagesink
重新编译QT5.6 (注意是针对pc版的):
./configure -release -opensource -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/linux-x86_64_2 -gstreamer 1.0
//-prefix  安装地址
//-gstreamer 1.0  表示将构建与 gstreamer 1.0 接口的qt功能模块 所以一定要checking for GStreamer 1.0, 如果检查到没有,就出错,
//-opensource 注册为开源用户
结果checking for GStreamer 1.0... no 直接出错!!,但明明把必要的模块都用上了
网上参考:
	安装所有gstreamer相关包
	gstreamer0.10-alsa                     gstreamer1.0-clutter                   gstreamer1.0-plugins-base-dbg
	gstreamer0.10-doc                      gstreamer1.0-clutter-3.0               gstreamer1.0-plugins-base-doc
	gstreamer0.10-ffmpeg                   gstreamer1.0-crystalhd                 gstreamer1.0-plugins-good
	gstreamer0.10-ffmpeg-dbg               gstreamer1.0-doc                       gstreamer1.0-plugins-good-dbg
	gstreamer0.10-gconf                    gstreamer1.0-dvswitch                  gstreamer1.0-plugins-good-doc
	gstreamer0.10-gnomevfs                 gstreamer1.0-espeak                    gstreamer1.0-plugins-ugly
	gstreamer0.10-nice                     gstreamer1.0-fluendo-mp3               gstreamer1.0-plugins-ugly-amr
	gstreamer0.10-plugins-base             gstreamer1.0-hybris                    gstreamer1.0-plugins-ugly-dbg
	gstreamer0.10-plugins-base-apps        gstreamer1.0-libav                     gstreamer1.0-plugins-ugly-doc
	gstreamer0.10-plugins-base-dbg         gstreamer1.0-libav-dbg                 gstreamer1.0-pocketsphinx
	gstreamer0.10-plugins-base-doc         gstreamer1.0-nice                      gstreamer1.0-pulseaudio
	gstreamer0.10-plugins-good             gstreamer1.0-packagekit                gstreamer1.0-tools
	gstreamer0.10-plugins-good-dbg         gstreamer1.0-plugins-bad               gstreamer1.0-vaapi
	gstreamer0.10-plugins-good-doc         gstreamer1.0-plugins-bad-dbg           gstreamer1.0-vaapi-doc
	gstreamer0.10-pulseaudio               gstreamer1.0-plugins-bad-doc           gstreamer1.0-x
	gstreamer0.10-qapt                     gstreamer1.0-plugins-bad-faad          gstreamer-qapt
	gstreamer0.10-tools                    gstreamer1.0-plugins-bad-videoparsers  gstreamer-tools
	gstreamer0.10-x                        gstreamer1.0-plugins-base              
	gstreamer1.0-alsa                      gstreamer1.0-plugins-base-apps         
	除了 gstreamer1.0-hybris有依赖问题无法安装外，都安装了，问题依然	
	又安装如下包	
	libgstreamer0.10-0                 libgstreamer1.0-dev                libgstreamer-ocaml-dev             
	libgstreamer-plugins-	base1.0-0
	libgstreamer0.10-0-dbg             libgstreamermm-1.0-0v5             libgstreamer-plugins-bad1.0-0      
	libgstreamer-plugins-	base1.0-dev
	libgstreamer0.10-dev               libgstreamermm-1.0-dev             libgstreamer-plugins-bad1.0-dev    
	libgstreamer-plugins-	good1.0-0
	libgstreamer1.0-0                  libgstreamermm-1.0-doc             libgstreamer-plugins-base0.10-0    
	libgstreamer-plugins-	good1.0-dev
	libgstreamer1.0-0-dbg              libgstreamer-ocaml                 libgstreamer-plugins-base0.10-dev  
	问题依然，搜索了好久
	./configure -gstreamer 1.0 -qt-xcb 问题依然
	 pkg-config gstreamer-1.0 --cflags 结果正常
	-pthread -I/usr/include/gstreamer-1.0 -I/usr/lib/x86_64-linux-gnu/gstreamer-1.0/include -I/usr/include/glib-2.0 
		-I/usr/lib/x86_64-	linux-gnu/glib-2.0/include
	pkg-config gstreamer-1.0 --libs 结果正常
	-lgstreamer-1.0 -lgobject-2.0 -lglib-2.0
	经过这篇文章提示，http://askubuntu.com/questions/384059/error-compiling-a-package-configure-error-no-gstreamer-1-0-1-0-0	
	仔细检查，果然是漏掉了 sudo apt install libgstreamer-plugins-base1.0-dev 安装
	安装完后，rm config.cache，重新./configure 终于检测结果正常开启 GStreamer 1.0
根据网上参考,添加
sudo apt install libgstreamer-plugins-base1.0-dev 
重新 ./configure 
成功检测到 checking for GStreamer 1.0... yes,最终成功配置
然后make -j8.....make install
然后配置qtcreator 添加一个新的配置,使用这个新编译qmake版本
重新编译 官方自带例子 multimediawidgets的camera 成功显示图像!!!!

另外,补充关于qt的./configure 的使用!!!
./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float
//-release 不明
//-opensource 开源
//-xplatfrom 选择编译器,默认不选,是系统安装的gcc g++,出来的文件是针对x86_64_pc,例如这里选了linux-arm-gnueabi-g++ 就是针对 arm架构的
//-prefix 安装路径
//-no-c++11 相反的是 -c++11 表示是否应用c++11的标准编译
//-gstreamer 1.0  表示会用到 gstreamer 的1.0 版本
另外在ubuntu部署 gstreamer
sudo apt-get install libgstreamer0.10-dev gstreamer-tools gstreamer0.10-tools gstreamer0.10-doc
sudo apt-get install gstreamer0.10-plugins-base gstreamer0.10-plugins-good gstreamer0.10-plugins-ugly gstreamer0.10-plugins-bad gstreamer0.10-plugins-bad-multiverse
apt-get install libgstreamer* // 该命令的目的是安装头文件；注意’*’









20170323
为了了解是不是streamer 的问题,给内核加上了usb 摄像头模块UVC
make ARCH=arm menuconfig:
	Device Drivers -> Multimedia support -> Media USB adapters -> USB Video Class (UVC) -> UVC input events device support
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
然后烧录,把ov2640 去掉, 挂上usb摄像头 ,开启板子,然后执行命令行
gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! fbdevsink
成功显示!!虽然帧率比较低
然后绕到文件系统qt里自带的camera例子执行,也成功显示图像!!!!

这么说,问题应该就出在ov2640的驱动上!!!!
每次搜都是设置好后就主动关闭摄像头!!!你妹
然后把 ov2640 的的开关函数关于硬件关闭摄像头的部分关闭了!!!!
但是没用,查看log:
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt而且正确设置
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了打开ov2640的步骤
//后来莫名其妙调动了soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0	//soc_camera_close->soc_camera_remove_device->ops->remove(icd)
soc-camera-pdrv soc-camera-pdrv.0: camera device close			//至此soc_camera_close 完毕
//然后又是soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0 //soc_camera_add_device
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)

gstreamer1.0 失败log:
//soc_camera_open 
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0	//soc_camera_add_device
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera	//__soc_camera_power_on
//soc_camera_open 里的 soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: camera device open 	//至此,完成了 soc_camera_open 打开ov2640的步骤
//很突然执行了 soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera	//__soc_camera_power_off
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0 //soc_camera_remove_device
soc-camera-pdrv soc-camera-pdrv.0: camera device close  //至此,完成了 soc_camera_close
//很突然又执行了 soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//很突然执行了 soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
soc-camera-pdrv soc-camera-pdrv.0: camera device close	//至此,完成了 soc_camera_close
//暂停pipeline
Setting pipeline to PAUSED ...
//很突然又执行了 soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//???
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
New clock: GstSysoc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
stsoc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
esoc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
mClock
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
ERROR: from element /GstPipeline:pipeline0/GstV4l2Src:v4l2src0: Iov2640 0-0030: ov2640_hw_power: DISABLE the camera
natmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
tsoc-camera-pdrv soc-camera-pdrv.0: camera device close
ernal data flow error.
Additional debug info:
gstbasesrc.c(2948): gst_base_src_loop (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
streaming task paused, reason not-negotiated (-4)
Execution ended after 0:00:00.455205440
Setting pipeline to PAUSED ...
Setting pipeline to READY ...
Setting pipeline to NULL ...
Freeing pipeline ...

gstreamer0.1 成功log:
Setting pipeline to PAUSED ...
//soc_camera_open 
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare //打开时钟输出开关
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
//soc_camera_open 里的 soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//然后就是不断地 ops->vidioc_try_fmt_vid_cap : soc_camera_try_fmt_vid_cap -> soc_camera_try_fmt -> TRY_FMT
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
......
//然后 ops-> vidioc_g_fmt_vid_cap : soc_camera_g_fmt_vid_cap->"current_fmt->fourcc"
soc-camera-pdrv soc-camera-pdrv.0: current_fmt->fourcc: 0x56595559
//然后 ops-> vidioc_s_fmt_vid_cap : soc_camera_s_fmt_vid_cap -> soc_camera_set_fmt
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge//至此第二次完成soc_camera_set_fmt
//然后是 vb2_ops->queue_setup : queue_setup
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
//v4l2_file_operations->mmap : soc_camera_mmap
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd42423a0
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb68c4000, size=614400, ret=0
//v4l2_file_operations->mmap : soc_camera_mmap
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd4242500
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb682e000, size=614400, ret=0
//pmc开启计时器??反正不重要的
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock

对比成功log 和不成功log 发现 gstreamer1.0 应该是多线程工作的,所以发现虽然开始时是无尽的关闭重启,重启关闭,但是最后还是看到一些端倪,
发现gstreamer1.0可能真的需要多次重启关闭重启关闭,然而在程序使用的时候,因为i2c初始化的log占据大量时间,
	导致,gstreamer1.0工作时,摄像头还是没有初始化好!!!
所以先尝试关闭内核i2c调试信息!!!
make ARCHarm menuconfig: Device Driver -> I2C upport -> 不选 I2C core debugging message 和 i2c Bus debugging messages 
编译和烧录测试, 没有用!!!
但是发现了,除去i2clog后, 在Setting pipeline to PAUSED ... 只有一回合开了又关
	在i2clog未去前,有两回合,开了又关
终于,感觉 摄像头打开和软件初始化采集工作并不是顺序进行而是并行进行的,以至于,软件开始采集时,摄像头其实还没有初始化完!!!









20170324
dunp_stack soc_camera_open 和 soc_camera_close 
发现只能跟踪到内核态里的调用,上不去用户态的调用关系!
soc_camera_close
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033ffcc>] (soc_camera_close+0x18/0xc8)
[<c033ffcc>] (soc_camera_close) from [<c0324840>] (v4l2_release+0x34/0x74)
[<c0324840>] (v4l2_release) from [<c0096500>] (__fput+0x80/0x1b0)
[<c0096500>] (__fput) from [<c003068c>] (task_work_run+0x88/0xbc)
[<c003068c>] (task_work_run) from [<c0011464>] (do_work_pending+0x94/0xb4)
[<c0011464>] (do_work_pending) from [<c000f3ac>] (work_pending+0xc/0x20)
soc_camera_open
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c0340094>] (soc_camera_open+0x18/0x2d4)
[<c0340094>] (soc_camera_open) from [<c0324920>] (v4l2_open+0xa0/0xe0)
[<c0324920>] (v4l2_open) from [<c0098958>] (chrdev_open+0xa0/0x140)
[<c0098958>] (chrdev_open) from [<c0093858>] (do_dentry_open.isra.11+0xe8/0x2e8)
[<c0093858>] (do_dentry_open.isra.11) from [<c009f460>] (do_last.isra.43+0x4cc/0xb9c)
[<c009f460>] (do_last.isra.43) from [<c00a0f48>] (path_openat+0x7c/0x520)
[<c00a0f48>] (path_openat) from [<c00a2140>] (do_filp_open+0x2c/0x80)
[<c00a2140>] (do_filp_open) from [<c009495c>] (do_sys_open+0x110/0x1cc)
[<c009495c>] (do_sys_open) from [<c000f360>] (ret_fast_syscall+0x0/0x3c)
感觉,open和close是两个独立的线程或者是进程并行工作的,而不是在同一个线程里顺序工作!!!
使用 meld 来观察 gst-launch-1.0.c 和 gst-lanuch-0.1.c 的区别!!
共同特点是 Setting pipeline to PAUSED ... 后都启动 soc_camera_open
但是1.0 在之前也来了一回合开关 soc_camera_open
0.1版,在Pipeline is live and does not need PREROLL ... 之前完成了 ov2640 整个初始化,
1.0版,在Pipeline is live and does not need PREROLL ... 之前未完成 ov2640 整个初始化,
Setting pipeline to PAUSED ... 与 Pipeline is live and does not need PREROLL ... 间
	隔着一个 ret = gst_element_set_state (pipeline, GST_STATE_PAUSED); 函数!!
无意中怀疑一个gst打开/dev/video0的函数:
	gst_v4l2_object_open()->gst_v4l2_open
无意中习得一种 gstreamer 的调试手段!!!
在 gst-launch 命令前 加上 GST_DEBUG=...
例如: GST_DEBUG=6 gst-launch-1.0 ....		//这里是把所有6级及以下的调试信息都打印出来
例如: GST_DEBUG=GST_ELEMENT_*:6 gst-launch-1.0 ...	//这是把所有 GST_ELEMENT_*组别的 6级及以下的调试信息都打印出来












20170327
由于gstreamer1.0 与ov2640 的冲突实在是太明显了,所以就尝试使用 qt4 避开gsreamer1.0
所以先在buildroot里移植qt4
	使用buildroot1 make menuconfig:选qt
	除了要勾上例程外,还要注意pixel depths 的设置,例如,开发板只支持24位的rgb888模式, 
		不然运行测试程序会显示blit_setup(): Screen depth 24 not supported! 之类的错误
	还有 graphic driver 选 linux framebuffer mouse driver选 linux input 或者 tslib
	最后虽然成功显示,但是似乎并没有打开触摸屏未知原因!!
还有 qt4程序的执行  一定要加 -qws 参数才可以
	例如 : ./fingerpaint -qws &		//& 表示进程后台运行,不占据 tty串口控制台console,不后台进行可以不加&	
结果,发现例程都没有打开触摸屏!!!,(如果打开了,会有消息显示)不知到为啥!!
然后再编译pc上的qt4 环境:
首先擦哈坎buildroot 发现使用的是qt-4.8.7,所以移植qt-4.8.7
从官网下载了qt4.8.7并解压,然后开始编译安装:
首先修改mkspecs/qws/linux-arm-gnueabi-g++:
#
# qmake configuration for building with arm-none-linux-gnueabi-g++
#

include(../../common/linux.conf)
include(../../common/gcc-base-unix.conf)
include(../../common/g++-unix.conf)
include(../../common/qws.conf)

# modifications to g++.conf
QMAKE_CC                = arm-linux-gnueabihf-gcc
QMAKE_CXX               = arm-linux-gnueabihf-g++
QMAKE_LINK              = arm-linux-gnueabihf-g++
QMAKE_LINK_SHLIB        = arm-linux-gnueabihf-g++

# modifications to linux.conf
QMAKE_AR                = arm-linux-gnueabihf-ar cqs
QMAKE_OBJCOPY           = arm-linux-gnueabihf-objcopy
QMAKE_STRIP             = arm-linux-gnueabihf-strip

load(qt_config)
然后执行:./configure -force-pkg-config -release -opensource -v -embedded arm -xplatform qws/linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-4.8.7/armv7-a -no-fast
//-force-pkg-config 不加上会出现 关于 pkg-config 的错误,此外mkspecs/qws/linux-arm-gnueabi-g++ 不修改过来也出现这种错误,
//-no-fast 表示编译所有模块!!!
然后make -j8 & make install
然后配置qtcreator 再编译一个例子程序和 camera程序烧到开发板,成功运行
然而还是有些问题未能解决:
	都没有打开触摸屏驱动
	camera2例子中,ov2640成功打开,但图像错乱,USB摄像头不能打开,直接出现段错误!!!
	(问题暂时搁置)
勉强成功安装测试了 qt4.8.7
另外,如果程序出现这种错误!!
‘close’ was not declared in this scope
没有包含头文件 unistd.h 造成的。
加上'
#include <unistd.h>











20170328
今天暂时不弄摄像头问题,直接处理sam9x35的板子
板子预装了linux系统,开机截取log:
RomBOOT
Start AT91Bootstrap...
Init DDR... Done!
Loading 1-Wire info...
Enumerate all roms:
Rom#0x0: 0xad 0x0 0x0 0x2 0xab 0xbb 0x1 0x2d 
Rom#0x1: 0x78 0x0 0x0 0x3 0x21 0xaf 0x93 0x2d 
Rom#0x2: 0x7a 0x0 0x0 0x1 0x2 0xb3 0x1f 0x23 
Done, 0x3 1-wire chips found!

Board name: SAM9X35-CM [B2]; Vendor name: RONETIX
Board name: SAM9x5-EK [B0]; Vendor name: FLEX
Board name: SAM9x5-DM [B0]; Vendor name: FLEX
sn: 0x4010466;   rev: 0x10421
Downloading image...
chip id: 0xadda
Copy 0x50000 bytes from 0x40000 to 0x26f00000
Done!


U-Boot 2010.06 (Jun 23 2011 - 10:51:37)

DRAM:  128 MiB
NAND:  256 MiB
In:    serial
Out:   serial
Err:   serial
Net:   macb0
macb0: Starting autonegotiation...
macb0: Autonegotiation complete
macb0: link up, 100Mbps full-duplex (lpa: 0x4de1)
Hit any key to stop autoboot:  0 

NAND read: device 0 offset 0x200000, size 0x250000
 2424832 bytes read: OK
## Booting kernel from Legacy Image at 22000000 ...
   Image Name:   Angstrom/2.6.39/at91sam9x5ek
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    2351680 Bytes = 2.2 MiB
   Load Address: 20008000
   Entry Point:  20008000
   Verifying Checksum ... OK
   Loading Kernel Image ... OK
OK

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Linux version 2.6.39 (nferre@RFOLXTS02.rfo.atmel.com) (gcc version 4.5.3 20110223 (prerelease) (GCC) ) #1 Thu Jun 23 09:29:18 CEST 2011
CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=00053177
CPU: VIVT data cache, VIVT instruction cache
Machine: Atmel AT91SAM9X5-EK
Memory policy: ECC disabled, Data cache writeback
Clocks: CPU 400 MHz, master 133 MHz, main 12.000 MHz
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/uboot/kernel)ro,-(rootfs) root=/dev/mtdblock1 rw rootfstype=ubifs ubi.mtd=1 root=ubi0:root
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Memory: 128MB = 128MB total
Memory: 124972k/124972k available, 6100k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    DMA     : 0xff000000 - 0xffe00000   (  14 MB)
    vmalloc : 0xc8800000 - 0xfee00000   ( 870 MB)
    lowmem  : 0xc0000000 - 0xc8000000   ( 128 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .init : 0xc0008000 - 0xc002a000   ( 136 kB)
      .text : 0xc002a000 - 0xc0489d68   (4480 kB)
      .data : 0xc048a000 - 0xc04baee0   ( 196 kB)
NR_IRQS:192
AT91: 128 gpio irqs in 4 banks
Console: colour dummy device 80x30
console [ttyS0] enabled
Calibrating delay loop... 199.06 BogoMIPS (lpj=995328)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
devtmpfs: initialized
NET: Registered protocol family 16
AT91: CM rev B and higher
AT91: EK rev B and higher
AT91: Power Management (with slow clock mode)
AT91: Starting after user reset
bio: create slab <bio-0> at 0
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
i2c-gpio i2c-gpio.0: using pins 62 (SDA) and 63 (SCL)
at_hdmac at_hdmac.0: Atmel AHB DMA Controller ( cpy slave ), 8 channels
at_hdmac at_hdmac.1: Atmel AHB DMA Controller ( cpy slave ), 8 channels
Advanced Linux Sound Architecture Driver Version 1.0.24.
Switching to clocksource tcb_clksrc
NET: Registered protocol family 2
IP route cache hash table entries: 1024 (order: 0, 4096 bytes)
TCP established hash table entries: 4096 (order: 3, 32768 bytes)
TCP bind hash table entries: 4096 (order: 2, 16384 bytes)
TCP: Hash tables configured (established 4096 bind 4096)
TCP reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
JFFS2 version 2.2. (NAND) (SUMMARY)  © 2001-2006 Red Hat, Inc.
msgmni has been set to 244
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 253)
io scheduler noop registered (default)
atmel_hlcdfb atmel_hlcdfb_base.0: 1500KiB frame buffer at 27a00000 (mapped at ffc00000)
cfg80211: Calling CRDA to update world regulatory domain
atmel_hlcdfb atmel_hlcdfb_base.0: fb0: Atmel LCDC at 0xf8038000 (mapped at c8864000), irq 25
atmel_hlcdfb atmel_hlcdfb_ovl.0: 1500KiB frame buffer at 27000000 (mapped at ffa00000)
atmel_hlcdfb atmel_hlcdfb_ovl.0: fb1: Atmel LCDC at 0xf8038100 (mapped at c886c100), irq -6
atmel_usart.0: ttyS0 at MMIO 0xfefff200 (irq = 1) is a ATMEL_SERIAL
atmel_usart.1: ttyS1 at MMIO 0xf801c000 (irq = 5) is a ATMEL_SERIAL
brd: module loaded
loop: module loaded
ssc ssc.0: Atmel SSC device at 0xc8880000 (irq 28)
atmel_nand atmel_nand: Using dma0chan0 for DMA transfers.
ONFI flash detected
NAND device: Manufacturer ID: 0xad, Chip ID: 0xda (Hynix NAND 256MiB 3,3V 8-bit)
atmel_pmecc_init_params
Scanning device for bad blocks
Bad eraseblock 147 at 0x000001260000
2 cmdlinepart partitions found on MTD device atmel_nand
Creating 2 MTD partitions on "atmel_nand":
0x000000000000-0x000000800000 : "bootstrap/uboot/kernel"
0x000000800000-0x000010000000 : "rootfs"
UBI: attaching mtd1 to ubi0
UBI: physical eraseblock size:   131072 bytes (128 KiB)
UBI: logical eraseblock size:    126976 bytes
UBI: smallest flash I/O unit:    2048
UBI: VID header offset:          2048 (aligned 2048)
UBI: data offset:                4096
UBI: max. sequence number:       11
UBI: attached mtd1 to ubi0
UBI: MTD device name:            "rootfs"
UBI: MTD device size:            248 MiB
UBI: number of good PEBs:        1983
UBI: number of bad PEBs:         1
UBI: number of corrupted PEBs:   0
UBI: max. allowed volumes:       128
UBI: wear-leveling threshold:    4096
UBI: number of internal volumes: 1
UBI: number of user volumes:     1
UBI: available PEBs:             0
UBI: total number of reserved PEBs: 1983
UBI: number of PEBs reserved for bad PEB handling: 19
UBI: max/mean erase counter: 2/0
UBI: image sequence number:  46740637
CAN device driver interface
at91_can at91sam9x5_can.1: can0: Features changed: 0x00004804 -> 0x00004004
at91_can at91sam9x5_can.1: device registered (reg_base=c88e0000, irq=30)
macb macb.0: invalid hw address, using random
macb macb.0: eth0: Features changed: 0x00004800 -> 0x00004000
MACB_mii_bus: probed
eth0: Atmel MACB at 0xf802c000 irq 24 (1a:61:4a:e7:06:84)
eth0: attached PHY driver [Davicom DM9161A] (mii_bus:phy_addr=0:00, irq=-1)
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
atmel-ehci atmel-ehci: Atmel EHCI UHP HS
atmel-ehci atmel-ehci: new USB bus registered, assigned bus number 1
atmel-ehci atmel-ehci: irq 22, io mem 0x00700000
UBI: background thread "ubi_bgt0d" started, PID 29
atmel-ehci atmel-ehci: USB 2.0 started, EHCI 1.00
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 3 ports detected
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
at91_ohci at91_ohci: AT91 OHCI
at91_ohci at91_ohci: new USB bus registered, assigned bus number 2
at91_ohci at91_ohci: irq 22, io mem 0x00600000
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 3 ports detected
Initializing USB Mass Storage driver...
usbcore: registered new interface driver usb-storage
USB Mass Storage support registered.
usbcore: registered new interface driver libusual
atmel_usba_udc atmel_usba_udc: MMIO registers at 0xf803c000 mapped at c88ee000
atmel_usba_udc atmel_usba_udc: FIFO at 0x00500000 mapped at c8900000
qt1070 0-001b: AT42QT1070 firmware version 15
input: AT42QT1070 QTouch Sensor as /devices/platform/i2c-gpio.0/i2c-0/0-001b/input/input0
atmel_tsadcc atmel_tsadcc: Master clock is set at: 133333333 Hz
atmel_tsadcc atmel_tsadcc: Prescaler is set at: 221
input: atmel touch screen controller as /devices/platform/atmel_tsadcc/input/input1
at91_rtc at91_rtc: rtc core: registered at91_rtc as rtc0
AT91 Real Time Clock driver.
i2c /dev entries driver
Linux media interface: v0.10
lirc_dev: IR Remote Control driver registered, major 249 
IR NEC protocol handler initialized
IR RC5(x) protocol handler initialized
IR RC6 protocol handler initialized
IR JVC protocol handler initialized
IR Sony protocol handler initialized
IR RC5 (streamzap) protocol handler initialized
IR LIRC bridge handler initialized
Linux video capture interface: v2.00
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
asoc: wm8731-hifi <-> atmel-ssc-dai.0 mapping ok
ASoC: at91sam9x5ek_init ok
ALSA device list:
  #0: AT91SAM9X5
nf_conntrack version 0.5.0 (1952 buckets, 7808 max)
ip_tables: (C) 2000-2006 Netfilter Core Team
TCP cubic registered
NET: Registered protocol family 17
can: controller area network core (rev 20090105 abi 8)
NET: Registered protocol family 29
can: raw protocol (rev 20090105)
lib80211: common routines for IEEE802.11 drivers
Registering the dns_resolver key type
at91_rtc at91_rtc: setting system clock to 2007-01-01 00:41:58 UTC (1167612118)
atmel_mci atmel_mci.0: Using dma0chan1 for DMA transfers
atmel_mci atmel_mci.0: Atmel MCI controller at 0xf0008000 irq 12, 1 slots
atmel_mci atmel_mci.1: Using dma1chan0 for DMA transfers
atmel_mci atmel_mci.1: Atmel MCI controller at 0xf000c000 irq 26, 1 slots
UBIFS: recovery needed
UBIFS: recovery completed
UBIFS: mounted UBI device 0, volume 0, name "root"
UBIFS: file system size:   247476224 bytes (241676 KiB, 236 MiB, 1949 LEBs)
UBIFS: journal size:       9023488 bytes (8812 KiB, 8 MiB, 72 LEBs)
UBIFS: media format:       w4/r0 (latest is w4/r0)
UBIFS: default compressor: lzo
UBIFS: reserved for root:  0 bytes (0 KiB)
VFS: Mounted root (ubifs filesystem) on device 0:13.
devtmpfs: mounted
Freeing init memory: 136K
init started: BusyBox v1.17.1 (2011-06-15 05:54:27 CEST)
starting pid 35, tty '/dev/console': '/etc/init.d/rcS'
mounting filesystems...done.
running rc.d services...
starting atmel-qml...done
starting udev
mounting tmpfs at /dev
creating static nodes
starting udevd...done
waiting for devices...done
Starting telnetd...
restoring mixer state...no /etc/asound.state, aborting
starting network interfaces...
udhcpc (v1.17.1) started
Sending discover...
eth0: link up (100/Full)
Sending discover...
Sending select for 200.200.200.110...
Lease of 200.200.200.110 obtained, lease time 7200
deleting routers
route: SIOCDELRT: No such process
adding dns 114.114.114.114
adding dns 200.200.200.1
loading modules

OSELAS(R)-SAM9-master (ptxdist-2011.06.0/2011-06-15T08:38:53+0200)

    _   _                  _ 
   / \ | |_ _ __ ___   ___| |
  / _ \| __| '_ ` _ \ / _ \ |
 / ___ \ |_| | | | | |  __/ |
/_/   \_\__|_| |_| |_|\___|_|
                             
 ____    _    __  __  ___  
/ ___|  / \  |  \/  |/ _ \ 
\___ \ / _ \ | |\/| | (_) |
 ___) / ___ \| |  | |\__, |
|____/_/   \_\_|  |_|  /_/ 
                           


starting pid 148, tty '/dev/console': '/sbin/getty -L 115200 ttyS0 vt100'

SAM9 login: root
login[148]: root login on 'ttyS0'
running /etc/profile.local
root@SAM9:~ 
经过观察,这板子是cpu ARM926EJ-S, 也属于Atmel AT91SAM9X5-EK
测试 sam-ba 的连接
先把核心板的 J1 跳线断开, 按nrst (reset)按钮,然后再闭合跳线
官网下载的 sam-ba2.16 窗口版本: 需要 sudo ./sam-ba 才能正常打开工作
用已装好的sam-ba3 命令行版本: 
	sudo sam-ba -p serial:ttyACM0:115200 -b sam9xx5-ek -a lowlevel	//测试连接
	//然而使用sam-ba3来烧录还是不行，未深入探究如何人使用
成功使用sam-ba2.16把demo烧录到到开发板并运行!!!
	//直接使用demo 的 .sh 执行文件实现的，修改 .tcl 文件，可以把自己编译的文件烧入系统
	//比起打开sam-ba2的窗口界面，以上命令行方式更快捷
想把现成的buildroot rootfs 拷入sam9x35的，但是由于flash不一样的，编译成ubi的参数也应该不一样
	make at91sam9x5ek_defconfig  //配置buildroot
还有ubi参数貌似调对了有又出现这种问题！！
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
	终于发现了， sam9x35终究不是contex-a5 架构的，所以在编译根文件系统时也要有所设置的，不只是ubi的设置要改，target options的设置也要改
	Target Architecture (ARM (little endian))  ---> 	
	Target Binary Format (ELF)  --->
	Target Architecture Variant (arm926t)  --->	//cpu类型
	[*] Enable VFP extension support
	Target ABI (EABI)  ---> 			//一定不能错 否则Kernel panic - not syncing:。。。。
	Floating point strategy (Soft float)  --->	//一定不能错 否则Kernel panic - not syncing:。。。。
	ARM instruction set (ARM)  --->  	
最后成功启动并能打开lcd 关于 touchscreen 的启动情况未得知
	但是，预装系统的触摸屏运行得非常溜！！！！
sam9x35的编译环境基本建立！！！
补充:核心板 J2跳线: 断开 nandflash启动 ， 闭合 sdcard启动
	   J1跳线： 断开 烧录模式， 闭合 常规启动模式，并接到nandflash /sdcard
 











20170330
接下来处理sama5d35 的板子！！！
预装系统log：
AT91Bootstrap 3.6.1-00079-gf8860d8 (Wed Feb 19 15:25:13 CST 2014)
1-Wire: Loading 1-Wire information ...
1-Wire: ROM Searching ... Done, 0x3 1-Wire chips found

1-Wire: BoardName | [Revid] | VendorName
  #0x0  SAMA5D35-CM [BB2]      RONETIX
  #0x1  SAMA5D3x-MB [EE5]      FLEX
  #0x2  SAM9x5-DM [B0]      FLEX

1-Wire: SYS_GPBR2: 0x481046d, SYS_GPBR3: 0xa11021

NAND: ONFI flash detected
NAND: Manufacturer ID: 0x2c Chip ID: 0x32
NAND: Disable On-Die ECC
NAND: Initialize PMECC params, cap: 0x4, sector: 0x200
NAND: Image: Copy 0x80000 bytes from 0x40000 to 0x26f00000
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x1a6,Bit# 0x7] 0xd0 -> 0x50
PMECC: sector bits = 0x8, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x1f,Bit# 0x1] 0xe3 -> 0xe1
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x2e,Bit# 0x4] 0x7e -> 0x6e
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x4e,Bit# 0x6] 0x6d -> 0x2d
NAND: Done to load image


U-Boot 2013.07-00053-g40cc764 (Feb 19 2014 - 17:53:17)

CPU: SAMA5D35
Crystal frequency:       12 MHz
CPU clock        :      528 MHz
Master clock     :      132 MHz
DRAM:  512 MiB
NAND:  256 MiB
MMC:   mci: 0
In:    serial
Out:   serial
Err:   serial
Net:   macb0
Warning: failed to set MAC address
, gmac0
Warning: failed to set MAC address

Hit any key to stop autoboot:  0 

NAND read: device 0 offset 0x200000, size 0x37be94
Bit flip in data area, byte_pos: 1173, bit_pos: 1, 0x02 -> 0x00
Bit flip in data area, byte_pos: 839, bit_pos: 2, 0x07 -> 0x03
Bit flip in data area, byte_pos: 1060, bit_pos: 7, 0x80 -> 0x00
Bit flip in data area, byte_pos: 1082, bit_pos: 1, 0x02 -> 0x00
Bit flip in data area, byte_pos: 494, bit_pos: 5, 0x61 -> 0x41
Bit flip in data area, byte_pos: 1833, bit_pos: 1, 0xa6 -> 0xa4
Bit flip in data area, byte_pos: 184, bit_pos: 6, 0xf1 -> 0xb1
Bit flip in data area, byte_pos: 1918, bit_pos: 4, 0xb6 -> 0xa6
Bit flip in data area, byte_pos: 180, bit_pos: 1, 0x7e -> 0x7c
Bit flip in data area, byte_pos: 161, bit_pos: 3, 0xfc -> 0xf4
Bit flip in data area, byte_pos: 27, bit_pos: 2, 0x8d -> 0x89
Bit flip in data area, byte_pos: 625, bit_pos: 7, 0xb1 -> 0x31
Bit flip in data area, byte_pos: 1066, bit_pos: 3, 0xfc -> 0xf4
Bit flip in data area, byte_pos: 140, bit_pos: 0, 0xe7 -> 0xe6
Bit flip in data area, byte_pos: 1507, bit_pos: 7, 0xf3 -> 0x73
Bit flip in data area, byte_pos: 1974, bit_pos: 4, 0xf9 -> 0xe9
Bit flip in data area, byte_pos: 656, bit_pos: 6, 0x54 -> 0x14
Bit flip in data area, byte_pos: 1888, bit_pos: 7, 0x80 -> 0x00
Bit flip in data area, byte_pos: 1072, bit_pos: 6, 0x40 -> 0x00
 3653268 bytes read: OK
## Loading kernel from FIT Image at 22000000 ...
   Using 'conf@sama5d35ek' configuration
   Trying 'kernel@1' kernel subimage
     Description:  AT91 SAMA5D3 Linux kernel
     Type:         Kernel Image
     Compression:  uncompressed
     Data Start:   0x22055a00
     Data Size:    3081320 Bytes = 2.9 MiB
     Architecture: ARM
     OS:           Linux
     Load Address: 0x20008000
     Entry Point:  0x20008000
     Hash algo:    crc32
     Hash value:   59f12b41
   Verifying Hash Integrity ... crc32+ OK
## Loading fdt from FIT Image at 22000000 ...
   Using 'conf@sama5d35ek' configuration
   Trying 'fdt_sama5d35ek@1' fdt subimage
     Description:  Flattened Device Tree blob for SAMA5D35EK
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x22355e30
     Data Size:    21292 Bytes = 20.8 KiB
     Architecture: ARM
     Hash algo:    crc32
     Hash value:   0d0af010
   Verifying Hash Integrity ... crc32+ OK
   Booting using the fdt blob at 0x22355e30
   Loading Kernel Image ... OK
   Loading Device Tree to 3ba4a000, end 3ba5232b ... OK

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Booting Linux on physical CPU 0x0
Linux version 3.10.0-00354-gdf700c9 (josh@shaarm01) (gcc version 4.7.3 (Sourcery CodeBench Lite 2013.05-24) ) #1 Wed Feb 19 15:28:48 CST 2014
CPU: ARMv7 Processor [410fc051] revision 1 (ARMv7), cr=10c53c7d
CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
Machine: Atmel SAMA5 (Device Tree), model: Atmel SAMA5D35-EK
Memory policy: ECC disabled, Data cache writeback
AT91: Detected soc type: sama5d3
AT91: Detected soc subtype: sama5d35
AT91: sram at 0x300000 of 0x20000 mapped at 0xfef58000
CPU: All CPU(s) started in SVC mode.
Clocks: CPU 528 MHz, master 132 MHz, main 12.000 MHz
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 130048
Kernel command line: console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/uboot/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs
PID hash table entries: 2048 (order: 1, 8192 bytes)
Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)
Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)
Memory: 512MB = 512MB total
Memory: 513644k/513644k available, 10644k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    vmalloc : 0xe0800000 - 0xff000000   ( 488 MB)
    lowmem  : 0xc0000000 - 0xe0000000   ( 512 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .text : 0xc0008000 - 0xc0563598   (5486 kB)
      .init : 0xc0564000 - 0xc058dc64   ( 168 kB)
      .data : 0xc058e000 - 0xc05c8cc0   ( 236 kB)
       .bss : 0xc05c8cc0 - 0xc05e6298   ( 118 kB)
NR_IRQS:16 nr_irqs:16 16
sched_clock: 32 bits at 100 Hz, resolution 10000000ns, wraps every 4294967286ms
Console: colour dummy device 80x30
Calibrating delay loop... 262.96 BogoMIPS (lpj=1314816)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
Setting up static identity map for 0xc0408878 - 0xc04088d0
devtmpfs: initialized
pinctrl core: initialized pinctrl subsystem
NET: Registered protocol family 16
DMA: preallocated 256 KiB pool for atomic coherent allocations
No ATAGs?
AT91: Power Management
gpio-at91 fffff200.gpio: at address fefff200
gpio-at91 fffff400.gpio: at address fefff400
gpio-at91 fffff600.gpio: at address fefff600
gpio-at91 fffff800.gpio: at address fefff800
gpio-at91 fffffa00.gpio: at address fefffa00
pinctrl-at91 pinctrl.2: initialized AT91 pinctrl driver
bio: create slab <bio-0> at 0
at_hdmac ffffe600.dma-controller: Atmel AHB DMA Controller ( cpy slave ), 8 channels
at_hdmac ffffe800.dma-controller: Atmel AHB DMA Controller ( cpy slave ), 8 channels
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
at91_i2c f0018000.i2c: using dma0chan0 (tx) and dma0chan1 (rx) for DMA transfers
at91_i2c f0018000.i2c: AT91 i2c bus driver.
Linux video capture interface: v2.00
Advanced Linux Sound Architecture Driver Initialized.
cfg80211: Calling CRDA to update world regulatory domain
Switching to clocksource tcb_clksrc
NET: Registered protocol family 2
TCP established hash table entries: 4096 (order: 3, 32768 bytes)
TCP bind hash table entries: 4096 (order: 2, 16384 bytes)
TCP: Hash tables configured (established 4096 bind 4096)
TCP: reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered named UNIX socket transport module.
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
msgmni has been set to 1003
io scheduler noop registered (default)
f0020000.serial: ttyS2 at MMIO 0xf0020000 (irq = 23) is a ATMEL_SERIAL
ffffee00.serial: ttyS0 at MMIO 0xffffee00 (irq = 36) is a ATMEL_SERIAL
console [ttyS0] enabled
brd: module loaded
loop: module loaded
ssc f0008000.ssc: Atmel SSC device at 0xe0858000 (irq 19)
atmel_nand_nfc 70000000.nfc: NFC is probed.
atmel_nand: Use On Flash BBT
atmel_nand 60000000.nand: Using dma0chan2 for DMA transfers.
ONFI param page 0 valid
ONFI flash detected
NAND device: Manufacturer ID: 0x2c, Chip ID: 0xda (Micron MT29F2G08ABAEAWP), 256MiB, page size: 2048, OOB size: 64
atmel_nand 60000000.nand: ONFI params, minimum required ECC: 4 bits in 512 bytes
atmel_nand 60000000.nand: Initialize PMECC params, cap: 4, sector: 512
atmel_nand 60000000.nand: Using NFC Sram read and write
Bad block table found at page 131008, version 0x01
Bad block table found at page 130944, version 0x01
2 cmdlinepart partitions found on MTD device atmel_nand
Creating 2 MTD partitions on "atmel_nand":
0x000000000000-0x000000800000 : "bootstrap/uboot/kernel"
0x000000800000-0x000010000000 : "rootfs"
atmel_spi f0004000.spi: version: 0x213
atmel_spi f0004000.spi: Using dma0chan3 (tx) and dma0chan4 (rx) for DMA transfers
atmel_spi f0004000.spi: Atmel SPI Controller at 0xf0004000 (irq 18)
atmel_spi f0004000.spi: master is unqueued, this is deprecated
m25p80 spi32766.0: unrecognized JEDEC id ffffff
CAN device driver interface
at91_can f000c000.can: device registered (reg_base=e0888000, irq=20)
at91_can f8010000.can: device registered (reg_base=e088a000, irq=27)
macb f0028000.ethernet (unregistered net_device): invalid hw address, using random
libphy: MACB_mii_bus: probed
macb f0028000.ethernet eth0: Cadence GEM at 0xf0028000 irq 24 (96:d9:d4:60:5a:46)
macb f0028000.ethernet eth0: attached PHY driver [Micrel KSZ9021 Gigabit PHY] (mii_bus:phy_addr=f0028000.etherne:01, irq=-1)
macb f802c000.ethernet (unregistered net_device): invalid hw address, using random
libphy: MACB_mii_bus: probed
macb f802c000.ethernet eth1: Cadence MACB at 0xf802c000 irq 30 (2a:b2:33:8e:32:a4)
macb f802c000.ethernet eth1: attached PHY driver [Micrel KSZ8031] (mii_bus:phy_addr=f802c000.etherne:00, irq=-1)
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
ehci-atmel: EHCI Atmel driver
atmel-ehci 700000.ehci: EHCI Host Controller
atmel-ehci 700000.ehci: new USB bus registered, assigned bus number 1
atmel-ehci 700000.ehci: irq 44, io mem 0x00700000
atmel-ehci 700000.ehci: USB 2.0 started, EHCI 1.00
usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: EHCI Host Controller
usb usb1: Manufacturer: Linux 3.10.0-00354-gdf700c9 ehci_hcd
usb usb1: SerialNumber: 700000.ehci
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 3 ports detected
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
at91_ohci 600000.ohci: AT91 OHCI
at91_ohci 600000.ohci: new USB bus registered, assigned bus number 2
at91_ohci 600000.ohci: irq 44, io mem 0x00600000
usb usb2: New USB device found, idVendor=1d6b, idProduct=0001
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: AT91 OHCI
usb usb2: Manufacturer: Linux 3.10.0-00354-gdf700c9 ohci_hcd
usb usb2: SerialNumber: at91
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 3 ports detected
usbcore: registered new interface driver cdc_acm
cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
usbcore: registered new interface driver usb-storage
usbcore: registered new interface driver usbserial
usbcore: registered new interface driver usbserial_generic
usbserial: USB Serial support registered for generic
usbcore: registered new interface driver ftdi_sio
usbserial: USB Serial support registered for FTDI USB Serial Device
usbcore: registered new interface driver pl2303
usbserial: USB Serial support registered for pl2303
atmel_usba_udc 500000.gadget: MMIO registers at 0xf8030000 mapped at e0898000
atmel_usba_udc 500000.gadget: FIFO at 0x00500000 mapped at e2400000
at91_rtc fffffeb0.rtc: rtc core: registered fffffeb0.rtc as rtc0
at91_rtc fffffeb0.rtc: AT91 Real Time Clock driver.
i2c /dev entries driver
soc-camera-pdrv soc-camera-pdrv.0: Probing soc-camera-pdrv.0
ov2640 1-0030: Product ID error 87:87
soc-camera-pdrv soc-camera-pdrv.1: Probing soc-camera-pdrv.1
ov5642 1-003c: reg_write: i2c write error, reg: 3103
ov5642: probe of 1-003c failed with error -121
leds-gpio leds.3: pins are not configured from the driver
atmel_aes f8038000.aes: version: 0x135
atmel_aes f8038000.aes: Atmel AES - Using dma1chan0, dma1chan1 for DMA transfers
atmel_tdes f803c000.tdes: version: 0x701
atmel_tdes f803c000.tdes: using dma1chan2, dma1chan3 for DMA transfers
atmel_tdes f803c000.tdes: Atmel DES/TDES
atmel_sha f8034000.sha: version: 0x410
atmel_sha f8034000.sha: using dma1chan4 for DMA transfers
atmel_sha f8034000.sha: Atmel SHA1/SHA256/SHA224/SHA384/SHA512
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
iio iio:device0: Resolution used: 12 bits
iio iio:device0: ADC Touch screen is disabled.
wm8904 1-001a: revision A
atmel-wm8904-audio sound.4: setting pck0 to 32768Hz
atmel-wm8904-audio sound.4:  wm8904-hifi <-> f0008000.ssc mapping ok
TCP: cubic registered
NET: Registered protocol family 10
sit: IPv6 over IPv4 tunneling driver
NET: Registered protocol family 17
can: controller area network core (rev 20120528 abi 9)
NET: Registered protocol family 29
can: raw protocol (rev 20120528)
can: broadcast manager protocol (rev 20120528 t)
can: netlink gateway (rev 20130117) max_hops=1
VFP support v0.3: implementor 41 architecture 2 part 30 variant 5 rev 1
UBI: attaching mtd1 to ubi0
UBI: scanning is finished
UBI: attached mtd1 (name "rootfs", size 248 MiB) to ubi0
UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
UBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048
UBI: VID header offset: 2048 (aligned 2048), data offset: 4096
UBI: good PEBs: 1980, bad PEBs: 4, corrupted PEBs: 0
UBI: user volume: 1, internal volumes: 1, max. volumes count: 128
UBI: max/mean erase counter: 2/0, WL threshold: 4096, image sequence number: 107862926
UBI: available PEBs: 0, total reserved PEBs: 1980, PEBs reserved for bad PEB handling: 36
UBI: background thread "ubi_bgt0d" started, PID 552
input: gpio_keys.5 as /devices/gpio_keys.5/input/input0
at91_rtc fffffeb0.rtc: setting system clock to 2007-01-01 04:36:35 UTC (1167626195)
atmel_mci f0000000.mmc: version: 0x505
atmel_mci f0000000.mmc: using dma0chan7 for DMA transfers
atmel_mci f0000000.mmc: Atmel MCI controller at 0xf0000000 irq 17, 1 slots
atmel_mci f8000000.mmc: version: 0x505
atmel_mci f8000000.mmc: using dma1chan5 for DMA transfers
atmel_mci f8000000.mmc: Atmel MCI controller at 0xf8000000 irq 26, 1 slots
ALSA device list:
  #0: wm8904 @ SAMA5D3EK
UBIFS: background thread "ubifs_bgt0_0" started, PID 565
UBIFS: recovery needed
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1189, bit_pos: 3, 0x0f -> 0x07
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 862, bit_pos: 3, 0x58 -> 0x50
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1803, bit_pos: 2, 0x14 -> 0x10
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
UBIFS: recovery completed
UBIFS: mounted UBI device 0, volume 0, name "rootfs"(null)
UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
UBIFS: FS size: 244936704 bytes (233 MiB, 1929 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
UBIFS: reserved for root: 0 bytes (0 KiB)
UBIFS: media format: w4/r0 (latest is w4/r0), UUID 061589C3-4114-491C-8ABD-5A0531BE13BA, small LPT model
VFS: Mounted root (ubifs filesystem) on device 0:11.
devtmpfs: mounted
Freeing unused kernel memory: 164K (c0564000 - c058d000)
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 51, bit_pos: 1, 0x06 -> 0x04
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 51, bit_pos: 1, 0x06 -> 0x04
Starting logging: OK
Populating /dev using udev: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
udevd[580]: starting version 182
done
Starting portmap: done
Initializing random number generator... done.
ALSA: Restoring mixer settings...
Starting network...
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1324, bit_pos: 2, 0x0c -> 0x08
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1665, bit_pos: 0, 0x5b -> 0x5a
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
Starting sshd: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 165, bit_pos: 0, 0x0d -> 0x0c
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1875, bit_pos: 0, 0x17 -> 0x16
OK

Welcome to Buildroot
buildroot login: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
root

官方demo烧录发现并没有lcd的初始化！！
还有debug串口是J14的usb口
烧录非常方便：接上USB-a, 先按cs_boot不放，然后按reset，然后再松开cs_boot 然后就可以使用sam-ba烧录了

demo使用的 是uImage镜像，并非zImage,显然这里的uboot也并不合适，所以需要重新编译uboot！！
先重现编译bootstrap：
	make sama5d3_xplainednf_uboot_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
重新编译uboot：
	git checkout origin/u-boot-2016.03-at91 -b u-boot-2016.03-at91	//选择分支
	make sama5d3_xplained_nandflash_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
然后编译kernel：
	观察到由于预装的demo是使用uImage的，所以，我们也假设使用uImage
	先把uboot的 mkimage 工具，放到 /usr/bin
	make ARCH=arm sama5_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- uImage LOADADDR=0x20008000 -j8
	撒后烧录时，注意要同时替换 dtb 和uImage，不然uImage对应不是同款内核编译出来的dtb时，启动会失败
以上都成功通过，
开始移植lcd！！！
注意，make ARCH=arm sama5_defconfig 后可不用 make ARCH=arm menuconfig 就已经绑入了lcd驱动
但是要配置dts，让lcd的驱动真正挂上系统，
测试过程中，lcd驱动有初始化，但就是没有得到 /dev/fb0
	原来是 dts没有做很好的配置，后来发现lcd的内容写在 sama5d3_lcd.dtsi，sama5d3xdm.dtsi
	所以只要sama535ek.dts里include上述两个文件就行！！
	但是，卡在ubi初始化之前！！
	经过跟踪实际上是，lcd初始化出问题了？？
	主要是背光灯处出现问题： 在dts里关于这个选项
	regulator-name = "backlight-power-supply"; 注释掉的话，系统流畅运行，但是fb0初始化失败，
		而使用这配置时，系统卡在初始化，跳不过去，具体卡在哪个点还不知道！！
		原来是 backlight 初始化出问题了！！！，在dts里取消掉backlight 的项的初始化就可以用！！！
		具体是， 注释掉panel panel：的 backlight = <&backlight>;
		blacklight：blacklight status = "disabled";
		然后就可以初始化出 fb0 了，关于 hlcdc 的dts 又有深的了解！！！
/ {
	ahb {
		apb {
			hlcdc: hlcdc@f0030000 {
				compatible = "atmel,sama5d3-hlcdc";
				reg = <0xf0030000 0x2000>;
				interrupts = <36 IRQ_TYPE_LEVEL_HIGH 0>;
				clocks = <&lcdc_clk>, <&lcdck>, <&clk32k>;
				clock-names = "periph_clk","sys_clk", "slow_clk";
				/* status = "disabled"; */
				status = "okay";

				hlcdc-display-controller {
					compatible = "atmel,hlcdc-display-controller";
					#address-cells = <1>;
					#size-cells = <0>;

					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_lcd_base &pinctrl_lcd_rgb888_alt>;

					port@0 {
						#address-cells = <1>;
						#size-cells = <0>;
						reg = <0>;

						hlcdc_panel_output: endpoint@0 {
							reg = <0>;
							remote-endpoint = <&panel_input>;
						};
					};
				};

				hlcdc_pwm: hlcdc-pwm {
					compatible = "atmel,hlcdc-pwm";
					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_lcd_pwm>;
					#pwm-cells = <3>;
				};
			};

			pinctrl@fffff200 {
				lcd {
					。。。。。。
					pinctrl_lcd_pwm: lcd-pwm-0 {
						atmel,pins = <AT91_PIOA 24 AT91_PERIPH_A AT91_PINCTRL_NONE>;	/* LCDPWM */
					};
					。。。。。。
				};
			};

		};
	};

	backlight: backlight {
		compatible = "pwm-backlight";
		pwms = <&hlcdc_pwm 0 50000 0>;
		brightness-levels = <0 4 8 16 32 64 128 255>;
		default-brightness-level = <6>;
		power-supply = <&bl_reg>;
		/* status = "okay"; */
		status = "disabled";
	};

	bl_reg: backlight_regulator {
		compatible = "regulator-fixed";
		regulator-name = "backlight-power-supply";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		status = "okay";
		/* status = "disabled"; */
	};

	panel: panel {
		compatible = "foxlink,fl500wvr00-a0t", "simple-panel";
		/* backlight = <&backlight>; */
		power-supply = <&panel_reg>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "okay";

		port@0 {
			#address-cells = <1>;
			#size-cells = <0>;

			panel_input: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&hlcdc_panel_output>;
			};
		};
	};

	panel_reg: panel_regulator {
		compatible = "regulator-fixed";
		regulator-name = "panel-power-supply";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		status = "okay";
		/* status = "disabled"; */
	};
};
观察上述节dts： 
	hlcdc 两个节点  hlcdc-display-controller（lcd控制器）  hlcdc_pwm（lcd背光灯控制）
	lcd初始化时，会初始化 hlcdc-display-controller 里的所有内容，包括远程节点 panel_input: endpoint@0的内容，
	而初始化远程节点 panel_input: endpoint@0的内容，前提要先初始化 panel: panel 父节点的内容，
	panel: panel 父节点的内容，包括 backlight: backlight panel_reg: panel_regulator
	而 backlight: backlight 又绕回去 初始化 与hlcdc-display-controller 同级同属节点 hlcdc_pwm 的内容，
	当所有的这些都完成了，hlcdc-display-controller 才真正完成初始化，出现fb0！！
	简单流程图：
	hlcdc-display-controller（start） -> &panel_input -> panel: panel -> &backlight
		-> &hlcdc_pwm(hlcdc_pwm: hlcdc-pwm) -> &panel_reg
		-> hlcdc-display-controller（end）得fb0，
	也就是说 hlcdc_pwm: hlcdc-pwm 本来是另一个同级同属模块来着，但是现在情况是要求先初始化好了，hlcdc-display-controller才算初始好
	注意 由于循序初始化节点，所以 hlcdc: hlcdc 初始化好了，后米娜还会重复初始化 backlight: backlight一遍，不过检测到之前已初始化，所以作罢
	而现在是发现初始化 backlight: backlight 有问题，所以，我们选择初始化 hlcdc-display-controller 期间，不会初始化 backlight: backlight
		所以，我们 注释掉 backlight = <&backlight>; 这项，于是，成功初始化 hlcdc-display-controller
		但是，由于循序初始化节点，所以 hlcdc: hlcdc 初始化好了，后米娜还会重复初始化 backlight: backlight一遍，
		而发现初始化 backlight: backlight 有问题的，所以即使现在 hlcdc-display-controller 已经成功初始化，
		但是内核还是卡死在初始化backlight: backlight上
		所以，我们要把 backlight: backlight 配置 status = "disabled";
		然后，就完美初始化内核和 fb0 了！！！
然而没有背光的lcd 是无法显示的，所以此刻我们要调查背光初始化失败的原因，首先怀疑是 hlcdc-pwm 针被复用了！！！

还有补充`不知道是不是忘记了的知识 发现zImage是位置无关码！！ 放在0x20008000 或 0x22000000 的位置运行都行
还有，为方便调试，在内核的Makefile添加 自动拷贝镜像到指定路径的选项：
	在arch/arm/Makefile：
dtbs: prepare scripts
	$(Q)$(MAKE) $(build)=$(boot)/dts
# by william
	cp $(boot)/dts/sama5d35ek.dtb /home/infortech-ubuntu-1404/SAMA5D35/demo/DemoV1.1/
	在arch/arm/boot/Makefile：
$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
	$(call if_changed,objcopy)
	@$(kecho) '  Kernel: $@ is ready'
# by william
	cp $(obj)/zImage /home/infortech-ubuntu-1404/SAMA5D35/demo/DemoV1.1/












20170407
关于内核，之后几个重点学习驱动系统：
Periodic Interval Timer (PIT)
Power Management Controller (PMC)
Static Memory Controller (SMC)
DMA Controller (DMAC)
USB High Speed Device Port (UDPHS)
USB Host High Speed Port (UHPHS)
Gigabit Ethernet MAC (GMAC)
Ethernet 10/100 MAC (EMAC)
High Speed Multimedia Card Interface (HSMCI)
Synchronous Serial Controller (SSC)

先分析 usb 系统
usb从设备的系统构成
	最底层 udc 驱动（usb device control ）：atmel_usba_udc.c 底层驱动一般厂商做好，自己并不需要处理
	usb从设备的上层驱动（也就是 对应的gadget驱动）了：usb串口，u盘，usb网卡 （负责具体从设备功能内容）
		而这些上层驱动，都通过访问同一个底层驱动实现功能，底层驱动提供给上层驱动的接口
		但是 某一刻只允许 其中只允许一个上层驱动 访问 底层驱动，如果要使用另一个上层驱动，需要把现在的上层驱动注销
		方便上层驱动的开发，上层驱动一般都使用一个统一的 usb上层驱动架构 composite
为了更快理解composite框架的上层驱动的系统 分析，zero.c的内容，这是最简单的 usb上层驱动！！并尝试移植实现

分析 并 实现 zero.c
使用 sama5d35 板子 和 kernel1 的内核进行测试！
通过测试 g_zero 的功能 来 学习开发 usb从设备的上层驱动
为了测试 g_zero pc端也要加载相关的 usb用户驱动 来 实现访问 usb从设备，而我们修改usb_skeleton驱动来作为这个驱动
而 usb_skeleton 就是我们平常说的 usb设备驱动

usb_skeleton 作为 pc端 的模块 （/test/usb_skeleton_and_g_zero）
通过 makefile 生成 usb_skeleton.ko
	make之前,修改usb_skeleton.c 对应宏 与 zero.c里对应的宏一致便于usb识别,
	需要将USB_SKEL_VENDOR_ID 改成 0x0525，USB_SKEL_PRODUCT_ID改成0xa4a0 //注意usb_skeleton 与 g_zero 模块使用相同的 id 不然出错
	注意,make一定要添加 KERNEL_DIR 参数,而且参数指向 pc端的源码库/usr/src/linux-headers-3.19.0-25-generic 	//不然make会出错

编译 g_zero.ko
注意:使用kernel1 执行测试,menuconfig 添加 <M> Gadget Zero  然后重新编译内核
g_zero 是 composize 架构的 gadgst驱动(usb从设备上层),
看源码发现 zero.只是初始化的内容,而真正的功能操作是在另外的c文件上,观察编译log证明这假设:
  CC [M]  drivers/usb/gadget/legacy/zero.o
  CC [M]  drivers/usb/gadget/function/f_loopback.o
  CC [M]  drivers/usb/gadget/function/f_sourcesink.o
  LD [M]  drivers/usb/gadget/legacy/g_zero.o
  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.o
  Building modules, stage 2.
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/zImage is ready
  MODPOST 41 modules
  CC      drivers/usb/gadget/function/usb_f_ss_lb.mod.o
  CC      drivers/usb/gadget/legacy/g_zero.mod.o
  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.ko
  LD [M]  drivers/usb/gadget/legacy/g_zero.ko
估计,要实现完整的 g_zero 需要加载 usb_f_ss_lb.ko 和 g_zero.ko 两个模块

进行测试：
	pc端:
		sudo insmod usb-skeleton.ko	//加载usb-skeleton
		这时:[3747318.188823] usbcore: registered new interface driver skeleton
		但是 /dev 未出现 skel0
	开发板:
		insmod atmel_usba_udc.ko	//底层 udc驱动
		insmod libcomposite.ko		//应用于从设备上层驱动 的composite 框架
		insmod usb_f_ss_lb.ko		//g_zero 的 sourcesink and loopback 具体功能模块
		insmod g_zero.ko  loopdefault=1	//g_zero 的注册函数, 默认使用 loopback 配置
	使用usb线连接 usba 与 pc 
		dmesg_log:
		[3751198.626811] usb 1-11: new high-speed USB device number 16 using xhci_hcd
		[3751198.756060] usb 1-11: New USB device found, idVendor=0525, idProduct=a4a0
		[3751198.756064] usb 1-11: New USB device strings: Mfr=1, Product=2, SerialNumber=3
		[3751198.756066] usb 1-11: Product: Gadget Zero
		[3751198.756068] usb 1-11: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
		[3751198.756069] usb 1-11: SerialNumber: 0123456789.0123456789.0123456789
		[3751198.761383] skeleton 1-11:2.0: USB Skeleton device now attached to USBSkel-0
		这时/dev 也出现 skel0 设备点
	注意 pc端 连接 开发板前 先添加usbtest黑名单，不然出现以下log：
		[3741856.946750] usb 1-11: new high-speed USB device number 10 using xhci_hcd
		[3741857.075341] usb 1-11: New USB device found, idVendor=0525, idProduct=a4a0
		[3741857.075345] usb 1-11: New USB device strings: Mfr=1, Product=2, SerialNumber=3
		[3741857.075348] usb 1-11: Product: Gadget Zero
		[3741857.075350] usb 1-11: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
		[3741857.075351] usb 1-11: SerialNumber: 0123456789.0123456789.0123456789
		[3741857.146253] usbtest 1-11:3.0: Linux gadget zero
		[3741857.146257] usbtest 1-11:3.0: high-speed {control in/out bulk-in bulk-out} tests (+alt)	
			//这条以及以上的都发现和分析接入的usb从设备
		[3741857.146270] usbcore: registered new interface driver usbtest	
			//貌似是主机(host)端关于这个usb从设备的主机部分的驱动  
		pc检测完usb后会自动加载usbtest 这个host端的驱动模块和我们要加载的skeleton冲突，所以需要去掉 usbtest.ko, 
		由于在现版本ubuntu,usbtest.ko融入到内核,而不是以模块存在,所以不能 rmmod usbtest 就杜绝日后不会自动加载
		最好的做法是加入黑名单: 
			sudo echo 'blacklist usbtest' >> /etc/modprobe.d/blacklist.conf		//出错!!
			原来不是/etc/..的权限问题,而是sudo 与 echo 的问题:
			因为重定向符号 “>” 和 ">>" 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限，
			但是没有让 “>” 和 ">>" 命令也具有 root 权限
			方法1:
			echo 'blacklist usbtest' | sudo tee -a /etc/modprobe.d/blacklist.conf
			方法2:
			sudo gedit /etc/modprobe.d/blacklist.conf 然后在最后一行添加 blacklist usbtest
	在pc的terminal上执行测试:
		echo 'helloworld' | sudo tee -a /dev/skel0	//相当于给从设备输入信息
		cat /dev/skel0		//由于默认 loopback 配置,所以g_zero 得到信息后会返回给pc的skeleton,所以应该显示 helloworld 	
	问题:
		基本实现
		但是:cat /dev/skel0 并没有得到预期效果,但是显示大量关于开发板的信息,未知问题根结
通过以上分析：
如果我们要开发一个usb从设备的驱动，其实开发的从设备的上层驱动，是 gadget驱动，是建立在composite架构上的驱动！！
例如 g_zero这个gadget驱动 除去composite框架外，由 usb_f_ss_lb.ko 和 g_zero.ko 组成
由f_loopback.c f_sourcesink.c zero.c共同组成！！

补充：
Peripheral ID 同时也作为 硬件中断号！！









20170412
今天分析 g_zero 的功能实现，
知道 g_zero 由zero.c 和 f_loopback.c 组成，现在挖掘loopback功能
loopback_complete() //这里只把内容递给指定端点ep的传送队列，而底层udc才把ep的队列的内容传送给pc端
		    //同时这里实现了 loopback 的具体操作，把in端点的内容放入out端点队列，把out端点
处理 cat /dev/skel0 无穷消息输出的问题！！
目前知道是 enable_endpoint 的 usb_ep_queue 开始往ep队列输送信息，当信息真正被udc送到pc端后，
就会促发并从loopback_cpmplete()继续usb_ep_queue 往ep队列输送信息
终于弄清楚问题所在：由于 loopback_complete() 存在的代码bug引起！！！（linux-at91-master 这个源码包出现的bug）
	在usb从设备上层驱动上，out-ep（out端点） 指的是 从pc机即host端 往usb从设备输入数据的端点 
			      in-ep（in端点） 指的是 usb从设备 往pc机输出数据的端点
	所以，in 和 out 是以 pc机（host端）为正参照物的，不是以 usb从设备端
	当pc机和开发板都挂好对应的驱动，并用usb线连接好后：
		pc端建立了 skel0 设备节点
		由于 kernel1 的 g_zero模块的代码不完整，loopback功能已经提交了一些杂乱的数据到 in-ep上
		而提交到in-ep的数据会组合打包！！组合打包指，数据会按先后顺序打包
			而且，大数据的request会被分开多个包
			小数据的request会组合成多个包
	然后我们 cat /dev/skel0 时， pc端和开发板端的底层驱动才开始工作，把 in-ep端点队列上的内容传递到 pc机上，终端看到数据
	这时才算完成了数据的传输，然后每个完成传输的request（注意是每个request，不是每个组合打包后的数据包）会触发loopback_complete
	loopback_comple用于对完成了的request的处理，
	而这里出现的bug是，把这个在in-ep完成了的 request 由重新放回 in-ep 队列
	而不是清空请求，所以造成了源源不断的相同消息重新输出！！！
修改：
	对 in-ep 完成了的请求，官方建议应该放入 out-ep 的队列，（会清空内容然后，留下来等待收集输入数据么？）
	对 out-ep 完成了的请求， 是把这个从pc端获得内容的请求重新放入 in-ep 队列，静待时机重新传回到 pc端
	关键源码：
	int			status = req->status;

	switch (status) {
	case 0:				/* normal completion? */
		if (ep == loop->out_ep) {
			req->zero = (req->actual < req->length);
			req->length = req->actual;
			ep = loop->in_ep;

			//by william  when ep == loop->out_ep
			DBG(cdev, "receive message!! \n");
		}
		else {
			ep = loop->out_ep;

			//by william  when ep == loop->in_ep
			DBG(cdev, "send message!! \n");
		}
		status = usb_ep_queue(ep, req, GFP_ATOMIC);
		if (status == 0)
			return;
这样。在pc终端： echo “ helloworld ” >> /dev/skel0 输入内容到开发板
		cat /dev/skel0 读取开发板输出到pc端的内容
关于usb数据传输还有很多奇怪的内容未通透
		例如 关于收取数据的 request 会发送数据的request 的产生，使用和注销等等
		还有 host端的发送数据的request 的内容长度 与 开发板 收取数据的 request 的内容长度不一样的冲突等等！！！
		这些都后续讨论

g_zero重点处理了，下一步，分析usb_skeleton 的结构框架！！！
一般我们讨论的 usb驱动 是 pc端（host端）用来访问usb从设备的接口工具，为了仿混淆，我们称为 host端usb驱动
挂载在 host端usb驱动 和 挂载在 usb从设备的上层驱动 的架构是不一样的，
usb从设备的上层驱动 是基于 composite 架构的，媒介一般是 端点的 request
而 host端usb驱动 并不是基于composite 架构的，媒介一般是 urb








20170413
分析 usb_skeleton 这个 host端usb驱动
1，usb_skeleton模块挂入的函数是，module_usb_driver(skel_driver);然而模块挂入，并没有真正的模块功能挂载到linux上
   只是注册了一些信息到 usb_core 上
2，当 usb 接上 设备，会识别 id.table,匹配好，就执行skel_probe ，然后才是初始化设备等一系列工作，并建立访问的设备节点 /dev/skel0
3，设备操作集：写函数：
   写入/dev/skel0 的一段内容，会先根据内容多少而分别存入多个 user_buffer
   对每个user_buffer都会执行一次skel_write，传递内容
   skel_write 流程：
	检测 /dev/skel0是不是已经被其他操作占用，不是则继续操作
	检测 /dev/skel0是否有错误在身，不是则继续
	分配一个urb 分配一个dma_bufer空间，把user_buffer数据放入
	检测，连接是否断开，不是则继续 （当usb线断开，系统自动执行 skel_disconnect）
	把 dma_buffer 装入urb usb_fill_bulk_urb（把dma_buffer地址加载到urb）
	关联 anchor锚点 和 urb ，方便跟踪urb 不知如何去跟踪使用！具体操作是list_add_tail(&urb->anchor_list, &anchor->urb_list);
	提交urb 
	最后就可以释放urb（注意，提交urb是把整个urb包“复制”到usb_core,所以提交后，这时的urb就没有用了又占大量空间，所以要释放掉）
			（更加注意的是，并不会等usb_core执行了这次提交的urb后，才释放，而是提交了就释放）
   skel_write_bulk_callback:
	当usb_core执行了提交的urb后，就会触发中断执行这个函数
	释放我们在skel_write 分配的dma_buffer 空间
	然而并不没有释放这个被复制到usb_core的urb，可能在skel_write_bulk_callback之外释放吧。
4，设备操作集：读函数：
   当usb连接后，只有当host端发送读数据请求到 usb从设备时，usb从设备才会把数据发向host端
   否则即使，usb从设备 已经主动把数据放到 in-ep 端点队列，usb总线也不会执行数据传输！！
   当 usb连接好，skel0设备节点也就设立了，cat /dev/skel0 也就执行读 skel0设备了的操作了
   注意 cat 打开了skel0后，不是只读一次设备然后显示，而是循环不断，读一次显示一次！！！
   假设当usb从设备 已经主动把数据放到 in-ep 端点队列，cat打开了skel0，开始读设备，开始执行skel_read，
   然而此刻usb线还未开始传输数据，以下分析skel_read：
	检查，设备skel0有没有拥有读入数据的功能，有则继续
		即检查host端驱动初始化时有没有预设了一个 申请从usb从设备获得数据的urb，dev->bulk_in_urb
		这个urb跟host端驱动生命周期相同，即同时存活，这个urb在probe分配得到，
		在disconnect调用的kref_put的skel_delete里释放！！！		
	检查，有没有其他操作占用设备skel0，没有则继续
	设置循环点retry
	检查，IO传输是不是正在执行（即usb总线是不是正在执行数据传输），还没有开始执行，于是继续
	检测 /dev/skel0是否有错误在身，不是则继续
	检查 skel0 有没有收到数据， usb总线还未曾执行数据传输，所以没有，于是继续
	执行 skel_do_read_io 即提交 获得usb从设备到host端数据 的urb，如果没有出错（这时usb总线才开始执行数据传输）
	然后跳回循环点retry执行
	检查，IO传输是不是正在执行（即usb总线是不是正在执行数据传输），这时正在执行
		检查skel0是不是阻塞设备，如果是，就结束skel_read,不再困在这个函数里，就是一时间读不到数据，但结束不在读。
		如果不是阻塞设备，就开始wait_event_interruptible 开始睡眠进程，直到时间到，或者被中断
	睡眠后，
	检测 是否有错误在身，不是则继续
	检查 skel0 有没有收到数据， 假如已经有！！
	检查available，由于是第一次循环读数据，而不是多次后，所以没有到数据末尾，所以是available。
	于是把dev->bulk_in_buffer + dev->bulk_in_copied地址的内容拷到 user 的 buffer
	最后，如果这时，我想读出count数据量，大于，我们实际收到的，我们会 再次skel_do_read_io，
	但不打算等待下次 usb从设备发来的数据，带着我们已经读到的数据，直接离开函数，
   skel_read()读函数比较麻烦，但是还是遵从一个规则，就是，他提交了读取数据的urb后，usb总线才开始传输数据！！！
   skel_read_bulk_callback：
	当 usb_core 执行好读取数据的urb后，即执行了 skel_do_read_io 提交的urb后
	数据已经从usb从设备处传到host端后，触发中断执行
	并没有特别操作 
5，其他操作函数：
	skel_open：打开设备节点
	skel_release：关闭设备节点，注意这执行了kref_put(&dev->kref, skel_delete)，但是kref并没有到0，所以不执行skel_delete
	skel_flush： flush一般是把内存的内容刷入硬盘的操作，而这里函数里只是完成并停止 usb总线的传输
		    （通知usb_core,通过删除未处理urb，或完成正在处理的urb），并不知道是为什么情况存在，
6，skelton驱动函数集，（与/dev设备点的函数集是不一样的）
	skel_probe： 如上述，
	skel_disconnect： 当人为或意外断开了usb总线连接，就会触发的卸载 skel0设备的函数
	skel_suspend： 完成并尽快停止 usb总线的传输，（通知usb_core,通过删除未处理urb，或完成正在处理的urb）
	skel_resume： 并无操作， 因为暂停skel只是处理urb，并不是从硬件或时钟处暂停usb，所以resume并不会有什么操作
	skel_pre_reset： 相当于skel_suspend pre_reset表示设备复位前做的工作
	skel_post_reset：重置error发flag post_reset表示设备复位后做的工作

（补充）linux 的常见api学习：
spin_lock的调用关系
	spin_lock
		-> raw_spin_lock
			-> _raw_spin_lock
				-> __raw_spin_lock
					->>preempt_disable();  
  					-spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);  
					->LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
spin_lock_irq的调用关系
	spin_lock_irq
		-> raw_spin_lock_irq
			-> _raw_spin_lock_irq
				-> __raw_spin_lock_irq
					->local_irq_disable();  
					->preempt_disable();  
					->spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);  
					->LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
spin_lock 是上spin锁，而spin_lock_irq是上spin锁前先禁止linux中断
usb_alloc_coherent：分配dma 缓存空间给urb存放要传输的内容
usb_anchor_urb：关联 anchor锚点 和 urb ，方便跟踪urb 不知如何去跟踪使用！
wait_event_interruptible（）：暂时睡眠进程，然后得到中断后再重新执行进程
usb_alloc_urb 和 usb_free_urb 是对立，一个是分配一个空间给urb，一个是释放占用的空间
kerf模块：
	kerf是镶嵌在模块里记录模块生命周期的计数器，
	probe 模块时，一般初始化一个kref计数器：kref_init设1，或 kref_set设一个自定义值
	在模块操作时会使用 kref_get kref_put 来记录生命周期变化情况
	例如，open一个设备，kref_get 加1，release一个设备，kref_put 减1，
	当模块出错，或者退出模块，或者意外断开，执行处理函数也要执行kref_put,继续减1，此刻计数器一般回到0，
	当计数器回到0时，就执行kref_put绑定的 自定义的处理函数来释放空间，删除初始化，删除模块
	










20170414
显然 usb_skelton是主机端usb系统 里的一个上层驱动，提供与再上一层的用户程序的接口，也通过usb系统提供的接口与usb主机控制器交互！！
主机端的usb驱动实际的构成如下
	上层驱动（具体功能驱动） --> usb_core服务架构 -->底层驱动（usb主机控制器驱动）
	上层驱动：如我们研究的 usb_skelton，是关于访问一个 usb从设备的驱动，通过usb_core服务架构最终控制主机控制器的数据传输达到访问目的
	usb_core服务架构: 源码/drivers/usb/core/×
	底层驱动： 例如ehci（usb2.0）的控制器驱动：ehci_atmel_hc_driver.c ehci_hcd.c
hcd（host control driver）：
	usb_core服务里关于主机控制器的操作是 hcd.c
	而ehci_atmel_hc_driver.c 是一个具体的底层hcd驱动，只提取特征初始化了一个通用的hcd控制器，指定了硬件寄存器指定访问地址
	而ehci_hcd.c 提供通用的hcd控制器，访问硬件寄存器，从而实现对主机控制器的访问
关于usb的大概框架已经了解，而详细细节需要看书补充

usb-core服务框架：
/drivers/usb/core/usb.c是服务框架初始化的开始
/drivers/usb/core/driver.c用作匹配 usb设备，和设备驱动的，匹配成功就会probe初始化设备驱动 
USB四大描述符：设备描述符，配置描述符，接口描述符，端点描述符
usb协议上说的接口interface 即是代表一个功能，例如一个usb从设备，扬声器是一个功能，u盘是一个功能，摄像头是一个功能
	而这些功能在linux系统上看来，这个扬声器属于声音这类主设备，的一个次设备，其他同理推
usb协议上说的配置configure 即是代表被激活可使用的一组功能，例如一个usb从设备，扬声器和u盘同时使用属于一个配置，
	摄像头与键盘与扬声器能同时使用是另一个配置















20170417
python 学习！！ 详见kingders/home/python_study
进入python命令行界面 $ python3.4

脚本编写：
#! /usr/bin/python3.4	//开头一定要表明翻译器
# -*- coding:UTF-8 -*-	//指定了使用 UTF-8 编码
在脚本里 if语法的执行句可以使用tab间隔，也可以多个空格间隔，在命令行界面上，只能用空格

开启翻译器时，先执行预执行脚本
命令行模式下得知放置预执行脚本位置：
	>>> import site
	>>> site. getusersitepackages ()
	'/home/kingders/.local/lib/python3.4/site-packages'
然后在/home/kingders/.local/lib/python3.4/site-packages目录下创建名为usercustomize.py 的文件
把预执行的内容加入到这个脚本文件里即可
下次开启翻译器时，先执行预执行脚本

python数值 与 数学运算 注意点：
>>> # 整 数 相 除 返 回 地 板 数 :此外“#”是注释符
... 7//3
2
>>> 7//-3
-3
>>> 8/5 # 整 数 相 除 时 并 不 会 丢 失 小 数 部 分 此外“#注释段”可与代码段同行
1.6
等号 ( '=' ) 用于把一个值分配给一个变量
>>> width = 20
>>> height = 5*9
>>> width * height
900
变量在使用之前必须要被“定义”(分配一个值), 否则会产生一个错误
>>>  n
Traceback (most recent call last):
File "<stdin >", line 1, in < module >
NameError : name 'n' is not defined
支持复数，虚数部分使用符号j
>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5
>>> abs(a)  # 求出虚数的模
1.5811388300841898

python 字符 字符串注意点：

单双引号标出字符串变量
>>> 'kj\"'  
'kj"'
>>> "kj\""
'kj"'

字符串变量赋值还有 \ 的应用，换行时代表逻辑延续，不换行时代表表示特殊符号
>>> hello = "我爱你\n\
... kjkjikjii你\
... 你好吗"
>>> print(hello)
我爱你
kjkjikjii你你好吗

三对双引号，可以简单初始化一个充满各种特殊符号的字符串
>>> hello = """ haha\
... 你是谁
... 我不知道      {真的}
... """
>>> print(hello)
 haha你是谁
我不知道      {真的}

字符串的加乘操作，没有减除法
>>> a ="iam"
>>> b ='kkk'
>>> c = a + b
>>> print(c)
iamkkk
>>> d = 4*a + b
>>> print(d)
iamiamiamiamkkk

字符自动粘连
>>> 'str ' 'ing '
'string '
>>> 'str '.strip() + 'ing '
'string '

字符串切片
>>> w = "abcdef"
>>> w[-6]
'a'
>>> w[2]
'c'
>>> w[0:2]
'ab'
>>> w[1:2]
'b'
>>> w[1:3]
'bc'
>>> w[0:]
'abcdef'
>>> w[1:]
'bcdef'
>>> w[2:2]
''
>>> w[-1:]
'f'
>>> w[-6:]
'abcdef'
>>> w[-6:3]
'abc'
>>> w[-6:-4]
'ab'
>>> 
理解图
+---+---+---+---+---+---+
| a | b | c | d | e | f |
+---+---+---+---+---+---+
0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1

字符串长度
>>> s = 'supercalifragilisticexpialidocious '
>>> len(s)
34

字符串数组，及其切片，长度
>>> a = ['spam ', 'eggs ', 100 , 1234]
>>> a
['spam ', 'eggs ', 100 , 1234]
>>> a[0]
'spam '
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs ', 100]
>>> a[:2] + ['bacon ', 2*2]
['spam ', 'eggs ', 'bacon ', 4]
>>> 3*a[:3] + ['Boo!']
['spam ', 'eggs ', 100 , 'spam ', 'eggs ', 100 , 'spam ', 'eggs ',
100 , 'Boo!']
>>> a[:]	#浅复制
['spam ', 'eggs ', 100 , 1234]
>>> a
['spam ', 'eggs ', 100 , 1234]
>>> a[2] = a[2] + 23
>>> a
['spam ', 'eggs ', 123 , 1234]
>>> # 替 代 一 些 项 :
... a[0:2] = [1, 12]
>>> a
[1, 12 , 123 , 1234]
>>> # 移 除 一 些 :
... a[0:2] = []
>>> a
[123 , 1234]
>>> # 插 入 一 些 :
... a[1:1] = ['bletch ', 'xyzzy ']
>>> a
[123 , 'bletch ', 'xyzzy ', 1234]
>>> # 在 开 始 处 插 入 自 身 ( 的 一 个 拷 贝 )
>>> a[:0] = a
>>> a
[123 , 'bletch ', 'xyzzy ', 1234 , 123 , 'bletch ', 'xyzzy ', 1234]
>>> # 清 除 列 表 : 用 空 列 表 替 代 所 有 的 项
>>> a[:] = []
>>> a
[]
>>> a = ['a', 'b', 'c', 'd']
>>> len(a)
4

嵌套列表
>>> q = [2, 3]
>>> p = [1, q, 4]
>>> len(p)
3
>>> p[1]
[2,3]
>>> p[1][0]
2
>>> p[1]. append ('xtra ')
>>> p
[1, [2, 3, 'xtra '], 4]
>>> q
[2, 3, 'xtra ']

多重赋值 (注意第二段赋值，先算a=b，但b=a+b时的a依然是1)
>>> a, b = 1, 2
>>> a, b = b, a+b
>>> a
2
>>> b
3

特别注意python的数据结构 元祖 列表 集合与字典的区别
元祖一般与()有关
列表一般与[]有关
字典一般与:有关
集合一般与{}有关
关于这些数据结构的内容日后再讨论

现在讨论函数包与函数模块的内容
导入模块/包：
inport ddd
from xxx import ×	//与 xxx 包里的__init__.py的 __all__ 参数一并使用，把__all__的指向的模块/子包全导入

文件操作集
>>> f = open('/home/kingders/python_study/test','r')	//打开文件，赋予读权限
>>> f.read()			//读出所有内容
'i am boy\nyou are girl\nlet marry \n'
>>> f.read()			//接着上次内容指针继续读，然而已经到文件结尾，并没有什么可以读出
''
>>> f = open('/home/kingders/python_study/test','r')	//重新打开文件，赋予读权限，所有状态复位
>>> f.readline()	//读出第一行内容
'i am boy\n'
>>> f.readline()	//读出第二行内容
'you are girl\n'
>>> f.readline()	//读出第三行内容
'let marry \n'
>>> f.readline()	//读出第四行内容，然而并没有内容了
''
>>> f = open('/home/kingders/python_study/test','r')	//重新打开文件，赋予读权限，所有状态复位
>>> f.readlines()	//分别读出所有行的内容并打印
['i am boy\n', 'you are girl\n', 'let marry \n']
>>> f.close()		//关闭文件
此外不不细说的内容有：
	open r读权限 w写权限 r+读写权限 a末尾追加写权限 b以binary mode 打开文件，可组合rb，wb，ab，rb+ 默认不填权限为读权限
	f.write()		//写文件
	f.seek()		//文件寻位置
	还有pickle模块：方便把python各种数据结构变量 与 字符串 的相互转换，方便把数据写到文件里，和从文件里取出数据来处理

异常发生剂处理，一般使用 try和expect组合
>>> while True:
...    try:
...        x = int(input (" Please ␣ enter ␣a␣ number :␣"))
...        break
...    except ValueError :
...        print ("Oops!  That was no valid number.  Try again ...")
先执行try段，正常运行时，不跑except段，当出现异常时，判断是不是except段指明的异常再执行expect段
还有一个 try，expect，final组合，不管是否有异常，try段后都会执行final段的内容

域和命名空间例子
>>>def scope_test ():
...    def do_local ():
...        spam = " local ␣spam"
...    def do_nonlocal ():
...        nonlocal spam
...        spam = " nonlocal ␣spam"
...    def do_global ():
...        global spam
...        spam = " global ␣spam"
...
...    spam = "test␣spam"
...    do_local ()
...    print(" After ␣ local ␣ assignment :", spam)
...    do_nonlocal ()
...    print(" After ␣ nonlocal ␣ assignment :", spam)
...    do_global ()
...    print(" After ␣ global ␣ assignment :", spam)
...
>>>scope_test ()
>>>print("In␣ global ␣ scope :", spam)
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
这里同名spam应该有4个，但是分贝属于不同空间，而且优先权也不一样
def 是定义内容的句柄，这里就定义了4个函数，而且出现的镶嵌定义的情况

类
>>> class Complex :
...    def __init__ (self , realpart , imagpart ):
...    self.r = realpart
...    self.i = imagpart
...
>>> x = Complex (3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
这是一个典型的类例子！！！上述关于类的初始化，特别注意，self指一个类变量他自己本身

关于python编程已经入门书了一遍，更多细节通过实践细节掌握！！

附加1：快速寻找文件路径命令which，例如： which python3.4
附加2：python的函数api
input（“please enter ”）	//输入内容函数，双括号只是显示出来的作为提示字符串，双括号的内容不计入为输入的内容
				//输入的内容纯记做为字符串
int（f）	//把检查f变量，如果是纯数字字符串，就转变为对应的数字变量，
		//如果是数字变量，变成是正整数数字变量

附加3：关于计算机的小数，浮点问题
计算机里小数是浮点数据表示，但是根据 IEEE-754估计标准和硬件结构，浮点是以二进制形式表示的，而精度只有53位（二进制的精度）
这么说 0.1 在计算机里的存在就不是完全的0.1，只能是近似的0.1！！
0.1 = 1/10 ～= J / 2^N
最近似的结果就是 7205759403792794 / 2^56
j为7205759403792794，N为56
做一个实验：
>>> a = 0.1+0.1+0.1
>>> a
0.30000000000000004
由于0.1在计算机上不能是完全的 0.1，只是近似值，所以3个连加也得不到真正的0.3！只能是有偏差的0.3！！！











20170418
bash学习：

引号内内容不被解释器解释

注意使用正则表达式

注意数组和数组字符串的操作

case用法，类似c语言的switch
case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*	) bail_out;;
esac

函数 函数的参数 声明 和 include 有待深究
function function_name {
command...
}
或
function_name () {
command...
}
参数直接在函数里使用以$1,$2,$3代表，并不需要在函数名开头就声明



附加1：
shell控制符
Ctl-B	光标后退,这应该依赖于 bash 输入的风格,默认是 emacs 风格的.
Ctl-C	Break,终止前台工作.
Ctl-D	从当前 shell 登出(和 exit 很像)
	"EOF"(文件结束符).这也能从 stdin 中终止输入.
	在 console 或者在 xterm window 中输入的时候,Ctl-D 将删除光标下字符.
	当没有字符时,Ctrl-D 将退出当前会话.在 xterm window 也有关闭窗口的效果.
Ctl-G	beep.在一些老的终端,将响铃.
Ctl-H	backspace,删除光标前边的字符.
Ctl-I	就是 tab 键.
Ctl-J	新行.
Ctl-K	垂直 tab.(垂直 tab?新颖,没听过)
	作用就是删除光标到行尾的字符
Ctl-L	clear,清屏.
Ctl-M	回车
Ctl-Q	继续(等价于 XON 字符),这个继续的标准输入在一个终端里
Ctl-S	挂起(等价于 XOFF 字符),这个被挂起的 stdin 在一个终端里,用 Ctl-Q 恢复
Ctl-U	删除光标到行首的所有字符,在某些设置下,删除全行.
Ctl-V	当输入字符时,Ctl-V 允许插入控制字符.比如,下边 2 个例子是等价的
	echo -e '\x0a'
	echo <Ctl-V><Ctl-J>
Ctl-V 在文本编辑器中十分有用,在 vim 中一样.
Ctl-W	删除当前光标到前边的最近一个空格之间的字符.
	在某些设置下,删除到第一个非字母或数字的字符.
Ctl-Z	终止前台工作.
附加2：
转义字符
\n	意味着新的一行
\r	回车
\t	tab 键
\v	vertical tab(垂直 tab),查前边的 Ctl-K
\b	backspace,查前边的 Ctl-H
\a	"alert"(如 beep 或 flash)
\0xx 转换成 8 进制 ASCII 解码,等价于 oxx










20170423
学习 mysql 数据库：
ubuntu 部署 mysql：（以下自家pc部署实践，不是公司机子部署）
sudo apt-get install mysql-server 
	//安装 mysql 服务器程序 会提示设置root 用户的 密码，我设为 3***************7
	//可能提示404  Not Found 错误，更新软件库：sudo apt-get update
	//过程中其实安装了以下包了：
		mysql-common all 5.5.54-0ubuntu0.14.04.1 [13.0 kB]
		mysql-client-core-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [709 kB]
		mysql-client-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [1,603 kB]
		mysql-server-core-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [3,763 kB]
		mysql-server-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [1,849 kB]
		mysql-server all 5.5.54-0ubuntu0.14.04.1 [11.3 kB]
	//新版此命令也安装了 mysql-client，
	//所以不用再 sudo apt-get isntall mysql-client，否则出错：E: Invalid operation isntall
sudo apt-get install libmysqlclient-dev 
	//安装 第三方软件 调用 mysql客户端 的接口库，有以下包：
		libmysqlclient18 amd64 5.5.54-0ubuntu0.14.04.1 [597 kB]
		libmysqlclient-dev amd64 5.5.54-0ubuntu0.14.04.1 [869 kB]
sudo netstat -tap | grep mysql
	//安装完后，此命令检查 server是否安装成功并开启：（出现listen，表示成功并开启，安装成功后默认开启）
tcp        0      0 localhost:mysql         *:*                     LISTEN      10611/mysqld 
sudo service mysql stop		//关闭mysql服务：一定要加sudo，否则出错：stop: Unknown job: mysql
sudo service mysql start	//打开mysql服务：一定要加sudo，否则出错：start: Unknown job: mysql
sudo service mysql restart	//重启mysql服务：一定要加sudo，否则出错
mysql -u root -p 	
	//还有一个参数是 -h xxx 表示数据库服务器所在主机名，这里由于与客户端登陆程序同在一个机子，即访问本地机子的数据库，可忽略	
	//登陆mysql数据库，-u 表示数据库开放给的用户对象的用户名， -p 表示登陆的用户密码，上面命令输入之后会提示输入密码
	//注意，登陆命令是打开了client端，通过客户端与后台运行的服务端交互
	//而操作人员直接与客户端的命令行界面交互	
登陆mysql数据库，进入命令行交互后：	
mysql>		//是这样的，每条命令结尾都要加；号，才表示执行一条完整命令
至此，基础部署完成，
执行 show databases; 查看当前构建了的数据库

mysql客户端快捷键：
Up 箭头,Ctrl-p 		调前面的行
Down 箭头,Ctrl-N 	调下一行
Left 箭头,Ctrl-B 	光标左移(向后)
Right 箭头,Ctrl-F	光标右移(向前)
Escape Ctrl-B 		向后移一个词
Escape Ctrl-F 		向前移一个词
Ctrl-A 			将光标移到行头
Ctrl-E 			将光标移到行尾
Ctrl-D 			删除光标下的字符
Delete 			删除光标左边的字符
Escape D 		删词
Escape Backspace 	删除光标左边的词
Ctrl-K 			删除光标到行尾的所有字符
Ctrl-_ 			撤消最后的更改;可以重复

mysql客户端批处理：
导入命令脚本实行批处理，
mysql -u root -p < file1	//执行 file1 批处理命令文件
导入命令脚本实行批处理，并把处理log输出到一个文本里记录下来
	-u root -p < file1 > file2	//把操作log输出到file2文件里记录下来

mysql客户端重要命令集：
show databases like ‘my%’;	//列出名称包含关字 my 的数据库
show databases;			//显示服务器里已经存在的数据库
create database xxx;		//创建数据库 xxx
drop database xxx;		//删除数据库
CREATE TABLE xxx.xxx1(id int, name TEXT);	//给xxx 创建一个表单xxx1
use xxx；			//转到 xxx 数据库
CREATE TABLE xxx2(sex TEXT, age int);		//同样给 xxx 创建一个表单xxx2 由于之前使用了use xxx；命令，所以不用指定数据库
insert into xxx1 values(1,"janice_vidal");	//给表 插入一条 完整数据内容，由于之前使用了use xxx；而不用指定数据库
insert into xxx.xxx1 values(2,"wingkidng_wong"),(3,"heddi_lee");//插入多条完整数据内容的做法，假如之前没有使用use xxx；要指定数据库
insert into xxx.xxx1(name) values("gem0816"),("dilirba");	//插入部分数据内容，列表中未给出名称的列都将赋予缺省值
select* from xxx.xxx1;		//查看xxx1数据表内容，显示内容例子如下：
				//+------+----------------+
				//| id   | name           |
				//+------+----------------+
				//|    1 | janice_vidal   |
				//|    2 | wingkidng_wong |
				//|    3 | heddi_lee      |
				//| NULL | gem0816        |
				//| NULL | dilirba        |
				//+------+----------------+
				//5 rows in set (0.00 sec)
select* from xxx.xxx1 where name="janice_vidal";	//查看特定行，显示内容例子如下：
							//+------+--------------+
							//| id   | name         |
							//+------+--------------+
							//|    1 | janice_vidal |
							//+------+--------------+
							//1 row in set (0.00 sec)
select name from xxx.xxx1;	//查看特定列，显示例子如下 
				//+----------------+
				//| name           |
				//+----------------+
				//| janice_vidal   |
				//| wingkidng_wong |
				//| heddi_lee      |
				//| gem0816        |
				//| dilirba        |
				//+----------------+
				//5 rows in set (0.00 sec)
				//（注意同时查看多列的格式示范，假如我们也建立了这些列，譬如：select name，birth，sex from xxx.xxx1;)	
select name from xxx.xxx1 where id=1;		//查看有筛选条件的特定列内容 显示例子如下
						//+--------------+
						//| name         |
						//+--------------+
						//| janice_vidal |
						//+--------------+
						//1 row in set (0.00 sec)
delete from xxx.xxx1				//删除xxx1表里的全部数据内容
delete from xxx.xxx1 from name=“gem0816”	//删除xxx1表里的某条（即某列）数据内容
alter table xxx1 add column money int;		//给数据表添加一列属性 columns（列项） money是这属性的名字，int是数据格式
						//mysql> select* from xxx1;
						//+----------------+------+-------+
						//| name           | id   | money |
						//+----------------+------+-------+
						//| janice_vidal   |    1 |  NULL |
						//| wingkidng_wong |    2 |  NULL |
						//| heddi_lee      |    3 |  NULL |
						//| gem0816        | NULL |  NULL |
						//| dilirba        | NULL |  NULL |
						//| a              |   41 |  NULL |
						//| b              |   20 |  NULL |
						//| c              |    6 |  NULL |
						//+----------------+------+-------+
						//8 rows in set (0.00 sec)
						//alter table xxx1 drop money;  删除一列属性及储存的数据内容
update xxx1 set id=39,money=1000 where name="wingkidng_wong";	//修改 数据表的 其中一条数据内容
								//mysql> select* from xxx1;
								//+----------------+------+-------+
								//| name           | id   | money |
								//+----------------+------+-------+
								//| janice_vidal   |    1 |  NULL |
								//| wingkidng_wong |   39 |  1000 |
								//| heddi_lee      |    3 |  NULL |
								//| gem0816        | NULL |  NULL |
								//| dilirba        | NULL |  NULL |
								//| a              |   41 |  NULL |
								//| b              |   20 |  NULL |
								//| c              |    6 |  NULL |
								//+----------------+------+-------+
								//8 rows in set (0.00 sec)
关于索引的功能探索，以及与数据表的关系：
alter table xxx.xxx1 add index(id)；	//添加一条索引信息（key）到 默认索引文件里
show keys from xxx1;			//显示添加的索引信息（key）
show index from xxx1;			//显示默认索引文件内容，
alter table xxx1 drop index id;		//删除添加了的 索引信息（key）：id
关于索引与数据表数据检索的操作与关系，理解后详细补充

以下是未细致认证的典型命令实例
mysql> CREATE TABLE pet1
    -> SELECT name AS animal,owner AS child
    -> FROM pet;	//把pet数据表的 name 和 owner 两列数据内容，拷到新建的数据表 pet1 的animal 和 child 列去

终端命令集：
mysql -u root -p 		//客户端登陆到服务器，并转到mysql客户端命令行终端 ，要按提示输入访问用户root的密码
mysqlshow -u root -p xxx	//显示本地数据库服务器上的 xxx 数据库，要按提示输入访问用户root的密码

mysql数据库知识
数据库里的每个数据表都是由三个文件组成一个格式(描述)文件.frm、一个数据文件.ISD/.MYD 和 一个索引文件.ISD/.MYI










20170424
python3.4 访问 mysql
安装链接库包;
1，mysql官网的 mysql-connector
先到mysql官网下载 python插件包：mysql-connector-python-cext-py3_2.1.6-1ubuntu14.04_amd64.deb
https://dev.mysql.com/downloads/connector/python/
针对ubuntu14.04 x64 使用deb软件包
成功安装针对python3的包，使用失败，在python3.4的命令行交互端里输入：import mysql.connector，出错：
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named 'mysql'
成功安装针对python2的包，使用失败，在python2.7的命令行交互端里输入：import mysql.connector，出错：
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named mysql.connector
2，MySQLdb
网上也说 这个第三方包不支持python3
3，PyMySQL ptyhon官方推荐的python3 的mysql接口
下载源码： https://github.com/PyMySQL/PyMySQL
解压安装，安装时一定要转到root用户安装
root@kingders-ThinkPad-T420:/home/kingders/smart210/study/python_study/thirdpart_pack/PyMySQL/PyMySQL-master# python3 setup.py install
running install
Checking .pth file support in /usr/local/lib/python3.4/dist-packages/
/usr/bin/python3 -E -c pass
TEST PASSED: /usr/local/lib/python3.4/dist-packages/ appears to support .pth files
running bdist_egg
running egg_info
creating PyMySQL.egg-info
writing PyMySQL.egg-info/PKG-INFO
writing dependency_links to PyMySQL.egg-info/dependency_links.txt
writing top-level names to PyMySQL.egg-info/top_level.txt
writing manifest file 'PyMySQL.egg-info/SOURCES.txt'
reading manifest file 'PyMySQL.egg-info/SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'PyMySQL.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_py
creating build
creating build/lib
creating build/lib/pymysql
copying pymysql/cursors.py -> build/lib/pymysql
copying pymysql/charset.py -> build/lib/pymysql
copying pymysql/connections.py -> build/lib/pymysql
copying pymysql/optionfile.py -> build/lib/pymysql
copying pymysql/times.py -> build/lib/pymysql
copying pymysql/err.py -> build/lib/pymysql
copying pymysql/__init__.py -> build/lib/pymysql
copying pymysql/_socketio.py -> build/lib/pymysql
copying pymysql/_compat.py -> build/lib/pymysql
copying pymysql/converters.py -> build/lib/pymysql
copying pymysql/util.py -> build/lib/pymysql
creating build/lib/pymysql/tests
copying pymysql/tests/test_issues.py -> build/lib/pymysql/tests
copying pymysql/tests/test_connection.py -> build/lib/pymysql/tests
copying pymysql/tests/test_DictCursor.py -> build/lib/pymysql/tests
copying pymysql/tests/test_optionfile.py -> build/lib/pymysql/tests
copying pymysql/tests/test_nextset.py -> build/lib/pymysql/tests
copying pymysql/tests/test_load_local.py -> build/lib/pymysql/tests
copying pymysql/tests/test_err.py -> build/lib/pymysql/tests
copying pymysql/tests/test_converters.py -> build/lib/pymysql/tests
copying pymysql/tests/test_SSCursor.py -> build/lib/pymysql/tests
copying pymysql/tests/base.py -> build/lib/pymysql/tests
copying pymysql/tests/__init__.py -> build/lib/pymysql/tests
copying pymysql/tests/test_cursor.py -> build/lib/pymysql/tests
copying pymysql/tests/test_basic.py -> build/lib/pymysql/tests
creating build/lib/pymysql/constants
copying pymysql/constants/SERVER_STATUS.py -> build/lib/pymysql/constants
copying pymysql/constants/ER.py -> build/lib/pymysql/constants
copying pymysql/constants/CR.py -> build/lib/pymysql/constants
copying pymysql/constants/FIELD_TYPE.py -> build/lib/pymysql/constants
copying pymysql/constants/__init__.py -> build/lib/pymysql/constants
copying pymysql/constants/FLAG.py -> build/lib/pymysql/constants
copying pymysql/constants/COMMAND.py -> build/lib/pymysql/constants
copying pymysql/constants/CLIENT.py -> build/lib/pymysql/constants
creating build/lib/pymysql/tests/thirdparty
copying pymysql/tests/thirdparty/__init__.py -> build/lib/pymysql/tests/thirdparty
creating build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/capabilities.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/__init__.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/egg
creating build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/cursors.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/charset.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/connections.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/optionfile.py -> build/bdist.linux-x86_64/egg/pymysql
creating build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_issues.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_connection.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_DictCursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_optionfile.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_nextset.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_load_local.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_err.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_converters.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_SSCursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/base.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_cursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_basic.py -> build/bdist.linux-x86_64/egg/pymysql/tests
creating build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty
creating build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/capabilities.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty
creating build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/SERVER_STATUS.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/ER.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/CR.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/FIELD_TYPE.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/FLAG.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/COMMAND.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/CLIENT.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/times.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/err.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/__init__.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/_socketio.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/_compat.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/converters.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/util.py -> build/bdist.linux-x86_64/egg/pymysql
byte-compiling build/bdist.linux-x86_64/egg/pymysql/cursors.py to cursors.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/charset.py to charset.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/connections.py to connections.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/optionfile.py to optionfile.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_issues.py to test_issues.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_connection.py to test_connection.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_DictCursor.py to test_DictCursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_optionfile.py to test_optionfile.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_nextset.py to test_nextset.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_load_local.py to test_load_local.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_err.py to test_err.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_converters.py to test_converters.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_SSCursor.py to test_SSCursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/base.py to base.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_cursor.py to test_cursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_basic.py to test_basic.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py to dbapi20.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py to test_MySQLdb_nonstandard.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/capabilities.py to capabilities.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py to test_MySQLdb_dbapi20.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py to test_MySQLdb_capabilities.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/SERVER_STATUS.py to SERVER_STATUS.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/ER.py to ER.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/CR.py to CR.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/FIELD_TYPE.py to FIELD_TYPE.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/FLAG.py to FLAG.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/COMMAND.py to COMMAND.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/CLIENT.py to CLIENT.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/times.py to times.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/err.py to err.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/_socketio.py to _socketio.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/_compat.py to _compat.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/converters.py to converters.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/util.py to util.cpython-34.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
zip_safe flag not set; analyzing archive contents...
pymysql.tests.__pycache__.base.cpython-34: module references __file__
pymysql.tests.__pycache__.test_load_local.cpython-34: module references __file__
creating dist
creating 'dist/PyMySQL-0.7.11-py3.4.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing PyMySQL-0.7.11-py3.4.egg
creating /usr/local/lib/python3.4/dist-packages/PyMySQL-0.7.11-py3.4.egg
Extracting PyMySQL-0.7.11-py3.4.egg to /usr/local/lib/python3.4/dist-packages
Adding PyMySQL 0.7.11 to easy-install.pth file

Installed /usr/local/lib/python3.4/dist-packages/PyMySQL-0.7.11-py3.4.egg
Processing dependencies for PyMySQL==0.7.11
Finished processing dependencies for PyMySQL==0.7.11
成功安装，python3.4交互界面输入：import pymysql.cursors 成功使用
详细的api使用介绍和例子在 github 下载页有！！












20170425
python爬虫学习：
简单扒下百度例子：
import urllib2
response = urllib2.urlopen("http://www.baidu.com")	//urlopen的函数完整格式 urlopen(url, data, timeout)
print response.read()		//显示扒下所有内容 即网页的所有内容
print response			//显示内容的属性，显示如下：
				//<addinfourl at 139764017715104 whose fp = <socket._fileobject object at 0x7f1d5b1a2bd0>>
也可以这样
import urllib2
request = urllib2.Request("http://www.baidu.com")	//实际操作中修改request参数比，一次次修改urlopen里的内容有效率多
response = urllib2.urlopen(request)	
print response.read()

post方式例子：给网站输入用户名和密码然后的骚登陆后数据的例子
import urllib
import urllib2
values = {"username":"1016903103@qq.com","password":"XXXX"}
data = urllib.urlencode(values) 
url = "https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()
也可以这样
import urllib
import urllib2
values = {}
values['username'] = "1016903103@qq.com"
values['password'] = "XXXX"
data = urllib.urlencode(values) 
url = "http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()

get方式例子：同样给网站输入用户名和密码然后的骚登陆后数据的例子
import urllib
import urllib2
values={}
values['username'] = "1016903103@qq.com"
values['password']="XXXX"
data = urllib.urlencode(values) 
url = "http://passport.csdn.net/account/login"
geturl = url + "?"+data
request = urllib2.Request(geturl)
response = urllib2.urlopen(request)
print response.read()
print geturl		//看看geturl到底变怎样？如下：
			//http://passport.csdn.net/account/login?username=1016903103%40qq.com&password=XXXX
更多基础和重点内容http://cuiqingcai.com/1052.html
正则表达式是重点。

安装PySpider爬虫框架：
sudo apt-get install python python-dev python-distribute python-pip libcurl4-openssl-dev libxml2-dev libxslt1-dev python-lxml //依赖包
sudo apt-get install phantomjs		//安装phantomjs 一个无界面的,可脚本编程的WebKit浏览器引擎，可处理网页数据的js脚本
sudo pip install pyspider		//安装pyspider，注意到pip工具 就是上述python-pip工具 
pyspider all		//启动pyspider，并启用所有组件，
firefox浏览器输入 http://localhost:5000 进入pyspider界面

phantomjs：浏览器引擎，一般用于解析js脚本内容
phantomjs helloworld.js		//直接运行js 脚本是使用方式

selenium： 用于桥接phantomjs到python 	
sudo pip install selenium

PyQuery：
sudo pip install pyquery

jQuery：










20170426
机器学习：（包含）
	supervised leaning 监督学习 ：根据 输入 预测 输出
		regression：预测结果
		classification：分类内容
	reinforcement leaning 强化学习： 做判断，决策
	unsupervised leaning 非监督学习：挖据有关输入的规律
人工智能 = 深度学习+强化学习    
强化学习 就是 训练最优大脑模型 实时训练 相当于人的最终大脑决策 判断， 
深度学习 相当于脑皮层 神经 对外部信息的处理。
	也称 supervised leaning 监督学习，
所以人工智能就是强化学习 加上深度学习 ，
比如alphaGo就是强化学习来负责决策，CNN来负责处理棋子 下棋位置的范围确定,MCTS树最后结合来搜索
这里讨论的是xxNN模型例子都是，深度学习的模型：
原理缥缈，直接学习使用 tensorflow 框架（做过alphago） 
下载安装 （只使用cpu，针对python2.7的版本）
sudo pip2 install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl
教程：
https://my.oschina.net/yilian/blog/664632
教程的范例都会在tensorflow_test里示范学习一遍
1,入门，线性拟合实验，linear_fitting_test.py
2,CNN卷积神经网络： CNN_test.py 
3,自修改的卷积神经网络： CNN_test2.py
4,使用可视化界面观察训练情况tensorboard，（安装tensorflow时就已经安装了）
	tensorboard --logdir=/tmp/logs
	Starting TensorBoard 16 on port 6006
	(You can navigate to http://0.0.0.0:6006)	//浏览器打开 http://0.0.0.0:6006 就可以开始监测
	但是要使用tensorboard监测，代码里也要做相对应的设置 CNN_test3_with_tensorboard.py
	出错，是关于tensorboard的api 的调用出现了问题，以后再处理！！
5，
9，RNN/LSTM循环神经网络长短期记忆网络使用 RNN_test.py
10,最强网络 RSNN深度残差网络 平均准确率96-99% RSNN_test.py 卡死出错












20170428
从最基本的例子 CNN_test.py 深入 深度学习的 基础原理和概念
import input_data	//下载了一个例子数据包，分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。
			//是一个 用于识别阿拉伯数字图片 的例子数据包 （0~9十个阿拉伯数字） 
			//训练数据用于训练模型，测试数据和训练数据其实是相同内容，
			//但独立出来是避免使用曾经用于训练模型的数据来检测模型，更公平得到模型的准确性
mnist = input_data.read_data_sets("/tmp/data/", one_hot=True)
			//这里是读取这个数据包的数据
			//每个数据包有两个数据集，
			//每个数据集都有两部分组成，一个是图片包，一个是对应的标签包
			//训练数据集有一个含60000张图片的图片包，和对应一个含60000行便签的标签包
			//测试数据集有一个含10000张图片的图片包，和对应一个含10000行便签的标签包		
			//每张图片对应一个 10维向量的便签，比如说：
			//图片包第200张图片显示”5“，便签包第200条10维向量对应为 ([0,0,0,0,0,1,0,0,0,0])
最基础的学习原理（矩阵乘法方程）：
使用线性回归的方法，就是通过提供的样本来训练出一个可以描述样本行为的 矩阵乘法方程，也叫训练出一种合理的特定”思维“
例子数据包每张图片是 28X28 分辨率的黑白图片，那每张图片可以表示为 28x28 = 784 维向量 x，对应的标签为 y
我们引入一个可以用于描述特征的 10×784 矩阵W， 和偏移向量量b  还引入一个特征标签10维向量 Y 
执行矩阵乘法： Y = W × x + b  （经过多样本训练，得到合理的 矩阵乘法 方程，最终W 和b稳定到一定区域，这个过程也称拟合，）
	Y1      W11x1  + W12x2  + W13x3  + ..... W1784x784  + b1
	Y2      W21x1  + W22x2  + W23x3  + ..... W2784x784  + b2
	Y3      W31x1  + W32x2  + W33x3  + ..... W3784x784  + b3
	Y4      W41x1  + W42x2  + W43x3  + ..... W4784x784  + b4
	Y5   =  W51x1  + W52x2  + W53x3  + ..... W5784x784  + b5
	Y6      W61x1  + W62x2  + W63x3  + ..... W6784x784  + b6
	Y7      W71x1  + W72x2  + W73x3  + ..... W7784x784  + b7
	Y8      W81x1  + W82x2  + W83x3  + ..... W8784x784  + b8
	Y8      W91x1  + W92x2  + W93x3  + ..... W9784x784  + b9
	Y10     W101x1 + W102x2 + W103x3 + ..... W10784x784 + b10		
即一张图片 x 通过特征矩阵 W 处理后，提取到特征便签 Y
再把特征便签归一化的预测标签 y_ = softmax（Y）
假如模型不断训练，特征矩阵 W 稳定到不需要改变，那么预测标签 y_ 与 x 对应的真实标签 y 应该一致！！！
如果不一致，y与y_就有误差，
通过统计误差，然后运用交叉熵等数学方法，得到修正量，反馈更新特征矩阵W和偏移向量b，
模型又进化成长了点，
通过不同图片 x 的训练 ，模型最终成长到一个接近完美的状态，这时，算出的y_与y极大多数一致，即表示模型基本能识别每一个图片上的数字
但仅仅y_与y一致，并不百分百认为识别对图片，
训练好的模型识别一张图片的过程是：
	得到图片的y_,y_与十中y中的一个吻合，基本确认图片数字与y对应的数字一样，
	然后模型继续取出 y 对应的那张暂存在模型里参照图片， 与正在识别的图片 执行布尔运算 （就是对俩个784维向量执行按维与运算）
	吻合程度超过75%，那么就完全确认正确图片上的数字！！！

欠拟合：训练出来的 矩阵乘法方程，与样本不能很好地吻合，不能很好形成合适的”思维“
过拟合：训练出来的的 矩阵乘法方程，只与已知的训练样本完全吻合，也不能形成合理的”思维“

加权回归：
	与线性回归的区别是，线性回归会考虑每一个样本，为训练出合适的 矩阵乘法方程 做贡献，
	而加权回归是，重视某部分样品对训练方程时的贡献，而忽略或减少某些样本对训练方程时的影响，所以训练的是变种 矩阵乘法方程

feedfroward模型神经网络:(FNN),而不是完整的CNN模型,对于CNN认识的补充有待讨论)：
	上述学习原理中，我们讲述是训练拟合一个合理的矩阵乘法方程（思维） Y = W × x + b，
		当这个 思维 被训练得相当成熟了，给机器 一个”信息：x“，根据 思维，机器做出一个”行为：y“
	这种思维只是一个 矩阵乘法方程，往往被视为思维简单，不管被训练得多久，最后应用时，做出的行为准确程度都不会太高！！
	如果现在改成以下方式：
	a1 = Wa1 × x + ba1，训练一个 向量乘法 方程提取抽象信息a1，即训练更新 特征向量Wa1，和偏移向量ba1
	a2 = Wa2 × x + ba2，训练一个 向量乘法 方程提取抽象信息a2，即训练更新 特征向量Wa2，和偏移向量ba2
	a3 = Wa3 × x + ba3，训练一个 向量乘法 方程提取抽象信息a3，即训练更新 特征向量Wa3，和偏移向量ba3
	a4 = Wa4 × x + ba4，训练一个 向量乘法 方程提取抽象信息a4，即训练更新 特征向量Wa4，和偏移向量ba4
	a5 = Wa5 × x + ba5，训练一个 向量乘法 方程提取抽象信息a5，即训练更新 特征向量Wa5，和偏移向量ba5
	可以看出，每个信息 x向量 都会得到 5个抽样信息组成的 a向量（a1,a2,a3,a4，a5）
	接着上述例子，一个样本信息集有60000个信息x，即60000个 x向量，就有60000个5维a向量
	然后继续：
	c1 = Wc1 × a + bc1，训练一个 向量乘法 方程提取抽象信息c1，即训练更新 特征向量Wc1，和偏移向量bc1
	c2 = Wc2 × a + bc2，训练一个 向量乘法 方程提取抽象信息c2，即训练更新 特征向量Wc2，和偏移向量bc2
	c3 = Wc3 × a + bc3，训练一个 向量乘法 方程提取抽象信息c3，即训练更新 特征向量Wc3，和偏移向量bc3
	c4 = Wc4 × a + bc4，训练一个 向量乘法 方程提取抽象信息c4，即训练更新 特征向量Wc4，和偏移向量bc4
	c5 = Wc5 × a + bc5，训练一个 向量乘法 方程提取抽象信息c5，即训练更新 特征向量Wc5，和偏移向量bc5
	c6 = Wc6 × a + bc6，训练一个 向量乘法 方程提取抽象信息c6，即训练更新 特征向量Wc6，和偏移向量bc6
	可以看出，每个a向量 都会得到 6个抽样信息组成的 c向量（c1,c2,c3,c4,c6）
	一个样本信息集有60000个信息x，就有60000个5维a向量，就有60000个6维c向量
	然后继续：
	Y = Wd × c + bd，训练一个 矩阵乘法 方程做出行为Y，即训练更新 特征矩阵Wd，和偏移向量bd
	最终通过抽象信息c做出行为Y
	比起简单的 x -> Y 思维，这里是 x -> a -> c -> Y 多层思维！
	每一个 向量乘法方程 视为一个神经元！
	那 5个 获取抽象信息a的 向量乘法方程 共同组成第一神经层
	那 6个 获取抽象信息c的 向量乘法方程 共同组成第二神经层
	每一条信息x 都处在输入层
	最后得到的行为Y 处在输出层
	那么：输入层x， 第一神经a， 第二神经层b， 输出层Y 组成的就是 一个神经网络
	发现每一层都是一个 矩阵方程(多个向量方程组成一个矩阵方程)
	上述是一个典型的神经网络例子，当然，实际的神经网络可以更多层，更复杂。
	一般矩阵乘法神经网络用于机械视觉，机械听觉类工作，例如识别图片内容，分析一首MP3属于什么类型音乐等等
	有一种改进的方法,可以减少计算复杂程度!!!
		就是对于上述的 所有 向量乘法方程 都加入同一个sigmond算子 或者 同一个tanh算子!!
		即都加 f(Z) = sigmond(z) 或者都加 f(z) = tanh(z)
		例如:
			a2 = f ( Wa2 × x + ba2 )
			....
			c5 = f ( Wc5 × a + bc5 )
			....
		如果是f()是tanh()这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近1,要深度接近近-1,即在[-1,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,-0.9,1,0.8,-1},....
		如果是f()是sigmond这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近0,要深度接近近1,即在[0,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,0.8,0,0.9,0},....
		这样再投入下一层网络的计算,计算量变得相当少,
		而且这种技巧被证明不影响模型的训练!!!
	还有一种算子叫 softmax() 与归一化相关的算子
	前向传导:就是上述的 向量x经一层层网络得到y
	反向传导:就是根据 实际推得y 和 预期y 的方差,往后修正网络中的各个W 和 b 的过程
				
			

卷积神经网络概念 （CNN）:
	参考:	http://blog.csdn.net/zkl99999/article/details/46805453
	   	https://www.zhihu.com/question/34681168
	现实中,的图片样品或者声音样品,如果使用传统的froward,那么就需要大量 矩阵方程,需要拟合大量的 大型W矩阵和b向量
	CNN的思想是:前期设立几层,通过卷积核提取样本特征!,最后得到多份的相互独立的特征碎片
		    后面的几层就是 统计和使用feedfroward模型等传统手段归类
	相比于feedfroward模型,
		CNN是多了一个提取出多份样本特征的过程,然后训练识别样本特征组成的输入向量.
		但是 feedfroward模型 ,直接把样本当成一个输入向量,然后训练,
		这么一比较就发现了 CNN 训练的时间成本低,而且,准确率不比feedfroward模型差!!
	一个重要的概念是 卷积核,其实就是一个nxn的小矩阵,
		卷积核用法:
			卷积核从样图片左上方开始,nxn卷积核 矩阵乘以 此刻所在nxn像素区域,
			得到的一个加权平均值,为新特征图的新的一个像素点!!
			(上述加权平均得到平均值的过程叫 池化)
			然后卷积核在样图片向右移动一个像素点,重复动作得到新特征图第二个像素点...
			卷积核移动轨迹从左到右,从上到下
		使用例子:
		例如一张300x300的样图image,通过一个 5x5的卷积核换算,得到一张296x296 的特征图map
		第一层conv为A,有10个5x5卷积核,那么这张image对应A层就有 10张296x296特征图A_map
		第二层conv为B,有6个100x100卷积核,那么A层每张map在B层又分别有 6张193x193特征图B_map,理应60张B_map
			然而事实上不一定60张B_map,可以有限定有30张B_map,这就是说随机某些A_map并没有透过某些卷积核生成B_map
		第三层conv为C,有6个100x100卷积核,那么B层每张map在C层又分别有 6张92x92特征图C_map,理应共30x6=180张C_map
			然而只取其中60张C_map
		最后一层conv为D 有5个92x92卷积核,那么C层每张map在d层又分别有 5张1x1特征图D_map,理应共60x5=3000张D_map
			最后一层,会全部使用300张1x1特征图D_map,	
			由于1x1特征图,所以直接构造成 300维的向量,所以最后一层的这种变换叫做 全连接(full connecttion)
		以上就是取特征的过程,
		最后就类似 feedfroward模型 方法训练300维的向量!!! D层相当于输入层
		layer1 有 200 个300x1 向量方程,300维向量经过layer1 得到1个200维向量
		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
			归一化后最后指出图片里是一辆汽车
		统计以下 要训练的参数!!!
		A层(10x5x5)+10=260, B层(6x100x100)+6=60006, C层(6x100x100)+6=60006, D层(5x92x92)+5=8469
		layer1 300x200+200=60200, ouput 200x50+50=10050
		共 198991 个需要训练参数
	对比 feedfroward模型的一个例子!!!
		同样一张300x300的样图image,相当于300x300=90000维向量
		layer1 有 200 个90000x1向量方程,90000维向量经过layer1 得到1个200维向量
 		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
		统计以下 要训练的参数!!!
		layer1 90000x200+200=18000200, ouput 200x50+50=10050
		共 18010250 个需要训练的参数,
		即使不要 layer1,直接转成 50维向量,也要 90000x50+50=4500050个训练参数!!
		都比 CNN 训练的参数要多!!!
		
循环神经网络概念 （RNN）：
	即过去的行为可以影响此刻行为的神经网络结构，以3层feedfroward神经模型 类比讲解 简单的3层经典RNN结构
	3层CNN即：输入层，第一层神经网络（假设只有4个神经元），输出层：从上述知道：
		第一神经网络对应的矩阵乘法方程有：
		a1 = Wa1 × x + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × x + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × x + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × x + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		经过训练后，经过这种传递关系 由x最终得到对应Y
	而 经典RNN 除了由此刻的x外，还又之前的x，共同得到此刻的 Y 的
		因此输入层 还是 x 不变
		第一神经网络对应的方程一般是这样，
		a1 = Wa1 × |x，<a-| + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × |x，<a-| + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × |x，<a-| + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × |x，<a-| + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		<a- 我暂且这样表示是 上一次的 x求Y 过程中 得到的的中间量 a（a1,a2,a3,a4）
		|x，<a-| 表示 x 与上一次的 a 的组成的矩阵
		也就说，除了输入层的x参数作为输入参数外，还有上次得到的a
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		输出层的形式保持不变，就是这样子，使得上一次的输入直接影响到此刻行为的结果	 
	RNN的变种非常多，上述是最简单模型也是最没有应用前景的模型
	迄今应用最为广泛是RNN模型是基于 LSTM单元的模型
	参考：http://colah.github.io/posts/2015-08-Understanding-LSTMs/
	http://blog.csdn.net/Dark_Scope/article/details/47056361
	http://blog.csdn.net/u014595019/article/details/52605693
	重点是，之前的都是一个矩阵乘法方程作为一神经元
	但是lstm 使用多个矩阵乘法方程组成特殊神经元，其中有三个矩阵乘法方程作为“门”通过归一化后得到的1后0来判断是否输入 x 和 <a- 信息
		到神经元核的矩阵乘法方程，也判断是否传递到下一次的 工作循环去，
深度神经网络概念 （DNN）：
	这个概念比较广泛，其实就是各种基础神经网络的混合，还有往往是多层网络！！











20170503
继续搭建安卓环境： （sama5d35ek为例！）
获取安卓源码：
$ mkdir android4sam_v4.4
$ cd android4sam_v4.4
$ repo init -u git://github.com/Android4SAM/platform_sammanifest.git -b android4sam_v4.4
$ repo sync
下了两周 （50GB啊 重点是 .repo 文件夹是重点不能删）！
配置编译！！
$ . build/envsetup.sh
$ lunch sama5d3-eng	//就是这里配置成 sama5d3的， 可能配置成 sama5d4的也在这里
$ make	//编译
$ mkubi_image -b sama5d3 	//做成ubi格式系统
烧录：
下载了对应的安卓demo镜像测试烧录：
修改 sama5d3ek_nandflash.sh 的samba命令路径 和 对应烧录usb口ttyACM1
sudo /home/infortech-ubuntu-1404/SAM9X35/tools/sama2.16/sam-ba_cdc_linux/sam-ba /dev/ttyACM1 AT91SAMa5d3x-EK sama5d3ek_nandflash.tcl > logfile.log 2>&1
然后执行sh烧录。
成功运行，
然后把源码编译出的文件系统代入测试：
首先，从demo发现有4种文件系统：
recovery
systemfs
datafs
cachefs
而源码编译出来的只有 systemfs 和 datafs
system_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img
userdata_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img
另外，还有两种fs文件并没有编译出来
替换demo对应的，成功烧录运行！！

编译安卓文件系统问题log;
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ . build/envsetup.sh
including device/atmel/sama5d3isi/vendorsetup.sh
including device/atmel/sama5d3/vendorsetup.sh
including device/generic/armv7-a-neon/vendorsetup.sh
including device/generic/armv7-a/vendorsetup.sh
including device/generic/mips/vendorsetup.sh
including device/generic/x86/vendorsetup.sh
including sdk/bash_completion/adb.bash

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
/bin/bash: bison: 未找到命令
build/core/config.mk:344: *** Error: could not find jdk tools.jar, please install JDK6, which you can download from java.sun.com。 停止。
** Don't have a product spec for: 'sama5d3'
** Do you have the right repo manifest?
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ sudo apt-get install bison

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
build/core/config.mk:344: *** Error: could not find jdk tools.jar, please install JDK6, which you can download from java.sun.com。 停止。
** Don't have a product spec for: 'sama5d3'
** Do you have the right repo manifest?
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ 
安装java6 http://blog.csdn.net/neuxiang/article/details/41956557

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=4.2.2
TARGET_PRODUCT=sama5d3
TARGET_BUILD_VARIANT=eng
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
TARGET_ARCH_VARIANT=armv7-a
HOST_ARCH=x86
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.19.0-25-generic-x86_64-with-Ubuntu-14.04-trusty
HOST_BUILD_TYPE=release
BUILD_ID=JDQ39B
OUT_DIR=out
============================================
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ make
............................................................
/bin/bash: flex: 未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ sudo apt-get install flex

/usr/include/stdlib.h:760:34: fatal error: bits/stdlib-bsearch.h: No such file or directory
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$  sudo apt-get install gcc-multilib
/bin/bash: xsltproc: 未找到命令
sudo apt-get install  xsltproc

/bin/bash: xmllint: 未找到命令
sudo apt-get install libxml2-utils

sh: 1: gperf: not found
sudo apt-get install gperf

Can't locate Switch.pm in @INC (you may need to install the Switch module) (@INC contains: /etc/perl /usr/local/lib/perl/5.18.2 /usr/local/share/perl/5.18.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.18 /usr/share/perl/5.18 /usr/local/lib/site_perl .) at external/webkit/Source/WebCore/make-hash-tools.pl line 23.
sudo apt-get install libswitch-perl

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ make
....................................................................
external/valgrind/tsan/ts_valgrind_intercepts.c:2505:1: warning: unused parameter 'unused_line' [-Wunused-parameter]
external/valgrind/tsan/ts_valgrind_intercepts.c: In function '_vgw00000ZZ_Za_AnnotateFlushExpectedRaces':
external/valgrind/tsan/ts_valgrind_intercepts.c:2621:1: warning: unused parameter 'file' [-Wunused-parameter]
external/valgrind/tsan/ts_valgrind_intercepts.c:2621:1: warning: unused parameter 'line' [-Wunused-parameter]
target SharedLib: vgpreload_tsan-arm-linux (out/target/product/sama5d3/obj/SHARED_LIBRARIES/vgpreload_tsan-arm-linux_intermediates/LINKED/vgpreload_tsan-arm-linux.so)
target Symbolic: vgpreload_tsan-arm-linux (out/target/product/sama5d3/symbols/system/lib/valgrind/vgpreload_tsan-arm-linux.so)
Export includes file: external/valgrind/tsan/Android.mk -- out/target/product/sama5d3/obj/SHARED_LIBRARIES/vgpreload_tsan-arm-linux_intermediates/export_includes
target Unstripped: vgpreload_tsan-arm-linux (out/target/product/sama5d3/obj/lib/vgpreload_tsan-arm-linux.so)
Generated: (out/target/product/sama5d3/android-info.txt)
Installed file list: out/target/product/sama5d3/installed-files.txt
Target system fs image: out/target/product/sama5d3/obj/PACKAGING/systemimage_intermediates/system.img
Running:  mkyaffs2image -f out/target/product/sama5d3/system out/target/product/sama5d3/obj/PACKAGING/systemimage_intermediates/system.img
Install system fs image: out/target/product/sama5d3/system.img
Target ram disk: out/target/product/sama5d3/ramdisk.img
Target userdata fs image: out/target/product/sama5d3/userdata.img
Running:  mkyaffs2image -f out/target/product/sama5d3/data out/target/product/sama5d3/userdata.img

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ mkubi_image -b sama5d3
==============================
Board chip:sama5d3
==============================
Generate android ubifs file, please wait for about 2-3 minutes ...
Success:you can get system_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img and userdata_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img under current directory!
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ 

接下来编译android 的linuxkernel
之前git clone下的linux-at91不能用，后来发现，匹配android的linux是另外的linux，需要重新下载
关于编译安卓内核，暂时搁置

ubuntu使用adb调试安卓设备(进入android shell) :
	lsusb
		Bus 001 Device 023: ID 0e8d:201d MediaTek Inc. 
	sudo gedit /etc/udev/rules.d/51-Android.rules
		添加一条: SUBSYSTEM=="usb", ATTR{idVendor}=="0e8d", ATTR{idProduct}=="201d", MODE="0600" , OWNER=="infortech-ubuntu-1404"
		sudo chmod a+rx /etc/udev/rules.d/51-Android.rules
	mkdir ~/.android
		gedit ~/.android/adb_usb.ini
		添加一条: 0x0e8d
	infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~$ adb kill-server
	infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~$ adb devices
		* daemon not running. starting it now on port 5037 *
		* daemon started successfully *
		List of devices attached 
		V101172401901	device		//然后就看到了已经这册好的android 设备在列表里
	adb shell //进入到安卓设备的shell假设只连接了一台安卓设备，可以直接这么干，进入安卓设备的shell终端
二、 adb 的常见指令：
    adb devices                  # 列出所有的设备
    reset adb                      # 若重启 adb。若 DDMS 中设备连接失败等故障时，可以重启来解决
    adb kill-server               # 杀死 adb 调试桥
    adb start-server            # 启动 adb 调试桥
    adb shell                       # 若电脑只有一个模拟器或只有一个手机，则进入该设备的 shell，此时可以执行 linux 命令
    adb shell [command]                  # 执行 linux 命令，如 adb shell ls  就是列出连接设备下的所有文件
    adb bugreport                            # 查看 bug 报告
    adb install <apk文件路径>        # 这个命令将指定的apk文件安装到设备上
    adb uninstall <软件名>              # 卸载软件
    adb uninstall -k <软件名>         # 如果加 -k 参数,为卸载软件但是保留配置和缓存文件
    adb push <本地路径> <远程路径>                  # 用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)
    adb pull <远程路径> <本地路径>                    # 用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑

git补充，版本分支处理：
	git checkout -b linux-at91 Android4sam_v4.4 //转向某个分支
	假如操作了分支文件后,
	git checkout //展示那些文件被更改/删除/新添加
	git checkout -- xxx   //假如原来分支版本有文件xxx,但被删掉/更改了,这样可以恢复文件
	git reset --hard      //有时候人为修改并保存后但做错了,而且没有add和commit,还是想checkout到以前,但这时chenckout会出错,
			      //这条命令就是强制重置版本,删除已经保存的修改,然后就可以checkout了
查看网速命令:
	slurm -i eth0		//监控eth0端的网络实时网速
限制网速: (repo android4m v4.4 时,常常因为速度爆表而挂掉vpn)
    	sudo apt-get install wondershaper   
	示例: $ sudo wondershaper eth0 100 20 （限制ppp0网卡下载速度100K，上传速度20K）
	示例:  $ sudo wondershaper clear eth0   (清除ppp0网卡的网速限制）
安装了一个护眼小工具(失败,python3程序):
	sudo add-apt-repository ppa:slgobinath/safeeyes
	sudo apt update
	sudo apt install safeeyes
关闭显示屏命令:
	xset dpms force off
暂停进程命令:
	按键 ctrl+z
	然后出现进程暂停的信息,例如:[6]+  Stopped                 python2.7 learning.py
	恢复进程,使用命令,例如: fg %6  		//6 是上述进程暂停信息的序号
sudo apt-get install 失败后解决方法:
	$ sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/
	$ sudo mkdir /var/lib/dpkg/info/
	$ sudo apt-get update
	...
	$ sudo apt-get -f install
	...
	$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old/		//注意忽略这个*/ 
	$ sudo rm -rf /var/lib/dpkg/info
	$ sudo mv /var/lib/dpkg/info_old/ /var/lib/dpkg/info/
	然后重新 sudo apt-get update 和 sudo apt-get upgrade 就没事了,但好像还是有一点点遗留症
.bashrc添加路径问题:
	#增加.so搜索路径
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/liheyuan/soft/lib
	#增加.a搜索路径
	LIBRARY_PATH=$LIBRARY_PATH:/home/liheyuan/soft/lib
	#增加bin搜索路径
	export PATH=$PATH:/home/liheyuan/soft/bin
	#增加GCC的include文件搜索路径
	export C_INCLUDE_PATH=$C_INCLUDE_PATH:/home/liheyuan/soft/include
	#增加G++的include文件搜索路径
	export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/home/liheyuan/soft/inc
加入新硬盘:
	装好然后开机,然后root用户
	fdisk -l	//查看新插入硬盘信息
	如果已经格式化过了,系统会加载这个硬盘,所以先fdisk -l 查看到新加入的硬盘是/dev/sdc,他的分区设备符号,如/dev/sdc1,/dev/sdc2
	如果系统默认加载了,便先卸载
	umount /dev/sdc1
	umount /dev/sdc2
	配置硬盘:
	fdisk /dev/sdc
	d	//表示删除分区命令
	1	//删除分区1
	2	//删除分区2
	w	//执行配置	然后 fdisk -l 变发现没了/dev/sdc1,/dev/sdc2
	fdisk /dev/sdc
	n	//表示添加分区
	p	//选择主盘类型 (还有一种是swap类型,即虚拟内存,)
	1	//分区号
	xx	//起始地址
	xxx	//结束地址
	n	//表示添加分区
	p	//选择主盘类型
	2	//分区号
	xx	//起始地址
	xxx	//结束地址
	....
	w	//执行配置	然后 fdisk -l 变发现出现了/dev/sdc1,/dev/sdc2,...
	格式化要使用的分区
	mkfs -t ext4 /dev/sdc1	
	mkfs -t ext4 /dev/sdc2
	...
	最后是设置启动自动挂载:
		先查看uuid:
		ls -l /dev/disk/by-uuid/
		/dev/sdc1  uuid:333333333...
		/dev/sdc2  uuid:444444444...
		....
		建立两个文件目录:
		mkdir /home/kingders/bb
		mkdir /home/kingders/nn
		然后修改fstab
		sudo gedit /etc/fstab	添加:
		UUID=333333333... /home/kingders/bb               ext4    defaults     0       2
		UUID=444444444... /home/kingders/nn               ext4    defaults     0       2
		....
		最后重启就会自动加载并映射到制定目录了!!!
		特别注意:
			如果多个分区挂到同一文件目录,如 fstab 有这样的,,
			UUID=333333333... /home/kingders/bb               ext4    defaults     0       2
			UUID=444444444... /home/kingders/bb               ext4    defaults     0       2
			系统会出错,也就是说,不能多个分区挂到同一目录上去!!!

清理Linux系统中的孤立、无用的软件包:http://blog.topspeedsnail.com/archives/9992#more-9992
Ubuntu 安装使用 Krita -专业绘画软件(相当于ps)http://blog.topspeedsnail.com/archives/9816
Ramme: 开源的Instagram桌面客户端:http://blog.topspeedsnail.com/archives/9664
Ubuntu 安装 Qucs电路模拟器:http://blog.topspeedsnail.com/archives/9369
Linux下的种子搜索工具:http://blog.topspeedsnail.com/archives/9363
tinyrenderer: 理解OpenGL的工作原理:http://blog.topspeedsnail.com/archives/9357
Ubuntu 安装 LibreCAD－开源的CAD软件:http://blog.topspeedsnail.com/archives/9184
Ubuntu 安装 Drawpile－多人协作绘图:http://blog.topspeedsnail.com/archives/9161
Ubuntu 安装 KiCad－EDA电路板设计软件:http://blog.topspeedsnail.com/archives/9157
Nightfall: 天文学软件-Ubuntu:blog.topspeedsnail.com/archives/10095
Ubuntu 安装 CGAL-计算几何算法库:http://blog.topspeedsnail.com/archives/10080
使用requests.get下载大文件－Python:http://blog.topspeedsnail.com/archives/9075
Ubuntu 安装 MakeHuman－3D人物角色建模软件:http://blog.topspeedsnail.com/archives/9051
Ubuntu 安装 OSSN－搭建自己的社交网站:http://blog.topspeedsnail.com/archives/8983
PyCryptodome密码学模块－Python:http://blog.topspeedsnail.com/archives/8586
Linux 安装 Kdenlive－视频编辑软件:http://blog.topspeedsnail.com/archives/8204
FFmpeg编译安装脚本－CentOS:http://blog.topspeedsnail.com/archives/7316
开发第一个Google Chrome浏览器插件:http://blog.topspeedsnail.com/archives/7114
Ubuntu 16.04安装Fcitx拼音输入法:http://blog.topspeedsnail.com/archives/6948
使用Dlib ( C++ / Python )－检测面部关键特征(机器学习有关):http://blog.topspeedsnail.com/archives/6935
Ubuntu14.04安装OpenCV:http://blog.topspeedsnail.com/archives/1257
Flask的安装和使用：第一个Hello World:http://blog.topspeedsnail.com/archives/1459
使用Flask搭建一个简单的静态网站:http://blog.topspeedsnail.com/archives/1528
使用Flask创建一个登陆页面:http://blog.topspeedsnail.com/archives/1540
关于机器人的开源项目:http://blog.topspeedsnail.com/archives/4423
开源软件架构－Nginxhttp://blog.topspeedsnail.com/archives/5595
开源软件架构－matplotlib(基于Python的绘图库，广泛用于Python科学计算界):http://blog.topspeedsnail.com/archives/5569
fabric: Linux的远程操作和自动部署(用于简化使用SSH的应用程序部署或多机操作):http://blog.topspeedsnail.com/archives/7868









20170508
编译android_kernel:
安卓的内核构造基于一般linux内核,但又很不一样,所以是另一套内核源码!!
编译安卓内核前先要完成安卓文件系统的编译!!!
下载源码:
	git clone git://github.com/Android4SAM/linux-at91.git
	cd linux-at91
	git checkout -b linux-at91 Android4sam_v4.4
把之前编译好了安卓文件系统的生成内容中的 root文件夹(<android_working_dir> /out/target/product/sama5d3/root)
	复制到安卓内核源码的根目录里
编译:
	make mrproper
	make ARCH=arm sama5_android_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gneabihf- uImage
利用开发板安卓demo的.sh文件烧录到开发板进行测试:
开机log:
.....
demo_fs with made_kernel
ALSA device list:
  #0: wm8904 @ SAMA5D3EK
Warning: unable to open an initial console.
Freeing unused kernel memory: 524K (c0686000 - c0709000)
init: skipping insecure file '/default.prop'
init: skipping insecure file '/init.rc'
init: Timed out waiting for /dev/.coldboot_done
init: Unable to open persistent property directory /data/property errno: 2
	卡死在这里!!!
经资料搜索,先系统分析了安卓系统的构成:
	安卓系统主要构成:安卓linux内核,systemfs,userfs.
	传统linux系统主要构成:内核,rootfs
	其实安卓系统是把rootfs分成的三部分,一部分systemfs,一部分userfs,还有一部分合并到安卓内核镜像里
	上述编译内核前得把编译好的安卓文件系统的root文件放入安卓内核源码根目录上的原因是,
		root里的内容 就是要合并到安卓内核镜像里的,属于rootfs一部分的内容,最后这些内容会出现在开发板的 / 根目录符上
上述初始化出错文件 init.rc 还有default.prop 就是那个root文件夹里的文件,编译内核时,会合并到 安卓内核镜像的
init: skipping insecure file 的原因是,因为出于安全性,default.prop, init.rc 等,这些文件是不可以出现用户写的模式的,
	当安卓内核初始化来到要执行default.prop, init.rc 等文件时,会检测文件是否存在允许文件写的模式,若存在就不会执行,然后初始化就卡死这了
	所以在编译内核前,还要去除 这些文件的写模式:
		sudo chmod a-w init.rc
		sudo chmod a-w default.prop
最后重行编译,成功运行!!!

新问题:
init: critical process 'servicemanager' exited 4 times in 4 minutes; rebooting into recovery mode
RomBOOTing system with command 'recovery'.
根据google,初步认为没有选上 buinder IPC : 
	make menuconfig: ->device driver ->staging drivers ->android ->android binder ipc driver
	但发现,其实已经选上
学习使用 logcat命令 观察错误log,却出错不能用:
	Unable to open log device '/dev/log/main': Permission denied
	初以为logcat 没达到 root权限,需要学习使用 android 的 su 命令:
尝试绕过su,用回 demo 的uimage 发现 logcat 可行,,怀疑并不是logcat命令的权限问题,而是/dev/log/main 的问题
	/dev/log/main 的问题,可能不是取不到权限,而是还未完全初始化!!,回过开机log:
		..................
		Warning: unable to open an initial console.
		Freeing unused kernel memory: 524K (c0686000 - c0709000)
		init: skipping insecure file '/init.usb.rc'
		init: could not import file '/init.usb.rc' from '/init.rc'
		init: could not import file '/init..rc' from '/init.rc'
		init: skipping insecure file '/init.trace.rc'
		init: could not import file '/init.trace.rc' from '/init.rc'
		init (1): /proc/1/oom_adj is deprecated, please use /proc/1/oom_score_adj instead.
		init: skipping insecure file '/ueventd.rc'
		init: cannot open '/initlogo.rle'
		UBIFS: mounted UBI device 0, volume 0, name "system", R/O mode
		UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
		UBIFS: FS size: 123039744 bytes (117 MiB, 969 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
		UBIFS: reserved for root: 0 bytes (0 KiB)
		UBIFS: media format: w4/r0 (latest is w4/r0), UUID 93D922B5-68F5-4DEC-9B37-A21E28B434FC, small LPT model
		UBIFS: background thread "ubifs_bgt1_0" started, PID 966
		UBIFS: mounted UBI device 1, volume 0, name "userdata"(null)
		UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
		UBIFS: FS size: 90533888 bytes (86 MiB, 713 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
		UBIFS: reserved for root: 0 bytes (0 KiB)
		UBIFS: media format: w4/r0 (latest is w4/r0), UUID BF841DE4-C845-435B-B3BF-AD516A1726E0, small LPT model
		init: cannot find '/system/bin/rild', disabling 'ril-daemon'
		init: cannot find '/system/etc/install-recovery.sh', disabling 'flash_recovery'
		/system/bin/sh: No controlling tty: open /dev/tty: Permission denied
		/system/bin/sh: warning: won't have full job control
		shell@android:/ $ init: untracked pid 971 exited
	发现可能是没有正确执行,init.usb.rc init.trace.rc /ueventd.rc 初始化,
	所以如上述处理 init.rc 的方法,处理这三个文件 init.usb.rc init.trace.rc /ueventd.rc
最后成功烧录运行,不再自动重启!!!!!

补充:
权限问题:
一般我们在Linux的console下输入 ls -l 会列出所有文件的权限。
	比如：-rwxr-xr-x，用过Linux的人都知道r代表该文件可读，w代表可写，x代表可执行，-就代表没有该权限。
		第一个rwx代表文件所有者的权限，
		第二个rwx代表和所有者同组人的权限，
		第三个rwx代表其他用户对该文件的权限
	再如：-rwsr-xr-x，它的执行权限标志位是一个s，s代表当任何一个用户执行该文件的时候都拥有文件所有者的权限，
		这文件的所有者是root，简单点说就是不管谁执行这个文件，他执行的时候都是以root身份执行的
android 里的 su 和 rooted 知识:(https://www.zhihu.com/question/21074979/answer/18176410)
	一般Linux下su以后输入密码就可以切换到root了，但Android里的su和Linux里的su是不一样的，
	Android里的su不是靠验证密码的，而是看你原来的权限是什么。
	意思就是如果你是root，那你可以通过su切换到别的用户，比如说shell,wifi,audio什么的。
	但如果你是root之外的其他用户，就不能切换回root了，会提示你permission denied
	那么我就把一个所有者是root的su程序权限标志位置成-rwsr-xr-x，那么不管谁执行它，都是root身份执行，
		su就可以顺利执行成功了，执行成功之后我就是root身份了。
	问题都清楚了，就是你需要把一个所有者是root的su拷贝到Android手机上，
		并且把su的权限标志位置成-rwsr-xr-x。能把这个事情搞定你就成功root了一个手机。
		大概意思就是两行代码
	 	cp /data/tmp/su /system/bin/                  
	 	#copy su 到/system/分区chown root:root su                                
		#su的所有者置成rootchmod 4755 /system/bin/su                   #把su置成-rwsr-xr-x
	但是,熟悉Android的同学都知道，执行上面的每一行代码都需要root权限才能成功。
		意思就是说，你只有有root权限的情况下才能执行上面两行代码，
		而这两行代码就是为了让你获得root权限的，这是一个逻辑闭环，
		那么如何打破这个逻辑闭环呢？
			一个办法就是找一个本身已经有root权限的进程来启动我上面的两行代码，那我这两行代码一启动就是root权限，就可以顺利执行了。
			但是已经有root权限的进程都是出厂时候就装到手机上的，代码写死了，你没法控制它执行你自己的代码啊。
			这个时候就需要你找漏洞了，比如用来破解Android2.3 root权限的zergRush漏洞就是利用一个拥有root权限的进程栈溢出漏洞。
	但是,上述是建立在不重新刷写系统的情况,
		假如文件系统是自己编译的,那么,我们可以尝试着在已构造好文件系统,但编译出镜像文件之前,
		先给 su chmod成-rwsr-xr-x,再编译出烧录镜像
	为什么su一定要放到/system/bin/或者/system/xbin/,而不能放在data分区?
		因为data分区在mount时就指定了不能给可执行程序加s位。在adb shell里执行mount就可以看到.
		即data分区的可执行程序都不可以有 s 这个执行模式,只能是 x 这个执行模式
		下面是google越来的解释:
		/*
		 * 首先，你当然可以把su这个程序copy到/data/分区，但你adb push进去的时候，su有这个程序的所有者肯定不是root，
		 * 一般是shell什么的(记不清了，应该是和adbd这个进程的所有者一样)，
		 * 这个时候即使你把它权限置为-rwsr-xr-x，哪你运行它的时候也是shell身份运行的，su会提示你输入密码的。
		 * 第二,我们root手机的目的是为了运行需要root权限的APP，比如goagent或者什么的。 
		 * 这些APP里代码需要获得root的时候是这么写的：
		 * 	Process p = Runtime.getRuntime().exec("su");
		 * 也就是它们在代码里调用了一下su这个程序，哪可以写成下面这个样子吗？
		 * 	Process p = Runtime.getRuntime().exec("./data/tmp/su");
		 * 我没写过APP，不太清楚，估计是不行的。换句话说你必须把su放到环境变量PATH所有的目录里，APP才能调用到它。
		 * 如果你不想放到bin或者xbin下，你就必须给PATH增加一个目录。PATH是root权限才能修改的，
		 * 你如果能修改PATH，说明你已经有root权限了，修改PATH就没必要了，还不如直接放到bin下面。
		 */
		关于sudoandroid的工程里没有sudo这个东西。sudo是为了给普通用户临时分配root权限的，
		Android里建立了很多用户，比如wifi,shell等等，
		这些用户可以访问那个文件，不可以访问那个文件，代码里已经写死了，权限也分配的很分明。
		它们在运行的过程中不需要临时获得root权限。所以Android不需要sudo这个程序。
android基础1:
	Android对标准的Linux内核代码做了大量的剪裁和优化，并且添加了许多特有的代码，主要包括：
		自定义UI系统，采用Bionic Libc库代替glibc库，添加Gold-Fish平台，编写专有的驱动程序，如Binder、Logger、PowerManager等等。
		由于版权分歧等原因，这些修改并没有merge到Linux主分支中去，
		因此，我们不能直接从Linux Kernel的官网（kernel.org）去下载适用于Android源码的Linux内核代码，
		而是要到Google官网提供的kernel网址去下载经过修改后的Linux内核代码。
		Google提供了多个版本的Linux Kernel，分别对应不同的设备或者厂商版本.
		安卓版本信息:https://en.wikipedia.org/wiki/Android_version_history
安卓系统的组成:(google得到的参考资料)
	1. MLO, u-boot.img (bootloader)
	u-boot编译输出文件有2个，一个是MLO，另一个是u-boot.img，
	因此，对于很多Android开发板而言，一定存在一个boot分区（通常是fat32格式），该分区里存放有MLO和u-boot.img这两个重要的文件。
	2. uImage
	由于Android系统是基于Linux内核的，因此，与嵌入式Linux启动过程一样，“bootloader”完成硬件检测和初始化配置后，
	第一步要做的也是加载并运行Linux内核镜像，因此，在Android设备启动过程中，除了MLO和u-boot.img文件外，
	另一个最重要的文件就是内核镜像uImage文件了。
	注：Linux内核编译成功后，会在arch/arm/boot/目录下生成zImage文件，通过mkimage命令，
	给zImage文件加上了64个字节的数据头得到uImage文件，这样才能被u-boot识别并正确引导。
	3. ramdisk.img
	在Linux内核启动时，首先去创建虚拟的根文件系统，然后在指定位置寻址真正的根文件系统镜像并加载到内存中，
	然后执行init可执行程序完成系统启动过程。
	对于嵌入式Linux系统而言，一般需要用busybox等工具专门创建一个根文件系统镜像，而Android源码中已经实现了一个根文件系统，
	即ramdisk.img，Android内核系统启动时会首先加载ramdisk.img作为根文件系统，然后再执行init程序，解析init.rc脚本，
	挂载系统其他分区、开启各个进程和服务等。
	因此，Android系统启动第三个必不可少的文件即ramdisk.img文件，它是Android系统的根文件系统镜像。
		//注意到,我们编译内核时需要的 安卓文件系统靠过来的root文件夹里包含的就是 ramdisk.img 一样的内容
	4. boot.img
	Android系统中，通常会把zImage和ramdisk.img打包到一起，生成一个boot.img镜像文件，
	放到boot分区，由bootloader来引导启动，其启动过程本质也是和分开的uImage&ramdisk.img类似，
	只不过把两个镜像按照一定的格式合并为一个镜像而已。	
		//注意到,我们sama5系列 最后用到的 uImage镜像 就是kernel和ramdisk.img的合并镜像
	bootloader如何知道去哪加载Linux内核(zImage)和根文件系统(ramdisk.img)呢？通常是由命令行参数传入bootloader程序，
	或者在bootloader代码中给出启动参数配置文件的路径，具体的原理可以去参考bootloader启动Linux内核相关的文章分析，这里就不做详细介绍了。
	5. system.img
	前面我们提到的镜像如“bootloader”，“Linux Kernel”，“文件系统”都是不包含Android系统的核心文件，
	那么，真正的Android操作系统核心部分在哪呢？其实就位于system.img中，它包含了Android系统的firmware、用户界面、一系列的预编译应用等等，
	会在内核启动后被挂载到/system分区。因此，它也是Android系统启动必不可少的镜像之一。
		//就是systemfs
	6. userdata.img
	前面介绍的system.img镜像中包含的都是Android系统级别的数据，而“用户”的“出厂”数据则都被放到了userdata.img镜像中了，
	它会被挂载到文件系统的/data分区，用户新存储的数据、安装的程序均会被放置到这个分区中，如果擦除这个分区，
	本质上则等同于手机恢复了出厂设置，它也是Android系统启动必不可少的镜像之一。
	7. 其他的镜像
	前面介绍的几个都是Android系统启动涉及到的最重要的几个镜像文件，当然，编译输出还有其他的几个文件包括：
	用来缓存最频繁访问的数据和应用的cache.img，
	用来恢复系统时使用的recovery.img等，这里就不详细讲解了。	
android 磁盘分区:
	一般有:
	/boot		->  /dev/mtd/mtd2	//放置 内核 initrd 等执行内容区
	/system		->  /dev/mtd/mtd3	//android系统软件 api 等 只读区
	/recovery	->  /dev/mtd/mtd1	//放置 内核 initrd 等执行内容的 备份恢复区
	/data		->  /dev/mtd/mtd5	//用户数据区
	/cache		->  /dev/mtd/mtd4	//内存的缓存区
	/misc		->  /dev/mtd/mtd0	//flags区,记录设备实时状态
	fastboot: 
		是google提供的方便 android设备与pc 通过usb 传输数据,烧写镜像的传输协议, 一般移植在 u-boot 上,
		若使用fastboot,u-boot会自动把镜像中对应的部分烧录到指定的区域,开发板启动时也会自动分配空间和读取内容到内存运行等等,,,
		当然如果不使用fastboot,工程师就得自己自己编写放置镜像各部分的位置,还有启动时,把哪些内容搬到内存执行,初始化哪些区域等等,,
android 启动过程:
	简图:
	prebootloader -> u-boot(bootloader) -> kernel -> init
		-->daemons
		-->zygote ->Dalvik VM ->systemserver ->managers -> applications(实际上app是zygote fork出的,但在systemserver以后才允许执行)
							  |
		----------------->serviceMagener <--______|
					 ^
		-->NativeServices -------|
		prebootloader 即芯片特有的固化启动程序,然后uboot初始化启动内核的环境,然后开始kernel的初始化,
		kernel初始化各种软硬件环境，加载驱动程序，挂载根文件系统，最后执行init程序,就开始进入android的世界
		kernel初始化与一般linux系统初始化无异,android与一般linux 区别就在于init程序的不同，
		init决定系统启动过程中，会启动哪些守护进程和服务，以及呈现出怎样的一个用户UI界面
	init程序是分析Android启动过程中最核心的程序主要有3点：
		创建和挂载一些系统目录/设备节点，设置权限，如：/dev, /proc, and /sys
		解析 init.rc 和 init.<hardware>.rc，并启动属性服务，以及一系列的服务和进程。
		显示boot logo，默认是“Android”字样
		最重要的是第二步，一系列的Android服务在这时被启动起来,
	本地服务(Native daemons):
		相当一部分是在 init.rc 和init.<hardware>.rc 里启动:
			ueventd, servicemanager, debuggerd, rild, mediaserver, app_process 等
			这些都是 init直接启动的本地服务,都是一个独立的linux进程,可通过top查看进程 
		另一部是被那些 已启动的服务 启动的,如:
			mediaserver: AudioFlinger, MediaPlayerService, CameraService
	Android服务 (system services):
		init 直接启动的本地服务中有一个 app_process服务,
		app_process 会创建 Zygote进程,
		Zygote进程内容是:先打开 Dalvik VM (android java机)虚拟机,然后通过虚拟机执行具体进程内容
		Zygote进程其中一个具体进程内容,就是,fork 出 systemserver 进程
		fork出的 systemserver 进程 自然也是需要已打开的java机辅助 才能正常执行的进程
		systemserver 进程 把所有 android核心服务启动起来,包括:
			Activity Manager		//管理 activity 生命周期, 和新的 activity 服务
			Package Manager			//管理 app (安装,卸载,更新,权限)
			Window Manager			//管理 窗口事件
			AppWidget Manager		//管理 andriod 插件
			Backup Manager			//管理 备份
			status bar			//状态栏 相关
 			power Manager 			//管理 电源
 			networkManagement Service	//网络 相关
			notification Manager		//通知栏 相关
			Location Manager		//位置信息 相关
			Entropy Mixer			//??
			Display Manager			//管理 显示
			Telephony Registry		//电话 相关
			Scheduling Policy		//管理 进程执行
			Account Manager			//管理 账户
			Content Manager			//管理 数据
			Battery Service			//管理 电池
			Alarm Service			//预约未来执行 某程序
			Input Manager			//管理 输入
			Device Policy			//设备安全策略
			Clipboard Service		//剪贴板
			NetworkStats Service		//网络状态
			NetworkPolicy SEvice		//网络安全策略
			WIFI p2pservice			//wifi 点对点连接
			Enternet Service		//万维网 连接
			WiFI Service			//管理 wifi
			Connectivity Service		//万罗连接状态
			Network Service Discovery Service	//网络发现服务
		systemserver 进程里的这些任务都是systemserver 进程的独立子线程运行的
		systemserver 进程所有服务启动了以后, Activity Manager服务会开始启动UI界面并发送广播信息"ACTION_BOOT_COMPLETED"
		Activity Manager服务 启动 luancher, luancher 启动 Home Screen
android log 输出:
	配置系统的log输出
		make menuconfig，勾选："Kernel hacking" -> "Show timing information on printks"
		将init进程的详细log输出到dmesg文件中,修改/system/core/rootdir/init.rc，把loglevel从3改为7
	抓取系统启动的log信息
		Android系统启动的log分为 Linux内核的log 和 Android Logger系统的log，
		抓取的方法如下：
			adb shell dmesg > dmesg.txt
			adb logcat -d -v time -b "main"   >  main.txt
			adb logcat -d -v time -b "system" >  system.txt
			adb logcat -d -v time -b "events" >  events.txt
	dmesg消息:	
		直到 "Freeing init memory" 消息出现前,都是Linux内核初始化的log,
		然后就是 init 的的消息,一般都有 "init: starting" 前缀
	关于Zygote初始化消息:
	 	init的时候就初始化Zygote, dmesg有 " init: starting 'zygote' "
		但 Zygote 进程的详细初始化log信息具体放到/dev/log/main文件中了
		由于后续所有的Android应用程序都是从Zygote进程fork出来的，
		Android系统为了提高应用程序的启动速度，会在Zygote进程初始化过程中加载一些常用的java class和资源文件到进程的内存中，
		从而共享常用的class和resourse资源。这个过程我们可以通过检索"preload"标签得到这个过程所消耗的时间，
	SystemServer初始化消息:
		Zygote完成了初始化工作后就启动SystemServer进程了，
		SystemServer进程的log信息被放到了/dev/log/system文件中了
	最后,整个系统初始化结束的标记 " boot_completed " 出现在dmesg消息里
android系统优化,裁剪:
	减少 Zygote初始化时proload 的java class 和 resource 一般操作这些文件
		frameworks/base/preload-classes
		frameworks/base/core/res/res/values/arrays.xml
	减少 不必要的 本地服务 和 android服务 一般操作的文件:
		system/core/rootdir/init.rc
		frameworks/base/services/java/com/android/server/SystemServer.java
	减少预装apk 一般操作的文件:
		build/target/product/xxxx.mk
		device/<company>/<product>/xxxx.mk
		vendor/..../xxxx.mk
	减少内核log打印级别: 修改system/core/rootdir/init.rc 的loglevel
	其他例如:
		优化启动动画，降低帧率和图片尺寸
		精简系统，减小boot.img文件大小，可以显著减少启动过程中加载和解压boot.img的时间
		预先创建一些目录和文件，而不是在init过程中创建
apk安装:
	android里 apk安装后,apk安装文件还是会被保存起来的:
		一般的apk安装 默认放在 /data/app里
		而系统自带apk放在 /system/app, /system/vendor/app, /system/priv-app
		由于在/system 如果没有rooted,无法删除系统自带app	
	安装一个xxx.apk(非系统自带apk):
		xxx.app执行文件dex放在 /data/dalvik-cache (android java机执行的程序是dex)
		相关数据(数据库,xml,cache,.so动态库)放在 /data/data/com.xxx 的新建目录里
		注册apk的AndroidManifinest.xml信息到 /data/system/packages.xml
			这些信息包括：权限、应用包名、APK的安装位置、版本、userID等等
		部分apk的安装也会向Launcher应用申请添加创建快捷方式
	删除那些存放在/data/app, /system/app, /system/vendor/app, /system/priv-app 里的apk,相当于卸载app
	









20170511
virtualbox 安装 kali linux
	 kali是集成众多hack工具的debian系统,最著名的工具有 metasploit
virtualbox不能安装64位系统问题:
	`进入BIOS后，找到Configuration选项，选择Intel Virtual Technology并回车
kalilinux在 virtualbox 安装:http://blog.topspeedsnail.com/archives/1841
	注意,安装时分配的硬盘尽可能大,比如大于20GB,不然安装出错!!
	登陆界面:用户填root 
	使用virtualbox 运行虚拟kali时,一定要分配动态硬盘,因为虚拟kali硬盘不够是可以扩容,扩容例子: (resize的单位是 MB!!)
		kingders@kingders-ThinkPad-T420:~/VirtualBox VMs/kali$ VBoxManage modifyhd "NewVirtualDisk1.vdi" --resize 1024
	注意:虚拟kali 使用的网络方式是 桥接方式,这样才可以让kali接到同一层局域网
kaliliunx加入拼音输入法:(卧槽,到最后都不知道是怎么成功的)
	语言输入两种框架 ibus, fcitx,按道理选择其中之一就好
	安装:
	apt-get install fcitx fcitx-googlepinyin
	aptitude install ibus ibus-pinyin
	配置:(使用ibus框架)
	# apt-get install ibus ibus-pinyin  然后在设置里点区域语言然后改成中文  在源选项哪里汉语pinyin 点添加
	# im-config 弹出窗口中选择ibus ibus智能拼音什么的,然后一路yes
	# ibus engine pinyin
	重启系统
	如果还不行再ibus engine pinyin 一次
	最后发现,只要 设置里点区域语言 中的格式选中国,而且之前im-config设置选ibus,日后如果打不出拼音,ibus engine pinyin 一下就好








20170512
机器学习破解验证码(cnn模型):http://blog.topspeedsnail.com/archives/10858/comment-page-1#comment-1332
		  http://blog.csdn.net/ljp1919/article/details/64501002
	整个项目使用python2
	拷下来的源码开头要加上: # -*- coding:UTF-8 -*-
	python2.7 gen_captcha.py	//验证码图片生成
		出错:
		  File "/usr/lib/python2.7/dist-packages/PIL/ImageDraw.py", line 164, in arc
		    self.draw.draw_arc(xy, start, end, ink)
		TypeError: must be sequence of length 4, not 2
		解决:sudo pip2 install -U Pillow //更新pillow -u 是upgrade的意思
	python2.7 learning_and_test.py	//不断使用gen_captcha.py里的函数,生成验证码图片然后用于训练,
					//最后当正确率大于50%后输出 训练成果文件
		出错1:
		  File "learning_and_test.py", line 164, in train_crack_captcha_cnn
		    loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		TypeError: sigmoid_cross_entropy_with_logits() got an unexpected keyword argument 'labels'
		解决,与python2.7版本有关:
		loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(output, Y)) //此版本python2.7使用这种格式
		#loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		出错2:
		  File "learning_and_test.py", line 178, in train_crack_captcha_cnn
		    sess.run(tf.global_variables_initializer())
		AttributeError: 'module' object has no attribute 'global_variables_initializer'
		解决,与python2.7版本有关:
		#sess.run(tf.global_variables_initializer())
 		sess.run(tf.initialize_all_variables()) //此版本python2.7使用这种格式
	python2.7 test.py	//使用训练成果文件 验证验证码!!
		出错1:
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/training/saver.py", line 1087, in restore
		    if not gfile.Glob(save_path):
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/platform/gfile.py", line 262, in Glob
		    return _glob.glob(glob)
		  File "/usr/lib/python2.7/glob.py", line 27, in glob
		    return list(iglob(pathname))
		  File "/usr/lib/python2.7/glob.py", line 38, in iglob
		    if not has_magic(pathname):
		  File "/usr/lib/python2.7/glob.py", line 95, in has_magic
		    return magic_check.search(s) is not None
		解决,与python2.7版本有关:
		saver.restore(sess, tf.train.latest_checkpoint('.'))	//可以这样
		#saver.restore(sess, "crack_capcha.model-7000")		//或者可以这样
		saver.restore(sess, tf.train.latest_checkpoint('crack_capcha.model-7000'))	//不可以这样
		出错2
		明明使用test.py,但是就偏偏也运行上了 learning.py 不应该运行的 train_crack_captcha_cnn()
		解决:
		给 train_crack_captcha_cnn() 前加上 if __name__ == '__main__': 
		出错3:
		各种notfound 问题,
		解决,后来发现 def crack_captcha 这个函数,还是放在 learning好,test.py只调用就好了!!1	
	总结:
		gen_captcha.py	定义了验证码生成函数 gen_captcha_text_and_image 并演示了 验证码生成
		learning.py	定义了cnn模型,
			   	定义了训练函数 train_crack_captcha_cnn
				定义了使用训练模型破解验证码的函数 crack_captcha
				并执行了训练函数 train_crack_captcha_cnn 训练结束生成训练模型 crack_capcha.model-7000
		test.py		执行了使用训练模型破解验证码的函数 crack_captcha
	通过learing 掌握 tensorboard 使用方法!!
		后台运行 tensorboard :	$ tensorboard --logdir=/tmp/logs &
					Starting TensorBoard 16 on port 6006
					(You can navigate to http://0.0.0.0:6006)
		learning.py里,我们对 accuracy 和 loss
			//定义初始化好 accuracy 和 loss 变量后,才添加监控项,即:
			//loss = tf.reduce_mean(...)
			//accuracy = tf.reduce_mean(...)
			//之后,添加监控项:
			tf.scalar_summary("loss", loss)	
			tf.scalar_summary("accuracy", accuracy)
			//把所有要监控的项 打包
			merged_summary_op = tf.merge_all_summaries()
			//初始化所有变量,sess.run(tf.initialize_all_variables())
			//动态监控文档放在 /tmp/logs文件夹里
			//注意,tf.initialize_all_variables() 是初始化了所有变量
			//sess.run()又是开始了迭代计算训练
			//初始化了所有变量,又开始了迭代计算训练才能添加动态监控文档:
			summary_writer = tf.train.SummaryWriter('/tmp/logs', graph_def=sess.graph_def)
			//注意后面的,
			//acc = sess.run(accuracy, feed_dict={X: batch_x_test, Y: batch_y_test, keep_prob: 1.})
			//_, loss_ = sess.run([optimizer, loss], feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//都读取迭代训练中途得到的数据结果,然后根据结果,更改收敛条件后,重新继续迭代训练
			//也就说,自从第一次sess.run后,就开始了迭代训练的计算,
			//每当下一次sess.run指令之前,中间其实经历了多次迭代训练,而不是只计算1次
			//迭代计算的结果是离散的,只有不断更改收敛条件才可以优化下一段时间的迭代计算,
			//而关于tensorboard调用的sess.run,只是得到当前迭代计算得到的结果,并没有更改收敛条件来影响后面的迭代训练活动
			summary_str = sess.run(merged_summary_op, feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//然后,上传到监控文件
			summary_writer.add_summary(summary_str, step)
		然后浏览器输入:http://0.0.0.0:6006/
			便能看到结果,如果发现没有内容,rm -r /tmp/logs/* 		//*/清空内容
			重新打开tensorboard 试试

补充:
python的一些重要模块:
	NumPy和SciPy是开源的 Python 的科学计算模块	
		NumPy：怎么处理缺失的数字:http://blog.topspeedsnail.com/archives/866
		NumPy入门详解:http://blog.topspeedsnail.com/archives/599
	pygame
		PyGame教程一：开始:http://blog.topspeedsnail.com/archives/2155
		PyGame教程二：声音和音乐:http://blog.topspeedsnail.com/archives/2166
安全与黑客:
	系统安全：开源的5个渗透测试工具:http://blog.topspeedsnail.com/archives/2817
	Katoolin – 在Ubuntu上安装Kali Linux工具集:http://blog.topspeedsnail.com/archives/4498
						 https://github.com/tiancode/learn-hacking
python的一种调用函数时的注意点:
		假如:
		a.py:	def了aa,bb,cc函数, 
			python a.py 时,会运行a.py的全局命令行, 
		b.py:	需要调用 a.py 的 aa 和 cc 函数, 就得加两行头 from a.py import aa,  from a.py import cc
			但是python b.py 时,除了成功调用aa cc外,还会,把a.py的全局命令行也执行一遍
			如果 b.py 只想运行自己的命令行,而不想执行 a.py 的命令行,但有可以使用别人def的函数,
			那么就得在 a.py的命令行前加上 if __name__ == '__main__':
			这样子: 
				python a.py 依然能完美执行自己的所有命令行
				python b.py 只执行自己的命令行,
python完美print出中文:
		print("某某某 {}, 哈哈哈 {} {} ".format(num1,charb,textc))  # (60, 160, 3)
		效果例子: 某某某 467, 哈哈哈 g kingders
		关键使用 " .format()" 格式函数  
python虚拟环境:
	不同的项目可能需要不同的python环境，
	比如不同的解释机: python2或者python3,专属的库文件,
	如果所以库和编译器都处于同一个环境时,就可能出现库与库之间冲突,或者项目库函数指向出错等兼容问题,
	所以针对不同的项目,需要不一样的编译器软件库,可以都放在一个独立的环境里!!在独立的环境里执行项目
	安装	
	pip install virtualenv  //(我机子默认python是python3的)默认使用python3安装的virtualenv版本
	创建:
	virtualenv aaa  	//创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
				//这种默认情况下,会把默认的解释机,和对应的默认软件库加入环境aaa
	virtualenv --no-site-packages bbb //创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
					  //这情况下,不会把默认的软件库加入环境bbb,
	virtualenv ccc --python=python2   //创建一个独立环境空间ccc,在当前文件夹建立一个ccc文件夹,
					  //这种默认情况下,会把默认的软件库,和默认的解释机加入环境ccc
	启用虚拟环境
	cd ccc	//进入环境文件夹
	source ./bin/activate
	cd ~ //进入要执行的项目的文件夹,例如~
	查看当前状态
	(ccc) kingders@kingders-ThinkPad-T420:~$ 	//先可以直观看到(ccc)前缀,就是说现在处于 ccc 的独立python 工作环境里下
	python -V  	//python 版本自动为2.7.6版本
	Python 2.7.6	
	pip -V		//pip 版本自动为显示为python2.7 对应的!!	
	pip 9.0.1 from /home/kingders/smart210/study/tensorflow_study/ramdom_captcha/ccc/local/lib/python2.7/site-packages (python 2.7)
	添加指定软件库
	pip install numpy scipy scikit-learn pillow h5py keras	//添加的软件库只会加入到 ccc 文件夹里,只为ccc环境所用
	退出虚拟环境
	deactivate
	/////////////////////////////////////////////////////////////
	以上是一般虚拟环境的使用过程
	如果要使用管理多个 虚拟环境, 建议再添加 virtualenvwrapper 补充功能软件
	安装:
	sudo pip install virtualenvwrapper //(我机子默认python是python3的)默认使用python3安装的virtualenvwrapper版本
	mkdir $HOME/.local/virtualenvs	  //创建虚拟环境管理目录 (不要加sudo)
	sudo gedit ~/.bashrc 	//末尾添加:
		# by william
		# setting about virtualenvwrapper
		export VIRTUALENV_USE_DISTRIBUTE=1        #  总是使用 pip/distribute                                        
		export WORKON_HOME=$HOME/.local/virtualenvs       # 所有虚拟环境存储的目录
		if [ -e $HOME/.local/bin/virtualenvwrapper.sh ];then
		   source $HOME/.local/bin/virtualenvwrapper.sh                                                
		else if [ -e /usr/local/bin/virtualenvwrapper.sh ];then
		         source /usr/local/bin/virtualenvwrapper.sh
		     fi
		fi
		export PIP_VIRTUALENV_BASE=$WORKON_HOME
		export PIP_RESPECT_VIRTUALENV=true
	source ~/.bashrc	//启动 virtualenvwrapper
	出错1: 每次打开终端都有:
		/usr/bin/python: No module named virtualenvwrapper
		virtualenvwrapper.sh: There was a problem running the initialization hooks. 
		If Python could not import the module virtualenvwrapper.hook_loader,
		check that virtualenvwrapper has been installed for
		VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is
		set properly.
		解决:这时候可以将VIRTUALENVWRAPPER_PYTHON路径(python全局路径)加入到~/.bashrc中，
		sudo gedit ~/.bashrc 	//在设置virtualenvwrapper其他内容前先添加:
			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
		source ~/.bashrc	//由于我们安装的virtualenvwrapper是针对python3版本,所以需要使用python3开启
					//而默认的/usr/bin/python虽然指向python3,但是这里不能很好指向python3
					//所以直接改成/usr/bin/python3
		成功后,每次打开终端都会自动打开了virtualenvwrapper后台.不再有上述问题信息出现!!
		







20170514
机器学习分类评论:http://blog.topspeedsnail.com/archives/10420
	这里分别对比使用了两个训练模型一个是 feedfroward,另外一个是CNN
	其中使用到nltk模块,也需要下载一些nltk插件,使用nltkdownload.py
	trainingandtestdata.zip 是训练用原始数据包,解压得:
		testdata.manual.2009.06.14.csv,
		training.1600000.processed.noemoticon.csv
	整个项目使用python3
	python3 preprocess.py	//预处理数据
		需要 nltk(自然语言工具库 Natural Language Toolkit)软件包,另外nltk还需要一些库,通过使用 nltkdownload.py下载到
		需要 pandas软件包,
		最后得到预处理后的据据 
			training.csv,
			tesing.csv
	python3 feedfroward_learning.py  //如果使用feedfroward学习模型,执行此训练
		出错1
		  File "feedfroward_learning.py", line 88, in train_neural_network
    		     cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/ops/nn_ops.py", line 1562, in _ensure_xent_args
		    "named arguments (labels=..., logits=..., ...)" % name)
		ValueError: Only call `softmax_cross_entropy_with_logits` with named arguments (labels=..., logits=..., ...)
		解决:
		#cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))	# tensor 旧版本
		cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=predict, labels=Y))	# tensor 新版本


	python3 CNN_learning.py		//如果使用CNN学习模型,执行此训练
		出错1:
		  File "CNN_learning.py", line 84, in neural_network
		    h_pool = tf.concat(3, pooled_outputs)
		.........
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/framework/tensor_util.py", line 302, in _AssertCompatible
		    (dtype.name, repr(mismatch), type(mismatch).__name__))
		TypeError: Expected int32, got list containing Tensors of type '_Message' instead.
		解决:tensorflow版本格式问题
		# h_pool = tf.concat(3, pooled_outputs)  tensorflow 0.x 版本写法
		h_pool = tf.concat(pooled_outputs, 3)	//正确写法
		出错2:
		  File "CNN_learning.py", line 102, in train_neural_network
		    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y))
		解决:tensorflow版本格式问题
		# loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y)) # tensorflow 旧版本写法
		loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=output, labels=Y)) # tensorflow 旧版本写法
		另外还要添加一个输出训练模型数据的代码!!!
		(准确率暂时只收敛到50%,准确率低主要是因为数据量太小,也不知道是不是模型不完整问题)








20170516
(以下都是个人pc上的)
安装opencv依赖:
	升级系统：
	$ sudo apt-get update
	$ sudo apt-get upgrade
	安装基本编译工具：
	$ sudo apt-get install build-essential cmake pkg-config
	由于OpenCV是计算机视觉库，总需要加载一些图像文件（ JPEG, PNG, TIFF）。使用下面命令安装一些必要的图像库：
	$ sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev	
	除了图片之外，OpenCV还要处理视频文件。使用下面命令安装一些视频编解码库：
	$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
	$ sudo apt-get install libxvidcore-dev libx264-dev
	OpenCV的GUI模块highgui依赖Gtk。安装gtk库：
	$ sudo apt-get install libgtk-3-dev
	下面安装一些可以提高OpenCV性能的库，如矩阵操作：
	$ sudo apt-get install libatlas-base-dev gfortran
	安装Python2和Python3的开发库：
	$ sudo apt-get install python2.7-dev python3.4-dev
编译安装opencv3.1.0
	下载opencv3.1.0源码包,并原地解压
	$ ~/other/opencv
	$ wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.1.0.zip
	$ unzip opencv.zip	
	$ wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip
	$ unzip opencv_contrib.zip	
	编译opencv
	$ cd ~/other/opencv/opencv-3.1.0
	$ mkdir build
	$ cd build
	$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
 		    -D CMAKE_INSTALL_PREFIX=/usr/local \
		    -D INSTALL_PYTHON_EXAMPLES=ON \
		    -D INSTALL_C_EXAMPLES=OFF \
		    -D OPENCV_EXTRA_MODULES_PATH=/home/kingders/other/opencv/opencv_contrib-3.1.0/modules \ # opencv_contrib路径
		    -D PYTHON_EXECUTABLE=/home/kingders/.local/virtualenvs/cv3/bin/python \  # 使用cv3
		    -D BUILD_EXAMPLES=ON ..  # ".."这两点不能忽略
	$ make -j4
		出错1
		In file included from /home/kingders/other/opencv/opencv-3.1.0/modules/videoio/src/cap_gstreamer.cpp:55:0:
		/usr/include/gstreamer-1.0/gst/gst.h:27:18: fatal error: glib.h: No such file or directory
 		#include <glib.h>
	                  ^
		compilation terminated.
		make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_gstreamer.cpp.o] Error 1
		make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2
		make[1]: *** Waiting for unfinished jobs....
		编译过程中遇到众多错误,原因都是因为不能从默认 /usr/include 找到头文件,但是明明很多模块都已经成功安装好的,
		方法一:cp对应.h文件到 /usr/include,
		方法二:.bashrc 添加对应c,c++ 头文件搜索目录!! 然后 source ~/.bashrc 例如:
		export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
		export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
	$ sudo make install
	$ sudo ldconfig
创建一个python3 虚拟环境cv3 配置cv3是一个python3,opencv环境!!
	mkvirtualenv cv3 -p python3
	workon cv3
	安装numpy
	pip install numpy
	添加opencv库
	//安装好的opencv对应python3.4的库安装路径和库名称为:/usr/local/lib/python3.5/site-packages/cv2.cpython-34m.so
	//建立链接文件到虚拟空间指定位置
	$ cd ~/.local/virtualenvs/cv3/lib/python3.4/site-packages/
	$ ln -s /usr/local/lib/python3.4/site-packages/cv2.cpython-34m.so cv2.so

训练一个游戏Ai: (DQN)
	目录:/home/kingders/smart210/study/tensorflow_study/AI_game
	参考:http://blog.topspeedsnail.com/archives/10459 
	这里其实是一个 决策模型!! DQN
	需要不断截取屏幕截图,所以需要opencv库!!
	workon cv3 使用cv3虚拟环境
	python3 ai_player.py		
	出错!!
	Traceback (most recent call last):
	  File "ai_player.py", line 203, in <module>
	    train_neural_network(input_image)
	  File "ai_player.py", line 179, in train_neural_network
	    minibatch = random.sample(D, BATCH)
	  File "/home/kingders/.local/virtualenvs/cv3/lib/python3.4/random.py", line 311, in sample
	    raise TypeError("Population must be a sequence or set.  For dicts, use list(d).")
	TypeError: Population must be a sequence or set.  For dicts, use list(d).
	解决:
	line179:改为 minibatch = random.sample(list(D), BATCH)

训练一个游戏Ai2: (遗传算法) http://blog.topspeedsnail.com/archives/10952
	安装图片转换工具:
	sudo apt-get install imagemagick
	转换图片到png
	mogrify -format png plane.jpeg
	mogrify -format png enemy.gif
	修改图片分辨率
	mogrify -resize 50x50 *.png
	执行游戏Ai2
	python ai_player2.py`
		//这类算法模型不需要屏幕截图,不加载需要opencv模块
		//neuro_evolution.py是支持函数库文件

自动写诗: (RNN) http://blog.topspeedsnail.com/archives/10542
	python3 training
	出错1:
	  File "training.py", line 86, in neural_network
	    cell_fun = tf.nn.rnn_cell.BasicLSTMCell
	AttributeError: 'module' object has no attribute 'rnn_cell'
	解决:
	tf.nn.rnn_cell.BasicLSTMCell变成tf.contrib.rnn.BasicLSTMCell
	后续继续出现问题:
	后来发现,并不是简单替换既可以,新版rnn的框架改变了,所以,并不能很快修改出错问题!!!
	所以这个例子搁置!!

自动写歌: (RNN) http://blog.topspeedsnail.com/archives/10508
	先安装midi播放器:
	sudo apt-get install timidity
	sudo apt-get install fluidsynth
	播放:
	timidity -Od "midi_pkg/HotelCalifornia.mid" 出错,不会用,搁置
	准备音乐包: 人手下载太慢,将为此练习爬虫!!!!!!
	所以这个例子也搁置!!

google_deepdream 网络:http://blog.topspeedsnail.com/archives/10667
	执行时出错

图像分类器 – retrain谷歌Inception模型: http://blog.topspeedsnail.com/archives/10685	












20170517
(实在太慢,所以以下都是公司pc上的)
按上述部署公司pc
练习了python3 的文件操作 python_basic
并测试生成妹子图项目:(pixcNN) http://blog.topspeedsnail.com/archives/10660
	总之先下载图片包...
docker: 
	docker用于管理和打包 集成运行环境(虚拟系统,docker容器)
	集成运行环境(docker容器):就是一个装好了各种库,能够独立运行指定软件的虚拟根文件系统镜像
		比如说 软件A 可以在一个定制好的 docker容器/虚拟系统 里运行,
		而不需要为了运行 软件A,往自己系统加装各种乱七八糟库,搞乱自己系统
	这次 open_nsfw 需要使用一个 caffe模型框架库,这个东西不常用,不需要为了运行他而折腾安装 
		替代方案是找一个 已经装好 caffe模型框架库 的docker容器就好了
	docker对系统的要求： Linux 内核3.10+, 64位系统
		cat /etc/lsb-release	//查看ubuntu版本
		uname -a		//查看内核版本
	安装docker: http://blog.topspeedsnail.com/archives/7562
	sudo apt install docker.io
	启动/关闭docker后台服务 (与参考链接有别)
	sudo service docker start
		docker start/running, process 12723
	sudo service docker stop 
		docker stop/waiting
	版本查看:
	sudo docker version
		Client version: 1.6.2
		Client API version: 1.18
		Go version (client): go1.2.1
		Git commit (client): 7c8fca2
		OS/Arch (client): linux/amd64
		Server version: 1.6.2
		Server API version: 1.18
		Go version (server): go1.2.1
		Git commit (server): 7c8fca2
		OS/Arch (server): linux/amd64

使用open_nsfw,一个基于Caffe的成人图片识别模型:
	启动 docker 服务
	sudo service docker start
	下载一个 别人做好的 装有 caffe框架的 docker容器 镜像: http://blog.csdn.net/elaine_bao/article/details/53117676
	docker pull elezar/caffe:cpu
	下载完成后，测试是否安装正确
	docker run -ti elezar/caffe:cpu caffe --version
		libdc1394 error: Failed to initialize libdc1394 
		caffe version 1.0.0-rc3
		//关于libdc1394 error不用理会,只是容器里其他内容没装完整
		//如果这条消息辣眼睛,可以禁用这个模块: ln -s /dev/null /dev/raw1394
	在generate_pic项目文件夹里下载 open_nsfw 然后 cd进去
		git clone https://github.com/yahoo/open_nsfw
		cd /home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw
	进入 caffe框架的 docker容器,并且以当前路径为镜像系统里的工作目录!!
		sudo docker run -t -i --volume=$(pwd):/workspace elezar/caffe:cpu /bin/bash
		root@21882b4bc80c:/workspace# 		//然后命令行变这样了,并是进入成功!!
		这时/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw,映射到虚拟系统离去了
		ls /workspace //里面的东西与/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw里一模一样
	运行 open_nsfw 鉴别图片色情级别!!
	python ./classify_nsfw.py --model_def nsfw_model/deploy.prototxt --pretrained_model nsfw_model/resnet_50_1by2_nsfw.caffemodel test1.jpg	
	//成功鉴别,输出级别分数!!
	//题外话,classify_nsfw.py是 python2的脚本,python3运行会出错,上面的docker容器默认python2,但也有python3
	//	而 elezar/caffe:cpu 这个虚拟系统里,默认python是python2,所以完美执行,
	//还有 .py脚本,只能使用虚拟系统里已有的支持库,如果没有也不会去搜索实体系统的支持库
	//	例如 elezar/caffe:cpu 这个虚拟系统里 没有pygame这个模块,所以运有 import pygame 的模块时,会出错!!!
	//import PIL 出问题,安装pillow库
	//	sudo apt-get install libjpeg-dev libpng12-dev libfreetype6-dev libtiff-dev
	//	pip install -I --no-cache-dir -v Pillow
	//关于 StringIO库 python3 与python2 兼容问题
	//	http://python.jobbole.com/81091/

训练生成妹子图!!! (generate_pic项目)
	预处理:(都在open_nsfw里操作)
	解压图片包,然后都扔进 images 文件夹
	workon cv_for_py3 (个人pc是cv3)
	together_dir.py	//遍历images文件夹及所有深层子文件夹,把所有分散的.jpg都剪切到girls文件夹里
	minimize.py	//把girls里的图片都缩成统一规格小图片 存到little_girls文件夹里
	dereplication.py	//图片去重 (4万张,好慢!!!!)
	nsfw.py		//未操作此步,计划是筛选出限制级图片删掉,此步需要 在docker容器里执行
	训练并生成妹子图!!!
	gen_pic.py	//由于新版本tensor,所以会有一些格式问题,幸亏变动不大可以迅速处理
			//使用资源十分庞大,电脑无法动了!!!!








20170518
学习使用flask架构,建立网站!!
	建立对应python虚拟机吧,
	mkvirtualenv flask -p python3	
	workon flask
	安装
	pip install flask
	pip install flask-login
	pip install flask-openid
	pip install flask-mail
	pip install flask-sqlalchemy
	pip install sqlalchemy-migrate
	pip install flask-whooshalchemy
	pip install flask-wtf
	pip install flask-babel
	pip install guess_language
	pip install flipflop
	pip install coverage
	一次性安装:
	pip install flask flask-login flask-openid flask-mail flask-sqlalchemy sqlalchemy-migrate flask-whooshalchemy flask-wtf flask-babel guess_language flipflop coverage

hello项目:
	建立文件夹
	hello
	|--app
	|  |--static	
	|  |--templates
	|
	|--tmp	
	习惯上:
		app目录用来存放Python脚本，
		static目录用来存放图片、javascript脚本和css文件。
		templates用来存放模版，tmp存放临时文件
	app下建立 __init__.py 脚本:
		脚本创建了应用程序对象app（Flask对象），然后引入views（下面创建的脚本）。

		views用来处理客户端（浏览器）的请求，每个view可以映射一个或多个URL
	app下建立 views.py 脚本:
		route声明网站根目录/
		route声明／index的URL映射为index函数，每次收到主页请求就会执行这个函数
	hello下建立 run.py 脚本
	Flask默认使用5000端口，打开浏览器输入地址:	
	http://localhost:5000   #  或  http://localhost:5000/index 均可
	上面两个地址都在views.py中定义了，如果输入其他地址，会得到错误信息







20170522
iar win7 编译环境配置
usb串口驱动:使用的是台湾的pi2303芯片
win7的pi2303驱动安装:反正把sam9x35里的usb串口都装就是了,而且只能使用指定一格usb插口,换了擦插口就出错了
(恶心的处理)

sam9x35: (裸机使用iar)
首先,逻辑软件包不一定要安装到iar的指定目录,因为软件包是一个独立完整包,里面的例程可摆脱iar自带依赖,独立工作
弄清楚了 裸机demo里使用了ddram但没有使用mmu,
	但软件包提供了一个mmuinitial()参考:初始化一张地址表,然后启动mmu
裸机demo很多都是在ddram 0x20000000 地址上,使用linux上的bootstraps引导,
	但是bootstraps的复制还有跳转执行的地址要从 0x26f00000 改为 0x20000000
usb cdc 就是串口,但是如何收发需要烧录测试后才能搞清楚api的使用情况
cdc_hid例程的hid 主要是ek上没有用户按键!!使用了模拟键盘按键方式,
	当在edebug串口输入数字1,demo会模拟源源不断按下按键a,作为hid输入到打开的的空白文本里
	再在edebug串口输入数字1,demo会 停止 模拟源源不断按下按键a!!
cdc_hid例程的cdc
	原来例子main.c注册了两个串口,一个是usart0,一个是usb的cdc,(不算dbug),怪不得这么奇怪,
	在uart0输入内容,usbcdc接收到内容
	在usbcdc输入内容,uart0接收到内容
	注意 dbug虽然也是串口,但是在main.c之前就初始化好了的调试串口,
	至于这个debug串口在哪初始化和初始化过程并没有显性公开!但是printf()指向debug串口的.
jlink:
	昨日按照网上调了一个下午还是用不了jlink,今天终于弄好,原来就是重新打开iar,重新加载项目文件就好了
	重申jlink配置:
	开发板启动,正常nandflash启动就好了,不管启动时有没有程序执行都没关系,只要板子通着电
	jlink连开发板和win7,win7设备管理器usb处多出了一个j-link driver
	打开iar,打开项目,不管项目本身被规定在ddram还是nandflash运行都没关系,
	项目->options->debugger->setup->driver(j-link/j-trace) 其他默认
		     ->J-link/J-trace->connection->communication(usb device 0) 其他默认!!!
	(最好重启)重新打开iar,打开项目,于是就可以使用 download and debug了
	还有:
		如果项目简单,放在外围 nandflash 芯片的0x0地址时,开发板nandflash启动时会把程序拷到sram里执行
			jlink download and debug 时,会跳过从nandflash拷贝的过程,直接从sram的程序运行地址开始调试
		如果项目复杂,要在ddram里运行,那么程序先放在nandflash里,
			芯片先把外围 nandflash 芯片的0x0地址时bootstrap拷到sram里执行
			bootstrap再把这项目程序拷到ddram指定位置,然后跳到ddram里的项目程序开始处开始执行!!!
			jlink download and debug 时,会跳过从之前步骤,直接从ddram的项目程序开始处开始调试
	jlink调试原理:jlink模块监测pc指针位置,时刻把pc指针的指向上报,
		而插入断点就是在pc跳转下一条指令前插入一条操作指令,继续执行时,给pc插入本接着要执行的下条指令
		所以从原理看到jlink 调试中断操作,并不是太友好和易操作




20170523
sam9g25: (裸机使用iar, camera例子!!!)
cam接线:
 * <table>
 *   <tr> <th>isi module</th> <th>ISI</th>       <th>PIO</th> </tr>
 *   <tr> <td>1 </td>         <td>3v3</td>       <td>3v3</td> </tr>
 *   <tr> <td>2 </td>         <td>Gnd</td>       <td>Gnd</td> </tr>
 *   <tr> <td>3 </td>         <td>Vdd_isi</td>   <td>3v3</td></tr>
 *   <tr> <td>4 </td>         <td>Gnd</td>       <td>Gnd</td></tr>

 *   <tr> <td>5 </td>         <td>Rst</td>       <td>Pioa28</td></tr>
 *   <tr> <td>6 </td>         <td>Pwd</td>       <td>Pioa29</td></tr>
 *   <tr> <td>7 </td>         <td>Slc</td>       <td>Pioa31</td></tr>
 *   <tr> <td>8 </td>         <td>Sda</td>       <td>Pioa30</td></tr>

 *   <tr> <td>9 </td>         <td>gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>10</td>         <td>Isi_mck</td>   <td>Pc15</td></tr>
 *   <tr> <td>11</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>12</td>         <td>Isi_vsync</td> <td>Pc13</td></tr>
 *   <tr> <td>13</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>14</td>         <td>Isi_hsync</td> <td>Pc14</td></tr>
 *   <tr> <td>15</td>         <td>Gnd</td>       <td>gnd</td></tr>
 *   <tr> <td>16</td>         <td>Isi_pck</td>   <td>Pc12</td></tr>
 *   <tr> <td>17</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>18</td>         <td>Isi_d0</td>    <td>Pc0</td></tr>
 *   <tr> <td>19</td>         <td>Isi_d1</td>    <td>Pc1</td></tr>
 *   <tr> <td>20</td>         <td>Isi_d2</td>    <td>Pc2</td></tr>
 *   <tr> <td>21</td>         <td>Isi_d3</td>    <td>Pc3</td></tr>
 *   <tr> <td>22</td>         <td>Isi_d4</td>    <td>Pc4</td></tr>
 *   <tr> <td>23</td>         <td>Isi_d5</td>    <td>Pc5</td></tr>
 *   <tr> <td>24</td>         <td>Isi_d6</td>    <td>Pc6</td></tr>
 *   <tr> <td>25</td>         <td>Isi_d7</td>    <td>Pc7</td></tr>
 *   <tr> <td>26</td>         <td>Isi_d8</td>    <td>Pc8</td></tr>
 *   <tr> <td>27</td>         <td>Isi_d9</td>    <td>Pc9</td></tr>
 *   <tr> <td>28</td>         <td>Isi_d10</td>   <td>Pc10</td></tr>
 *   <tr> <td>29</td>         <td>Isi_d11</td>   <td>Pc11</td></tr>
 *   <tr> <td>30</td>         <td>Gnd</td>       <td>gnd</td></tr>
 * </table>
经观察:
	ov2640只有10针数据线,虽然上面isi初始化了11针数据线,但到头来最多只使用其中10针
	还有,ov2640默认数据传输是10针高位模式,而demo里也是设置使用10针高位模式,
	也就是 ov2640 的 D0~D9 应接 9g25 的 isi_d0~isi_d9
	我们买回来的ov2640模块!!
		alientek 的软件源码要求是 10针低位模式,即 ov2640 D9~D0接 isi_d0~isi_d9,
			所以模块数据针标注反过来了,本来 D2-D9 的针,他们标成 D7~D0
		waveshare 直接从数据针标注知道要求是 8针高位模式, 即 ov2640 D2~D9接 isi_d0~isi_d7,
	由于我们 wavesahre做的模块 只有D2~D9,所以 D2~D9 接 isi_d2~isi_d9 试试看,
					    所以 D2~D9 接 isi_d0~isi_d7 试试看,
然后是关于demo的设计,从camera获取一张yuv,放到指定位置,然后压缩成一张jpg然后通过usb串口传输图片!!!
	目前,获取图片和压缩图片的思路都从sam4s里得到启发了,剩下的就是发送一张图片到pc端!!
	明天写一个单片机程序,接受串口传输的一个txt文本,并打印出来!
	jpg文件的文件结束符是 ff d9 所以传输文件检测到ffd9就表示结束!!!!
	然而 .txt文件没有结束符,所谓文件末就是不再有数据,已经到达数据未!!








20170527
编写 ubuntu 串口上位机程序!!! (sam9x35)
特别注意 串口中使用的多路复用 与开发板的edbg串口有严重冲突!!!容易造成 开发板的edbg跑偏不工作
附加:重和备份window
重装win7后 安装了vs2015后,使用winpe2013备份了c盘到移动硬盘里
注意备份的软件做了手脚,会自动给备份的系统装上了360卫士,还原系统后手动删掉就好了,使用unlocker解锁所有360文件,直接整个文件夹删掉
还有,cmd->msconfig里禁用360的开机启动服务!!!
关于pi2303串口模块win7安装的注意事项!!!!
	一定要先装光盘提供的旧版驱动!!!
	断开网络连接后再插入usb串口,等待绑定完成
	如果不断网插入,则会自动网上寻找并安装新版驱动,而新版驱动并不能用!!!
vs2015无法找到 stdio.h 等文件:
	项目->XXX属性->配置属性->VC++目录->包含目录:添加
		C:\Program Files %28x86%29\Windows Kits\10\Include\10.0.15063.0\ucrt
	项目->XXX属性->配置属性->VC++目录->库目录:添加
		C:\Program Files %28x86%29\Windows Kits\10\Lib\10.0.15063.0\ucrt\x86;$(LibraryPath)
	另一个方法(不可行):新建win32console程序时,向导不要勾选:预编译头,安全开发生命周期(SDL)检查
vs2015项目->属性 ->配置属性什么都没有!!
	新建一个例如是cpp文件.然后删掉,然后 项目 出现了 xxx属性 里面的配置属性就什么都有了	
关于win7 X64安装usb设备驱动 笔记:
	经过学习知道.inf 文件是一个 执行脚本文件,
		注册一个 usb驱动脚本 文件到系统,
		usb线连接设备和pc
		win7自动按照脚本联网匹配已注册到微软上的usb驱动,下载下来并安装!!!
		成功后即可使用
	而atmel提供的sam9x35例程包的提供的 usb驱动脚本 是面向 x86系统的,
	要想面向 x64系统,需要修改脚本!!!
以下附上修改前后的两个.inf脚本区别!!(拷贝成两份用meid查看比较方便)
/*****************************************************   适合x32的inf   **************************************************************/
; $Id: 6119.inf,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $

[Version]                                                       ; Version section
Signature="$Chicago$"                                           ; All Windows versions
Class=Ports                                                     ; This is a serial port driver
ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}                ; Associated GUID
Provider=%ATMEL%                                                ; Driver is provided by ATMEL
DriverVer=09/12/2006,1.1.1.5                                    ; Driver version 1.1.1.5 published on 23 February 2007

[DestinationDirs]                                               ; DestinationDirs section
DefaultDestDir=12                                               ; Default install directory is \drivers or \IOSubSys

[Manufacturer]                                                  ; Manufacturer section
%ATMEL%=AtmelMfg                                                ; Only one manufacturer (ATMEL), models section is named
                                                                ; AtmelMfg

[AtmelMfg]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[USBtoSer.Install]                                              ; Install section
include=mdmcpq.inf
CopyFiles=FakeModemCopyFileSection
AddReg=USBtoSer.AddReg                                          ; Registry keys to add are listed in USBtoSer.AddReg

[USBtoSer.AddReg]                                               ; AddReg section
HKR,,DevLoader,,*ntkern                                         ;
HKR,,NTMPDriver,,usbser.sys
HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"

[USBtoSer.Install.Services]                                     ; Services section
AddService=usbser,0x00000002,USBtoSer.AddService                ; Assign usbser as the PnP driver for the device

[USBtoSer.AddService]                                           ; Service install section
DisplayName=%USBSer%                                            ; Name of the serial driver
ServiceType=1                                                   ; Service kernel driver
StartType=3                                                     ; Driver is started by the PnP manager
ErrorControl=1                                                  ; Warn about errors
ServiceBinary=%12%\usbser.sys                                   ; Driver filename

[Strings]                                                       ; Strings section
ATMEL="ATMEL Corp."                                             ; String value for the ATMEL symbol
USBtoSerialConverter="AT91 USB to Serial Converter"             ; String value for the USBtoSerialConverter symbol
USBSer="USB Composite Serial Driver"                            ; String value for the USBSer symbol

/*****************************************************   适合x32的inf   **************************************************************/
-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------
/*****************************************************   适合x64的inf   **************************************************************/
; $Id: 6119.inf,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $

[Version]                                                       ; Version section
Signature="$Chicago$"                                           ; All Windows versions
Class=Ports                                                     ; This is a serial port driver
ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}                ; Associated GUID
Provider=%ATMEL%                                                ; Driver is provided by ATMEL
DriverVer=09/12/2006,1.1.1.5                                    ; Driver version 1.1.1.5 published on 23 February 2007

[DestinationDirs]                                               ; DestinationDirs section
DefaultDestDir=12                                               ; Default install directory is \drivers or \IOSubSys

[Manufacturer]                                                  ; Manufacturer section
%ATMEL%=AtmelMfg,NT,NTia64,NTAMD64                              ; Only one manufacturer (ATMEL), models section is named
                                                                ; AtmelMfg

[AtmelMfg]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NT]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NTia64]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NTAMD64]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[USBtoSer.Install.NTAMD64]                                              ; Install section
include=mdmcpq.inf
CopyFiles=FakeModemCopyFileSection
AddReg=USBtoSer.AddReg                                          ; Registry keys to add are listed in USBtoSer.AddReg

[USBtoSer.AddReg]                                               ; AddReg section
HKR,,DevLoader,,*ntkern                                         ;
HKR,,NTMPDriver,,usbser.sys
HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"

[USBtoSer.Install.NTAMD64.Services]                                     ; Services section
AddService=usbser,0x00000002,USBtoSer.AddService                ; Assign usbser as the PnP driver for the device

[USBtoSer.AddService]                                           ; Service install section
DisplayName=%USBSer%                                            ; Name of the serial driver
ServiceType=1                                                   ; Service kernel driver
StartType=3                                                     ; Driver is started by the PnP manager
ErrorControl=1                                                  ; Warn about errors
ServiceBinary=%12%\usbser.sys                                   ; Driver filename

[Strings]                                                       ; Strings section
ATMEL="ATMEL Corp."                                             ; String value for the ATMEL symbol
USBtoSerialConverter="AT91 USB to Serial Converter"             ; String value for the USBtoSerialConverter symbol
USBSer="USB Composite Serial Driver"                            ; String value for the USBSer symbol
/*****************************************************   适合x64的inf   **************************************************************/










20170601
通过串口程序系统学习MFC程序!!!
MFC项目 AAXX 的运作流程:
	新建过程向导会:
		自动生成 AAXX.h: 声明继承CWinApp的CAAXXApp类 和 CAAXXApp 类变量 theApp
		自动生成 AAXX.cpp:
初步看了看CSerialPort的类,发现,这个使用了一个线程监控串口情况,然后接收到的内容使用sendmessage方法传递!!
	但是 sendmessage 只对交互窗口类操作!!
	调用::sendmessage 之前加:: 表示使用的是全局范畴上的 sendmessage函数
	但是有一个问题:使用sendmessage一定是把信息传给窗口类的,
	所以只能用MFC框架了,不能用非交互窗口的了,因为这样要修改 CSerialPort的类 污染了,变得不再通用!!
	大概懂了,在人家串口程序的基础上加传输文件内容的就行,也找到接受数据的执行函数!!
通过从串口工程添加传输文本文件发现
	本来打算用Cfile类,在一个线程上构建书写文件,
	最后发现,写入的文件内容后,如果线程不退出,即使执行了.close函数也不会成功
	注意学习了如何建立线程!!!
	还没有测试如何 使用 sendmessage 框架
	本以为串口传文件应该是直接数据传输的,但原来是通过数据握手协议传输的,所以要找到文件传输协议才行
	串口程序的发送功能有问题,只能发一遍
		










20170612
发现ov2640 的i2c协议,与9g25-ek的默认的使用的不一样,硬件协议不一样,,
静止时,9g25 slc是高电平,sda是高电平, 插上ov2640的i2c接口后,sda变低电平!!,
后来发现,并不是这么一回事,,
原因是我使用jlink调试,而开发板上电时默认启动自带linux程序!!!
由于不知道linux程序初始化时做了什么,后面用jlink调试 ov2640 时,i2c初始化时出错!!
总之 使用ov2640 作为sam9g25-ek 的 usbcamera的功能没有问题!!!








20170613
分析sam9g25-ek_usb设备的初始化实现过程,学习usb从设备一般的实现思路
首先,9g25 usb_camera 探索如何变成200万像素相机,
初始化阶段,虽然_ConfigureOvpins()标榜配置迎合ov芯片的针口 ,
	理论只需要8位data并线,但实际上,直接把12位data并线都一并初始化了!!!
_Configureisi配置了缓存,DMA等资源,还有中断函数
ov_init()通过i2c设置sensor芯片!!!!
	用jlink测试时,特别是i2c通讯传输数据实际执行处,不能分步执行,i2c模块会从此崩溃不再工作!!
	就是所 ov_id(),ov_Manufacturer(),ov_TestWrite()一步跳过,不要逐步边执行便分析!!
	其实还没有配置摄像头的工作配置,就是读取了一些摄像头厂商信息和产品码,核对..
USBPower_Configure()然后开始配置usb,首先是配置usb电源管理,就是Vbus
	9g25有三个usb口,虽然我们使用USB-A口,但A,B,C口的Vbus针全配置个遍
USBDDriver_Initialize
	分配空间存储一系列descriptors信息,
USBD_init()
	USBD_HAL_Init(),usb硬件模块的初始化
		初始化DMA
		初始化usb-peripheral-clock
		初始化所有 endpoint 
		D+ usb串口线加上拉电阻
		reset UDPHS
		打开PMC的usb模块工作时钟,usb模块开始工作
		进一步初始化每个endpoint 的 DMA
		设定 usb normal (根据实际 转换 fullspeed 12mbs 或者 hight-speed 480mhz )模式,不要被开头说明force fullspeed迷惑!!!!!
		配置 usb 的 wakeup endofrsm det_suspd 中断 
		关闭PMC的usb模块工作时钟,usb模块暂停工作
	USBDCallbacks_Initialized() 配置中断函数,并打开中断
VBus_Configure配置vbus针的中断处理函数,
	VBus_Configure 不能逐步执行,不然容易崩溃
	此刻后,usb的配置全部完成,一旦有usb线连接pc和开发板,vbus针电压发生变化触发Vbus中断,
	usb便开始工作,把自己的一些列descriptors信息传到pc
	while (USBD_GetState() < USBD_STATE_CONFIGURED);如果没有连到pc,mian一直卡在这里,目的就是等待链接,
	连接后,才开始 while(1) 循环内容
	中途断开,开发板主程序依然在 while(1) 循环,重新连接后可继续正常工作
然后while(1)循环
	if (bVidON && !bVideoON) {} 这一段语句并没有执行过,直到usb软件关闭,不再使用摄像头
	if (!bVidON && bVideoON) () 
		当usb连上了,而且被usb软件开启摄像头,才执行这一段语句
		_PreviewMode();
			其中的ov_configure()才是用i2c配置摄像头工作的真正函数		
     	        USBD_HAL_SetTransferCallback(VIDCAMD_IsoInEndpointNum, (TransferCallback)VIDD_PayloadSent, 0);
         	VIDD_PayloadSent(NULL, USBD_STATUS_SUCCESS);
		这段if实现了i2c配置摄像头,和开始拍照传输的真正工作,瞬间实现i2c配置,然后工作
		但是我们打开usb摄像头软件是,却要等待一段时间的初始化,那是usb与pc的多次轮询初始化有关!!!

当usb摄像头软件,指定要打开usb摄像头时,
	usb软件会给usb发送多次配置请求,每次接收到了配置请求都会触发中断函数处理请求
	USBDCallbacks_RequestReceived是被触发的中断程序
	VIDD_GetCUR 是pc提出获取当前CUR的请求,对应地,开发板通过 usb_write 回送对应的信息
	VIDD_SetCUR 是pc提出设置开发CUR的请求,对应地,开发板通过 usb_read 向pc获取具体设置内容,
		    然后在下一次接收到pc传来的数据后,执行VIDD_StatusStage,进行具体设置

	VIDD_GetDEF 是pc提出获取DEF的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetINFO 是pc提出获取INFO的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetMIN 是pc提出获取MIN的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetMAX 是pc提出获取MAX的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetRES 是pc提出获取RES的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	怪不得,usb配置这一块浪费这么多时间,原来是因为一些请求超时!!
	比起无视请求,或者可以选择接着发一个USBD_Write(0,0,0,0),来结束这次请求通讯!!(未测试!!)

usb摄像头打开摄像头时,dbug输出的log:
	-- SAM9XX5-EK
	-- Compiled: Jun 13 2017 17:35:16 --
	-E- Do nothing: MMU not enabled
	-I- VBus configuration
	-I- conn
	Susp Susp Vid GetCUR(26) VS PROBE 
	Vid GetMax(1,100,26)
	
	Vid GetMin(1,100,26)
	
	Vid SetCUR(26) VS PROBE 
	Vid GetCUR(26) VS PROBE 
	Vid GetMax(1,100,26)

	Vid GetMin(1,100,26)
	
	Vid SetCUR(26) VS PROBE 
	Vid GetCUR(26) VS PROBE 
	Vid SetCUR(26) VS COMMIT -W- UDP_Stall: EP0 locked 	//锁住了endpoint0, 也就说不能在做设置!!
	
	vidS
	FR USB:  53; ISI:  16
	
	//经历了getcur setcur 等等枚举过程后,最后setcur 上的commit协商结果,然后就setinterface 然后开始同步传输 
	
320x240修改成640x480 模式 需要改frmW frmH,
在定义frmW frmH 定义的位置赋值 640,480 并不起作用,原因是后续会更改此数值!!! 
追踪到 VIDD_StatusStage()处的 viddProbeData.bFrameIndex 导致修改了 frmW frmH
然而也不可以在定义 viddProbeData 赋值修改,因为 viddProbeData中途还是被改了!!!
后来甚至发现 viddProbeData 的参数,最后又usb摄像头软件传输过来的数据告诉的,,??
经过测试发现,原来分辨率 和 帧率 还有图片格式的选择最终是通过 usb摄像头程序 发送请求来选择的,
手动设置参数斌没有用,甚至会破坏配置,
而我之间的的摄像头软件只能配置320x240的设置
换了功能更全的摄像头软件,就可以手动配置可供选择的分辨率了!!!

接下来要探究,usb摄像头数据传输实践
不管是数据帧 与 请求设置帧,都使用
	要分析多个函数 USBD_Read  USBD_Write VIDD_PayloadSent
		USBD_Read() -> USBD_HAL_Read() -> UDPHS_Read()
		USBD_Write() -> USBD_HAL_Write -> UDPHS_Write()
		VIDD_PayloadSent -> USBD_HAL_WrWithHdr
	分析发现 USBD_HAL_WrWithHdr() UDPHS_Read() UDPHS_Write() 才是usb传输数据的实现函数
	传输的步骤无非是填充DMA,然后开中断.

接下来是探究,摄像头的图像采集.
	ISI_IrqHandler 处理每一次isi中断,如果接收到新图片数据,会把图片指针指向新图片数据地址
	        S_Video.lcd_fb_addr = FbList[S_Video.IsiPrevBuffIndex].Current;
		否则会留在旧图片地址处,
	然而VIDD_PayloadSent() 源源不断地发送图片流数据,它并不关心传输的图片数据是旧的还是新的.


先处理中断处理程序!!!
	USBDDriverCallbacks_InterfacesettingChanged() 处理 bVideoON 标记
	USBDDriver.c -> setInterface() 调用 USBDDriverCallbacks_InterfacesettingChanged()
	USBDDriver.c -> USBDDriver_RequestHandler() 调用 setInterface()
	usb_video_isi.c -> USBDCallbacks_RequestReceived() 调用 USBDDriver_RequestHandler()
	core.c -> USBD_RequestHandler() 调用 USBDCallbacks_RequestReceived() 
		USBDCallbacks_RequestReceived() 也 处理 GET_CUR SET_CUR 相关的请求!!!!!
	USBD_HAL.c -> UDPHS_EndpointHandler 调用 USBD_RequestHandler()
		UDPHS_EndpointHandler 是大boss,所有接收到的usb数据包都会触发这个中断函数,主要有4个内容:
		IN packet sent: 发出去的内容,得到了回复.
		out packt received: 得到host端传来的数据包!!!
		stall sent : 关闭端点的请求发出后,返回的回复!!
		setup packet received: 收到设置包内容,就是典型的 0端口,发来的各种设置请求!!!
		
	
关于CUR内容!!
	viedo 的 CUR内容是指此刻的 数据流 设定内容 !!!!分两种,
	一种是probe,即枚举设定: 就是详细的设置内容: _USBVideoProbeCommiData,例如!!
		/** Probe & Commit Controls */
		static USBVideoProbeData viddProbeData =
		{
		    0, /* bmHint: All parameters fixed: sent by host */
		    0x01,   /* bFormatIndex: Format #1 */
		    //0x01,   /* bFrameIndex: Frame #1 */
		    //by william
		    0x2,   /* bFrameIndex: Frame #1 */
		    FRAME_INTERVALC(4), /* dwFrameInterval: in 100ns */
		    0, /* wKeyFrameRate: not used */
		    0, /* wPFrameRate: not used */
		    10000, /* wCompQuality: highest */
		    0, /* wCompWindowSize: ?K */
		    100, /* wDelay: Internal VS latency in ms */
		    FRAME_BUFFER_SIZEC(800, 600), /* dwMaxVideoFrameSize: in bytes */
		    640//FRAME_PACKET_SIZE_HS /* dwMaxPayloadTransferSize: in bytes */
		};
	另一种是commit,可以理解为 视频流接口的设定!!,
		可以有多个视频流接口,一般指对应多个摄像头,每个视频流都有自己的setting,
		不过这个setting只是一个 8位数据, 并不知道是什么类型的 setting 内容
		
	GET_CUR 是往pc USBD_Write()数据 例如:
		USBD_Write(0, &viddProbeData, len, 0, 0);(端口,地址,长度,callback函数,callback函数参数)
		往0端口写入 放在&viddProbeData地址且长度为len的内容 
		然后由于callback函数和函数参数为零,使用write后,不执行callback函数!!
	SET_CUR 是从pc USBD_Read()入数据 例如:
		USBD_Read(0, pControlBuffer, len, (TransferCallback)VIDD_StatusStage, 0);(端口,地址,长度,callback函数,callback函数参数)
		从0端口读入长度为len的数据, 放入 pControlBuffer地址, 读后执行VIDD_StatusStage函数!!!
	 	VIDD_StatusStage函数最后会 USBD_Write(0,0,0,0)结束 当下这阶段的通讯
		注意!!
		SET_CUR 设置了 commit 类 参数时,禁止了 endpoint0 的工作!!!
	总的说,9g25只是响应了 CUR 的请求!!,其他请求都无视掉!!!
	关于 cur 有许多误解,在后面的 UVC 笔记中解决

关于isi 的 USBDCallbacks_RequestReceived()
	处理处理 GET_CUR SET_CUR 的这些 videorequest 分支外,
	还有 STD request 这分支:而这分支估计就是做 然而似乎并不是实现一个,多个uvc标准命令的地方!!!
	STD request:包括 
		获取 usb各种内容描述结构符,在usb插入后枚举阶段的工作
		设置 usb设备地址
		获取/设置 configuration 在usb插入后枚举阶段的工作
			usb插入枚举过程中可能选着其中一个configure: configurationDescriptorsHS和configurationdescriptorsFS
		获取/设置 设备/端点 的status
		设置/清除 远程wakeup/端点关闭与否 的特征feature
		获取/设置 接口interface (在这里的接口指的是 视频流输出的接口)
sp2519补充:
	有三个电源针!! 
		AVDD 2.8v 片内模拟电路供电
		DVDD 1.5v 片内数字逻辑电路供电
		DOVDD 1.8~3.3V I/O控制电路供电,I/O电路一般为开漏电路,所以电源可以按照实际情况选择具体值
			I/O电路就是使用I/O针与其他芯片进行通讯,I/O使用的逻辑电平与供电值有关!!
			如果I/O逻辑1是3.3V,哪么要求控制电路电源是3.3V
			(sp2519的摄像头逻辑电平是3.3V的,所对应的这边的I/O电路也需要3.3v的电压)
开漏电路拓展:
	开漏电路概念中提到的“漏”就是指MOSFET的漏极。
	同理，开集电路中的“集”就是指三极管的集电极。
	开漏电路就是指以MOSFET的漏极为输出的电路。
	一般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件和开漏上拉电阻组成








20170614
分析sam9g25-ek_usb cdc_hid设备的初始化实现过程,继续学习usb从设备一般的实现思路
首先,程序除了初始化一个usb串口外,还需要另外一个串口配合工作
首先 usb设备部分的初始化:
	CDCHIDDDriver_Initialize()
然后测试cdc工作:
	pc给串口usart发送一个字符,usart收到后,会递交给usb串口cdc,让cdc往pc发送字符,
		即pc -> _UsDmaRxCallback -> cdc转发回pc(透过TC中断) ->_UsartDmaRx(重置usart read DMA)
	pc给usb串口cdc发送一个字符,cdc收到后,会递交给usb串口cdc,让cdc往pc发送字符,
		即pc -. _UsbDataReceived -> _UsartDmaTx(usart发数据) -> _UsDmaTxCallback(重置usbcdc 的接收数据中断)
测试hid:
	每次循环都会执行 _HIDDKeyboardProcessKeys()处理hid操作,
	而真正传递按键动作是其中的 HIDDKeyboard_ChangeKeys,其中的 USBD_Write()







20170619
移植sp2519:根据ov2640
阅读sp2519 daatasheet,记录关键:
	Rolling shutter:卷帘快门,其实就是逐行扫描采集像数数据
	Support UXGA (2Mega, 1600x1200) resolution
	Support 720P (0.9Mega, 1280x720) resolution
	Support SVGA (0.48Mega, 800x600) resolution
	RGB to YUV Conversion
	YUV to RGB Conversion
	传感器1600x1200外围还有一些多余的像数点,用来其他作用.所以实际像数区域是1628x1252,
		例如最底下20行像数用于 Black Level Calibration 黑电平校准,
	黑电平校准指在不同曝光环境下,采集颜色的电路电流都有区别,最典型拿黑色采集为例,所以需要电流校准
	i2c:
	The write device address is 60H and the read device address is 61H
	关键寄存器内容: (page 28 of datasheet)
		sp2519把控制寄存器放在了4个page里,需要先选择page,再选择寄存器地址!!
		P0:0x02	chip ID	0x25
		P0:0xa0	chip ID	0x19
		0xfd  page select   00:page0,01page1,10page2,page3
		P1:0x36 yuv输出时,开关 H和V 信号开关, 还有选择yuv的输出模式
		P1:0x35 yuv输出格式的排序模式, YUYV? UYVY? 
		P0:0x3f	关于 镜向 和上下翻转输出模式的设置 !!! mirror和flip 
	只能输出 RAW 和YUV422 两种格式
阅读sp2519 MTKdriver c文件,记录关键:
	通篇没有插入内核的内容和与内核框架接口的函数
	通篇都是i2c初始化,或修改参数对的函数内容
	关于图像传输,或者终端处理函数什么的都没有一点踪迹
	其实与内核相联系的是 kd_camera 驱动框架的事情,而sp2519yuv_Sensor.c只是驱动框架上的一部分内容
阅读atmel 提供的 ov2640.c文件,记录关键点:
	同样发现,ov2640.c是属于 soc_camera 驱动框架的某篇具体内容




补充:
cmos sensor 的 ISP(in sensor process)(片上执行模块) 有:
	黑电平校准指在不同曝光环境下,采集颜色的电路电流都有区别,最典型拿黑色采集为例,所以需要电流校准
	AE:自动亮度调节,不同环境下的曝光度调节
	AWB: (自动白平衡)是传感器对在光线不断变化环境下的色彩准确重现的能力表示
	GMAAM:伽玛校正,也叫对比度校正
	工频干扰 (Banding):传感器采集采取逐行扫描,而日光灯,显示屏都是50-60Hz频闪,给图像采集产生flicker条纹,所以需要做规避工频处理
	Chief Ray Angle:CRA 主光角
	Lens shading: 亮度矫正,因为光镜学成像,所以中间向四周亮度不断减少,所以需要矫正,让输出图片的色彩是匀称的!!! lens是镜头
	BPC: bad pixel correction 坏像数点矫正
	DVP: 就是传统的 图像并口数据传输协议
	MIPI: 超高速的 图像串口数据传输协议
	iris: 光圈!!曝光栅孔
	zoom: 缩放
	pantilt: PAN&TILT两维数控转台是一种能够同时绕铅垂轴和水平轴旋转的机械工作台，简称PT转台

RAW:格式!!也是cmos的采集格式!!!注意,与RGB有天大的差异!!!
	RAW格式是,每个像数点pixel只采集RGB三色中其中一种颜色!!!!
	即没个每个像数点只有一种颜色的数值
	RGB不一样,RGB 是一个像数点pixel有RGB三种颜色的数据!!!
	YUV什么的也是一个像数点含有YUV三个参数的像数点格式
	RAW的像数点排布是这样的:
		R,G,R,G,R,.....
		G,B,G,B,G,.....
		R,G,R,G,R,.....
		G,B,G,B,G,.....
	RGB的像数点排布是这样的:
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
	YUV的像数点排布是这样的:
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
RGB:红绿蓝三色 像数点格式
YUV:Y亮度+UV两个描述色彩的 像数点格式
	YUV和RGB的转换:
	Y = 0.299 R + 0.587 G + 0.114 B
	U = -0.1687 R - 0.3313 G + 0.5 B + 128
	V = 0.5 R - 0.4187 G - 0.0813 B + 128
		R = Y + 1.402 (V-128)
		G= Y - 0.34414 (U-128) - 0.71414 (V-128)
		B= Y + 1.772 (U-128)
YCbCr: YUV的一个最广泛使用的分支格式,JPEG、MPEG均采用此格式,一般人们所讲的YUV大多是指YCbCr
	YCbCr与RGB的相互转换
	Y=0.299R+0.587G+0.114B
	Cb=0.564(B-Y)
	Cr=0.713(R-Y)
	R=Y+1.402Cr
	G=Y-0.344Cb-0.714Cr
	B=Y+1.772Cb
YUV（YCbCr）采样格式：
主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。
其中YCbCr 4:1:1 比较常用，其含义为：每个点保存一个 8bit 的亮度值(也就是Y值), 
	每 2 x 2 个点保存一个 Cr和Cb值, 图像在肉眼中的感觉不会起太大的变化。
	所以, 原来用 RGB(R,G,B 都是 8bit unsigned) 模型, 每个点需要 8x3=24 bits， 
	而现在仅需要 8+(8/4)+(8/4)=12bits, 平均每个点占12bits。这样就把图像的数据压缩了一半。
下面给出几种具体的存储形式：
（1） YUV 4:4:4
	YUV三个信道的抽样率相同，因此在生成的图像里，每个象素的三个分量信息完整（每个分量通常8比特），
	经过8比特量化之后，未经压缩的每个像素占用3个字节。
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3
（2） YUV 4:2:2
	每个色差信道的抽样率是亮度信道的一半，所以水平方向的色度抽样率只是4:4:4的一半。对非压缩的8比特量化的图像来说，
	每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存(例如下面映射出的前两个像素点只需要Y0、Y1、U0、V1四个字节)。
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 Y1 V1 Y2 U2 Y3 V3
	映射出像素点为：[Y0 U0 V1] [Y1 U0 V1] [Y2 U2 V3] [Y3 U2 V3]
（3） YUV 4:1:1
	4:1:1的色度抽样，是在水平方向上对色度进行4:1抽样。对于低端用户和消费类产品这仍然是可以接受的。
	对非压缩的8比特量化的视频来说，每个由4个水平方向相邻的像素组成的宏像素需要占用6字节内存
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 Y1 Y2 V2 Y3
	映射出像素点为：[Y0 U0 V2] [Y1 U0 V2] [Y2 U0 V2] [Y3 U0 V2]
（4）YUV4:2:0
	4:2:0并不意味着只有Y,Cb而没有Cr分量。它指得是对每行扫描线来说，只有一种色度分量以2:1的抽样率存储。
	相邻的扫描行存储不同的色度分量，也就是说，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是4:2:0...以此类推。
	对每个色度分量来说，水平方向和竖直方向的抽样率都是2:1，所以可以说色度的抽样率是4:1。
	对非压缩的8比特量化的视频来说，每个由2x2个2行2列相邻的像素组成的宏像素需要占用6字节内存。
	下面八个像素为：
		[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
		[Y5 U5 V5] [Y6 U6 V6] [Y7U7 V7] [Y8 U8 V8]
	存放的码流为：
		Y0 U0 Y1 Y2 U2 Y3
		Y5 V5 Y6 Y7 V7 Y8
	映射出的像素点为：
		[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]
		[Y5 U0 V5] [Y6 U0 V5] [Y7U2 V7] [Y8 U2 V7]









20160622
调整测试环境(使用 sama5d4开发板)
先建立一个 for_sp2519_project 的 专门调试 sp2519 驱动的项目文件夹
at91bootstrap-sama5d4_xplained.bin  //原demo提供的
u-boot.bin	//uboot1编译出的
.dtb	//kernel1最后编译的
zImage	//kernel1最后编译的
rootfs  //之前的编译的rootfs没一个适用,需要重新编译buildroot,只需要gstreamer相关库就行,不需要 tslib和qt
	//编译出来.ubi大小才14mb
	//傻逼了,重新设置编译,忘了先备份已经下好的 dl软件包!!!!!
	//注意:
	//	rootfs1是用于生成一个rootfs的实验!!!
	//	rootfs2是官方demo的,用来实现解压ubi和重新编译ubi的实验
	//	rootfs3的并没有安装gstreamer,只是可以测试touchscreen,和QT的
成功运行ov2640摄像头并显示!!!
测试环境通过;
后面就是修改测试 sp2519的摄像头驱动了!!!!
首先修改 ov2640 框架直接对sensor操作的函数
	sp2519_write_array i2c队列写的				感觉不用改
	sp2519_mask_set 构造具体数值,i2c写入			暂时用不着
	sp2519_reset	i2c写入控制 芯片重启!!			已改
	sp2519_select_win 选择窗口大小				感觉不用改
	sp2519_set_params 调用 sp2519_write_array		感觉要大改!!!!!!
		首先ov2640是可以以多种格式传输的,RGB YUV RAW
		而sp2519 只可以yuv和raw格式传输,所以并没有专门的这样的函数设计
		主要看传输格式的变化!!!
		要清楚都干了什么的话,需要分析他们的寄存器初始化操作!!!
		ov2640:
			其实也就是设置了IMAGE_MODE 而已,其他的只是做了延时处理
	sp2519_s_ctrl i2c写入控制 选择是否对图像镜向翻转操作	已改
至此,驱动文件的修改大致完成:
接着 修改内核配置添加 sp2519,按照之前弄ov7670那样配置,
接着,为了提高调试效率!!先录下使用ov2640时的log消息:









20160628
几经波折,终于可以使用I2C
	读取productID 这一步是,芯片通 mck后, 的第一次 设置配置操作
	然而芯片还没有完全动起来,就用i2c会导致失败
	所以在sp2519_video_probe 使用i2c之前,先延时一段时间, msleep(5);
开始初始化,在i2c第 442 条配置后,开始出错
	第442条初始化是启动 VS 信号 输出data
	但是一个问题是,一旦启动了VS信号后,就会干扰到i2c,使得i2c不能正常工作!!!!
	所以要在所有设置都完成后才output图像!!!
	比如我是在init_array最后才设置output_on,但是似乎是错误的,因为除了init_array后还有其他i2c设置
		因为init后也有其他的初始化!!!!
		然而很意外地成功运行了,但是失真严重,而且640X480 只有11.5帧,
			而且是在探针接到h v 信号时,阻挡了一些干扰i2c的成分,让i2c可以继续设置,才成功运行
	不过总算成功了,所以也证明了以下一些内容:
		做出来的电源可用,thank goodness
		对于fpc那25针的次序排列并没有错封装 sp2519的D2~D9,接sama5d4的D0~D7
		i2c的时钟数据触发等所有特性都可以沿用 ov2640了
		还有 h v信号的特性也 与 ov2640 一样,
		还有 datasheet 说用24mhz,但是sama5d4只能用25mhz的,然而勉强可用,
	但是不知道,是不是时钟的原因导致失真,
	也不知道,哪里设置了帧数率
接下来就是分析gstreamer软件的调用,具体去分析摄像头驱动是怎么被调用的!!!!!
	特别是要知道,图像是怎么源源不断进来的机制!!!!!
				





20160629
/**log**/
# gst-launch v4l2src device="/dev/video0" ! video/x-raw-yuv,width=640,height=480
 ! ffmpegcolorspace ! fbdevsink
Setting pipeline to PAUSED ...
CPU: 0 PID: 727 Comm: gst-launch-0.10 Not tainted 4.1.0-linux4sam_5.3 #313
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c034001c>] (soc_camera_open+0x18/0x2d4)
[<c034001c>] (soc_camera_open) from [<c03248a8>] (v4l2_open+0xa0/0xe0)
[<c03248a8>] (v4l2_open) from [<c0098958>] (chrdev_open+0xa0/0x140)
[<c0098958>] (chrdev_open) from [<c0093858>] (do_dentry_open.isra.11+0xe8/0x2e8)
[<c0093858>] (do_dentry_open.isra.11) from [<c009f460>] (do_last.isra.43+0x4cc/0xb9c)
[<c009f460>] (do_last.isra.43) from [<c00a0f48>] (path_openat+0x7c/0x520)
[<c00a0f48>] (path_openat) from [<c00a2140>] (do_filp_open+0x2c/0x80)
[<c00a2140>] (do_filp_open) from [<c009495c>] (do_sys_open+0x110/0x1cc)
[<c009495c>] (do_sys_open) from [<c000f360>] (ret_fast_syscall+0x0/0x3c)
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
clk_sam9x5_peripheral_enable
ov2640 0-0030: ov2640_reset: (ret 0)
ov2640 0-0030: ov2640_set_params: Init default
ov2640 0-0030: ov2640_set_params: Set size to SVGA
ov2640 0-0030: ov2640_set_params: Set cfmt
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: current_fmt->fourcc: 0x56595559
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 640x480)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 640x480)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
ov2640 0-0030: ov2640_reset: (ret 0)
ov2640 0-0030: ov2640_set_params: Init default
ov2640 0-0030: ov2640_set_params: Set size to VGA
ov2640 0-0030: ov2640_set_params: Set cfmt
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd41c1030
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb6802000, size=614400, ret=0
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd41bcfa8
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb676c000, size=614400, ret=0
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
/**log**/
gstreamer先学着打开 /dev/video0
	do_sys_open -> do_filp_open -> path_openat -> do_last.isra.43 -> do_dentry_open.isra.11 -> chrdev_open
 	由于/dev/video0 注册为字符设备,自然通过 chrdev_open 的入口:
		static int chrdev_open(struct inode *inode, struct file *filp) (/fs/Char_dev.c)
		其中:ret = filp->f_op->open(inode, filp);就是调用了/dev/video0 注册了的f_op.open:V4l2_open
		至于何时如何从哪个驱动注册上,并未探知
	继续讨论 V4l2_open:
		static int v4l2_open(struct inode *inode, struct file *filp) (/drivers/media/v4l2-core/V4l2-dev.c)
		其中:ret = vdev->fops->open(filp);调用了注册在v4l2驱动上的 soc_camera_open
		而这个就是我们atmel 特有的摄像头驱动框架
	而一切初始化内容都是从soc_camera出发!!

以下重点分析 soc_camera.c 和 soc_camera_platform.c
先分析:soc_camera_platform.c (v4l2_subde的具体实现)

	static struct v4l2_subdev_core_ops platform_subdev_core_ops = {
		.s_power = soc_camera_platform_s_power,			//启动,这里是启动了isi,还是设置了sensor的pwd? 未挖掘
	};
	static struct v4l2_subdev_video_ops platform_subdev_video_ops = {
		.s_stream	= soc_camera_platform_s_stream,		//start streaming
		.cropcap	= soc_camera_platform_cropcap,		//设置 v4l2_cropcap
			//cropcap即cropping capacity (取景属性)   其中:
			//	v4l2_cropcap.bounds 是sensor捕捉图像的位置和范围
			//	v4l2_cropcap.defrect 是指在bounds内,可取样范围
			//	v4l2_cropcap.pixelaspect; // 定义了图片的宽高比
			//补充:
			//	v4l2_crop.c 是seneor 可取样范围里,的实际取景范围	(这里.c是其中那个c变量,不要混淆 .c文件)
			//		而这部分取景范围才是 我们用户使用的有效数据
			//		这部分数据再经 scaling (缩放)算法缩放成实际输出图像
		.g_crop		= soc_camera_platform_g_crop,		//设置v4l2_crop的,重点设置v4l2_crop.c
		.g_mbus_config	= soc_camera_platform_g_mbus_config,	//设置图像传输总线方式:
			//例如以下三种:
 			// * @V4L2_MBUS_PARALLEL:	parallel interface with hsync and vsync
			// * @V4L2_MBUS_BT656:		parallel interface with embedded synchronisation, can
			// *				also be used for BT.1120
			// * @V4L2_MBUS_CSI2:		MIPI CSI-2 serial interface
	};
	static const struct v4l2_subdev_pad_ops platform_subdev_pad_ops = {
		.enum_mbus_code = soc_camera_platform_enum_mbus_code,	//枚举 sensor 提供多少种 图像传输 格式
		.get_fmt	= soc_camera_platform_fill_fmt,		//获取 图像传输 格式 
		.set_fmt	= soc_camera_platform_fill_fmt,		//设置 图像传输 格式 
			//get_fmt 和 set_fmt 都一样 (所以貌似这两个并没有实际用上)
	};
	static struct v4l2_subdev_ops platform_subdev_ops = {
		.core	= &platform_subdev_core_ops,
		.video	= &platform_subdev_video_ops,
		.pad	= &platform_subdev_pad_ops,
	};
//卧槽,soc_camera_platform.c 并没有被烧录写入,白分析了!!!!!!!!!!!!
//soc_camera.c 和 soc_camera_platform.c是功能框架一样的,但是却是面向不同的sensor类型
接着分析:soc_camera.c ()
	很神奇,module_platform_driver(soc_camera_pdrv);说明了这是一平台总线上的设备,
		所以执行 probe初始化时,先要有步骤把 "soc-camera-pdrv" device信息注入平台总线上才行.
		但是并没有找到在哪里注入? 注意,并没有在dtb上注入,但是可以肯定的是,一定probe了!!!
		
	soc_camera_host_register() 实际上所有驱动初始化都从这里走,
		而调用这的是 atmel_isi.c,而不是	soc_camera.c本身里面自己的函数调用
	感觉分析不下去了,要先看 atmel_isi.c 因为 soc_camera.c作为平台总线上的设备驱动,
		在没有设备信息注入的情况下自己soc_camera_pdrv_probe了,
		还有, soc_camera_pdrv_probe之前, soc_camera.c自身的函数居然还可以被调用,卧槽!!!
卧槽
卧槽,终于找到了为什么会这样了!!!!!!!
	首先 dtb 并没有  "soc-camera-pdrv" 项,所以不可能通过dtb 注入设备信息!!!
	然后发现,atmel_isi_probe的时候,就会自动 soc_camera_pdrv_probe,!!!
	经过 dump_stack()发现,不简单, 先来一段启动 log!!!
/*log*/
atmel_isi_probe!!
in atmel_isi_probe, before stepin soc_camera_host_register  !!
scan_of_host !! 
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
atmel_isi f0008000.isi: group probe failed: -17
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c0341648>] (soc_camera_async_complete+0x10/0x5c)
[<c0341648>] (soc_camera_async_complete) from [<c03340f4>] (v4l2_async_test_notify+0xec/0xf8)
[<c03340f4>] (v4l2_async_test_notify) from [<c03342b4>] (v4l2_async_notifier_register+0x104/0x154)
[<c03342b4>] (v4l2_async_notifier_register) from [<c0341a20>] (soc_of_bind.isra.2+0x120/0x1c8)
[<c0341a20>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_async_complete !! 
soc_camera_probe !! 
soc-camera-pdrv soc-camera-pdrv.1: Probing soc-camera-pdrv.1
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 1
soc-camera-pdrv soc-camera-pdrv.1: Found 6 supported formats.
atmel_isi f0008000.isi: Providing format Packed YUV422 16 bit using code 8200
atmel_isi f0008000.isi: Providing format RGB565 using code 8200
atmel_isi f0008000.isi: Providing format Packed YUV422 16 bit using code 8198
atmel_isi f0008000.isi: Providing format RGB565 using code 8198
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 1
in atmel_isi_probe, after soc_camera_host_register  !!
atmel_isi_probed !! 
/*log*/
	上述log是 atmel_isi_probe 的全过程!!!!!!
	首先atmel_isi_probe -> soc_camera_host_register 
		注意这时,soc_camera.c只是挂入了platform总线,但是还没有匹配device信息,所以没有probe,
		所以从传统方式看,因为还未把里面的操作函数挂到指定 ops集上,
		所以理论上还未能访问soc_camera.c 里的函数,
		但是 soc_camera_host_register 用 EXPORT_SYMBOL(soc_camera_host_register); 标出是全局可用
		所以就直接用上了!!!
	soc_camera_host_register -> scan_of_host -> soc_of_bind-> soc_camera_add_pdev 
		这里是soc_camera_host_register调用内部的一些函数,
		soc_camera.c自己给自己构造设备信息,然后再自己注入 平台总线上
		soc_of_bind.isra.2 与 soc_of_bind 区别????(一样的,不过不知道为何名字改了)
	soc_camera_add_pdev -> soc_of_bind -> soc_camera_dyn_pdev ->
		pdev = platform_device_alloc("soc-camera-pdrv", i);	在这里设置了设备信息
	然后就是 -> platform_device_add 注入设备信息
	然后就辗转到 soc_camera_pdrv_probe 完成了设备驱动注册到linux
	然后,回到 soc_of_bind 继续 -> soc_camera_async_complete -> soc_camera_probe
		soc_camera_probe()才是进行一些列的驱动初始化工作!!
	最后,回到 atmel_isi_probe 继续完成isi的初始化工作!!!
补习:
container_of(ptr,type,member) //已知member位置, 需找member所在的type变量的位置, 返回type变量的位置指针 
	





20170704
探究失真问题:
	一开始认为是转接口布线紊乱的问题,
	然后使用了排线,却没有用,后来发现是布线太长的问题,芯片驱动能力不够!!!
	尝试 加大data排线 I/O 口的驱动能力!!
	默认 p0:0x1c 是0x0f Data pad driver current 4ma
	     p0:0x1f 是0xd0 pclk pad driver current 8ma
	     p0:0x2e 是0xc0 hv signal is 00
	暂时相对稳定!!!
	调试:
	data   0x17 8ma		pclk  0xe0 12ma		hvsignal  0xc5 01	图像偏不稳定,不易开启
	data   0x1f 12ma	pclk  0xe0 12ma		hvsignal  0xc5 01	图像更不稳定
	data   0x1f 12ma	pclk  0xf0 16ma		hvsignal  0xc5 01	图像更不稳定
	data   0x1f 12ma	pclk  0xf0 16ma		hvsignal  0xca 10	图像更不稳定
	data   0x17 8ma		pclk  0xe0 12ma		hvsignal  0xca 10	图像偏不稳定
	data   0x0f 4ma		pclk  0xd0 8ma		hvsignal  0xca 10	图像不显示
	data   0x0f 4ma		pclk  0xd0 8ma		hvsignal  0xc5 01	不好启动,但相对最稳定

	提高了data pck 驱动电流,反而死的更快!!!
	还有发现了,有时,当光通量足够多的时候, 更容易成功开启!!!!当光通量更暗时,更难开启
	还有一个重点是,布线干扰,摄像头不能直接粘到板子上!!!!因为贴住地方的 toplayer层有布线,所以有强烈的电磁干扰!!!!!!!
最后发现是电源噪音的问题!!!
	芯片工作时,芯片噪音高达 66mhz
	在sensor三个电源处并联,100nf,10nf 1nfa 510pf
	在ldo 芯片输入电源处并联,100nf,10nf 1nfa 510pf
	发现并没有很好地滤波(卧槽 ,多不知道怎么接了)








20170706
分析V4L2!!!
参考:http://blog.csdn.net/evilcode/article/details/6337155

V4L2(video for linux) 可以支持多种设备，它可以有以下5种接口：
1、视频采集接口(video capture interface)：这种应用的设备可以是高频头或者摄像头.V4L2的最初设计就是应用于这种功能的.下面也是着重讲解这种应用；
2、视频输出接口(video output interface)：可以驱动计算机的外围视频图像设备——像可以输出电视信号格式的设备；
3、直接传输视频接口(video overlay interface)：它的主要工作是把从视频采集设备采集过来的信号直接输出到输出设备之上,而不用经过系统的CPU；
4、视频间隔消隐信号接口(VBI interface)：它可以使应用可以访问传输消隐期的视频信号；
5、收音机接口(radio interface)：可用来处理从AM或FM高频头设备接收来的音频流；

下面从一个例子分析 v4l2
soc_camera是一个平台总线设备,
但与其他传统平台总线设备有些区别, 它不像是硬件总线控制器设备, 更像是一个具体的设备
但也是一个基于 v4l2 的 模块化视频采集设备 (之所以说是模块化是因为统一的操作策略,而摄像头的硬件操作分离出来,即可简单更换移植各种摄像头)
基于 v4l2 的视频采集设备 首先有 v4l2_file_operations 操作集!!(soc_camera.c里)
static struct v4l2_file_operations soc_camera_fops = {
	.owner		= THIS_MODULE,
	.open		= soc_camera_open,
	.release	= soc_camera_close,
	.unlocked_ioctl	= video_ioctl2,
	.read		= soc_camera_read,
	.mmap		= soc_camera_mmap,
	.poll		= soc_camera_poll,
}; 
还有 v4l2_ioctl_ops 对应ioctl操作的 操作函数集	(soc_camera.c里)
static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
	.vidioc_querycap	 = soc_camera_querycap,
	.vidioc_try_fmt_vid_cap  = soc_camera_try_fmt_vid_cap,
	.vidioc_g_fmt_vid_cap    = soc_camera_g_fmt_vid_cap,
	.vidioc_s_fmt_vid_cap    = soc_camera_s_fmt_vid_cap,
	.vidioc_enum_fmt_vid_cap = soc_camera_enum_fmt_vid_cap,
	.vidioc_enum_input	 = soc_camera_enum_input,
	.vidioc_g_input		 = soc_camera_g_input,
	.vidioc_s_input		 = soc_camera_s_input,
	.vidioc_s_std		 = soc_camera_s_std,
	.vidioc_g_std		 = soc_camera_g_std,
	.vidioc_enum_framesizes  = soc_camera_enum_framesizes,
	.vidioc_reqbufs		 = soc_camera_reqbufs,
	.vidioc_querybuf	 = soc_camera_querybuf,
	.vidioc_qbuf		 = soc_camera_qbuf,
	.vidioc_dqbuf		 = soc_camera_dqbuf,
	.vidioc_create_bufs	 = soc_camera_create_bufs,
	.vidioc_prepare_buf	 = soc_camera_prepare_buf,
	.vidioc_expbuf		 = soc_camera_expbuf,
	.vidioc_streamon	 = soc_camera_streamon,
	.vidioc_streamoff	 = soc_camera_streamoff,
	.vidioc_cropcap		 = soc_camera_cropcap,
	.vidioc_g_crop		 = soc_camera_g_crop,
	.vidioc_s_crop		 = soc_camera_s_crop,
	.vidioc_g_selection	 = soc_camera_g_selection,
	.vidioc_s_selection	 = soc_camera_s_selection,
	.vidioc_g_parm		 = soc_camera_g_parm,
	.vidioc_s_parm		 = soc_camera_s_parm,
};
还有的 是一个视频基类结构 是一个实质的采集设备对象!!!比如这样:
static struct video_device soc_camera1 = {
	.name		= "soc_camera1",
	.fops           = &soc_camera_fops,
	.ioctl_ops 	= &soc_camera_ioctl_ops,
	....
};
然而实际实际上 这些对象是实际注册时自动生成的,而不是既定的,比如通过这个函数生成 video_dev_create() (soc_camera.c里)
然后,介绍 soc_camera 的设备结构体:
struct soc_camera_device {
	struct list_head list;		//设备所在的内核双向链表
	struct soc_camera_desc *sdesc;
	struct device *pdev;		/* Platform device */
	struct device *parent;		/* Camera host device */
	struct device *control;		/* E.g., the i2c client */
	s32 user_width;
	s32 user_height;
	u32 bytesperline;		/* for padding, zero if unused */
	u32 sizeimage;
	enum v4l2_colorspace colorspace;
	unsigned char iface;		/* Host number */
	unsigned char devnum;		/* Device number per host */
	struct soc_camera_sense *sense;	/* See comment in struct definition */
	struct video_device *vdev;	 //指向具体的 视频基类结构 的某设备对象,也是 soc_camera_device结构对象的 核心项
	struct v4l2_ctrl_handler ctrl_handler;
	const struct soc_camera_format_xlate *current_fmt;
	struct soc_camera_format_xlate *user_formats;
	int num_user_formats;
	enum v4l2_field field;		/* Preserve field over close() */
	void *host_priv;		/* Per-device host private data */
	/* soc_camera.c private count. Only accessed with .host_lock held */
	int use_count;
	struct file *streamer;		/* stream owner */
	struct v4l2_clk *clk;
	/* Asynchronous subdevice management */
	struct soc_camera_async_client *sasc;
	/* video buffer queue */
	union {
		struct videobuf_queue vb_vidq;
		struct vb2_queue vb2_vidq;
	};
};
上述是 基于 v4l2 框架 移植过来的 视频采集设备的基本内容和结构
当然根据实际需求,还有一些深层的封装,例如:
struct soc_camera_host {
	struct v4l2_device v4l2_dev;
	struct list_head list;
	struct mutex host_lock;		/* Main synchronisation lock */
	struct mutex clk_lock;		/* Protect pipeline modifications */
	unsigned char nr;		/* Host number */
	u32 capabilities;
	struct soc_camera_device *icd;	/* Currently attached client */
	void *priv;
	const char *drv_name;
	struct soc_camera_host_ops *ops;
	struct v4l2_async_subdev **asd;	/* Flat array, arranged in groups */
	unsigned int *asd_sizes;	/* 0-terminated array of asd group sizes */
};
这里的host,我怀疑指的是isi总线!!!

驱动与应用程序的数据传输方式有三种:
1）read与write这种方式，它像其它设备驱动一样，但是这种方式很慢，对于数据视频流不能满足其要求；
2）直接的内存访问，可以通过其映射方式来传输(IO数据流，交换指向缓冲区指针的方法)；
   这是视频设备通常用的方法，采用mmap()的方法，即有内核空间里开辟内存，再在程序里把这部分的内存映射到程序空间。
   如果有设备内存，即直接映射到设备的内核，这种性能更高。
3）反过来,用户态申请的内存隐射到内核里被使用!!!
soc_camera 使用了 第二种方法, 把内核态分出的内存隐射出来让用户程序也可以操作
soc_camera_mmap 干了这事,特别是:
videobuf_mmap_mapper(&fh->vb_vidq, vma);  这个核心函数把设备的I/O内存或者设备内存映射到系统为它开辟的虚拟内存。

操控设备的实现: ioctl
long video_ioctl2(struct file *file, unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, __video_do_ioctl);
}
__video_do_ioctl 这个函数里调用一些命令来设备V4L2模块中的一些结构参数来改变或者获取设备的参数。
一般使用ioctl函数来对设备的I/O通道进行管理：
	extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
	__fd：设备的ID，例如刚才用open函数打开视频通道后返回的cameraFd；
	__request：具体的命令标志符。
在进行V4L2开发中，一般会用到以下的命令标志符：
	VIDIOC_REQBUFS：分配内存 
	VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 
	VIDIOC_QUERYCAP：查询驱动功能 
	VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式 
	VIDIOC_S_FMT：设置当前驱动的频捕获格式 
	VIDIOC_G_FMT：读取当前驱动的频捕获格式 
	VIDIOC_TRY_FMT：验证当前驱动的显示格式 
	VIDIOC_CROPCAP：查询驱动的修剪能力 
	VIDIOC_S_CROP：设置视频信号的边框 
	VIDIOC_G_CROP：读取视频信号的边框 
	VIDIOC_QBUF：把缓存放入缓存队列 
	VIDIOC_DQBUF：把缓存从缓存队列中取出来 
	VIDIOC_STREAMON：开始视频显示函数 
	VIDIOC_STREAMOFF：结束视频显示函数 
	VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。 
	这些IO调用，有些是必须的，有些是可选择的。

struct v4l2_subdev  在这里一般就是,视频采集设备里子功能设备,如编解码器,声色子功能等等 一般都使用I2C控制 !!!
重点结构体:
/* kernel/include/media/v4l2-subde.h */
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
#endif
    struct list_head list;
    struct module *owner;
    u32 flags;
    struct v4l2_device *v4l2_dev;
    const struct v4l2_subdev_ops *ops;    // 各种策略的ops
    /* Never call these internal ops from within a driver! */
    const struct v4l2_subdev_internal_ops *internal_ops;
    /* The control handler of this subdev. May be NULL. */
    struct v4l2_ctrl_handler *ctrl_handler;
    /* name must be unique */
    char name[V4L2_SUBDEV_NAME_SIZE];
    /* can be used to group similar subdevs, value is driver-specific */
    u32 grp_id;
    /* pointer to private data */
    void *dev_priv;
    void *host_priv;
    /* subdev device node */
    struct video_device devnode;
    /* number of events to be allocated on open */
    unsigned int nevents;
};
struct v4l2_subdev_ops {
    const struct v4l2_subdev_core_ops    *core;    // 所有sub-device通用
    const struct v4l2_subdev_tuner_ops    *tuner;
    const struct v4l2_subdev_audio_ops    *audio;
    const struct v4l2_subdev_video_ops    *video;
    const struct v4l2_subdev_vbi_ops    *vbi;
    const struct v4l2_subdev_ir_ops        *ir;
    const struct v4l2_subdev_sensor_ops    *sensor;
    const struct v4l2_subdev_pad_ops    *pad;
};
ops的调用:
1. 直接调用：
	err = sd->ops->core->g_chip_ident(sd, &chip);
2. 宏调用
	err = v4l2_subdev_call(sd, core, g_chip_ident, &chip);
#define v4l2_subdev_call(sd, o, f, args...)                \
    (!(sd) ? -ENODEV : (((sd)->ops->o && (sd)->ops->o->f) ?    \
        (sd)->ops->o->f((sd) , ##args) : -ENOIOCTLCMD))
/*
　　宏调用优点：1. 对sd是否为空的检测
　　　　　　   2. 调用函数f所在的ops是否为空的检测
　　          3. 调用函数f是否为空的检测
　　　　　　   4. 调用是被返回负值，成功返回函数f的返回值
*/

soc_camera 里的函数:
soc_camera_expbuf() 把buf 模拟成一个暂时文件,输出这个文件的文件描述符
soc_camera_init_user_formats ????
soc_camera_add_device(icd) 只是 加到抽象的 host 对象里 
__soc_camera_power_on 重点是: ret = v4l2_subdev_call(sd, core, s_power, 1);
soc_camera_poll ???轮询??
v4l2_ctrl_add_handler ???
scan_async_xxx 什么的,似乎我们并没有使用!!!	

atmel_isi.c 
fb 是 frame buffer
fbd 是 frame buffer descriptor
isc 是 isi 低版本的 图像通讯硬件协议

为了掌握 驱动`的执行情况,我使用了dump_stack 来追溯
发现 atmel_isi 也是在 soc_camera 下工作





20170710
microchip学习:
	FPU:浮点运算单元!!
	emmc 与 nandflash 的区别: emmc 是集成了控制器的nandflash,
		数据内容放入nandflash时,单单是nandflash,时,要人工指定地址段,而emmc则自己安排地址,用户不用管
	
atmel MPU启动:
	rom-coder固化程序:启动时钟,枚举用户程序所在地方: emmc nandflash sdcard...,没有则启动 samba-morritor
		假如 枚举到是nandflash,就会把nandflash的开始地址的 bootloader放入sram执行
	bootloader 会初始化 ddram 等等,然后把uboot拷到ddram(ddram是sdram的一种)
	uboot 初始化 linux 环境,并跳入linux初始化

fat 的文件分区表是在开头位置, 而yaff,ubi文文件分区表是分布式的,linux之所以不用fat文件系统格式是因为flash有读写次数
如果使用fat 那么统一位置的分区表大量写,很快就挂掉了!!而分布的,分摊了写次数,延长寿命

上电: 外设先上,然后再核心上!!

devicetree 补充学习: dts_debug 案例
# ls /proc/device-tree/
#address-cells	clocks
#size-cells
compatible
ahb
cpus
aliases
fixedregulator@0
chosen
fixedregulator@1
gpio_keys
interrupt-parent
leds
memory
model
name
sram@00210000

# ls /proc/device-tree/ahb/apb/mmc@fc000000/
#address-cells compatible
#size-cells
dma-names
pinctrl-0
clock-names
dmas
pinctrl-names
clocks
interrupts
reg
name
slot@0
status
vmmc-supply
vqmmc-supply

# cat /proc/device-tree/ahb/apb/mmc@fc000000/status
okay

# cat /proc/device-tree/ahb/apb/mmc@fc000000/compatible
atmel,hsmci

# cat /proc/device-tree/ahb/apb/mmc@fc000000/clocks
G

# ls /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/
gpio-ranges
pinconf-groups
pingroups
pinmux-pins
pinconf-config
pinconf-pins
pinmux-functions
pins

# cat /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/pinconf-pins
Pin config settings per pin
Format: pin (name): configs
pin 0 (pioA0):PULL_UP
pin 128 (pioE0):PULL_DOWN
pin 129 (pioE1):PULL_UP|DEGLITCH

# cat /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/pinmux-pins
Pinmux settings per pin
Format: pin (name): mux_owner gpio_owner hog?
pin 0 (pioA0): (MUX UNCLAIMED) (GPIO UNCLAIMED)
pin 30 (pioA30): f8014000.i2c (GPIO UNCLAIMED) function i2c0 group i2c0-0
pin 31 (pioA31): f8014000.i2c (GPIO UNCLAIMED) function i2c0 group i2c0-0
pin 67 (pioC3): (MUX UNCLAIMED) fc06c000.gpio:67
pin 131 (pioE3): fc000000.mmc fc06d000.gpio:131 function board group mmc1_cd

# ls /sys/kernel/debug/pinctrl/fc038000.pinctrl/
gpio-ranges
pinconf-groups pingroups
pinconf-config pinconf-pins
pinmux-functions
pinmux-pins
pins

# cat /sys/kernel/debug/pinctrl/fc038000.pinctrl/pinconf-pins
Pin config settings per pin
Format: pin (name): configs
pin 0 (PA0): (sdmmc0_default, ioset 1)
pin 1 (PA1): (sdmmc0_default, ioset 1) pull-up
pin 39 (PB7): (pinctrl_mxt_irq, ioset 0) pull-up debounce

# cat /sys/kernel/debug/pinctrl/fc038000.pinctrl/pinmux-pins
Pinmux settings per pin
Format: pin (name): mux_owner gpio_owner hog?
pin 0 (PA0): a0000000.sdio-host (GPIO UNCLAIMED) function A group PA0
pin 41 (PB9): gpio_keys (GPIO UNCLAIMED) function GPIO group PB9

# cat /sys/kernel/debug/clk/clk_summary
[20/1851]
clock				enable_cnt 	prepare_cnt	rate		accuracy	phase
----------------------------------------------------------------------------------------------------------
slow_rc_osc			0 		0 		32768 		250000000 	0
main_rc_osc 			0 		0 		12000000 	100000000 	0
clock				0		0		12000000	0		0
adc_op_clk			1		1		1000000		0 		0
main_xtal			1		1		12000000	0 		0
   main_osc			1		1		12000000	0 		0
      mainck			2		2		12000000	0 		0
         utmick			2		2		480000000	0 		0
            usbck		1		1		48000000	0 		0
               udpck		0		0		48000000	0 		0
               uhpck		1		1		48000000	0 		0
         pllack			1		1 		1200000000	0 		0
            plladivck		1		1		600000000	0 		0
               smdclk		0		0		600000000	0 		0
                  smdck		0		0		600000000	0 		0
               masterck		5		5		200000000	0 		0
                  isi_clk	0		0		200000000	0 		0
                  lcdc_clk	0		0		200000000	0 		0
                  dma1_clk	1		1		200000000	0 		0
                  vdec_clk	0		0		200000000	0 		0
                  matrix0_clk	0		0		200000000	0 		0
                  mpddr_clk	1		1		200000000	0 		0









20170713
德沃 SAM4S 板子
	1,PIR 例子中似乎并没有做 UVC例子,需要移植,大大麻烦
	2,似乎使用ek 而非PIR例子指定开发板, 所以摄像头,需要自己画板子!!! 大麻烦
	3,未知用ek 还是 PIR-DEMO板子
	








20170719
搭建sam4s烧录环境:
	首先,使用sam-ba2.16 需要打上补丁才可以 connect sam4s系列的芯片,
	虽然是xplainted 板子,但是connect里只有ek板子选项,所以可以选ek对应型号代替
	每次烧录,eraseall时,都会有超时错误!!!,所以eraseall后,要重新登陆sam-ba 去烧录
uvc研究安装amcap工程:
	几经波折,终于找到了vs2015可用的amcap程序(直接一套windows sdk7_sample,)
	源码地址:https://github.com/pauldotknopf/WindowsSDK7-Samples
	先打开 directshow/baseclasses 的sln 编译baseclasses库,例如我们编为debug版本
	然后打开 amcap 项目 ,先配置 amcap项目属性 -> VC++目录 -> 
		包含目录是添加 directshow/baseclasses
		库目录添加 directshow/baseclasses/debug
	然后编译,就可以工作了
分析amcap:
	重点关注 启动摄像头的函数!!!
	所以关注函数:
	amcap.cpp
		AddDevicetoMenu
		chooseDevices
		setappcaption
		startpreview
		getdc
		Makebuilder 建立 capture graph builder 对象 
		CoCreateInstance 获得 ICaptureGraphBuilder 接口指针
		CreaterClassEnumerator 列举捕捉系统设备
	SampleCGB.cpp
		Findinterface
		Findpin
		reanderstream
		setfiltergraph
研究发现amcap把打开摄像头设备的函数封装起来了!!!
	关注变量:
	gcap!!!
	gcap.fWantPreview(预览功能)
	gcap.iMasterStream(声音流,视频流谁主导,谁配合同步)
struct _capstuff
{
    WCHAR wszCaptureFile[_MAX_PATH];		// 捕捉文件的路径，该文件保存捕捉到的视频
    WORD wCapFileSize;  // size in Meg		捕捉文件的size
    ISampleCaptureGraphBuilder *pBuilder;	// ISampleCGB    类对象实例的指针
    IVideoWindow *pVW;						// 视频显示窗口的指针，利用该指针将视频显示在项目的界面内
    IMediaEventEx *pME;						// 媒体事件接口的指针，用来控制filtergraph的play、stop等
    IAMDroppedFrames *pDF;					// 获取捕捉过程中丢帧数的接口指针
    IAMVideoCompression *pVC;				// 视频压缩接口指针，捕捉文件为mpeg2格式时用到
    IAMVfwCaptureDialogs *pDlg;				// 用于捕捉器件设置的对话框接口指针
    IAMStreamConfig *pASC;      // for audio cap	音频捕捉流配置接口指针
    IAMStreamConfig *pVSC;      // for video cap	视频捕捉流配置接口指针
    IBaseFilter *pRender;					// 显示视频图像的filter的接口指针
    IBaseFilter *pVCap, *pACap;				// 视频、音频捕捉器件的filter的接口指针
    IGraphBuilder *pFg;						// ISampleCGB中用于建立filtergraph的builder的接口指针
    IFileSinkFilter *pSink;					// 保存文件要用到的FileSinkFilter的接口指针
    IConfigAviMux *pConfigAviMux;			// Avi合成器件的filter的接口指针
    int  iMasterStream;						// 标识哪一个流作为MsterStream的整型变量
    BOOL fCaptureGraphBuilt;				// 标识是否 已建立了捕捉用的filter graph
    BOOL fPreviewGraphBuilt;				// 是否已建立了预览用的filter  graph
    BOOL fCapturing;						// 是否正在捕捉？
    BOOL fPreviewing;						// 是否正在预览？
    BOOL fMPEG2;							// 是MPEG2的视频源码？如有线电视接收器等的信号源
    BOOL fCapAudio;							// 需要捕捉音频吗?
    BOOL fCapCC;							// 需要显示MPEG2中的隐藏式字幕吗?
    BOOL fCCAvail;							// 有可用的隐藏式字幕吗?只有VBI图文视频流才可用
    BOOL fCapAudioIsRelevant;				// 捕捉的视频已有关联的音频吗？
    bool fDeviceMenuPopulated;				// Devices菜单已填写？
    IMoniker *rgpmVideoMenu[10];			// 保存视频捕捉器件菜单中每个器件的标识(名字)接口
    IMoniker *rgpmAudioMenu[10];			// 保存音频捕捉器件菜单中每个器件的标识(名字)
    IMoniker *pmVideo;						// 获取视频捕捉filter的friendlyname的标识接口的指针
    IMoniker *pmAudio;						// 获取音频捕捉filter的friendlyname的标识接口的指针
    double FrameRate;						// 用户设定的帧率数值，即每秒帧数
    BOOL fWantPreview;						// 需要预览吗？
    long lCapStartTime;						// 开始捕捉的时间
    long lCapStopTime;						// 停止捕捉的时间
    WCHAR wachFriendlyName[120];			// 保存捕捉器件的友善名称的字符串数组
    BOOL fUseTimeLimit;						// 是否使用时间限制？
    BOOL fUseFrameRate;						// 是否使用用户设定的帧率？
    DWORD dwTimeLimit;						// 用户设定的时间限制长度数值
    int iFormatDialogPos;					// VFW设备设置format输出格式的属性页的起始位置值
    int iSourceDialogPos;					// VFW设备设置source信号源的属性页的起始位置值
    int iDisplayDialogPos;					// VFW设备设置display显示参数的属性页的起始位置值
    int iVCapDialogPos;						// WDM视频设备的属性页的起始位置值
    int iVCrossbarDialogPos;				// WDM视频设备的输入选择对话框的起始位置值
    int iTVTunerDialogPos;					// WDM电视设备的调谐对话框的起始位置值
    int iACapDialogPos;						// WDM音频设备的属性页的起始位置值
    int iACrossbarDialogPos;				// WDM音频设备的输入选择对话框的起始位置值
    int iTVAudioDialogPos;					// WDM电视设备的音频属性页的起始位置值
    int iVCapCapturePinDialogPos;			// WDM视频设备的捕捉Pin属性页的起始位置值
    int iVCapPreviewPinDialogPos;			// WDM视频设备的预览Pin属性页的起始位置值
    int iACapCapturePinDialogPos;			// WDM音频设备的捕捉Pin属性页的起始位置值
    long lDroppedBase;						// 丢帧数
    long lNotBase;							// 捕捉帧数
    BOOL fPreviewFaked;						// 当捕捉设备没有preview pin时，是否用capture pin充当preview pin
    CCrossbar *pCrossbar;					// CCrossbar类对象指针
    int iVideoInputMenuPos;					// 选中的视频输入源在输入菜单中的位置值
    LONG NumberOfVideoInputs;				// 视频输入源的数量
    HMENU hMenuPopup;						// 菜单句柄
    int iNumVCapDevices;					// 现有视频捕捉设备数量
} gcap;









20170721
分析sam4s 的pir程序:
	主要是了解 并行io 如何抓取图像
	全程只有判断 vsync 信号
	还有 是通过 pioc 并口中断 来执行中断处理函数的,
		而且,似乎是8位针状态同时改变会被监测到,并且触发 并口中断,记录下并口针状态信息,就是一个像素点!!!
	首先,知道了固定的cap_buf 指针变量: cap_dest_buf
	就是,在 获取像素数据的中断处理函数出现疑问!!!!
	rxbuff interrupt 是接受buf溢出中断,表示接收好一张图片,通过 PIO_capture_buff来表示 
	芯片提供的pio功能 可处理两个缓存
	pio->RPR receive pointer register	//第一个缓存地址
	pio->RCR receive counter register	//第一个缓存大小
	pio->RNPR receive next pointer register	//第二个缓存地址
	pio->RNCR receive next counter register //第二个缓存大小
	piodc工作原理假设:
	首先 PIODC_Capture_init() 设置了需要采集 pio数据 的那9个位,(8个数据,一个pck)
	当这些位的状态改变后就会触发中断,中断执行过程中,还有新的改变会被忽略!!!
	而每次中断都会采集 当下的 pio针位状态 并记录,
	一般,数据位几乎同时间改变,即使说有数据位先改变先触发中断,但是在中函数记录数据位状态之前,
	数据位已经全部改变完毕处于稳定状态,这是记录下来的数据是有效的!!!!
	关于记录数据!!
	PIO_CaptureHandler 似乎并没有做什么!! 关键是_PioCaptureCopy->xxxx 这些xxxxx虚拟函数都没有指向,所以什么都没有做
	而记录数据处理的,似乎是PioInterruptHandler(),但发现又好像不是!!!
	都不知道是在哪里记录数据的!!!
	不过,很多实际问题表示,上述piodc假设只对了一部分,
	中断触发的检测不应该是检测所有数据针,而应该仅仅是 pck针 被监测而已!!!!
	
	
	






20170724
linux 补充学习:
Linux 系统启动过程可以分为5个阶段：
	内核的引导。
	运行 init。
	系统初始化。
	建立终端 。
	用户登录系统。
init程序的类型：
        SysV: init, CentOS 5之前, 配置文件： /etc/inittab。
        Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。		//这段注释不用管"*/"
        Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。
内核引导
	当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。
	操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。
运行init
	init 进程是系统所有进程的起点，没有这个进程，系统中任何进程都不会启动。
	init 程序首先是需要读取配置文件 /etc/inittab。
运行级别
	许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。
	init进程的一大任务，就是去运行这些开机启动的程序。
	不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。
	Linux允许为不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）。也就是说，启动时根据"运行级别"，确定要运行哪些程序。
	Linux系统有7个运行级别(runlevel)：
		运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
		运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
		运行级别2：多用户状态(没有NFS)
		运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
		运行级别4：系统未使用，保留
		运行级别5：X11控制台，登陆后进入图形GUI模式
		运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
系统初始化
	在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，
	而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。
		它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。
	l5:5:wait:/etc/rc.d/rc 5
	这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，
	它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，
	/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，
	真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。
	而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。
	/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以以S开头的启动脚本，将以start参数来运行。
	而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，
		则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。
		这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。
	至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的"System Services"来自行设定。
建立终端
	rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。
	init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：
	1:2345:respawn:/sbin/mingetty tty1
	2:2345:respawn:/sbin/mingetty tty2
	3:2345:respawn:/sbin/mingetty tty3
	4:2345:respawn:/sbin/mingetty tty4
	5:2345:respawn:/sbin/mingetty tty5
	6:2345:respawn:/sbin/mingetty tty6
	从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。
	同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，
	而用户输入的用户将作为参数传给login程序来验证用户的身份。
用户登录系统
	一般来说，用户的登录方式有三种：
	（1）命令行登录
	（2）ssh登录
	（3）图形界面登录
	对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入KDE、Gnome等窗口管理器。
	而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。
	Linux的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。
	然后login会对用户名进行分析：如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。
	这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许root用户登录，
	如果不存在这个文件，则root可以在任何终端上登录。
	/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。
图形模式与文字模式的切换方式
	Linux预设提供了六个命令窗口终端机让我们来登录。
	默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。
	如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。
	当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。
	如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 
	如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。
Linux 关机
	在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。
	正确的关机流程为：sync > shutdown > reboot > halt
	关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。
	例如你可以运行如下命令关机：
	sync 将数据由内存同步到硬盘中。
	shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：
	shutdown –h 10 ‘This server will shutdown after 10 mins’ 	//计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。
	Shutdown –h now //立马关机
	Shutdown –h 20:25 //系统会在今天20:25关机
	Shutdown –h +10 //十分钟后关机
	Shutdown –r now //系统立马重启
	Shutdown –r +10 //系统十分钟后重启
	reboot 就是重启，等同于 shutdown –r now
	halt 关闭系统，等同于shutdown –h now 和 poweroff
	最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。
	关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。


	







20170726
uvc 枚举过程分析:
	http://bbs.eeworld.com.cn/thread-474097-1-1.html

uvc详细学习分析:	
	CONTROL SELECTOR (cs)

	camera terminal (CT) :  修改控制 video stream 特征 终端 就是说是uvc 标准命令终端
		例如 zoom iris AE roll 等控制
	input terminal (IT) : 原始流数据进入 视频编码器 端口 : 这里说的是,设备本身就存有的视频流,等
	output terminal (OT) : 视频编码器 输出数据流 的端口 : 这里说的是,数据从device端的视频编码器流出,进入host IN端
		一般来说,我们的 UVC 只用 OT 端, 而不会使用 IT端!!!,
		因为源数据从摄像头流入视频编码器,再通过usb传上pc
		而不是源数据从pc通过usb 流入设备的视频编码器,
	selector unit (SU): 多路输入流 经SU 选择其中一路,输出
	Processin unit (PU): 和 CT 相似,也是处理 uvc 标准命令的!!!
	Encoding unit (EU): 编码单元!!!
	Extension unit (XU): 延伸unit ,额外的控制单元供厂商使用 
	uvc拓扑结构例子分析:
		1,
		sensor -> CT(unit ID 2) ----------------|
				  	   		|--> su(unit ID 3) -> pu(unit ID 4) -> OT(unit ID 5) ->PC
		composite_from_device -> IT(unit ID 1) -|
		一般uvc系统由多个模块联接而成, 
		CT(camera terminal):从sensor引入数据流,而IT(input terminal)从其他渠道引入的数据流,IT,CT的功能是差不多的	
		SU(selector unit):就是从众多输入单元,诸如 CT IT中选择其中一个,供给后续处理
		PU(processing unit):数据流进一步处理的单元
		OT(output terminal):输出单元,就是往usb总线输出流数据的单元!!!
		上述模块都有一个unit ID,这些ID是人为设定的而不是协议规定地,ID都设在各自的 descriptor 里, 
			usb插入枚举时,会上传到pc上!!!,unitID非常重要, 
		#define CT_CONTROL_UNDEFINED                0x00
		#define CT_SCANNING_MODE_CONTROL            0x01
		#define CT_AE_MODE_CONTROL                  0x02
		#define CT_AE_PRIORITY_CONTROL              0x03
		#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL   0x04
		#define CT_EXPOSURE_TIME_RELATIVE_CONTROL   0x05
		#define CT_FOCUS_ABSOLUTE_CONTROL           0x06
		#define CT_FOCUS_RELATIVE_CONTROL           0x07
		#define CT_FOCUS_AUTO_CONTROL               0x08
		#define CT_IRIS_ABSOLUTE_CONTROL            0x09
		#define CT_IRIS_RELATIVE_CONTROL            0x0A
		#define CT_ZOOM_ABSOLUTE_CONTROL            0x0B
		#define CT_ZOOM_RELATIVE_CONTROL            0x0C
		#define CT_PANTILT_ABSOLUTE_CONTROL         0x0D
		#define CT_PANTILT_RELATIVE_CONTROL         0x0E
		#define CT_ROLL_ABSOLUTE_CONTROL            0x0F
		#define CT_ROLL_RELATIVE_CONTROL            0x10
		#define CT_PRIVACY_CONTROL                  0x11
		上述是对 CT单元操作的一些标准指令集,实际操作例子:
		給sensor传递一个缩放动作的请求, 我们的usb如此递交这样的申请
			bmRequestType	0x21		D7: 0 = Host to device
							D6..5: 01 = Class request
							D4..0: 00001 = Recipient is interface	
			bRequest	0x01		SET_CUR
			wValue		0x0B00		CT_ZOOM_ABSOLUTE_CONTROL
			wIndex		0x0200		CT(unit ID 2) -> 0x02, VideoControl interface ID 0 -> 0x00
			wLength		0x0002		datasize 2 bytes
			data		0xc4 0x56	data	
		特别注意wIndex ,这里填的ID 是 descriptors 设定好的id, 
			如果 CT(unit ID 7),VideoControl interface ID 6	则变为0x0706
			如果 CT(unit ID 2),VideoControl interface ID 0  而wIndex是0x0500,
			由于 unit ID 5 不是 CT模块, 而是 PU模块 
			所以 wValue = 0x0B00,并不是指代CT_ZOOM_ABSOLUTE_CONTROL指令,
			而是 PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL
			分配 unit ID 号时,不能分配 0号ID, 因为unit ID 0 号在UVC上有固定用途!!
		2,
		sensor -> CT -> PU ------------> OT -> (USB IN Endpoint 1,video streaming interface 1)
				    |-> EU ----> OT -> (USB IN Endpoint 2,video streaming interface 2)
				    |-> EU ----> OT -> (USB IN Endpoint 3,video streaming interface 3)
				    .....
		EU (extend unit): 延伸模块,就是用户自定义处理模块!!!!!!
渐渐地 UVC 有点眉目了!!
	首先 一个 usb请求 分 bmRequestType bRequest wValue wIndex wLength Data
		bmRequestType :标识是 UVC 
		bRequest : setcur getcur getmax setmax ........
		wValue : control selector 
		wIndex : 0(控制端口) 和其他端口
		wLength : Data 数据 size
		Data: 数据!!!
	然而wValue wValue 是关键, wValue可以是CT_ , VS_ ,PU_ ,,,, 很多都重码,不知道什么时候是CT_操作,什么时候是PU_操作,,,,,(已解决)
UVC启动枚举分析:
	1,
	bmRequestType	0xA1		D7: 1 = Device To host
					D6..5: 01 = Class request
					D4..0: 00001 = Recipient is interface	
	bRequest	0x01		SET_CUR
	wValue		0x0100		VS_PROBE_CONTROl
	wIndex		0x0001		unit ID 0 -> 0x00, Videostreaming interface ID 1 -> 0x01
	wLength		0x001A		datasize 26 bytes
	然后收到请求后 device 返回
	

sam4s16c-ek 的iar demo问题:
	关于 core_cmd4.h 找不到: c++ include路径添加同项目的 CMSIS/Include
	关于 __get_PSR() 找不到: 检查,项目对应的target 有没有选对cpu !!!!
	卧槽,ek板子的demo程序是只能 放在 SRAM上, reset, 会跳到 sram 上运行!!!!,怎么烧到flash上运行?
		解决: 项目的options-linker-config 下更换linker文件为 flash.icf,而非sram.icf
		这下,可以通过samba 烧到 flash 里运行了  	
补充:
natation 原子操作!!










20170802
linux内核态, 用户态, MMU, page-table 管理 等等关于内存分配管理的内容 补充学习!!!
首先分析内核启动中的内存内容
start_kernel()
    ->setup_arch()
        ->内存设置代码
          meminfo结构表明内存情况，是对物理内存结构meminfo的默认初始化。
          nr_banks指定内存块的数量，bank指定每块内存的范围，
          PHYS _OFFSET指定某块内存块的开始地址，MEM_SIZE指定某块内存块长度。
          PHYS _OFFSET和MEM_SIZE都定义在include/asm-armnommu/arch-XXX/memory.h文件中，
          其中 PHYS _OFFSET是内存的开始地址，MEM_SIZE就是内存的结束地址。
          if (meminfo.nr_banks == 0) 
          { 
              meminfo.nr_banks = 1; 
              meminfo.bank[0].start = PHYS_OFFSET; 
              meminfo.bank[0].size = MEM_SIZE; 
          }
        ->内核内存空间管理
          每一个任务都有一个mm_struct结构管理其内存空间，init_mm 是内核的mm_struct。
          其中设置成员变量* mmap指向自己， 意味着内核只有一个内存管理结构，
          设置 pgd=swapper_pg_dir，swapper_pg_dir是内核的页目录，ARM体系结构的内核页目录大小定义为16k。
          init_mm定义了整个内核的内存空间，内核线程属于内核代码，同样使用内核空间，其访问内存空间的权限与内核一样。
          init_mm.start_code = (unsigned long) &_text; 内核代码段开始 
          init_mm.end_code = (unsigned long) &_etext; 内核代码段结束 
          init_mm.end_data = (unsigned long) &_edata; 内核数据段开始 
          init_mm.brk = (unsigned long) &_end; 内核数据段结束 
        ->内存结构初始化
          bootmem_init(&meminfo)函数根据meminfo进行内存结构初始化。
          bootmem_init(&meminfo)函数中调用reserve_node_zero(bootmap_pfn, bootmap_pages) 函数，
	  这个函数的作用是保留一部分内存使之不能被动态分配。
	  这些内存块包括：
          reserve_bootmem_node(pgdat, __pa(&_stext), &_end - &_stext); /*内核所占用地址空间*/ 
          reserve_bootmem_node(pgdat, bootmap_pfn<<PAGE_SHIFT, bootmap_pages<<PAGE_SHIFT) /*bootmem结构所占用地址空间*/
        ->创建内核页表 paging_init(&meminfo, mdesc) 
          只映射所有部分物理内存供内核进程使用
          这张内核页表是给硬件单元MMU使用的,
	  至于要使用一级页表还是多级页表映射是!!是硬件MMU决定的,例如9g25这个arm架构的MMU是执行二级页表映射的!!
          因为虚拟地址转物理地址是由硬件实现的!!所以kernal只是提供建立了的页表,地址转换还是由mmu来完成!!
	  由于打开了mmu后cpu只访问虚拟地址,所以所以物理地址都需要映射到虚拟地址后才可以使用,
          由于mpu各功能寄存器是物理地址的一部分,所以cpu访问这些地址时,也要通过往虚拟地址映射
          然而内核页表一般映射的是部分ddram物理内存地址,并不包含功能寄存器地址
          关于功能寄存器的访问后述
		    
Linux 简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0～4G。
	Linux内核将这4G字节的空间分为两部分。将最高的 1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。
	而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。
	因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统 内的所有进程共享。
	于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。
linux每个用户进程都有自己单独的页表,内核线程使用内核的页表!! 每个用户进程要转到内核态时,内核态的代码都是使用这同一个内核页表
	所以进程切换时,也要执行页表切换!!!
	内核页表地址存放在 swapper_pg_dir ,每个用户态进程创建的时候,都会将这个页表复制到自己进程的页表中,成为自己页表的一部分
	1g的内核虚拟内存空间里,有128mb空间 是高端内存,具体说,这个空间可以被操作临时映射所有的物理内存地址,即可以访问所有的物理地址 
打开与不打开MMU的区别:
	未打开前,cpu访问的是实际地址,打开以后,cpu访问的只有虚拟地址
mmu 与 硬件寄存器访问关系
	打开mmu以后,cpu访问的只有虚拟地址,mpu的硬件寄存器也需要要设置到页表上,即要把物理地址映射到物理地址上,才能被访问
	一块mpu的全局地址空间除了给各个硬件分配的寄存器,还完全容纳了ddram的所有地址空间
	开启了MMU后,所有全局地址都要经过映射才能被正确访问,即ddram地址和其他硬件寄存器地址都需要映射
	keinel初始化构建内核态页表时,映射的所谓1gb内核态空间指的仅仅是ddram物理内存,并未建立对硬件寄存器的映射
	硬件寄存器的映射是在具体驱动初始化时,修改内核态页表部分内容,即分配部分虚拟地址映射到硬件寄存器地址上
	一般内核访问寄存器操作顺序是
		 request_mem_region 申请-> ioremap 建立映射-> 寄存器操作 
		-> iounmap 解除映射-> release_mem_region 释放申请。
		本质就是修改内核页表,使一部分虚拟地址映射到功能寄存器上
		一般来说，申请和释放操作分别放在open和release函数内比较好
从linux的进程切换深入理解mmu 与 页表 
	上下文概念:
		操作系统管理很多进程的执行. 有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。
		当一个进程从内核中移出，另一个进程成为活动的, 这些进程之间便发生了上下文切换. 
		操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息. 这些信息被称作上下文, 它描述了进程的现有状态, 
		进程上下文是进程执行活动全过程的静态描述, 
		当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文。
		当内核需要切换到另一个进程时，它需要保存当前进程的 所有状态，即保存当前进程的上下文，
		以便在再次执行该进程时，能够必得到切换时的状态执行下去。
		在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。
		但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程 的执行.
		进程的上下文信息包括:
			指向可执行文件的指针, 栈, 内存(数据段和堆), 进程状态, 优先级, 
			程序I/O的状态, 授予权限, 调度信息, 审计信息, 有关资源的信息(文件描述符和读/写指针), 
			有关事件和信号的信息, 寄存器组(栈指针, 指令计数器)等等, 诸如此类.
	用户进程:
		每个用户进程都已一张自己独有的内存页表,
		每个用户进程都有 用户态进程部分 和 内核态进程部分,
		所以每张用户进程页表都有两部分: 用户态页表部分 和 内核态页表部分, 相当于每个用户进程是拥有"4g内存"空间的
		其中 所有用户进程页表的 内核态页表部分 都是一模一样!!
		某时刻,进程要正在执行时,这张页表所在的物理地址是放在cp15寄存器的cr3里的,给MMU硬件模块使用
		当执行的是内核态进程而不是用户态进程时,使用的内核页表是一般是 最近一次的 用户进程页表的 内核态页表部分
		由于所有用户进程页表的 内核态页表部分 是一样的,所以其实内核态进程 使用的是指同一张内核页表
		对同一用户进程,用户态和内核态理解:
			内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。
			用户态进程所用的栈，是在进程线性地址空间中；
			而内核栈是当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，那么内核空间中使用的就是这个内核栈。
			因为内核控制路径使用很少的栈空间，所以只需要几千个字节的内核态堆栈。
	内核进程:
		一般是某些系统管理进程
		只有 内核态进程部分
		使用的 内核页表 与 用户进程内核态页表部分 是一样的,
		所以,不管是 用户进程的内核态进程部分 还是 内核进程, 都使用同一个内核页表!!
		所以切换到内核进程时并不会执行换页表操作,因为内核进程只会访问页表的内核态页表部分!!!
	进程切换,
		切换的是用户进程 与 用户进程, 用户进程的页表直接换过来
		当 用户进程 换成 内核进程时,不用换页表,内核进程直接使用用户进程的 内核态页表部分
		当 内核进程 换成 内核进程时,不用换页表,内核进程沿用最近一次的用户进程的 内核态页表部分
		因为不管是 用户进程的内核态进程部分 还是 内核进程, 都使用同一个内核页表!!,所以根本就就不用换
	context_switch进程上下文切换
		context_switch 是进程调度的核心
		用户进程A执行时,当遇到中断等各手段通知执行进程切换的时候,会转向保存用户态进程的各种信息,
			然后转向 用户进程A的内核态进程部分,然后就在此执行context_switch 切换到其他进程!!!
		内核进程B执行时,当遇到中断等各手段通知执行进程切换的时候,会转向执行context_switch 切换到其他进程!!!
		注意要认为 context_switch只在 内核进程执行,也可以在 用户进程的内核态进程部分执行!!!!
		prepare_arch_switch切换前的准备工作
			在进程切换之前, 首先执行调用每个体系结构都必须定义的prepare_task_switch挂钩, 
			这使得内核执行特定于体系结构的代码, 为切换做事先准备. 
			大多数支持的体系结构都不需要该选项
		换页表:
			struct task_struct *next->mm		//新进程内存描述符(内存描述符包含进程页表信息)
			struct task_struct *next->active_mm	//新进程活动的内存描述符(内存描述符包含进程页表信息)
			struct task_struct *prev->mm		//旧进程内存描述符
			struct task_struct *prev->active_mm	//旧进程活动的内存描述符(内存描述符包含进程页表信息)
			用户进程->active_mm 是自己的内存描述符	(active_mm)是用来做标记用的!!!
			内核进程->active_mm 是变化的
			用户进程->mm 是自己的内存描述符
			内核进程->mm 是mull值
			用户进程 换成 内核进程, 内核进程 换成 内核进程时:
				由于内核进程使用最近用户进程页表的内核态页表部分,但是注意:
				所以实际并没有换页表的实际操作
				prev是用户进程,next是内核进程,那么next会用prev的 active_mm,即next用prev页表的内核态页表部分
				prev是内核进程,next是内核进程,那么next会用prev的 active_mm,即next用最近一次用户进程页表的内核态页表部分
					而prev的 active_mm 最后要变回null
			用户进程 换成 用户进程, 内核进程 换成 内核用户进程时:
				switch_mm(prev->active_mm, next->mm, next);
				道中涉及换页表的实际操作!!就是把页表的物理地址放到cp15
				load_cr3(next->mm->pgd);	//换页表到cp15 的 cr3
				load_mm_ldt(next->mm);		//应该是换到了next进程那保存了用户态进程部分各种信息的数据结构体
				注意pgd不是GDT!! (GDT IDT LDT)的概念后面分清楚!!!
			虽然换页表了,但是进程还没有被切换,但是由于还是在内核态工作,内核页表一样,所以能继续正常工作!!!
		switch_to
			最后用switch_to完成了进程的切换, 该函数切换了寄存器状态和栈, 
			执行环境的切换是在switch_to()中完成的, switch_to完成最终的进程切换，
			它保存原进程的所有寄存器信息，恢复新进程的所有寄存器信息，并执行新的进程
			即switch_to之前还是 prev进程,switch_to执行了后,便转到了next进程的switch_to后的内容
			就是prev会停在prev的switch_to函数里,next却从next的switch_函数返回出来了!!(真正完成了进程切换)
			即开始执行 next进程switch_to之后的代码
			而prev进程switch_to之后的代码只有在当前进程下一次被选择运行时才会执行
			在每个switch_to被调用的时候, prev和next指针位于各个进程的内核栈中, 
				prev指向了当前运行的进程, 而next指向了将要运行的下一个进程
			switch_to执行了以下操作:
				进程切换, 即esp的切换, 由于从esp可以找到进程的描述符
				硬件上下文切换, 设置ip寄存器的值, 并jmp到__switch_to函数
				堆栈的切换, 即ebp的切换, ebp是栈底指针, 它确定了当前用户空间属于哪个进程
			switch_to(prev, next, last) 有三个参数意义
				譬如有a,b,c,d 4个进程,有如下切换 a->b, b->d, d->b, b->c, c->d, d->a
				第一次切换 switch_to(a,b,last) 执行switch_to的时候是a进程,要切到b进程去,
				当真的切到b后,其实a进程停在了他自己的switch_to函数,就说这个 switch_to(a,b,last) 停住了
				但最后一次切换 switch_to(d,a,last)后,a进程从停在的他自己的switch_to函数动起来了,
				就说这个 switch_to(a,b,last) 又动起来了,然后这last记录了是由那个进程切回到a进程来,这里last=d
				系统为了告知调度器, a再次执行前的进程是d, 通过switch_to的last参数返回的prev指向d
				即prev也从a换成了d,即 prev=last=d,
		barrier路障同步
			从switch_to返回后,其实就已经活动在新的进程了,后面的这些函数都是新进程内核态里执行的,
			也可以这么想进程在switch_to停住的时候其实是被切换了,现在又从switch_to动起来并跳出,说明已经切换回来可以继续动!!!!
			重新动起来的第一件事是barrier()
			其实这个barrier()应该不需要的,但在编译器编译的时候起作用的,
			如果没有barrier()
			switch_to()后面就是finish_task_switch()了,
			但编译的时候,编译器的优化有可能把switch_to()和finish_task_switch()的执行步骤糅合一块
			因为编译器不能分辨这时进程切换的关键地方,反而他优化分析到,他们是个连续过程,以下的做法运行更快,执行文件更小
			先执行switch_to()几条命令后,又优先插入finish_task_switch()几条命令,然后再继续执行switch_to()几条命令
			这时万万不允许的,所以,编译的时候,一定要避免两者因为编译优化而指令穿插!!!!
			所以中间由 barrier 隔开
		finish_task_switch(prev)完成清理工作
			重新动起来的第二件事是finish_task_switch()
			处理转回来时,之前的被停住的进程的相关信息!!!
			比如说上述的  a->b, b->d, d->b, b->c, c->d, d->a
			最后转回到a时, 即switch_to(d,a,last)停住,switch_to(a,b,last)返回时,
			switch_to(a,b,last)的prev参数从本来指向a自己,变成了指向了d
			finish_task_switch(prev)是处理进程 d 的状态 信息, 
			比如说,a发现d进程已经处于TASK_DEAD状态,就释放d进程的TASK_STRUCT结构,即真正地删除了标识已结束的d进程!!!!
虽然上下文切换是两个进程间的切换核心,但是如何唤起进程切换是一个大问题!!
	意味如果唤起进程切换 的是在 内核进程中运行, 那又是如何唤起进程切换先进入这个所谓的内核进程呢?是一个死结问题
	若是kernel的中断程序唤起进程切换,那这个中断程序是属于哪个进程呢?
	如果中断不属于任何进程,那又是如何做到让现在进程停下手上工作,突然间开始切换到新进程的内核态代码区?
进程调度切换只有一个方法: schedule()->context_switch()
	schedule()->context_switch()在切换动作前运行在 prev进程,
	在切换动作后,schedule()->context_switch()的收尾指令运行在 next进程
主调度器(核心调度器):
	指进程主动调用schedule()
	schedule()是在当前执行中德尔进程执行的,直至切换到别的进程.并不是在某个特定的内核进程的执行两个进程的调度
	context_switch()是schedule()的核心内容
周期调度器(通用调度器):周期性机制,
	定时中断,中断时,cpu从user_mode 进入irq_mode ,执行定时中断函数
	(其实就是本来cpu运行在user_mode的寄存器组,中断后,转到irq_mode寄存器组上工作,user_mode的寄存器组被冻结在当前状态)
	定时中断函数先 保存当前cpu在user_mode下执行的进程(例如进程A)的进度以及上下文,即被冻结的user_mode的寄存器组相关内容会被包存起来
		然后给进程A插入一段ret_from_sys_call（）内容,即改写user_mode的寄存器组内容,
		使得中断函数结束返回后,cpu回到user_mode,进程A不会继续之前的内容,而是先执行ret_from_sys_call（）后再执行之前的内容
	注意:
		我们之前一直谈论的 用户进程 ,内核进程 指的是 cpu工作在user_mode的寄存器组时 做进程的划分,
		当cpu工作在irq_mode的寄存器组时,这时执行的只是中断函数,并没有什么进程划分,并不属于上面的用户进程,内核进程任一方,
		即 scheduler_tick() 是在中断函数中执行的, 不是在某个 内核进程 或者 用户进程里执行
	scheduler_tick() 会分析当前cpu从user_mode下执行的进程(例如进程A)是不是要进行调度了!!!
		如果是,则在进程A的数据结构上标记相关内容 这叫激发延迟调度
	中断函数结束返回后,cpu回到user_mode执行进程A,进程A不会继续之前的内容,会先执行ret_from_sys_call（）
		ret_from_sys_call（）如果检测相关标记,就会执行 schedule()->context_switch() 切换掉进程A,
		假若进程A真被切换掉了,进程A会停在ret_from_sys_call（）->schedule()->context_switch()
		后面,进程A被切换回来重新运行,会先从ret_from_sys_call（）返回,然后回到之前被定时中断函数打断的地方执行!!!
	调用关系:
	static irqreturn_t ioc_timer_interrupt(int irq, void *dev_id)		(arch/arm/mach-rpc) 所以timer_tick应该没有用到
	    ->void timer_tick(void)			(arch/arm/kernel)
	        ->update_process_times(int user_tick)	
	            ->scheduler_tick();
	void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)
	    ->void tick_handle_periodic(struct clock_event_device *dev)
	        ->static void tick_periodic(int cpu)	(kernel/time)
	            ->update_process_times(int user_tick)	
	                ->scheduler_tick();
	void tick_setup_sched_timer(void)
	    ->static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)
	        ->static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)	(kernel/time)
	            ->update_process_times(int user_tick)	
	                ->scheduler_tick();
	int tick_check_oneshot_change(int allow_nohz)
	    static void tick_nohz_switch_to_nohz(void)
	        static void tick_nohz_handler(struct clock_event_device *dev)
	            ->static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)	(kernel/time)
	                ->update_process_times(int user_tick)	
	                    ->scheduler_tick();

未整理的网络参考: https://zhidao.baidu.com/question/756077885634341164.html
Linux在众多进程中是怎么进行调度的，这个牵涉到Linux进程调度时机的概念，由Linux内核中Schedule（）的函数来决定是否要进行进程的切换，
如果要切换的话，切换到哪个进程等等。
Linux进程调度时机主要有：
1、进程状态转换的时刻：进程终止、进程睡眠；
2、当前进程的时间片用完时（current->counter=0）；
3、设备驱动程序
4、进程从中断、异常及系统调用返回到用户态时；
时机1，进程要调用sleep（）或exit（）等函数进行状态转换，这些函数会主动调用调度程序进行进程调度；
时机2，由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机4是一样的。
时机3，当设备驱动程序执行长而重复的任务时，直接调用调度程序。在每次反复循环中，驱动程序都检查need_resched的值，
	如果必要，则调用调度程序schedule()主动放弃CPU。
时机4，如前所述，不管是从中断、异常还是系统调用返回，最终都调用ret_from_sys_call（），由这个函数进行调度标志的检测，
	如果必要，则调用调用调度程序。那么，为什么从系统调用返回时要调用调度程序呢？这当然是从效率考虑。
	从系统调用返回意味着要离开内核态而返回到用户态，而状态的转换要花费一定的时间，因此，在返回到用户态前，系统把在内核态该处理的事全部做完。
对于直接执行调度程序的时机，我们不讨论，因为后面我们将会描述调度程序的工作过程。前面我们讨论了时钟中断，知道了时钟中断的重要作用，
	下面我们就简单看一下每个时钟中断发生时内核要做的工作，首先对这个最频繁的调度时机有一个大体了解，然后再详细讨论调度程序的具体工作过程。
每个时钟中断（timer interrupt）发生时，由三个函数协同工作，共同完成进程的选择和切换，
	它们是：schedule（）、do_timer（）及ret_form_sys_call（）。我们先来解释一下这三个函数：
schedule（）：进程调度函数，由它来完成进程的选择（调度）；
do_timer（）：暂且称之为时钟函数，该函数在时钟中断服务程序中被调用，是时钟中断服务程序的主要组成部分，
	该函数被调用的频率就是时钟中断的频率即每秒钟100次（简称100赫兹或100Hz）；
ret_from_sys_call（）：系统调用返回函数。当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作，例如信号处理、核心任务等等。
这三个函数是如何协调工作的呢？
前面我们看到，时钟中断是一个中断服务程序，它的主要组成部分就是时钟函数do_timer（），
	由这个函数完成系统时间的更新、进程时间片的更新等工作，更新后的进程时间片counter作为调度的主要依据。
在时钟中断返回时，要调用函数ret_from_sys_call（），前面我们已经讨论过这个函数，在这个函数中有如下几行：
cmpl $0, _need_resched
jne reschedule
……
restore_all:
RESTORE_ALL

reschedule:
call SYMBOL_NAME(schedule)
jmp ret_from_sys_call

这几行的意思很明显：检测 need_resched 标志，如果此标志为非0，那么就转到reschedule处调用调度程序schedule（）进行进程的选择。
	调度程序schedule（）会根据具体的标准在运行队列中选择下一个应该运行的进程。当从调度程序返回时，如果发现又有调度标志被设置，
	则又调用调度程序，直到调度标志为0，这时，从调度程序返回时由RESTORE_ALL恢复被选定进程的环境，返回到被选定进程的用户空间，使之得到运行。
以上就是时钟中断这个最频繁的调度时机。讨论这个的主要目的使读者对时机4有个大致的了解。
另外，TIF_NEED_RESCHED的设置时机 :
设置这个标志的函数主要有两个: resched_task(),set_tsk_need_resched().主要是resched_task,
	而resched_task的调用者 check_preempt_curr更是通过:try_to_wake_up/wake_up_new_task/pull_task /__migrate_task 
	这些被广泛使用的函数, 从而分布在内核中大量的检查点有机会抢占进程.
最后要说明的是，系统调用返回函数ret_from_sys_call（）是从系统调用、异常及中断返回函数通常要调用的函数，
	但并不是非得调用，对于那些要经常被响应的和要被尽快处理的中断请求信号，为了减少系统开销，
	处理完成后并不调用 ret_from_sys_call（）（因为很显然的，从这些中断处理程序返回到的用户空间肯定是那个被中断的进程，无需重新选择），
	并且，它们作的工作要尽可能少，因为响应的频率太高了。
Linux进程调度和其他的UNIX进程调度不同，尤其是在“nice level”优先级的处理上，与优先权调度（priority高的进程最先运行）不同，
	Linux用的是时间片轮转调度（Round Robing），但同时又保证了高优先级的进程运行的既快、时间又长（both sooner and longer）。
	而标准的UNIX调度程序都用到了多级进程队列。大多数的实现都用到了二级优先队列：一个标准队列和一个实时（“real time”）队列。
	一般情况下，如果实时队列中的进程未被阻塞，它们都要在标准队列中的进程之前被执行，并且，每个队列中，“nice level”高的进程先被执行。
总体上，Linux 调度序程在交互性方面表现很出色，当然了，这是以牺牲一部分“吞吐量”为代价的。 

扩展内容 cache:
机子启动时会先把所有cache关闭,因为这时的cache存蓄随机数据,如果不关,根据cache的工作原理分析,机子运作可能会失败
在一个处理器系统中，指令Cache与数据Cache的组成方式和使用规则有所不同。
在现代处理器系统中，在L1 Cache层面，指令Cache与数据Cache通常分离，
而在其后的Cache层次中，指令与数据混合存放，在多数情况下L1指令Cache是只读的，
因此Cache Block中包含的状态较少一些，一致性处理相对较为简单









20170808
进程深入学习:
	esp寄存器是CPU栈指针
	namespace 是只使用一个内核在一台物理计算机上运作，前述的所有全局资源都通过命名空间抽象起来。
		  这使得可以将一组进程放置到容器中，各个容器彼此隔离。
		  本质上，命名空间建立了系统的不同视图。此前的每一项全局资源都必须包装到容器数据结构中，
		  只有资源和包含资源的命名空间构成的二元组仍然是全局唯一的。虽然在给定容器内部资源是自足的，但无法提供在容器外部具有唯一性的ID
		  这意义相当于 让同一台电脑,同时间运行多个个各自独立的linux系统,互相隔离,互不影响
		  一个进程有多个pid 分别属于多个namespace
	 各种相关id:
	 	PID 内核唯一区分每个进程的标识
			pid是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。
			在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值
			这个pid用于内核唯一的区分每个进程
			注意它并不是我们用户空间通过getpid( )所获取到的那个进程号，至于原因么，接着往下看
		TGID 线程组（轻量级进程组）的ID标识
			在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程
			（即轻量级进程，Linux其实没有严格的进程概念），它们处于一个线程组，
			该线程组的所有线程的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID，
			但是由于他们是不同的进程，因此其pid各不相同；线程组组长（也叫主线程）的TGID与其PID相同；
			一个进程没有使用线程，则其TGID与PID也相同。
			该进程的线程描述符。在linux内核中对线程并没有做特殊的处理，还是由task_struct来管理。
			所以从内核的角度看， 用户态的线程本质上还是一个进程。
			对于同一个进程（用户态角度）中不同的线程其tgid是相同的，但是pid各不相同。 
			主线程即group_leader（主线程会创建其他所有的子线程）。如果是单线程进程（用户态角度），它的pid等于tgid。
		PGID
			另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作
			例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。
		SID
			几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。
			会话组中所有进程都有相同的SID,保存在task_struct的session成员中
		全局ID 在内核本身和初始命名空间中唯一的ID，在系统启动期间开始的 init 进程即属于该初始命名空间。
			系统中每个进程都对应了该命名空间的一个PID，叫全局ID，保证在整个系统中唯一。
			全局PID和TGID直接保存在task_struct中，分别是task_struct的pid和tgid成员：
		局部ID 对于属于某个特定的命名空间，它在其命名空间内分配的ID为局部ID，该ID也可以出现在其他的命名空间中。
		struct task_struct -> nsproxy 	指针指向namespace相关的域，通过nsproxy域可以知道该task_struct属于哪个pid_namespace
	#如何快速地根据局部ID、命名空间、ID类型找到对应进程的 task_struct
		pid_hash[]
		这是一个hash表的结构，根据pid的nr值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。
		这样，就能解决开始提出的第2个问题了，根据PID值怎样快速地找到task_struct结构体：
		首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项
		遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid
		再通过该 pid 结构体的 tasks 指针找到 node
		最后根据内核的 container_of 机制就能找到 task_struct 结构体
	#如何快速地给新进程在可见的命名空间内分配一个唯一的 PID
		pid_map
		这是一个位图，用来唯一分配PID值的结构，图中灰色表示已经分配过的值，在新建一个进程时，
		只需在其中找到一个为分配过的值赋给 pid 结构体的 nr，再将pid_map 中该值设为已分配标志。
		这也就解决了上面的第3个问题——如何快速地分配一个全局的PID
		至于上面的**第1个问题*就更加简单，已知 task_struct 结构体，根据其 pid_link 的 pid 指针找到 pid 结构体，取出其 nr 即为 PID 号。
	linux线程与进程区别!!!
		我们在区分Linux进程类别, 但是我还是想说Linux下只有一种类型的进程，那就是task_struct，
		当然我也想说linux其实也没有线程的概念, 只是将那些与其他进程共享资源的进程称之为线程
		Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称他们为线程或者轻量级进程
		Linux上进程分3种，内核线程（或者叫核心进程）、用户进程、用户线程, 当然如果更严谨的，你也可以认为用户进程和用户线程都是用户进程
		这里的线程不是我们印象中多cpu并行执行的线程
	Linux下有3个特殊的进程，idle进程($PID = 0$), init进程($PID = 1$)和kthreadd($PID = 2$)
		idle进程由系统自动创建, 运行在内核态 idle进程其pid=0，其前身是系统创建的第一个进程，
			也是唯一一个没有通过fork或者kernel_thread产生的进程
		0号进程创建1号进程的方式如下 :kernel_thread(kernel_init, NULL, CLONE_FS);
			随后，1号进程调用do_execve运行可执行程序init，并演变成用户态1号进程，即init进程。	
		1号进程的执行函数就是kernel_init, 这个函数被定义init/main.c中
		由0号进程创建1号进程（内核态），1号内核线程负责执行内核的部分初始化工作及进行系统配置，
			并创建若干个用于高速缓存和虚拟主存管理的内核线程。
		kthreadd: 是其他内核线程的建造者. 
			内核线程其实就是上述区分说明的内核进程,由于共用资源的关系,所以属于linux线程的定义,所以也叫内核线程
			ps -eo pid,ppid,command		//查看当前存在的进程
			以下显示 其中一部分 的内核内核线程
			  PID  PPID COMMAND
			    1     0 /sbin/init
			    2     0 [kthreadd]
			    3     2 [ksoftirqd/0]
			    5     2 [kworker/0:0H]
			    7     2 [rcu_sched]
			    8     2 [rcu_bh]
			    9     2 [rcuos/0]
			   10     2 [rcuob/0]
			   11     2 [migration/0]
			   12     2 [watchdog/0]
			   13     2 [watchdog/1]
			   14     2 [migration/1]
			   15     2 [ksoftirqd/1]
			   17     2 [kworker/1:0H]
			   18     2 [rcuos/1]
			   19     2 [rcuob/1]
			   20     2 [watchdog/2]
			   21     2 [migration/2]
			   22     2 [ksoftirqd/2]
			   24     2 [kworker/2:0H]
			   25     2 [rcuos/2]
			   26     2 [rcuob/2]
			   27     2 [watchdog/3]
			   28     2 [migration/3]
			   29     2 [ksoftirqd/3]	
	系统调用:
		实现与C库不同, 普通C函数通过将参数的值压入到进程的栈中进行参数的传递。
		由于系统调用是通过中断进程从用户态到内核态的一种特殊的函数调用，
		没有用户态或者内核态的堆栈可以被用来在调用函数和被调函数之间进行参数传递。
		系统调用通过CPU的寄存器来进行参数传递。在进行系统调用之前，系统调用的参数被写入CPU的寄存器，
		而在实际调用系统服务例程之前，内核将CPU寄存器的内容拷贝到内核堆栈中，实现参数的传递。
		即不同的体系结构可能需要采用不同的方式或者寄存器来存储函数调用的参数， 
		因此linux在设计系统调用的时候, 将其划分成体系结构相关的层次和体系结构无关的层次, 
		前者复杂提取出依赖与体系结构的特定的参数， 后者则依据参数的设置执行特定的真正操作
	thread_info结构:
		除了thread信息外,还紧贴着一个内核栈,一般加起来共8k空间
	do_fork:
		只是复制出一个新的进程
	do_execve:
		替换进程里的程序内容,使进程执行被设计的程序内容!!
	ELF:
		代表Executable and Linkable Format。他是一种可执行文件、目标文件和库使用的文件格式。
memory深入学习:(内核内存分配管理)
	服务器系统架构来看，目前的商用服务器大体可以分为三类
		对称多处理器结构(SMP：Symmetric Multi-Processor):
			多cpu 共享统一硬盘,内存,各类I/O
		非一致存储访问结构(NUMA：Non-Uniform Memory Access):
			安排每个cpu都有自己的硬盘,内存,各类I/O,访问速度快,每个cpu也可以直接访问其他cpu的资源,但是访问速度慢
		海量并行处理结构(MPP：Massive Parallel Processing):
			多个SMP并联,每个smp之间通讯通过特定协议!!
	共享存储型多处理机有两种模型
		均匀存储器存取（Uniform-Memory-Access，简称UMA）模型:
			传统的多核运算是使用SMP(Symmetric Multi-Processor )模式：将多个处理器与一个集中的存储器和I/O总线相连。
			所有处理器只能访问同一个物理存储器，因此SMP系统有时也被称为一致存储器访问（UMA）结构体系，
			一致性意指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值
		非均匀存储器存取（Nonuniform-Memory-Access，简称NUMA）模型
			NUMA模式是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址，大幅度提高并行性。 
			NUMA总是多处理器计算机,系统的哪个CPU都有本地内存, 可支持快速的访问, 各个处理器之前通过总线链接起来, 
			以支持堆其他CPU的本地内存的访问, 当然访问要比本地内存慢.
	linux 的内存机构,使用的是 NUMA
		处理器被划分成多个"节点"(node), 每个节点被分配有的本地存储器空间. 所有节点中的处理器都可以访问全部的系统物理存储器，
		但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多
		按道理,每个 node 对应 一个cpu!!
		内存被分割成多个区域（BANK，也叫"簇"），依据簇与处理器的"距离"不同, 访问不同簇的代码也会不同. 
		比如，可能把内存的一个簇指派给每个处理器，或则某个簇和设备卡很近，很适合DMA，那么就指派给该设备。
		因此当前的多数系统会把内存系统分割成2块区域，一块是专门给CPU去访问，一块是给外围设备板卡的DMA去访问
		注意:
			linux 的内存机构基于 NUMA ,但是兼容 SMP系统架构及对应的UMA, 像以下方式兼容：
    			SMP多cpu 看做成一个cpu组,
			在UMA系统中, 内存就相当于一个只使用一个NUMA节点来管理整个系统的内存. 
			而内存管理的其他地方则认为他们就是在处理一个(伪)NUMA系统.
		Linux把物理内存划分为三个层次来管理:
			存储节点(Node): 	
				CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 
				即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点
				用pd_data_t描述内存节点node
			管理区(Zone):
				每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存
				一个管理区(zone)由struct zone结构体来描述
			页面(Page):
				内存被细分为多个页面帧, 页面是最基本的页面分配的单位
	管理区(Zone):
		zone:讨论的是 内核虚拟地址空间分配,不包括用户空间的分配与使内容
		对于典型x86机器，管理区(内存区域)类型如下分布
			类型 		区域
			ZONE_DMA 	0~15MB
			ZONE_NORMAL 	16MB~895MB
			ZONE_HIGHMEM 	896MB~物理内存结束
			而由于32位系统中, Linux内核虚拟地址空间只有 1G, 而0~895M这个986MB被用于DMA和直接映射, 
			剩余的物理内存被成为高端内存. 那内核是如何借助剩余128MB高端内存地址空间是如何实现访问可以所有物理内存？
		高端内存:
			当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，
			借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），
			临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存
	start_kernel启动过程:
		在初始化过程中, 还必须建立内存管理的数据结构, 以及很多事务. 因为内核在内存管理完全初始化之前就需要使用内存.
		start_kernel()
		    |---->page_address_init()
		    |     考虑支持高端内存
		    |     业务：初始化page_address_pool链表；
		    |          将page_address_maps数组元素按索引降序插入
		    |          page_address_pool链表; 
		    |          初始化page_address_htable数组.
		    | 
		    |---->setup_arch(&command_line);
		    |     初始化特定体系结构的内容
		    	  |
		    	  |---->arm64_memblock_init( );
		          |     初始化引导阶段的内存分配器memblock
			  |     (memblock已经通过arm64_memblock_init完成了初始化, 至此系统中的内存可以通过memblock分配了)
		          |
		          |---->paging_init();
		          |     分页机制初始化
			  |     (paging_init完成了分页机制的初始化, 至此内核已经布局了一套完整的虚拟内存空间)
		          |
		          |---->bootmem_init();   [当前位置]
		          |     始化内存数据结构包括内存节点, 内存域和页帧page
		                |
		                |---->arm64_numa_init();
		                |     支持numa架构
		                |
		                |---->zone_sizes_init(min, max);
		                    来初始化节点和管理区的一些数据项
		                    |
		                    |---->free_area_init_node
		                    |   初始化内存节点
		                    |
		                        |---->free_area_init_core
		                            |	初始化zone
		                            |
		                            |---->memmap_init
		                            |	初始化page页面
		                |
		                |---->memblock_dump_all();
		                |   初始化完成, 显示memblock的保留的所有内存信息
		         	   |
		    |---->build_all_zonelists()	初始化每个内存节点的zonelists
		    |     为系统中的zone建立后备zone的列表.
		    |     所有zone的后备列表都在
		    |     pglist_data->node_zonelists[0]中;
		    |
		    |     期间也对per-CPU变量boot_pageset做了初始化. 
	 	    |
		    |
		    |---->page_alloc_init()
		         |---->hotcpu_notifier(page_alloc_cpu_notifier, 0);
		         |     不考虑热插拔CPU 
		         |
		    |---->pidhash_init()
		    |     详见下文.
		    |     根据低端内存页数和散列度，分配hash空间，并赋予pid_hash
		    |
		    |---->vfs_caches_init_early()
		          |---->dcache_init_early()
		          |     dentry_hashtable空间，d_hash_shift, h_hash_mask赋值；
		          |     同pidhash_init();
		          |     区别:
		          |         散列度变化了（13 - PAGE_SHIFT）;
		          |         传入alloc_large_system_hash的最后参数值为0;
		          |
		          |---->inode_init_early()
		          |     inode_hashtable空间，i_hash_shift, i_hash_mask赋值；
		          |     同pidhash_init();
		          |     区别:
		          |         散列度变化了（14 - PAGE_SHIFT）;
		          |         传入alloc_large_system_hash的最后参数值为0;
		          |
		在系统启动过程期间, 使用了额外的简化悉尼股市的内存管理模块, 然后在初始化完成后, 将旧的模块丢弃掉.
		setup_arch 	        是一个特定于体系结构的设置函数, 其中一项任务是负责初始化自举分配器
		mm_init_cpumask 	初始化CPU屏蔽字
		setup_per_cpu_areas 	函数(查看定义)给每个CPU分配内存，并拷贝.data.percpu段的数据. 为系统中的每个CPU的per_cpu变量申请空间.
					在SMP系统中, setup_per_cpu_areas初始化源代码中(使用per_cpu宏)定义的静态per-cpu变量, 
					这种变量对系统中每个CPU都有一个独立的副本.此类变量保存在内核二进制影像的一个独立的段中,
					setup_per_cpu_areas的目的就是为系统中各个CPU分别创建一份这些数据的副本在非SMP系统中这是一个空操作
		build_all_zonelists 	建立并初始化结点和内存域的数据结构
		mm_init 		建立了内核的内存分配器,
					其中通过mem_init停用bootmem分配器并迁移到实际的内存管理器(比如伙伴系统)
					然后调用kmem_cache_init函数初始化内核内部用于小块内存区的分配器
		kmem_cache_init_late 	在kmem_cache_init之后, 完善分配器的缓存机制,　
					当前3个可用的内核内存分配器slab, slob, slub都会定义此函数　
		kmemleak_init 		Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，
					其方法类似于跟踪内存收集器。当独立的对象没有被释放时，
					其报告记录在 /sys/kernel/debug/kmemleak中, Kmemcheck能够帮助定位大多数内存错误的上下文
		setup_per_cpu_pageset 	初始化CPU高速缓存行, 为pagesets的第一个数组元素分配内存, 换句话说, 其实就是第一个系统处理器分配
					由于在分页情况下，每次存储器访问都要存取多级页表，这就大大降低了访问速度。
					所以，为了提高速度，在CPU中设置一个最近存取页面的高速缓存硬件机制，当进行存储器访问时，
					先检查要访问的页面是否在高速缓存中.
	内存分配:
		linux内核的内存管理分三个阶段。
			第一阶段 | 系统启动 | bootmem或者memblock初始化完成 
				(此阶段只能使用memblock_reserve函数分配内存， 早期内核中使用init_bootmem_done = 1标识此阶段结束)
				(bootmen内核刚启动时执行的内存管理!!)
			第二阶段 | bootmem或者memblock初始化完 | buddy完成前 | 引导内存分配器bootmem或者memblock接受内存的管理工作, 
				早期内核中使用mem_init_done = 1标记此阶段的结束 
			第三阶段 | buddy初始化完成 | 系统停止运行 | 可以用cache和buddy分配内存	
		memblock内存分配
			是将所有的物理内存放到memblock.memory中作为可用内存来管理, 
			分配过的内存只加入到memblock.reserved中, 并不从memory中移出
			同理释放内存也会加入到memory中. 也就是说, memory在fill过后基本就是不动的了. 
			申请和分配内存仅仅修改reserved就达到目的. 在初始化阶段没有那么多复杂的内存操作场景, 
			甚至很多地方都是申请了内存做永久使用的, 所以这样的内存管理方式已经足够凑合着用了, 
			毕竟内核也不指望用它一辈子. 在系统完成初始化之后所有的工作会移交给强大的buddy系统来进行内存管理
	伙伴系统:
		分出一个含2的n次方个页的块,然后这个块分成连部分,一个使用,一个空闲.这两个块是伙伴(n根据实际情况定)
		如果使用的块提供的内存不够,空闲的块再次分成两块,一个使用,一个空闲.这两个块又是另一伙伴
		如此类推.
		内核初始化时使用的是memblock内存分配,初始化后,就把所有内存管理的任务交给了伙伴系统
		当那一个使用的块占用完毕,会跟自己的空闲块伙伴重新变成上一级的空闲块
		有关伙伴系统和当前状态的信息可以在/proc/buddyinfo中获取
		kmalloc: 一般是分配 内核的空间的zone_nomal虚拟空间,直接映射到 物理内存的 从3g+16mb到3g+895mb 的内存
		vmalloc:一般分配 zone_highmen的前120mb虚拟空间 可映射每一个物理内存位置
		kmap:一般是分配 zone_highmen的中间4mb虚拟空间 可以映射每一个物理内存位置
		kmap_automic:kmap的高效版,一般是分配 zone_highmen的最后4mb虚拟空间 可以映射每一个物理内存位置
	slab分配器:
		也叫slab着色器,其实就是一个个的结构数据预备队列,用的时候使用已分配好内存的空闲的结构数据,用完后返还回空闲结构数据
		通常用于 常用的结构数据 例如 struct task 什么的
		
		这种方式,比起 每次使用新结构数据时 都要重新通过伙伴系统分配内存,不用则释放内存的做法要高效
		slab分配器初始化:
			start_kernel() -> mm_init() -> kmem_cache_init();
			第一个阶段 	是根据kmem_cache来设置cache_cache的字段值
			第二个阶段 	首先是创建arraycache_init对应的高速缓存，同时也是在这个kmem_cache_create的调用过程中，
					创建了用于保存cache的kmem_cache的slab，并初始化了slab中的各个对象
			第三个阶段 	创建kmem_list3对应的高速缓存，在这里要注意的一点是，
					如果sizeof(arraycache_t)和sizeof(kmem_list3)的大小一样大，
					那么就不再使用kmem_cache_create来为kmem_list3创建cache了，
					因为如果两者相等的话，两者就可以使用同一个cache
			第四个阶段 	创建并初始化所有的通用cache和dma cache
			第五个阶段 	创建两个arraycache_init对象，
					分别取代cache_cache中的array字段 和 malloc_sizes[INDEX_AC].cs_cachep->array字段
			第六个阶段 	创建两个kmem_list3对象，取代cache_cache中的kmem_list3字段
					和malloc_sizes[INDEX_AC].cs_cachep->nodelist3字段.
					如此一来，经过上面的六个阶段后，所有的初始化工作基本完成了
		slab使用:
			例如系统频繁申请使用 A结构的数据,所以建立一个A结构数据的预备队
			kmem_cache_create() 创建一个 A结构数据预备队! 从伙伴系统里分出内存组建预备队
			struct kmem_cache 是一个预备队的描述符结构,即一个 struct kmem_cache代表 一个结构数据的预备队
			一个预备队只服务于同一个数据结构
			一个 A结构数据预备队:
				有多个slab组,一个slab组是连续的多个页构成
				每个slab组上放置着多个 A结构数据对象
				这些对象,标记为空闲的表示未使用,标记非空闲表示正在使用中.
				当所有slab上的对象都被使用时,内核进程还继续需要新的结构数据时,就会通过伙伴系统继续分配内存来组建新的slab组
			kmem_cache_alloc() 分配空闲结构数据对象 给进程使用,
			kmem_cache_free() 回收不在使用的数据对象, 即不再使用的数据对象重新标记为空闲
			kmem_cache_destroy 当所有A结构数据对象都不再使用时,可调用此销毁整个预备队,释放内存
				依次扫描slabs_free链表上的slab. 首先对每个slab上的每个对象调用析构器函数，然后将slab的内存空间返回给伙伴系统.
				释放用于per-CPU缓存的内存空间。
				从cache_cache链表移除相关数据。
	
			补充:
			struct kmem_cache 中有多个 array_cache 内容是指向cpu的,有多少个cpu就有多少个array_cache
			array_cache 是指向 cpu 的高速缓存的,
			即如果有些需要使用的结构数据对象 要求对象是在 cpu_cache(即高速缓存)时,跟array_cache的内容就有关系了
		kmalloc: 分配内存给结构数据时,
			如果检测到是常用的结构数据时,就会选择使用slab分配
			然后如果发现没有对应的预备队,就会建一个 kmem_cache_create()
			然后 kmem_cache_alloc() 分配出一个对象来供使用
		kfree: 释放一个结构数据
			如果检测到预备队里的 数据对象, 就kmem_cache_free() 标记空闲并归还给预备队
memory深入学习:(用户进程的用户态内存分配管理)
	每个用户进程都有自己的用户态空间和内核空间,对于32机器说共4gb,其中3gb用户空间和1gb用户空间!!
	其实,用户进程的用户态进程部分和内核态部分应该算作是两个独立的进程,都参与调度!!但是他们比较特别,共用一个PID!!
		如果是内核态部分在运作时,用户态部分永远在沉睡,进程调度永远不会调到这个对应的用户态部分,除非内核态部分完成并唤醒用户态部分!!!
		相反谈论,同样道理
	用户态部分有自己的3g内存空间, 内核态部分,则和所有内核进程共用1g空间.
		用户态部分有自己的3g内存空间, 指每个用户进程用户态部分都有自己页表映射到物理内存,
		内核态部分共用1g空间,指用户进程内核态部分都共用一张页表.
	一个用户进程的用户态地址空间主要由两个数据结来描述:
		mm_struct:
			最高层次的mm_struct结构描述了一个用户态部分的进程的整个虚拟地址空间。每个用户进程只有一个mm_struct结构,
			在每个用户进程的task_struct结构中, 有一个指向该进程的结构,
			成员有页表位置,栈,堆,参数变量,系统变量,等等的位置
			mm_struct 这个数据对象是放在内核态内存区的,虽然他是用来描述一个用户进程用户态部分的内存结构
		vm_area_structs
			较高层次的结构vm_area_truct描述了用户态虚拟地址空间的一个区间(简称虚拟区).
			一般的虚拟区有:
				当前运行代码的二进制代码. 该代码通常称之为text,所处的虚拟内存区域称之为代码段(text section).
				可执行文件的已初始化全局变量的内存映射, 称为数据段(data section).
				包括未初始化全局变量(也就是bss段的零页)的内存映射， 页面中的信息全部为0值, 所以可用于映射bss段等目的.
				用于保存局部变量和实现函数/过程调用栈(不要和进程内核栈混淆, 进程的内核栈独立存在并由内核维护)的零页内存映射
				程序使用的动态库的代码, 诸如C库或动态连接程序等共享库的代码段, 数据段和bss段.
				存储动态产生的数据的堆
				环境变量和命令行参数的段.
				将文件内容映射到虚拟地址空间中的内存映射
	建立布局(建立用户进程和内核进程均适用):
		当fork一个新进程后,执行exec 把一个新程序替换原有的程序时,就出现加载程序文件的操作
		会使用load_elf_binary装载一个ELF二进制程序文件,装嵌的工程中需要对进程的各种空间重新布局适应新程序
		重新布局的工作有:
			arch_pick_mmap_layout 根据实际情况选择布局样式,例如根据 legacy_va_layout 指示
			如何选择内存映射的基地址, 该工作由mmap_base来完成
		回到load_elf_binary. 该函数最后需要在适当的位置创建栈





201708011
m7板子samv70移植ov7725
ov7725的一些内容:
	i2c: 0x42 for write, 0x43 for read
	未知数据输出开关: com3 bit0  ??  com11 bit1  HREF bit3   ??  com2 bit4  ??
		         HSTART~VSIZE(这里是定的是采集的图片大小,与输出开关无关)
		         com10 bit1(重点,这里似乎是设置vsync有效的极性)
	由于不知道图片传输的信号开关,所以试图 从采集图片开始分析!! (还没开始分析)
同样m7板子same70_xplaint移植 摄像头
	烧录环境搭建: 
		iar jlink不行, 但是sam-ba可以通过j-link烧录!
		注意编译前 linker文件选flash的,不是sram的
	测试:
		使用ov2640 ,居然不能读出型号寄存器的值,但i2c完好工作!
		流数据并口连接: ISI_D0~D7 接seneor D2~D9
		卧槽,更奇葩的来了:烧录了程序后,先开发完全断电!!!然后插上usb,然后打开软件就可以看到了视频流!!!!
		但是如果在非掉电的情况下,reset 后, 就会出现读取芯片的寄存器失败!!!!
			原因是,一上电后sensor芯片其实一直在做视频流输出的工作,不管有没有打开了视频软件,
			当我们非掉电reset时,sensor其实并没有reset到,反而因为突然的输入xclk断开了而出现一些混乱,
			整体说sensor已经跑飞了!!!!需要reset,但是开发板的reset没有reset到sensor!!1
			证明:当我在开发板非掉电reset前拔掉sensor的3.3v针,非掉电reset后插上, 就成功启动了!!
		所以试图软件reset sensor,(sensor虽然跑飞,但是i2c模块还是正常工作的,通过i2c传输软reset到指定寄存器)
			1,例如操作pwdn 但是后来发现买回来的ov2640模块的pwdn实际上是notconnect的,
			  任我m7芯片怎么操作 PIO_Set/PIO_Clear pwdn针也没有用!!!
			2,尝试操作reset寄存器,注意reset寄存器有多个,易混淆,注意是 sensor控制区的com7寄存器的bit7 而不是其他!!
			  成功!!! 
			  即以后 非掉电reset时,seneor也会得到reset!!! 从而可以正常启动!!!!!
			  相关重点代码:
				//by william
				const sensorReg_t ov2640rst[] = {
					{0xFF, 0x01},	//选sensor块
					{0x12, 0x80},	//com7 bit7 reset
				        {0x0E, 0x11},	//0x0e是一个无作为的寄存器,通过给无作为寄存器写内容达到延时作用!!!!
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
					{0xFF, 0xFF}
				};
			        //by william ov2460 reset
			        sensor_twi_write_regs (&twid, ov2640rst);
				//注意 sendorStatus_t sensor_twi_write_regs(Twid *pTwid, const sensorReg_t *pReglist)
				//还有 Twid twid;
开始移植 ov7725:
	The device slave addresses are 0x42 for write and 0x43 for read  即7位地址为0x21
	ov7725的芯片跑不过来处理i2c传来的内容,所以每次i2c通讯之间需要加延时!!!!设置时 原子读过程中,写地址,和读数据间都要延时!!!
	但是秉火的可以通讯,秉火的是12mhz运转时钟的
	跟商家换了个模块 可以i2c通讯了 也有vs hf pck d0-d7 的信号输出了,但上位机软件就是没有图像
	换了商家的代码,终于有视频流了!!! 但是图像色彩翻转,原来是用了RGB格式, 应该换成yuv格式
	0x12,0x40 换成了yuv格式 还是色彩颠倒!!!
	怀疑是数据流传输格式问题.
		更改:UV swap (works with register COM3[4] (0x0C)and DSP_Ctrl3[7](0x66))
		{COM3[4], DSP_Ctrl3[7]}	= 10: U0Y0, V1Y1, U2Y2, V3Y3, ...
		成功显示!!!
	从QVGA(320x240) 转到 VGA(640x480)
		main,ov7725 该做成vga的也该了,而且摄像头也变慢了,应该是摄像头设置为vga成功了,
		但是还是出来 320x240 的图,demo说过由于空间问题,所以demo只输出qvga的视频流,所以还有某个与usb交互的地方固死了参数!!
		怀疑 viddprobedata 里的 bframeIndex 应该为 2 !!  也不对
		找到了frmW, frmH的初次声明给定值,设为 640,480 出错了,居然黑屏了,但是手动调到640x480后,可以工作!!!
		但是出现断帧的情况!!!首先设置帧速率30f/s 这个跟设置uvc 的帧速率有关
		但是怎么调试还是出现断帧的情况!! 就是第一次打开摄像头没事,后面打开时就断帧了,
		另外:软件打开时不能默认视频流是vga 后面发现:
			VS Format Uncompressed 的 Payload uncompressed format 的 default frameformat选了1(QVGA)的,应该选2(vga)
			注意这里好像有两个,VS Format Uncompressed,不要搞错!!所以有两个default frameformat
			只修改其中一个有效!!
			此外,不要忘记手动设frmW, frmH的初次声明给定值,设为 640,480,不然没有图像出来!!
			还有,开发板给 sensor 的工作时钟改回 25mhz
		怀疑是mck速度跟不上,或者是buffer不够大!!
		修改: ISI_MAX_PREV_BUFFER
		      viddProbeData -> FRAME_INTERVALC,FRAME_PACKET_SIZE_HS 
		      没有用
		本来找最终原因的,但是还是算了,直接在再次开启前重新初始化就是了
		就是在 if(bVidON && !bVideoON) 段最后添加:
			_isiinit()
			_ConfigureTc()
			成功显示,不在出现 多次重开上位机也不再出现断帧现象
			初步怀疑是 timer counter 的问题!!
	学习如何建立UVC命令:		
		还有,怀疑 getcur setcur 根本什么都没有工作过, 所以viddProbeData()似乎么有被修改过, frmW,frmH也没有被改过!!
		怀疑所有 getcur 都NAK回应, 而setcur是工作的!! 注意 probedata过程中并未被改动过,所以 
		添加 trace_debug !! USBLib_Trace.h 添加define!!
		_isiinit里的setinputstream为啥设的是 RGB_INPUT??不是说好是YUV的吗?
			哲理有好多预置,比如sensor采样窗口大小,输出图片流的窗口大小,sensor图片流格式RGB
	m7开发板,去外在sram:
		通过isi_DMA 寄存器分析 isi工作原理, 
			isiDMA有两种,一种是previeW的即采集的原始数据DMA,另一种把原始数据编码处理后再缓存的DMA
			我们就 原始数据DMA举例说明:
			首先这种DMA框架有两个地址寄存器 descriptor 和 buffer 
			descriptor 放的是 descriptor数组结构对象A的地址
			buffer 放的是帧缓存首地址A
			一个descriptor数组结构对象有3个成员,缓存地址A,控制数据A,指向下一个descriptor数组结构对象B的指针
			首先,把一个 descriptorA 和 bufferA 的地址 放到对应寄存器, 开启服务
			isi传来的字节刘数据,会存到 buffer寄存器指向的寄存器,然后bufer寄存器自动加1指向下一字节,继续接收数据
			直到收到了一个帧的数据,然后在isi发生中断的同时,
			isi模块自动把 descriptor寄存器 指向的数组对象A 第三个成员(下一个descriptor数组对象B的指针)放入descriptor寄存器
			然后再把 descriptorB 的第一个成员 bufferB的地址 放入 buffer寄存器
			就这样准备好接收下一帧数据,由于这种机构,帧缓存列表满了后,可以回过来重新覆写
			isiDMA框架接收数据是独立于cpu执行的.所以不管cpu在干什么,isi都只顾自己源源不断,并不停歇地接收一帧帧的数据
			每传输好一帧就,标记一次flag,但是isi本身不会等待flag被消除后才重新执行下一帧的接收
			就是说不管flag有没有被clear,每帧接收完后都会例行set一次flag!! 
			最后关于手动写入地址寄存器的数据 都是 word对齐的,即32位,4个字节对齐,
			虽然4字节对齐,但因为一帧vga_yuv至少达600kb,是4字节的倍数,所以符合4字节对齐,并没有问题
		不能指望通过isi来传输图片!!因为没有留出dma接口,没有其他接口提供
		那么就剩下利用菜谱主频来获取数据,但是占据大部分cpu频率,使得cpu无法干其他事情!!!
	发现gray模式一帧300kb, 可以尝试使用gray模式试试!!!!
		grayscale太奇葩了,sensor是vga采集的格式的,但是经过isi后,原始vga数据被直接阉割成 QVGA 卧槽,做不下去了!!
		还有usb数据流 断帧的问题!!
			假如重福发同一sram位置的同一帧的数据就没有问题!!,但是一旦改变着sram位置发数据时,就出现断帧情况
		注意.ISI_setPreviewSize 和 ISI_SetSensorSize 在 设置gray模式中非常诡异!!! 是vga变QVGA的元凶!!
		现在停在 ISI_setPreviewSize 和 ISI_SetSensorSize 的探究!!!
		重新分析 isi grayscale 的初始化!!!
		灰阶的 真的硬生生把 VGA 割回 qvga 的分辨率!!!
		怀疑 GS_MODE GRAYSCALE 的问题, 
			发现demo 没有可以设置 GS_MODE GRAYSCALE 
			手动设置后出问题!! 查看pdf 8-bit gray模式发现: 要求 clear GRAYSCALE !! 
			但demo isi_setGrayscaleMode()预示要设 GS_MODE 先set GRAYSCALE 为 1
			手动 单设 GS_MODE 并任何正负面作用,可以说明 GS_MODE 配合 GRAYSCALE =1 才有用
		pdf 8-bit gray模式 告诉使用 8-bit gray模式 要用 codec_channel, 使用codec_channnel后 发现没有!!!
		pdf 8-bit gray模式 只是注明 ISI_CFG2->IM_HSIZE 要 640/2-1,而ISI_PSIZE->PREV_HSIZE并没有这样说!!
			但是 ISI_PSIZE->PREV_HSIZE 不设成640/2-1, 而是 640-1 时, isi模块工作出错!!
		使用codec_channel 并且, ISI_PSIZE->PREV_HSIZE 设成 640-1 时, isi模块工作继续出错!!
		gray-demo的isi默认设置是 ISI_CFG2:0000 0001 0011 1111 1001 0001 1101 1111
			0-10 bit: 001 1101 1111 = VSIZE = 479
			11 bit: 0 -> 2 pixel gray
			12 bit: 1 -> RGB_MODE->RGB565
			13 bit: 0 -> GRAYSCALE -> disable (这里的GRAYSCALE指的是12位的grayscale)
			14 bit: 0 -> RGB_SWAP -> D7-R7
			15 bit: 1 -> COLOR_SAPCE-> RGB
			16-26 bit: 001 0011 1111 = HSIZE =319
			28-29 bit: 00 -> YCC_SWAP -> byte0-Cb,byte1-Y,byte2-Cr,byte3-Y...
			30-31 bit: 00 -> RGB_CFG -> byte0-R/G(MSB),byte1-G(LSB)/B,byte2-R/G(MSB),byte3-G(LSB)/B ....
		对比彩色demo 的isi默认设置 ISI_CFG2: 0110 0010 0111 1111 1001 0001 1101 1111
			0-10 bit: 001 1101 1111 = VSIZE = 479
			11 bit: 0 -> 2 pixel gray
			12 bit: 1 -> RGB_MODE->RGB565
			13 bit: 0 -> GRAYSCALE -> disable (这里的GRAYSCALE指的是12位的grayscale)
			14 bit: 0 -> RGB_SWAP -> D7-R7
			15 bit: 1 -> COLOR_SAPCE-> RGB
			16-26 bit: 010 0111 1111 = HSIZE =639
			28-29 bit: 10 -> YCC_SWAP -> byte0-Y,byte1-Cb,byte2-Y,byte3-Cr...
			30-31 bit: 01 -> RGB_CFG -> byte0-B/G(MSB),byte1-G(LSB)/R,byte2-B/G(MSB),byte3-G(LSB)/R ....
		新假设: isi 8-bit 灰度 把每个采集的字节都当成 Y ,所以把sensor传来的 U,V 都当成了Y!!
			那就尝试把 ov7725 sensor 输出 改成 YYYYY 的输出!!
			ov7725 开灰度图模式,先要 开SDE 0x64 bit5
			0x26 允许 grayscale 输出黑白灰度!! 但是也是 YUV输出 没有只是Y输出
			0x26 允许 U,固定值,0x60,0x61,填写俩个强制的值,比如说 0x80
				那么u,v的输出就会变成强制值0x80, 从而得到, uv值为不同强制值后,得到不同色系的灰度图 





20170824
继续m7 板子添加uvc命令!!!	
加led灯!!
一个完整的uvc configuration 拓扑结构,以下是一个拓扑结构例子,一个拓扑结构有先后顺序地包含多个 descriptor
	
	一个uvc configuration_A 分先后次序包含以下多个descriptor: (**号标记的是要重点理解的项)
	/* configuration descriptor */
		bLength		0x09	//这个descriptor长度(包括bLength) 这里占9字节
		bDescriptorType	0x02	//descriptor 的标记,0x02 表明这个是 configuration 的 descriptor
					//这个descriptor一定在众多 descriptor 之首
					//也表明接下来的 接收到的 descriptor 同属这一个 uvc configuration_A 拓扑结构的内容
		wTotalLength	??	//指整个uvc configuration_A 所有内容所占总字节数,即所有descriptor所占据字节的总和
		bNumInterfaces	0x02	//interface接口数 2个
		bConfigurationValue 0x01//指 uvc configuration_A 的编号 这里编号是 1 
		iConfiguration		//空置,没有用处
		bmAttributes	0x80	//usb 设备特性, 自供电, 不接受远程唤醒
		bMaxPower	??	//usb bus电流大小 这里设了最大 100ma
	/* Interface Association Descriptor (IAD) */
		bLength		0x08	//这个descriptor长度(包括bLength) 这里占8字节
		bDescriptorType	0x0b	//descriptor 的标记,0x0b 表明这个是 Interface Association 的 descriptor
		bFirstInterface 0x00	//控制接口,也是第一个要使用的接口 我们分配 0号接口为这个接口
		bInterfaceCount	0x02	//这个uvc configuration_A分配的 interface接口数 2个
		bFunctionClass	0x0e	//表示这个IAD 分到的 class是:video interface class code (CC_video)   
		bFunctionSubClass 0x03	//表示这个IAD 分到 CC_video 的 SC_VIDEO_INTERFACE_COLLECTION subclass里
		bFunctionProtocol 0x00	//空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iFunction	0	//这是id,指向对应id的 string descriptor,这个被指的descriptor会有些备注字符串信息, id=0表示没有指向
		//这个descriptor可以说是一个 视频类接口的集合器
	/* VideoControl Interface Descriptor  (VC)*/
		bLength		0x09	//这个descriptor长度(包括bLength) 这里占9字节		
		bDescriptorType	0x04	//descriptor 的标记,0x04 表明这个是 INTERFACE接口 的 descriptor
		bInterfaceNumber 0x0    //这个接口的id是0, 也就是上面IAD->bFirstInterface 指向的接口
	**	bAlternateSetting 0x0	//这里表示 VC 默认指向 id=0 的Alternatesetting 
					// id=0 的Alternatesetting 在这里只包含 一个VS 而这个VS 并没有 数据端口,只用一些格式的设定
	**	bNumEndpoints	0	//这个接口使用多少端口, 这里使用0个,虽然会使用到端口0,但端口0不算入这个统计里,所以是0个
		bInterfaceClass 0x0e	//表示接口 到的 class 是 CC_video ,接口属于 视频类
		bInterfaceSubClass 0x01	//表示接口 分到 CC_video 的 SC_VIDEOCONTROL subclass里, 接口是视频类的控制类
					//即这是一个视频控制接口!!
	**	bInterfaceProtocol 0x0  //空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iInterface	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		//以下几个descriptor是紧接这个descriptor的!!进一步描述 视频控制接口
	/* Class-specific Interface header Descriptor about VC */
		bLength		0x0e	//这个descriptor长度(包括bLength) 这里占13字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubType 0x01	//descriptor 的子标记,0x01表明是 接口类 的 VC_header descriptor
	**	bcdUVC 		0x0110	//表示 videocontrol 符合 uvc 1.1 标准 
		wTotalLength	??	//整个 videocontrol interface class 内容的所占总字节数,即整个SC_VIDEOCONTROL子类具体内容所占总字节数
					//包括:
					//	当前的 header descriptor,
					//	Input Terminal Descriptor about Camera ,
					//	Output Terminal Descriptor,
		dwClockFrequency ??	//uvc 设备运转时间,这里是 123mhz
		bInCollection	1	//有多少个 流接口,(streaming interface) 这里有1个
		baInterfaceNr(1)  1	//VideoStreaming interface 1 归这个 VideoControl Interface 管
	/* Class-specific Input Terminal Descriptor about Camera */	camera为源的输入终端
		bLength		0x12	//这个descriptor长度(包括bLength) 这里占18字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE 接口类 descriptor
		bDescriptorSubtype 0x02	//descriptor 的子标记 0x02 ->VC_INPUT_TERMINAl 这是视频控制接口 的 输入控制端模块
	**	bTerminalID 	0x01	//这个模块 的 id为 1
		wTerminalType	0x0201	//表示是输入控制端模块 控制的是 camera输入	(ITT_CAMERA)
		bAssocTerminal	0	//No association 不知道干什么用的
		iTerminal	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		wObjectiveFocalLengthMin 0 //No optical zoom supported 不知道干什么用的
		wObjectiveFocalLengthMax 0 //No optical zoom supported 不知道干什么用的
		wOcularFocalLength 0	//No optical zoom supported 不知道干什么用的
		bControlSize	3	//The size of the bmControls is 3 bytes
		bmControls    0x000000	//No controls are supported
			//bControlSize,bmControls 是 UVC命令的关键!! bControlSize 说明 bmControls 占3字节
			//bmControls中 某个位设置为1,表示着设备支持某个UVC指令的功能:字位与uvc指令功能的对应如下:
			//	D0: Scanning Mode
			//	D1: Auto-Exposure Mode
			//	D2: Auto-Exposure Priority
			//	D3: Exposure Time (Absolute)
			//	D4: Exposure Time (Relative)
			//	D5: Focus (Absolute)
			//	D6 : Focus (Relative)
			//	D7: Iris (Absolute)
			//	D8 : Iris (Relative)
			//	D9: Zoom (Absolute)
			//	D10: Zoom (Relative)
			//	D11: PanTilt (Absolute)
			//	D12: PanTilt (Relative)
			//	D13: Roll (Absolute)
			//	D14: Roll (Relative)
			//	D15: Reserved
			//	D16: Reserved
			//	D17: Focus, Auto
			//	D18: Privacy
			//	D19: Focus, Simple
			//	D20: Window
			//	D21: Region of Interest
			//	D22 – D23: Reserved, set to zero
			//这个descriptor 描述的是一个 IT unit ,也提供一部分主要的 UVC 标准命令
			//还有一个 pu unit 提供另外一部分主要的 UVC 标注命令:
			// pu unit descriptor 的 bControlSize bmControls, 也是表示支持uvc 命令的关键
			//同样 bControlSize 说明 bmControls 占3字节
			//bmControls中 某个位设置为1,表示着设备支持某个UVC指令的功能:字位与uvc指令功能的对应如下:
			//	D0: Brightness
			//	D1: Contrast
			//	D2: Hue
			//	D3: Saturation
			//	D4: Sharpness
			//	D5: Gamma
			//	D6: White Balance Temperature
			//	D7: White Balance Component
			//	D8: Backlight Compensation
			//	D9: Gain
			//	D10: Power Line Frequency
			//	D11: Hue, Auto
			//	D12: White Balance Temperature, Auto
			//	D13: White Balance Component, Auto
			//	D14: Digital Multiplier
			//	D15: Digital Multiplier Limit
			//	D16: Analog Video Standard
			//	D17: Analog Video Lock Status
			//	D18: Contrast, Auto
			//	D19 – D23: Reserved. Set to zero.
	/* Class-specific Output Terminal Descriptor */ 输出终端
		bLength		0x9	//这个descriptor长度(包括bLength) 这里占9字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE 接口类 descriptor
		bDescriptorSubtype 0x03	//descriptor 的子标记 0x02 ->VC_OUTPUT_TERMINAl 这是视频控制接口 的 输出控制端模块
	**	bTerminalID 	0x02	//这个模块 的 id为 2	
		wTerminalType	0x0101	///表示是输出控制端模块 控制的是 usb streaming输出 (TT_STREAMING)
		bAssocTerminal	0	//No association 不知道干什么用的
	**	bSourceID	1	//表示这个 输出模块的 输入源是 id=1的模块,即 上面的 camera input terminal 模块
		iTerminal	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		//至此 VideoControl Interface (视频控制接口)的内容都由
		//	VideoControl Interface Descriptor
		//	|-Class-specific Interface header Descriptor about VC
		//	|-Class-specific Input Terminal Descriptor about Camera 
		//	|-Class-specific Output Terminal Descriptor
		//这几个 descriptor 描述完毕
		//当中,这里应该还有一个pu模块,然后才可以使用 uvc 命令,后面再处理!!
	/* VideoStreaming Interface Descriptor (VS) */
		bLength		0x9	//这个descriptor长度(包括bLength) 这里占9字节			
		bDescriptorType	0x04	//descriptor 的标记,0x04 表明这个是 INTERFACE接口 的 descriptor
	**	bInterfaceNumber 0x01	//这个接口的id是1,也是 上述 VC header->baInterfaceNr(1)中指向的 接口id
	**	bAlternateSetting 0x0	//这个 VideoStreaming Interface Descriptor 的 也归类到 id=0 的Alternatesetting 里的一个子项
*********	bNumEndpoints	0	//这个接口使用多少端口, 这里使用0个,既然要输出数据应该有个非0端口吧,为什么说没有???重点!!!
		bInterfaceClass 0x0e	//表示接口 到的 class 是 CC_video ,接口属于 视频类
		bInterfaceSubClass 0x02	//表示接口 分到 CC_video 的 SC_VIDEOSTREAMING subclass里, 接口是视频类的视频流子类
					//即这是一个视频控制接口!!
	**	bInterfaceProtocol 0x0  //空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iInterface	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
	/* Class-specific Interface header Descriptor about VS */
		bLength		0x0e	//这个descriptor长度(包括bLength) 这里占13字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
*********	bDescriptorSubType 0x01	//descriptor 的子标记,0x01表明是 接口类 的 VS_input_header descriptor	???
	**	bNumFormats 	0x01	//有 1 个视频流格式 format descriptor  
		wTotalLength	??	//整个 videocontrol interface class 内容的所占总字节数,即整个SC_VIDEOCONTROL子类具体内容所占总字节数
					//包括:
					//	当前的 header descriptor,
					//	Class-specific VS Format Descriptor,
					//	Class-specific VS Frame Descriptor 320x240,
					//	Class-specific VS Frame Descriptor 640x480,
					//	Class-specific VS Frame Descriptor 176x144,
					//	Class-specific color matching Descriptor,	
*********	bEndpointAddress ox80	//用于实时传输流数据的 端点的id=0x82,为啥demo上是0x80,有这个非零端点,为啥上面说没有endpoints?
		bmInfo			//No dynamic format change supported
		bTerminalLink	2	//VideoStreaming interface 要连到 模块id=2的 output terminal 
		bStillCaptureMethod 0   //0 means -- still image capture method not support
		bTriggerSupport		//not support trigger
		bTriggerUsage	0	//no Trigger Usage
		bControlSize	1	//The size of the bmControls is 1 bytes
		bmControls    	0x00	//No No VideoStreaming specific controls are supported
	/* Class-specific VS Format Descriptor */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x04	//descriptor 的子标记,0x04 表明是VS_FORMAT_uncompressed 即原始格式视频流
		bFormatIndex	0x01	//这个format id=1
		bNumFrameDescriptors 3  //这个format 有三种frame格式,即有三种 frame descriptor
		guidFormat	??	//guid yuy2 的编码,不知道是啥,但是因为是 VS_FORMAT_uncompressed 所以有这个成员
		bBitsPerPixel	16	//16bit perpixel 也是因为是 VS_FORMAT_uncompressed 的关系
		bDefaultFrameIndex 2	//默认使用哪个frame_2格式
		bAspectRatioX	0	// Non-interlaced stream – not required
		bAspectRatioY	0	// Non-interlaced stream – not required
		bmInterlaceFlags 0	// Non-interlaced stream
		bCopyProtect	0	//No restrictions imposed on the duplication of this video stream.
	/* Class-specific VS Frame Descriptor 320x240 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x01	//这个frame id=1
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		320	//帧宽
		wHeight		240	//帧高
		dwMinBitRate	320*240*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	320*240*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  320*240*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!
	/* Class-specific VS Frame Descriptor 640x480 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x02	//这个frame id=2
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		640	//帧宽
		wHeight		480	//帧高
		dwMinBitRate	640*480*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	640*480*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  640*480*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!		
	/* Class-specific VS Frame Descriptor 176x144 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x03	//这个frame id=3
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		176	//帧宽
		wHeight		144	//帧高
		dwMinBitRate	176*144*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	176*144*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  176*144*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!
	/* Class-specific color matching Descriptor */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x0d	//descriptor 的子标记,0x04 表明是VS_colorformat 即原始格式视频流	
		bColorprimaries 1	//BT.700, sRGB    ???
		bTranfercharacteristics 4	//BT.601   ???
		//至此, 一个完整的 VideoStreaming Interface 结构由
		//	VideoStreaming Interface Descriptor
		//	|-Class-specific Interface header Descriptor about VS,
		//	|-Class-specific VS Format Descriptor,
		//	|-Class-specific VS Frame Descriptor 320x240,
		//	|-Class-specific VS Frame Descriptor 640x480,
		//	|-Class-specific VS Frame Descriptor 176x144,
		//	|-Class-specific color matching Descriptor,	
		//这几个 descriptor 描述完毕.
		//注意 这个 VS 与再上面的 VC 同属于一个 alternate setting
		//而这个 VS 并没有分配endpoint 的 ,所以并不知道 视频刘数据如何输出!!!  
	/* VideoStreaming Interface Descriptor (VS) */
		bLength		0x9	//这个descriptor长度(包括bLength) 这里占9字节			
		bDescriptorType	0x04	//descriptor 的标记,0x04 表明这个是 INTERFACE接口 的 descriptor
	**	bInterfaceNumber 0x01	//这个接口的id是1,也是 上述 VC header->baInterfaceNr(1)中指向的 接口id
					//但是这样的话,VC 不就指向两个相同id号的VS ?? ,怀疑应该有个参数作区分,这个参数是 alternate setting??
	**	bAlternateSetting 0x1	//这个 VideoStreaming Interface Descriptor 归类到 id=1 的Alternatesetting 里的一个子项
*********	bNumEndpoints	1	//这个接口使用 1 端口, 这个是 数据输出口??
		bInterfaceClass 0x0e	//表示接口 到的 class 是 CC_video ,接口属于 视频类
		bInterfaceSubClass 0x02	//表示接口 分到 CC_video 的 SC_VIDEOSTREAMING subclass里, 接口是视频类的视频流子类
					//即这是一个视频控制接口!!
	**	bInterfaceProtocol 0x0  //空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iInterface	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
	/* Standard VS Isochronous Video Data Endpoint Descriptor */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节					
		bDescriptorType	0x05	//descriptor 的标记,0x05 表明这个是 ENDPOINT接口 的 descriptor
		bEndpointAddress 0x80 | 2  //IN endpoint 2
		bmAttributes	1	//Isochronous transfer type  实时传输的端口类型
		wMaxPacketSize	??	//数据包最大大小(代码上是是 4096 + 1020 ??)
		bInterval	2	//传输间隔 2 frame interval
		//显然这个被分配的 端点应该就是 视频流输出端口,但是这样就奇怪了,因为参数设置的 第一个id=0 的VS
		//真正数据流发生在 id=1 的VS
		//这个 VideoStreaming Interface 结构 的完整内容是
		//	VideoStreaming Interface Descriptor
		//	|-Standard VS Isochronous Video Data Endpoint Descriptor
		//猜测是这样的,VC先选 Alternate setting id=0 的vs 设置相关内容, 
		//然后换选 Alternate setting id=1 的vs 的Isochronous endpoint执行 实时输出
		
上述是一个 configuration descriptor 数据结构,是在usb设备插入pc后要被枚举的内容,
	但并不是,上位机打开设备后, get_cur,set_cur传递的内容,
	configuration descriptor 的地址 会集成到 usbdDriverdescriptor 里,被USB枚举所用
	对应的是 main 函数里的USBDDRIVER_Initialize() usb从设备驱动初始化
	所以添加一个brightness 需要加一个 pu 模块
	经分析, VC 这个interface 设定了各种模块unit, vs 这个 interface 设定了各种帧格式!!! 还定义了一个实时传输的endpoint 
现在开始移植uvc 命令!!
	原VIDEODescriptors.h 的 uvc configuration descriptor结构 不变
	struct UsbVideoCamConfigurationDescriptors {
		/* Configuration descriptor */
		USBConfigurationDescriptor configuration;
		/* IAD */
		USBInterfaceAssociationDescriptor iad;
		/* VideoControl I/F */
		USBInterfaceDescriptor interface0;
		/* VideoControl I/F Descriptors */
		UsbVideoControlInterfaceDescriptor vcInterface;
		/* VideoStreaming I/F */
		    USBInterfaceDescriptor interface10;
		/* VideoStreaming I/F Descriptors */
		UsbVideoStreamingInterfaceDescriptor vsInterface;
		/* VideoStreaming I/F */
		USBInterfaceDescriptor interface11;
		/* Endpoint */
		USBEndpointDescriptor ep11;
	};
	原VIDEODescriptors.h 的 VideoControl I/F Descriptors descriptor结构
	typedef struct _UsbVideoControlInterfaceDescriptor {
		UsbVideoControlInterfaceHeader1 header;
		USBVideoCameraTerminalDescriptor it;
		USBVideoOutputTerminalDescriptor ot;
	} UsbVideoControlInterfaceDescriptor;
	变成: (添加pu模块,因为brightness命令是pu模块实现的)
	typedef struct _UsbVideoControlInterfaceDescriptor {
		UsbVideoControlInterfaceHeader1 header;
		USBVideoCameraTerminalDescriptor it;
		USBVideoOutputTerminalDescriptor ot;
		USBVideoProcessingUnitDescriptor pu;
	} UsbVideoControlInterfaceDescriptor;
	原USBDDriverDescriptors.c 更换 VC Output Terminal 一段为以下内容:
		/* VC Output Terminal */
		{
			sizeof(USBVideoOutputTerminalDescriptor),
			VIDGenericDescriptor_INTERFACE, /* CS_INTERFACE */
			VIDGenericDescriptor_OUTPUTTERMINAL, /* VC_OUTPUT_TERMINAL */
			2, /* Terminal ID: #2 */
			VIDTerminalDescriptor_STREAMING, /* Streaming terminal */
			0, /* Assoc: None */
			//1, /* Source: Terminal is connected to #1 */
                        3, /* Source: Terminal is connected to #3(process_unit) by william */
			0  /* No string */
		},
                //by william
                /* Process Unit */
		{
			sizeof(USBVideoProcessingUnitDescriptor),
			VIDGenericDescriptor_INTERFACE, /* CS_INTERFACE */
			VIDGenericDescriptor_PROCESSINGUNIT, /* VC_PROCESSING_UNIT */
			3, /* Process Unit ID: #3 */
			1, /* Source: Terminal is connected to #1 */
			0, /* Max digital magnification: unused */
			2, /* Size of bmControls: 2 */
			1,  /* Brightness control supports */
			0  /* No string */
		}
		上面主要:
			是添加pu模块descriptor,
			让input模块先接入pu模块,
			最后让pu模块接到output模块	
		结果, usb插入枚举时就分辨不出来设备来
		问题分析: 
			踩中	uvc1.5协议说明中 Processing Unit Descriptor 多了一个 bmVideoStandards 参数项, demo里pu结构体却没有
				所以要 参照 协议说明 更改 USBVideo.h 的pu struct 
			踩中	uvc1.5协议说明中 bControlSize 0x03,不是表示有三个字节的bmControls么? 为啥 bmControls 却只有两个字节
				协议说明的例子出错 ,既然是demo中pu struct 的bmControls是2元字节数组,
				那bControlSize 就填0x02 表示有两个字节的bmControls
			踩中	bmControls[2] 是一个数组,注意数组的填写格式!!!
				例如要写成 {15.0},的样子 写到结构体里
			没关系	使用pu 要同时激活 su么??   不需要
			踩中	两个HS FS 两个configuration都要同样改
				不能只改Hs 就忘了 FS !!, 不然出错!!
		修改后的  USBDDriverDescriptors.c VC Output Terminal和 Process Unit 段为:
		/* VC Output Terminal */
		{
			sizeof(USBVideoOutputTerminalDescriptor),
			VIDGenericDescriptor_INTERFACE, /* CS_INTERFACE */
			VIDGenericDescriptor_OUTPUTTERMINAL, /* VC_OUTPUT_TERMINAL */
			2, /* Terminal ID: #2 */
			VIDTerminalDescriptor_STREAMING, /* Streaming terminal */
			0, /* Assoc: None */
			//1, /* Source: Terminal is connected to #1 */
                        3, /* Source: Terminal is connected to #3(process_unit) by william */
			0  /* No string */               
                },
                //by william
                /* Process Unit */
		{
			sizeof(USBVideoProcessingUnitDescriptor),
			VIDGenericDescriptor_INTERFACE, /* CS_INTERFACE */
			VIDGenericDescriptor_PROCESSINGUNIT, /* VC_PROCESSING_UNIT */
			3, /* Process Unit ID: #3 */
			1, /* Source: Terminal is connected to #1 */
			0, /* Max digital magnification: unused */
			0x02, /* Size of bmControls: 2 */
			{1, 0},  /* Brightness control supports */
			0,  /* No string */
                        0   /* Unused */
		}			 
		USBVideo.h 需要做更改, 添加 bmVideoStandards
		typedef struct _USBVideoProcessingUnitDescriptor {
		    uint8_t  bLength; /**< Size of descriptor: 9 + 2 bytes */
		    uint8_t  bDescriptorType; /**< CS_INTERFACE descriptor type */
		    uint8_t  bDescriptorSubType; /**< VC_PROCESSING_UNIT descriptor subtype */
		    uint8_t  bUnitID; /**< None-zero Unit ID */
		    uint8_t  bSourceID; /**< ID of the Unit or Terminal to which this Unit is connected */
		    uint16_t wMaxMultiplier; /**< Max digital magnification, multiplied by 100 */
		    uint8_t  bControlSize; /**< Size of bmControls: 2 */
		    uint8_t  bmControls[2];
		    uint8_t  iProcessing; /**< Index of string descriptor */
		    uint8_t  bmVideoStandards; /**< Unused but need maybe  by william */
		} USBVideoProcessingUnitDescriptor;
	至此descriptor 的移植已经完整!,win完美识别并成功安装 usb视频驱动!
	////////////////////////////////////////分割符号///////////////////////////////////////
	接下来修改程序,实现uvc命令功能,
		实践发现,插入uvc摄像头时,
			枚举usb,获取descriptor,
			根据信息,联网安装usb视频设备驱动!!
			视频设备驱动安装后,会执行初步初始化设备!!
				(譬如检测到descriptor,发现视频设备支持标准uvc命令,
				于是对每个命令执行 getinfo,getmin,getmax,getres,get_def 的初始化)
				然而,开发板并未做uvc命令相关处理操作,导致命令初始化失败,所以UVC命令最后还是不能用
	现在开始实现 开发板上uvc命令相关操作,以下是相关修改:
	首先:demo使用的是uvc1.1 标准的!!,所以要 probedata 要改成符合uvc1.1标准会比较规范:
	//USBVideo.h
	typedef struct _USBVideoProbeCommitData {
	    uint16_t bmHint; /**< Parameters shall be kept fixed */
	    uint8_t  bFormatIndex; /**< Video format index from a format descriptor */
	    uint8_t  bFrameIndex; /**< Video frame index from a frame descriptor */
	    uint32_t dwFrameInterval; /**< Frame interval in 100ns units */
	    uint16_t wKeyFrameRate; /**< Key frame rate in key frame/video frame units */
	    uint16_t wPFrameRate; /**< PFrame rate in PFrame/key frame units */
	    uint16_t wCompQuality; /**< Compression quality control in abstract units 0(lowest) to 10000(highest) */
	    uint16_t wCompWindowSize; /**< Window size for average bit rate control */
	    uint16_t wDelay; /**< Internal video streaming interface latency in ms from video data capture to presentation on the USB */
	    uint32_t dwMaxVideoFrameSize; /**< Maximum video frame size in bytes */
	    uint32_t dwMaxPayloadTransferSize; /**< Maximum number of bytes that the device can transmit in a single payload transfer */
	    uint32_t dwClockFrequency; /**< have no idea  set 0 maybe ok */
	    uint8_t bmFramingInfo; /**< have no idea  set 0 maybe ok */
	    uint8_t bPreferedVersion; /**< have no idea  set 0 maybe ok */
	    uint8_t bMinVerdion; /**< have no idea  set 0 maybe ok */
	    uint8_t bMaxVersion; /**< have no idea  set 0 maybe ok */
	} USBVideoProbeData, USBVideoCommitData;
	//main.c
	static uint8_t pControlBuffer[34];      //uvc1.1 need 34 byte 对应的接受缓存!!
	static USBVideoProbeData viddProbeData = {
		0, /* bmHint: All parameters fixed: sent by host */
		0x01,   /* bFormatIndex: Format #1 */
	        //by william
		0x02,   /* bFrameIndex: Frame #2 640X480 */
		//0x01,   /* bFrameIndex: Frame #1 320X240 */
		//FRAME_INTERVALC(4), /* dwFrameInterval: in 100ns */
		FRAME_INTERVALC(1), /* dwFrameInterval: in 100ns */
		0, /* wKeyFrameRate: not used */
		0, /* wPFrameRate: not used */
		10000, /* wCompQuality: highest */
		0, /* wCompWindowSize: ?K */
		100, /* wDelay: Internal VS latency in ms */
		FRAME_BUFFER_SIZEC(800, 600), /* dwMaxVideoFrameSize: in bytes */
		//FRAME_PACKET_SIZE_FS /* dwMaxPayloadTransferSize: in bytes */
	        FRAME_PACKET_SIZE_HS,
	        //by william
	        0,
	        0,
	        0,
	        0,
	        0
	};
	然后,处理uvc的命令如下修改:
	//main.c
	//by william  命令内容缓存
	static uint16_t bvalue;
	static uint8_t binfo;		
	/**
	 * uvc command process.
	 * by william	接搜到命令后,最后的命令内容处理函数,我暂时什么都不处理,
	 */
	static void command_p(void)
	{
	       printf("processing command \n\r");
	}
	/**
	 * Brightness command
	 * by william	brightness命令分析函数
	 */
	static void Brightness(const USBGenericRequest *pReq)
	{
	        uint16_t bres;
	        printf("brightness\n\r");
	        
	 	switch (USBGenericRequest_GetRequest(pReq)) {
		case VIDGenericRequest_SETCUR: 	
	              USBD_Read(0, &bvalue, 2, (TransferCallback)command_p, 0);	//接受上位机setcur对话的下阶段传来的2字节内容
	              break;
		case VIDGenericRequest_GETCUR:
	              USBD_Write(0, &bvalue, 2, 0, 0);	//上传给上位机getcur对话请求的2字节内容
	              break;
		case VIDGenericRequest_GETDEF:		//设置 default value,这里上传默认值
	              bvalue = 0x64;
	              USBD_Write(0, &bvalue, 2, 0, 0);
	              break;
		case VIDGenericRequest_GETINFO:       //have noidea whtat it is
	              binfo = 0x07;                   //note use binfo ,set 0x07 without meaning, can try to set other value
	              USBD_Write(0, &binfo, 1, 0, 0);  //note length = 1
	              break;
		case VIDGenericRequest_GETMIN:		//设置 min value,这里上传最小值
	              bvalue = 0x00;
	              USBD_Write(0, &bvalue, 2, 0, 0);
	              break;
		case VIDGenericRequest_GETMAX:		//设置 max value,这里上传默认值
	              bres = 100;
	              USBD_Write(0, &bres, 2, 0, 0);
	              break;
		case VIDGenericRequest_GETRES:          //get resolution value must be 1
	              bvalue = 1;
	              USBD_Write(0, &bvalue, 2, 0, 0);
	              break;
	        }
	}	
	/**
	 * Handle SetCUR request for USB Video Device.	setcur统一处理命令
	 */
	static void VIDD_SetCUR(const USBGenericRequest *pReq)
	{
		uint8_t bCS = USBVideoRequest_GetControlSelector(pReq);
		uint32_t len;
		TRACE_INFO_WP("SetCUR(%d) ", pReq->wLength);
	
	        //by william
	        if (pReq->wValue == 0x200 && pReq->wIndex == 0x300 ) {	//wValue == 0x200 表示是brightness命令,
	          Brightness(pReq);					//wIndex == 0x300 表示是pu模块的内容
	          
	        }else if (pReq->wIndex == VIDCAMD_StreamInterfaceNum) {
			TRACE_INFO_WP("VS ");
		...........	
	}
	/**
	 * Handle GetCUR request for USB Video Device.	getcur统一处理命令
	 */
	static void VIDD_GetCUR(const USBGenericRequest *pReq)
	{
		uint8_t bCS = USBVideoRequest_GetControlSelector(pReq);
		uint32_t len;
		TRACE_INFO_WP("GetCUR(%d) ", pReq->wLength);
	
	        //by william
	        if (pReq->wValue == 0x200) {	//wValue == 0x200 表示是brightness命令,
	          Brightness(pReq);
	          
	        } else if (pReq->wIndex == VIDCAMD_StreamInterfaceNum) {
			TRACE_INFO_WP("VS ");
		..............
	}
	/**
	 * Handle GetDEF request for USB Video Device.	getdef统一处理命令
	 */
	static void VIDD_GetDEF(const USBGenericRequest *pReq)
	{
		printf("GetDEF(%x,%x,%d)\n\r", pReq->wIndex, pReq->wValue, pReq->wLength);
	        //by william
	        if (pReq->wValue == 0x200) {
	          Brightness(pReq);
	        }
	}	
	/**
	 * Handle GetINFO request for USB Video Device.	getinfo统一处理命令
	 */
	static void VIDD_GetINFO(const USBGenericRequest *pReq)
	{
		printf("GetINFO(%x,%x,%d)\n\r", pReq->wIndex, pReq->wValue, pReq->wLength);
	        //by william
	        if (pReq->wValue == 0x200) {
	          Brightness(pReq);
	        }
	}	
	/**
	 * Handle GetMIN request for USB Video Device.	getmin统一处理命令
	 */
	static void VIDD_GetMIN(const USBGenericRequest *pReq)
	{
		printf("GetMin(%x,%x,%d)\n\r", pReq->wIndex, pReq->wValue, pReq->wLength);
	        //by william
	        if (pReq->wValue == 0x200) {
	          Brightness(pReq);
	        }
	        else
	                VIDD_GetCUR(pReq);	
	}	
	/**
	 * Handle GetMAX request for USB Video Device.	getmax统一处理命令
	 */
	static void VIDD_GetMAX(const USBGenericRequest *pReq)
	{
		printf("GetMax(%x,%x,%d)\n\r", pReq->wIndex, pReq->wValue, pReq->wLength);
	        //by william
	        if (pReq->wValue == 0x200) {
	          Brightness(pReq);
	        }
	        else
	                VIDD_GetCUR(pReq);
	}	
	/**
	 * Handle GetRES request for USB Video Device.	getres统一处理命令
	 */
	static void VIDD_GetRES(const USBGenericRequest *pReq)
	{
		printf("GetRES(%x,%x,%d) ", pReq->wIndex, pReq->wValue, pReq->wLength);
	        //by william
	        if (pReq->wValue == 0x200) {
	          Brightness(pReq);
	        }
	}
	视频设备驱动初始化 uvc命令时,会依照getinfo,getmin,getmax,getres,get_def 的顺序,
		比如发来 getinfo 会转到 getinfo统一处理命令, 判断是不是brightness命令相关,
		若是便转向 brightness命令分析函数 执行switch 找到VIDGenericRequest_GETINFO,执行相关内容.
		即最后执行了USBD_Write 上传了一个字节内容!!
	补充一个额外内容: getmin/getmax 让上位机获得最小最大值后, 上位机brightness命令值便只能之于最小最大值间,
	至此!brightness命令完美执行,
	至此结束brightness的移植
	////////////////////////////////////////分割符号///////////////////////////////////////
	以下是 bus host 抓到的数据包内容 log 供参考:
/*log start*/
Bus Hound 6.01 capture on Windows Vista Service Pack 1 (x86). Complements of www.perisoft.net
  Device - Device ID (followed by the endpoint for USB devices)
            (50) USB Composite Device
            (51) USB2.0 PC CAMERA
            (58) USB Composite Device
            (59) USB 视频设备
  Address - FireWire async address or channel number
  Length - Total transfer length
  Phase  - Phase Type
            CTL   USB control transfer       
            IN    Data in transfer           
            OUT   Data out transfer          
            RESET bus reset                  
  Data   - Hex dump of the data transferred
  Descr  - Description of the phase
  Cmd... - Position in the captured data
Device  Address              Length    Phase  Data                                                Description       Cmd.Phase.Ofs(rep)
------  -------------------  --------  -----  --------------------------------------------------  ----------------  ------------------
  58.0                                 CTL    80 06 00 01  00 00 12 00                            GET DESCRIPTOR           1.1.0        
  58.0                             18  IN     12 01 00 02  ef 02 01 40  eb 03 36 61  01 00 00 00  .......@..6a....         1.2.0        
                                              00 01                                               ..                       1.2.16       
  58.0                                 CTL    80 06 00 02  00 00 09 00                            GET DESCRIPTOR           2.1.0        
  58.0                              9  IN     09 02 f0 00  02 01 00 c0  32                        ........2                2.2.0        
  58.0                                 CTL    80 06 00 02  00 00 f0 00                            GET DESCRIPTOR           3.1.0        
  58.0                            240  IN     09 02 f0 00  02 01 00 c0  32 08 0b 00  02 0e 03 00  ........2.......         3.2.0        
                                              00 09 04 00  00 00 0e 01  00 00 0d 24  01 10 01 34  ...........$...4         3.2.16       
                                              00 c0 d4 54  07 01 01 12  24 02 01 01  02 00 00 00  ...T....$.......         3.2.32       
                                              00 00 00 00  00 03 00 00  00 09 24 03  02 01 01 00  ..........$.....         3.2.48       
                                              03 00 0c 24  05 03 01 00  00 02 01 00  00 00 09 04  ...$............         3.2.64       
                                              01 00 00 0e  02 00 00 0e  24 01 01 89  00 82 00 02  ........$.......         3.2.80       
                                              00 00 00 01  00 1b 24 04  01 03 59 55  59 32 00 00  ......$...YUY2..         3.2.96       
                                              10 00 80 00  00 aa 00 38  9b 71 10 02  00 00 00 00  .......8.q......         3.2.112      
                                              1e 24 05 01  00 40 01 f0  00 00 80 32  02 00 80 32  .$...@.....2...2         3.2.128      
                                              02 00 58 02  00 15 16 05  00 01 15 16  05 00 1e 24  ..X............$         3.2.144      
                                              05 02 00 80  02 e0 01 00  00 84 03 00  00 84 03 00  ................         3.2.160      
                                              60 09 00 35  b7 0c 00 01  35 b7 0c 00  1e 24 05 03  `..5....5....$..         3.2.176      
                                              00 b0 00 90  00 00 a0 b9                            ........                 3.2.192      
  58.0                                 CTL    00 09 01 00  00 00 00 00                            SET CONFIG               4.1.0        
  59.0                                 CTL    80 06 00 01  00 00 12 00                            GET DESCRIPTOR           5.1.0        
  59.0                             18  IN     12 01 00 02  ef 02 01 40  eb 03 36 61  01 00 00 00  .......@..6a....         5.2.0        
                                              00 01                                               ..                       5.2.16       
  59.0                                 CTL    80 06 00 02  00 00 09 00                            GET DESCRIPTOR           6.1.0        
  59.0                              9  IN     09 02 e8 00  02 01 00 c0  32                        ........2                6.2.0        
  59.0                                 CTL    80 06 00 02  00 00 e8 00                            GET DESCRIPTOR           7.1.0        
  59.0                            232  IN     09 02 e8 00  02 01 00 c0  32 09 04 00  00 00 0e 01  ........2.......         7.2.0        
                                              00 00 0d 24  01 10 01 34  00 c0 d4 54  07 01 01 12  ...$...4...T....         7.2.16       
                                              24 02 01 01  02 00 00 00  00 00 00 00  00 03 00 00  $...............         7.2.32       
                                              00 09 24 03  02 01 01 00  03 00 0c 24  05 03 01 00  ..$........$....         7.2.48       
                                              00 02 01 00  00 00 09 04  01 00 00 0e  02 00 00 0e  ................         7.2.64       
                                              24 01 01 89  00 82 00 02  00 00 00 01  00 1b 24 04  $.............$.         7.2.80       
                                              01 03 59 55  59 32 00 00  10 00 80 00  00 aa 00 38  ..YUY2.........8         7.2.96       
                                              9b 71 10 02  00 00 00 00  1e 24 05 01  00 40 01 f0  .q.......$...@..         7.2.112      
                                              00 00 80 32  02 00 80 32  02 00 58 02  00 15 16 05  ...2...2..X.....         7.2.128      
                                              00 01 15 16  05 00 1e 24  05 02 00 80  02 e0 01 00  .......$........         7.2.144      
                                              00 84 03 00  00 84 03 00  60 09 00 35  b7 0c 00 01  ........`..5....         7.2.160      
                                              35 b7 0c 00  1e 24 05 03  00 b0 00 90  00 00 a0 b9  5....$..........         7.2.176      
                                              00 00 a0 b9  00 00 c6 00                            ........                 7.2.192      
  59.0                                 CTL    00 09 01 00  00 00 00 00                            SET CONFIG               8.1.0        
  59.0                                 CTL    01 0b 00 00  01 00 00 00                            SET INTERFACE            9.1.0        
  59.0                                 CTL    a1 86 00 02  00 03 01 00                            GET INFO                10.1.0        
  59.0                              1  IN     07                                                  .                       10.2.0        
  59.0                                 CTL    a1 82 00 02  00 03 02 00                            GET MIN                 11.1.0        
  59.0                              2  IN     00 00                                               ..                      11.2.0        
  59.0                                 CTL    a1 83 00 02  00 03 02 00                            GET MAX                 12.1.0        
  59.0                              2  IN     64 00                                               d.                      12.2.0        
  59.0                                 CTL    a1 84 00 02  00 03 02 00                            GET RES                 13.1.0        
  59.0                              2  IN     01 00                                               ..                      13.2.0        
  59.0                                 CTL    a1 87 00 02  00 03 02 00                            GET DEF                 14.1.0        
  59.0                              2  IN     64 00                                               d.                      14.2.0        
  59.0                                 CTL    a1 81 00 01  01 00 22 00                            GET CUR                 15.1.0        
  59.0                             34  IN     00 00 01 02  80 96 98 00  00 00 00 00  10 27 00 00  .............'..        15.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        15.2.16       
                                              00 00                                               ..                      15.2.32       
  59.0                                 CTL    a1 83 00 01  01 00 22 00                            GET MAX                 16.1.0        
  59.0                             34  IN     00 00 01 02  80 96 98 00  00 00 00 00  10 27 00 00  .............'..        16.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        16.2.16       
                                              00 00                                               ..                      16.2.32       
  59.0                                 CTL    a1 82 00 01  01 00 22 00                            GET MIN                 17.1.0        
  59.0                             34  IN     00 00 01 02  80 96 98 00  00 00 00 00  10 27 00 00  .............'..        17.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        17.2.16       
                                              00 00                                               ..                      17.2.32       
  59.0                                 CTL    21 01 00 01  01 00 22 00                            SET CUR                 18.1.0        
  59.0                             34  OUT    00 00 01 02  35 b7 0c 00  00 00 00 00  10 27 00 00  ....5........'..        18.2.0        
                                              64 00 00 a6  0e 00 00 00  00 00 00 00  00 00 00 00  d...............        18.2.16       
                                              00 00                                               ..                      18.2.32       
  59.0                                 CTL    a1 81 00 01  01 00 22 00                            GET CUR                 19.1.0(3)     
  59.0                             34  IN     00 00 00 00  00 00 00 00  00 00 00 00  10 27 00 00  .............'..        19.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        19.2.16       
                                              00 00                                               ..                      19.2.32       
  59.0                                 CTL    a1 83 00 01  01 00 22 00                            GET MAX                 20.1.0(3)     
  59.0                             34  IN     00 00 00 00  00 00 00 00  00 00 00 00  10 27 00 00  .............'..        20.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        20.2.16       
                                              00 00                                               ..                      20.2.32       
  59.0                                 CTL    a1 82 00 01  01 00 22 00                            GET MIN                 21.1.0(3)     
  59.0                             34  IN     00 00 00 00  00 00 00 00  00 00 00 00  10 27 00 00  .............'..        21.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        21.2.16       
                                              00 00                                               ..                      21.2.32       
  59.0                                 CTL    21 01 00 01  01 00 22 00                            SET CUR                 25.1.0(2)     
  59.0                             34  OUT    00 00 01 02  35 b7 0c 00  00 00 00 00  10 27 00 00  ....5........'..        25.2.0        
                                              64 00 00 a6  0e 00 00 00  00 00 00 00  00 00 00 00  d...............        25.2.16       
                                              00 00                                               ..                      25.2.32       
  59.0                                 CTL    a1 81 00 01  01 00 22 00                            GET CUR                 30.1.0        
  59.0                             34  IN     00 00 00 00  00 00 00 00  00 00 00 00  10 27 00 00  .............'..        30.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        30.2.16       
                                              00 00                                               ..                      30.2.32       
  59.0                                 CTL    21 01 00 02  01 00 22 00                            SET CUR                 31.1.0        
  59.0                             34  OUT    00 00 00 00  00 00 00 00  00 00 00 00  10 27 00 00  .............'..        31.2.0        
                                              64 00 00 a6  0e 00 fc 03  00 00 00 00  00 00 00 00  d...............        31.2.16       
                                              00 00                                               ..                      31.2.32       
  59.0                                 CTL    01 0b 01 00  01 00 00 00                            SET INTERFACE           32.1.0        
  59.0                                 CTL    a1 81 00 02  00 03 02 00                            GET CUR                 33.1.0(3)     
  59.0                              2  IN     64 00                                               d.                      33.2.0        
  59.0                                 CTL    21 01 00 02  00 03 02 00                            SET CUR                 36.1.0        
  59.0                              2  OUT    64 00                                               d.                      36.2.0        
  59.0                                 CTL    21 01 00 02  00 03 02 00                            SET CUR                 37.1.0        
  59.0                              2  OUT    63 00                                               c.                      37.2.0        
  59.0                                 CTL    21 01 00 02  00 03 02 00                            SET CUR                 38.1.0        
  59.0                              2  OUT    61 00                                               a.                      38.2.0        
  59.0                                 CTL    21 01 00 02  00 03 02 00                            SET CUR                 39.1.0        
  59.0                              2  OUT    60 00                                               `.                      39.2.0        
  59.2                                 RESET                                                                              40.1.0        
  59.0                                 CTL    01 0b 00 00  01 00 00 00                            SET INTERFACE           41.1.0
/*log end*/
	观察 Cmd.Phase.Ofs 分析:
		上面只采集了 控制 对话包 实时传输ISOC包,即视频流包并没有去抓
		9.1.0   是打开了 interface0 即 控制接口
		10.1.0 ~ 14.2.0 是插入后,视频驱动 初始化 brightness uvc 命令的对话
		15.1.0 ~ 31.2.32 是上位机打开后 ,初始化 probedata 的对话,
		32.1.0	是打开了 interface1 即 实时传输接口, 然后上位机就开始接收 视频流内容了
		33.1.0 ~ 33.2.0 是上位机控制板打开时,向设备查询当时的 brightness 值
		36.1.0 ~ 39.2.0 是上位机 三次 向设备 设置 brightness 值
		40.1.0 ~ 41.1.0 是上位机关闭时 发送的命令
	新问题,好多 NAK 就是 发送发送不成功吧!!!
		检查发现,demo使用uvc1.1, 但是使用的uvc库却是 uvc1.0
		uvc VS_PROBE_CONTROL uvc1.0是26个字节 uvc1.1 是34个字节,
		但是按照更改还是改变不了 nak 的问题,先搁置
		(未解决)
NAk问题的正视:
	终于知道为啥,frmH,frmW 初始化时一定要设置初始值,因为后续斌不能改变!!
	主要原因是set_cur 的 USBD_Read()出了重大问题!!!,uusbd 并不会接收到usb传来的数据!!
	set_cur功能 子无需有!!
	把 VS probe USBD_Read()禁掉后,即 set_cur VS Probe不作为,
		pc也不再发 set_cur VS commit来!
		这时,其他get_xxx 操作都恢复 ack 响应了! 
		这时 brightness get_cur 也是 ack 响应
		但是 brightness set_cur 引用了一次 setcur后,以后的get_cur 又变回Nak	
	找到一个关键点, pdata 要求32位对齐,4字节对齐 查找 ->pData
		寻找哦数据被填充的操作位置
		排除 UDPHS_EndofTransfer 里 pxfr->pData = 0 表示 传输结束, 释放 pData指针
		排除 UDPHS_WritePayload	里 pTransfer->pData 是把pData写入 fifo 准备透过usb 传到pc端的
		确认 UDPHS_ReadPayload	里 pTransfer->pData 是把fifo写入 pData 准备使用的 居然是一字节对齐
		排除 UDPHS_DmaSingle	里 pTransfer->pData 的地址挂到DMA 寄存器上, 不知道之后怎么用
		排除 UDPHS_DmaHandler	里 pxfr->pData SCB_InvaildateDCache 这里是禁止 pdata 这段内容作为DCache
		排除 UDPHS_Write	里 pxfr->pData 是被设置位置而已
		排除 UDPHS_Read		里 pxfr->pData 是被设置位置而已
		排除 UDPHS_HAL_WrWithHdr 里 pxfr->pData 是被设置位置而已
	测试 UDPHS_ReadPayload 发想原来wPacketSize 一直等于0 所以 fifo的内容并没有赋值给pData 所以的没有得到内容!!
		折中解决,手动设置为 wPacketSize = 2,	成功实现 brightness set_cur 问题!!
		追到 wPacketSize 在 USBHS_DEVEPTISR[0] 状态值为 40199 高位即 代表BYCT区值为0,即 wPacketSize=0
		(uvc命令未完待续)
图像卡顿问题:
	probedata : 
		vdelay,	100				//不懂
		frameintervalc	frame_intervalc(4)	//设了跟没设样
		isi_buffer 3
	usbddriverdescriptor->hs->frame from 640*480
		FRAME_BITRATEC(VIDCAMD_FW_2, VIDCAMD_FH_2, 8), /* Min bitrate */ 最小位数率(起码可以传8帧图片)
		FRAME_BITRATEC(VIDCAMD_FW_2, VIDCAMD_FH_2, 12), /* Max bitrate */ 最大位数率(起码可以传12帧图片)
		FRAME_INTERVALC(4), /* Default interval: 12F/s */	默认帧数率 这里是 4帧每秒但感觉设了跟没设样
		1, /* 1 Interval setting */	选择帧数率表的第一项,即选择12帧每秒这项,是这个地方决定了上位机的显示的帧速率!!
		{FRAME_INTERVALC(12)}, /* 12F/s, 7372.8KB/s */	帧数率表,这里只有12帧每秒这项,所以上位机只有这个选项!!
	目前这种配置下,效果最优!!








20170921
iar编译库文件及!!!使用










20170922
做板子:
vmware扩展硬盘后,在win7虚拟机上我的电脑->管理->磁盘管理-> c盘->右键扩展卷!!然后装ad
edbug模块:使用 AT32UC3A4256J-C1UR 单片机,可以考虑不用!!!
	接到 e70的pb4针!! 这是e70 专门的Edebug uart口
sram模块,针口:
	PC20 A0
	PC21 A1
	PC22 A2
	PC23 A3
	PC24 A4
	PC25 A5
	PC26 A6
	PC27 A7
	PC28 A8
	PC29 A9
	PD13 A10
	PA20 A11  (winbond的没有A11口,etrontech有A11口)
	DQ0  PC0
	DQ1  PC1
	DQ2  PC2
	DQ3  PC3
	DQ4  PC4
	DQ5  PC5
	DQ6  PC6
	DQ7  PC7
	DQ8  PE0
	DQ9  PE1
	DQ10 PE2
	DQ11 PE3
	DQ12 PE4
	DQ13 PE5
	DQ14 PA15
	DQ15 PA16	
	VDDQ1	(
	VDDQ2	 data线电源:(3.3v)	
	VDDQ3		统一并联多个100nf的电容
	VDDQ4		来滤波
	VSSQ1	data线地
	VSSQ2
	VSSQ3		
	VSSQ4	)
	VDD	( 
	VDD     芯片电源:(3.3v)统一并联多个100nf电容来滤波
	VSS	芯片地	
	VSS	)
	CLK  PD23
	CKE  PD14
	CS   PC15
	RAS  PD16
	CAS  PD17
	WE   	PD29
	LDQM PC18
	UDQM PD15
	对比了 winbond和etrontech 的芯片:
		wnbond 没有A11针,但多了一个BA针
		etrontch 完全符合
电源直接使用开发板提供的方案
摄像头模块:
	PA13 (ISI_RST)
	PC19 (ISI_PWD)
	PA4  (TWCK0)
	PA3  (TWD0)
	PA6  (PCK0)
	PD25 (ISI_VSYNC)
	PD24 (ISI_HSYNC)
	PA24 (ISI_PCK)
	PD22 (ISI_D0)
	PD21 (ISI_D1)
	PB3  (ISI_D2)
	PA9  (ISI_D3)
	PA5  (ISI_D4)
	PD11 (ISI_D5)
	PD12 (ISI_D6)
	PA27 (ISI_D7)
	PD27 (ISI_D8)
	PD28 (ISI_D9)
	PD30 (ISI_D10)
	PD31 (ISI_D11)
usb:
	HSDP
	HSDM
jlink:模块
	pb6 SWDIO
	pb7 SWCLK
	pb5 TRACESWO
uart/usart模块:
	Instance Signal I/O Line Peripheral
	USART0 	 CTS0	 PB2	 C
	USART0	 DCD0	 PD0	 D
	USART0	 DSR0	 PD2	 D
	USART0	 DTR0	 PD1	 D
	USART0	 RI0	 PD3	 D
	USART0	 RTS0	 PB3	 C
	USART0	 RXD0	 PB0	 C
	USART0	 SCK0	 PB13	 C
	USART0	 TXD0	 PB1	 C
	USART1	 CTS1	 PA25	 A
	USART1	 DCD1	 PA26	 A	
	USART1	 DSR1	 PA28	 A
	USART1	 DTR1	 PA27	 A
	USART1	 LONCOL1 PA3	 B
	USART1	 RI1	 PA29	 A
	USART1	 RTS1	 PA24	 A
	USART1	 RXD1	 PA21	 A
	USART1	 SCK1	 PA23	 A
	USART1	 TXD1	 PB4	 D
	USART2	 CTS2	 PD19	 B
	USART2	 DCD2	 PD4	 D
	USART2	 DSR2	 PD6	 D
	USART2	 DTR2	 PD5	 D
	USART2	 RI2	 PD7	 D
	USART2	 RTS2	 PD18	 B
	USART2	 RXD2	 PD15	 B
	USART2	 SCK2	 PD17	 B
	USART2	 TXD2	 PD16	 B
	UART0	 URXD0	 PA9	 A
	UART0	 UTXD0	 PA10	 A
	UART1	 URXD1	 PA5	 C
	UART1	 UTXD1	 PA4	 C
	UART1	 UTXD1	 PA6	 C
	UART1	 UTXD1	 PD26	 D
	UART2	 URXD2	 PD25	 C
	UART2	 UTXD2	 PD26	 C
	UART3	 URXD3	 PD28	 A
	UART3	 UTXD3	 PD30	 A
	UART3	 UTXD3	 PD31	 B
	UART4	 URXD4	 PD18	 C
	UART4	 UTXD4	 PD3	 C
	UART4	 UTXD4	 PD19	 C
pwm模块:
	先要识别pwm在这芯片上的一些内容:
	Instance Signal 		I/O Line Peripheral
	PWM0	 PWMC0_PWMEXTRG0	 PA10	 B
	PWM0	 PWMC0_PWMEXTRG1	 PA22	 B
	PWM0	 PWMC0_PWMFI0		 PA9	 C
	PWM0	 PWMC0_PWMFI1		 PD8	 B
	PWM0	 PWMC0_PWMFI2		 PD9	 B
	PWM0	 PWMC0_PWMH0		 PA0	 A
	PWM0	 PWMC0_PWMH0		 PA11	 B
	PWM0	 PWMC0_PWMH0		 PA23	 B
	PWM0	 PWMC0_PWMH0		 PB0	 A
	PWM0	 PWMC0_PWMH0		 PD11	 B
	PWM0	 PWMC0_PWMH0		 PD20	 A
	PWM0	 PWMC0_PWMH1		 PA2	 A
	PWM0	 PWMC0_PWMH1		 PA12	 B
	PWM0	 PWMC0_PWMH1		 PA24	 B
	PWM0	 PWMC0_PWMH1		 PB1	 A
	PWM0	 PWMC0_PWMH1		 PD21	 A
	PWM0	 PWMC0_PWMH2		 PA13	 B
	PWM0	 PWMC0_PWMH2		 PA25	 B
	PWM0	 PWMC0_PWMH2		 PB4	 B
	PWM0	 PWMC0_PWMH2		 PC19	 B
	PWM0	 PWMC0_PWMH2		 PD22	 A
	PWM0	 PWMC0_PWMH3		 PA7	 B
	PWM0	 PWMC0_PWMH3		 PA14	 B
	PWM0	 PWMC0_PWMH3		 PA17	 C
	PWM0	 PWMC0_PWMH3		 PC13	 B
	PWM0	 PWMC0_PWMH3		 PC21	 B
	PWM0	 PWMC0_PWMH3		 PD23	 A
	PWM0	 PWMC0_PWML0		 PA1	 A
	PWM0	 PWMC0_PWML0		 PA19	 B
	PWM0	 PWMC0_PWML0		 PB5	 B
	PWM0	 PWMC0_PWML0		 PC0	 B
	PWM0	 PWMC0_PWML0		 PD10	 B
	PWM0	 PWMC0_PWML0		 PD24	 A
	PWM0	 PWMC0_PWML1		 PA20	 B
	PWM0	 PWMC0_PWML1		 PB12	 A
	PWM0	 PWMC0_PWML1		 PC1	 B
	PWM0	 PWMC0_PWML1		 PC18	 B
	PWM0	 PWMC0_PWML1		 PD25	 A
	PWM0	 PWMC0_PWML2		 PA16	 C
	PWM0	 PWMC0_PWML2		 PA30	 A
	PWM0	 PWMC0_PWML2		 PB13	 A
	PWM0	 PWMC0_PWML2		 PC2	 B
	PWM0	 PWMC0_PWML2		 PC20	 B
	PWM0	 PWMC0_PWML2		 PD26	 A
	PWM0	 PWMC0_PWML3		 PA15	 C
	PWM0	 PWMC0_PWML3		 PC3	 B
	PWM0	 PWMC0_PWML3		 PC15	 B
	PWM0	 PWMC0_PWML3		 PC22	 B
	PWM0	 PWMC0_PWML3		 PD27	 A
	PWM1	 PWMC1_PWMEXTRG0	 PA30	 B
	PWM1	 PWMC1_PWMEXTRG1	 PA18	 A
	PWM1	 PWMC1_PWMFI0		 PA21	 C
	PWM1	 PWMC1_PWMFI1		 PA26	 D
	PWM1	 PWMC1_PWMFI2		 PA28	 D
	PWM1	 PWMC1_PWMH0		 PA12	 C
	PWM1	 PWMC1_PWMH0		 PD1	 B
	PWM1	 PWMC1_PWMH1		 PA14	 C
	PWM1	 PWMC1_PWMH1		 PD3	 B
	PWM1	 PWMC1_PWMH2		 PA31	 D
	PWM1	 PWMC1_PWMH2		 PD5	 B
	PWM1	 PWMC1_PWMH3		 PA8	 A
	PWM1	 PWMC1_PWMH3		 PD7	 B
	PWM1	 PWMC1_PWML0		 PA11	 C
	PWM1	 PWMC1_PWML0		 PD0	 B
	PWM1	 PWMC1_PWML1		 PA13	 C
	PWM1	 PWMC1_PWML1		 PD2	 B
	PWM1	 PWMC1_PWML2		 PA23	 D
	PWM1	 PWMC1_PWML2		 PD4	 B
	PWM1	 PWMC1_PWML3		 PA5	 A
	PWM1	 PWMC1_PWML3		 PD6	 B
adc模块;
	Instance 	Signal 			I/O Line 	Peripheral
	AFEC0		AFE0_ADTRG 		PA8 		B
	AFEC0 		AFE0_AD0 		PD30 		X1
	AFEC0 		AFE0_AD1/PIODCEN2 	PA21 		X1
	AFEC0 		AFE0_AD2/WKUP12 	PB3 		X1
	AFEC0 		AFE0_AD3 		PE5 		X1
	AFEC0 		AFE0_AD4 		PE4 		X1
	AFEC0 		AFE0_AD5 		PB2 		X1
	AFEC0 		AFE0_AD6 		PA17 		X1
	AFEC0 		AFE0_AD7 		PA18 		X1
	AFEC0 		AFE0_AD8/WKUP9 		PA19 		X1
	AFEC0 		AFE0_AD9/WKUP10 	PA20 		X1
	AFEC0 		AFE0_AD10/RTCOUT0 	PB0 		X1
	AFEC1 		AFE1_ADTRG 		PD9 		C
	AFEC1 		AFE1_AD0/RTCOUT1 	PB1 		X1
	AFEC1 		AFE1_AD1 		PC13		X1
	AFEC1 		AFE1_AD2 		PC15		X1
	AFEC1 		AFE1_AD3 		PC12		X1
	AFEC1 		AFE1_AD4 		PC29		X1
	AFEC1 		AFE1_AD5 		PC30		X1
	AFEC1 		AFE1_AD6 		PC31 		X1
	AFEC1 		AFE1_AD7 		PC26 		X1
	AFEC1 		AFE1_AD8 		PC27 		X1
	AFEC1 		AFE1_AD9 		PC0 		X1
	AFEC1 		AFE1_AD10		PE3 		X1
	AFEC1 		AFE1_AD11		PE0 		X1
除usb/sdram/isi/jlink外需要的针口:
	pb4  usart1 tx  (EDbug)
	pa21 usart1 rx  (EDbug)
	pa23 PWMC0_PWMH0
	pd18 uart4 rx
	pd19 uart4 tx

注意:VDDCORE VDDUTMIC VDDPLL 的1.2v 都是由 mcu 的 VDDOUT供电的!!!!
对于sensor 需要额外的1.8v 电源
sdram的知识,例如 etron的em636165
	有2 banks,这里的banks是芯片内部bank,称为logic_bank(Lbank)
	每个bank 有 2048rows X 256colums 个单元 (一个单元称为word)
	每个单元 能存 16bits 内容
	所以容量共: (2 x 2048 x 256 x 16) / 8 / 1024 = 2mb 两兆字节
	由于有两个Lbank 所以 A11 针是Lbank片选,低电平LbankA,高电平LbankB
	关于A10地址针, 输入rows地址时,计入并口地址的最高位, 输入colums地址时,为低电平	
	关于sdram的布线还是传统的来吧,关于打乱地址线和数据线的做法先不实现,或者说,数据线可以打乱,但是地址线不能打乱!!!
	开发板的 IS42S16100F-5Bl 是 200mhz 的,但是并未知道mpu支持多大频率的时钟
	暂且认为开发板sdramc输出时钟只是100mhz !!!!,
		不对,经过对 SDRAMC_CR 的一些内容反算,发现 时钟应该是200mhz!!!
		还是不知道这个200mhz是怎么来的
		后来发现这个推算的结果应该是错误的,因为张工说,SDCK就是MCK,所以应该只有 125mhz左右!!! 
	芯片还没有告诉sdram的clk频率,但是发现 PMC并没有 sdramc 的时钟开关!!!
		(PMC_EnablePeripheral(ID_SDRAMC)实际什么都没干),这是通用代码在个别型号里的亢余部分
	考虑到布线的困难,可以混乱接部分针口,这时,虽然数据放在sdram上是错乱的,但是读取出来时的内容u准确无变化
	根据 sdram的内存框架,乱接也有规则
		mpu-A11 接 sdram-A11 不变  因为控制 bank 片选  net标记: A11
		mpu-A10~A8 可与 sdram-A10~A8 交叉相接  因为这三针仅用于rows地址的,不能共用到cloum地址去
			mpu-A8(76) 接 sdram-A8(31)	net标记: A8
			mpu-A9(16) 接 sdram-A10(20)	net标记: mA9sA10
			mpu-A10(88) 接 sdram-A9(32)	net标记: mA10sA9
		mpu-A7~A0 可与 sdram-A7~A0 交叉相接  因为这八针共用于rows地址和cloum地址
			mpu-A0(120) 接 sdram-A7(30)	net标记: mA0sA7			
			mpu-A1(122) 接 sdram-A6(29)	net标记: mA1sA6			
			mpu-A2(124) 接 sdram-A3(24)	net标记: mA2sA3	
			mpu-A3(127) 接 sdram-A2(23)	net标记: mA3sA2			
			mpu-A4(130) 接 sdram-A5(28)	net标记: mA4sA5			
			mpu-A5(133) 接 sdram-A4(27)	net标记: mA5sA4			
			mpu-A6(13) 接 sdram-A0(21)	net标记: mA6sA0
			mpu-A7(12) 接 sdram-A1(22)	net标记: mA7sA1
		mpu-DQ0~DQ15 可与 sdram-DQ0~DQ15 交叉相接 数据虽然存放时错位,但可以准确读出 
		x	mpu-DQ0(11) 接 sdram-DQ2(5)	net标记: mD0sD2
		x	mpu-DQ1(38) 接 sdram-DQ7(12)	net标记: mD1sD7
			mpu-DQ2(39) 接 sdram-DQ15(49)	net标记: mD2sD15
			mpu-DQ3(40) 接 sdram-DQ14(48)	net标记: mD3sD14
			mpu-DQ4(41) 接 sdram-DQ13(46)	net标记: mD4sD13
			mpu-DQ5(58) 接 sdram-DQ8(39)	net标记: mD5sD8
			mpu-DQ6(54) 接 sdram-DQ9(40)	net标记: mD6sD9
			mpu-DQ7(48) 接 sdram-DQ11(43)	net标记: mD7sD11
			mpu-DQ8(4) 接 sdram-DQ6(11)	net标记: mD8sD6
			mpu-DQ9(6) 接 sdram-DQ5(9)	net标记: mD9sD5
			mpu-DQ10(7) 接 sdram-DQ4(8)	net标记: mD10sD4
			mpu-DQ11(10) 接 sdram-DQ3(6)	net标记: mD11sD3
			mpu-DQ12(27) 接 sdram-DQ1(3)	net标记: mD12sD1
			mpu-DQ13(28) 接 sdram-DQ0(2)	net标记: mD13sD0
		x	mpu-DQ14(49) 接 sdram-DQ10(42)	net标记: mD14sD10
		x	mpu-DQ15(45) 接 sdram-DQ12(45)	net标记: mD15sD12

		 
电路中的 mpu电源连接需要串联一个电感, 现在电感取值未知 暂时认为是 10uh~68uh之间,所以 暂时留下一个0603的封装位置






20171013
小米6 通过还原备份方式构建 google框架服务!!! 不用root!!!
	网上下载了的 Mi-pad-3-googleplay 把techtablets文件目录解压到 用户根目录->MIUI->backup->AllBackup->techtablets
	然后在 设置 -> 备份和重置 -> 本地备份 -> 4月18日 下午10:09 ->开始恢复
	然后登vpn 就可以使用googleplay了
	手机开了vpn后, dukto不正常!!,需要先退出vpn
	还有认识了一个好用的vpn atomvpn,还有蓝灯vpn!!!
	所有备份在 other -> xiaomi6-googleplay-vpn 目录里





20171201
板子整改
	usb正常!!
	板子焊好好了,先测试整体电路,电源 e70-cam v1 再焊上主芯片!!!
	u9 的 ams1117  vin vout 反了 ,  而且散热片连接的是 vout不是gnd !!!
	ldo芯片供电e70到达极限,转用dcdc方案!!
	mcu data0-7 接 sensor data2-9 多出的mpu 多出的 data线接地,sensor多出的data线先悬空!!!
	usart 是 ttl硬件协议,需要加个共地线 
	usb接口往外
	按钮该标签 reset user
	sdram  LDQM UDQM 各管理 d0-7, d8-15. 所以数据线乱接,d0-7 单独一区域, d8-15 单独一区域
		mpu-DQ0~DQ15 可与 sdram-DQ0~DQ15 交叉相接 数据虽然存放时错位,但可以准确读出 
			mpu-DQ0(11) 接 sdram-DQ2(5)	net标记: mD0sD2
			mpu-DQ1(38) 接 sdram-DQ7(12)	net标记: mD1sD7
			mpu-DQ2(39) 接 sdram-DQ15(49)	net标记: mD2sD15
			mpu-DQ3(40) 接 sdram-DQ14(48)	net标记: mD3sD14
			mpu-DQ4(41) 接 sdram-DQ13(46)	net标记: mD4sD13
			mpu-DQ5(58) 接 sdram-DQ8(39)	net标记: mD5sD8
			mpu-DQ6(54) 接 sdram-DQ9(40)	net标记: mD6sD9
			mpu-DQ7(48) 接 sdram-DQ11(43)	net标记: mD7sD11
		udqm区域
			mpu-DQ8(4) 接 sdram-DQ6(11)	net标记: mD8sD6
			mpu-DQ9(6) 接 sdram-DQ5(9)	net标记: mD9sD5
			mpu-DQ10(7) 接 sdram-DQ4(8)	net标记: mD10sD4
			mpu-DQ11(10) 接 sdram-DQ3(6)	net标记: mD11sD3
			mpu-DQ12(27) 接 sdram-DQ1(3)	net标记: mD12sD1
			mpu-DQ13(28) 接 sdram-DQ0(2)	net标记: mD13sD0
		X	mpu-DQ14(49) 接 sdram-DQ10(42)	net标记: mD14sD10
			mpu-DQ15(45) 接 sdram-DQ12(45)	net标记: mD15sD12
	pwm灯改为3极管 (ss8050)驱动的0.5w白光补灯!!
	
sram 对比: ISI4216100   				em63636165
	A11 slect bank					A11 slect bank
	2048 refresh cycles every32ms			4096 refresh cycles every64ms
	(未完,深入学习sram 内容!!!)
加入pwm,使用pwmdemo,控制灯!!!
	注意,examples 的许多例子编译后不可用,未知问题所在,但是把main函数的pwm操作部分函数发放到 usb_video 后可以工作
	注意,即使搬到usb_video里,也讲究放置的位置!!!
		sensor_setup会读取 ov7725_config定义的内容  const 内容
		但在 sensor_setup 前, pwm功能初始化会 初始化一个dma_buffer块:
		COMPILER_ALIGNED(32) static uint16_t dwDutys[DUTY_BUFFER_LENTH];
		而给这个块初始化赋值时,却居然没有识别到 ov7725_config定义的内容  const 内容占用了内存的位置
		因为未知这块空间已使用,而强制在const内容的位置里 初始化 dwDutys[DUTY_BUFFER_LENTH] buffer,错误刷写了const的内容
		然后导致 sensor_setup 读取到 错误的const内容而出错!!
		假如在pwm程序块初始化 COMPILER_ALIGNED(32) static 前先 sensor_setup,可能这样就先访问到const位置的内容,
		而后续初始化 COMPILER_ALIGNED(32) static 缓存就不会触到这块已知空间??
		实践证明可行,但不代表上述假设成立,可能是更复杂的内存冲突问题!!
	简述这芯片的pwm运行原理,
		基础:
		一般pwm是通过计数器累加来统计pwm输出针数据信号的持续时间,
		一开始计数器从0开始数,直到起始值标记,会反相数据信号
		一旦计数器数到,终点值标记就overcount,也会又一次反相数据信号,计数器重置
		计数器又从0开始数.....
		而e70的pwm添加了很多功能, 譬如 DMA功能,
		譬如改变 终点值标记/起始值标记 可以改变信号的持续时间,一般是修改对应寄存器
		而这里是通过pwm自动访问dma的数据,自己定时自动改变 终点值标记/起始值标记, 来达到更复杂的信号控制功能
		不需要用户去主动修改对应寄存器,只需要把一段数据放到dma,让pwm自己定时逐条读取dma内容自动 改变终点值标记/起始值标记!!
		所以修改 pwm信号,只需要修改 dma,不需要做复杂的寄存器读写工作
		例如
		如果想pwm输出恒定信号,dma里写满同一个值!
		如果想pwm输出渐变信号,dma里写一堆渐变数据!
添加用户按钮 (针64.pa11)
	最好是中断方式!!
	一定要 通过 source_insight 在程序包里找一下,肯定会有的!!!
	移植注意是否与当前设置兼容
	按键去抖:
		进入handler函数时,一定要先关闭中断,不然因为抖动会陆陆续续有好多嵌套中断产生,
		这样就保证当前只产生一个handler函数
		我发现抖动间隙特别长,handler里做的延时要足够长 125mhz_mck 的芯片,建议 i=10000;while(i--);
		退出时打开重新打开中断!! 
	
第二版测试：
	sdram 管脚！！！内容
		clk： cpu传入的masterclock
		cs： 片选信号，本来是交互信号，但这里一直低电平， 并没有问题，cpu操作
		ras： cpu操作的信号， 平时高电平，读写数据时，cpu要拉低信号
		ras： cpu操作的信号， 平时高电平，读写数据时，cpu会拉低信号
		we：  cpu操作的信号，写操作允许信号，平时高电平，读写数据时，cpu会拉低信号
		U/Ldqm： cpu操作的信号，data线控制信号，一直低电平，表示data线使能！！
		也就说，sram控制线，全部都是cpu在主动控制，sram在被动被控制，没有控制！！
		所以说，sram初始化，是初始化mpu的内部sram控制模块，不会跟sram交互信息握手控制什么的，
		所以就算没有接sram芯片，mpu的sram初始化也会成功不报错！！！
		U/Ldqm 由来，因为sram一个单元16bits，相当于两字节，而映射到mpu上的是8位地址，就是说sram一个单元，
		映射到mpu两个地址，通过U/Ldqm 分辨 此刻mpu地址对应的是 sram 的某个单元的高八位还是低8位 
	sram看datasheet发现 adress9 与address10 不能换
	usb布线大意了，按照之前的布， 不稳定， 要记录usb布线经验
	dcdc电源的封装要更改！ 换电容封装 最小0603 ，不要ad自带的封装
	三极管封装要更改！！
	差分线旁边不能有 gnd 或其他信号线
	换电容封装 最小0603
	电源和地，尽量像差分线那样并排布线处理，不要中间夹一堆元器件 滤波电容在 电源的输入输出端旁边
	程序烧不进去，记得先erase flash
	摄像头换 ldo 电源！！
		以mcp1700为例子：看他的电源抑制比
		比如 60khz 下是 -30db，表示输入端噪音达 60khz，输出端噪音也是60khz
		据专门 ldo的 psrr计算公式：psrr = 20 * log_10( Δvout / Δvin) = -30db
		即 输入电压一个比较大的变化量 Δvin，对应输出电压的变化量 Δvout 相对较小
		db越小（不是绝对值越小！！），输出端的噪音纹波越小，输出端输出越平滑
		虽然输出端和输入端噪音频率几乎一致，但是输出端的噪音交变电压变化量越小，输出端输出越平滑，抑制噪音的效果也就越好

电源及信号布线与去噪 经验
	电源/地 推荐的星状布线，特别是电源：
		     —————————————————— A
		    /
		   /
	Vcc/GND ——————————————————————— B
		   \
		    \
		     —————————————————— C
	电源/地 不推荐的紧邻布线：
	Vcc/GND ————————————————————|
				    |—— A
				    |
				    |—— B
				    |
				    |—— C

		因为模块 A B C 个工作过程中不可避免会产生 电气属性 纹波噪音反映到电源/地的线路上！！
		如果使用 紧邻布线，例如A产生的的纹波噪音会通过短途线路迅速影响到 B 和 C 的输入电源，影响 B C 工作
		如果使用 星状布线，例如A产生的的纹波噪音会通过传回到电源线主脉，如果电源线主脉有去噪电路，去掉噪音
		即使电源主脉没有去噪音电路，噪音回到主脉再绕到 B C 的分脉去影响 B C，噪音要经过长长的一段线路，噪音会衰减而难以影响

	一般布线，单路传输过程中不能出现直角！！
		即：	A——————\		A————————|
				\			 |
				 |			 |
				 |			 |
				 B   正确		 B   错误

	但是但是单路传输遇到过孔跨层，可允许跨层直角！		
		即： A——————————。
				|
				|
				|
				B    允许

	分支线路时，允许分支处直角！
		即： A————————————————————C
				|
				|
				|
				B    允许

	模拟线路，和数字电路，不能共地共源， 同属于数字电路不推荐分地
		即： Vcc/GND ———————————— R ———————————————————AC
					|
					|
					|
					DC
		DC电路 与 AC电路 的 地/源 要分路，之间甚至需要 一个电阻 分隔

摄像头横条纹噪音 处理：
	2.7V的AVDD，1.8V和1.2V的DVDD，纹波均控制在40mV，还能有什么原因导致横条纹，不是个例，不存在sensor坏
	低照度的时候出现条纹的情况，一般都是由于电源纹波引起的，
	你可以测一下你板子上面的纹波，其中内核电压和模拟电压上面的纹波会低照度的影响是最大的，
	我也在调试sensor板，发现其实滤波效果最好的还是在板子上面的电源上面加容值大点的高分子电容或者钽电容，
	这两种电容的滤波效果是最明显的，它们的ESR比较小，不过有点贵，
	还想问一下，你板子上面的模拟电压是怎么产生的呢，是用LDO来输出的么，还是直接通过数字电源来转的呢，中间有加一个合适的磁珠么？
	还有DGND和AGND的layout也是很重要的，这两地处理不好的话，低照度效果也会很差的，
	检查一下你的PCB布板。

	修改sensor的图片采样率！！ 
		直接修改 0d 地址 的 pll 为6x
		修改 e70提供的 isipck ： _isiPckInit(Void)

	注意修改usb descriptor 只是改变了usb传输速率，而不是sensor的图片采样率！

换ldo，减纹波：
	e70 总电流 150ma，3.3v 工作压
	sensor 总功率 120mw 保守电流 66ma
	sram Operating Current 150ma
	总电流：380ma左右！！
	最后换了 主电源芯片 MP1470H 后，还有细调了外部电路， 电源输出纹波，示波器没有显示改善多少，但是摄像头横杠问题解决了！！
继续让体积缩1/3
	出现了轮廓黑点！！（只有一块出现，未解决，初步认为是 sdram的问题，轮廓黑点可以说是特定rgb像素点，传输到sdram时出错）
	很多时候是 sdram sensor 等焊接问题！！
	芯片不过工作，注意晶震的并联电容容值问题。
	首先不怀疑 mcu的问题，
	试了把拆机片焊回去，工作。
	布线不要轻易有过孔，并口数据排线尽量等长，
	这次缩板工作，妥协打破了好多并不肯定的布线规则，出来效果也不算太差，值得为后面的设计做参考
	电源的滤波电容根据更小的新板子数值做了修改，完美工作
	e70-cam结案！
	










20180226
SAMA5D2-xplained
开机：
	usb-EDBG 或者 usb-A 供电， DEBUG串口交互调试信息。115200/8/noparity/1-stopbit
	不使用 usb-EDBUG 本身 交互调试信息，因为，reset按键也会重启EDBG辅助芯片，造成本连接好的串口通讯断开
	这个与 a5d4的板子是有重大区别的！！，a5d4板子可以直接用usb-EDBUG 本身 交互调试信息，即使按reset按键也不受影响
编译裸机包：
	裸机包在ubuntu上尝试编译，不是在win-IAR上，
		make TARGET=sama5d2-xplained VARIANT=ddram CROSS_COMPILE=arm-linux-gnueabihf-
	补充：
		可以修改softpack_sama5_2.3/scripts/Makefile.vars: CROSS_COMPILE 
		(这样make命令上不用加CROSS_COMPILE项)
	出错：
		arm-linux-gnueabihf-gcc: 错误：nano.specs：没有那个文件或目录
		softpack_sama5_2.3/scripts/Makefile.vars: CROSS_COMPILE 定义的link选项！
		nano.specs是 arm-none-eabi- 的文件之一，我们的arm-linux-gnueabihf- 并没有！！
		所以还是安装一个 arm-none-eabi- 编译器吧！！
	安装 arm-none-eabi- 编译器 （现成安装，非源码编译安装）
		网址：https://launchpad.net/gcc-arm-embedded/+download
		下载 gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2
		安装：
			sudo tar xjf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2 -C /opt
		gedit ~/.bashrc 
			添加：export PATH=$PATH:/opt/gcc-arm-none-eabi-5_4-2016q3/bin
			save
			立即生效：source ~/.bashrc
		安装的 arm-none-eabi- 与本来存在的 arm-linux-gnueabihf- 是可以共存的，
		arm-linux-gnueabihf- 也是这样安装上的，
		由于使用两者中的一个编译项目时，工具的前缀不一样，所以不会冲突
	重新编译：
	make TARGET=sama5d2-xplained clean	//清除
	make TARGET=sama5d2-xplained VARIANT=ddram 	//这时回到默认使用 arm-none-eabi-XX 编译	
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c erase	//必须先擦除spiflash
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c writeboot:xxx_ddram.bin //烧到spiflash启动失败！！
	再一次：
	make TARGET=sama5d2-xplained //默认编译 VARIANT=sram，等于make TARGET=sama5d2-xplained VARIANT=sram ）
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c erase	//必须先擦除spiflash
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c writeboot:xxx_sram.bin //烧到spiflash成功启动！！	

烧写官方linux demo：
	预说明：
		官方使用 sam-ba 3.2, 现有是sama5d4时候的 sam-ba 3.1 继续用 3.1，不用 3.2
		a5d2使用 spiflash 和 emmc-flash 复合存储模式，不像 a5d2 使用的 nand-flash 单存储模式
		a5d2使用 spiflash 写 bootstrap，uboot-env，uboot，emmc-flash 写 rootfs 而且是 .wic格式的，不是.ubi格式
		a5d2 使用ttyACM0 usb端口烧写，还有发现，edbg与usb-a共用ttyACM0 usb端口，
		所以usb-a烧录与edbg输出串口信息冲突，不能共用，
		对比 a5d4 edbg用ttyACM0，ubb-a烧录用ttyACM1,所以可共用不冲突！！
	闭合boot_dis跳针，reset按钮，打开boot_dis跳针
	擦除 spiflash：（spiflash 4194304 bytes）
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c erase
	写 bootstrap 到 spiflash
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c writeboot:at91bootstrap-sama5d2_xplained.bin
	写 uboot-env 到 spiflash
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c write:u-boot-env.bin:0x00006000
	写 uboot 到 spiflash
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c write:u-boot-sama5d2-xplained.bin:0x00008000
	写 打包镜像（kernel+dtb+rootfs）到 emmc
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a sdmmc:0:0 -c write:atmel-xplained-demo-image-sama5d2-xplained.wic:0
	成功开机，说明 sam-ba3.1 可用于a5d2
	注意，-a sdmmc:0:0 因为在sam-ba3.1的a5d2没有做默认参数，所以要自己填上:0:0,表示 sdmmc0,partiton0，参考（sam-ba3.2做了的默认参数）
编译烧写 bootstrap：
	获取，用之前下载在a5d3的。拷贝过来！
	make mrproper //清理
	make sama5d2_xplaineddf_uboot_defconfig //配置
	（注意：make sama5d2_xplaineddf_uboot_defconfig //这个配置，表示bootstrap加了sdcard功能）
	make CROSS_COMPILE=arm-none-eabi- -j8 //编译
	烧写 binaries/sama5d2_xplained-dataflashboot-uboot-3.8.7.bin 成功运行！！
	注意，bootstrap 拷贝 uboot到ddr运行！
	拷贝uboot的参数：	uboot在 flash 位置 0x8000, uboot大小 0x80000， 拷到ddr的位置 0x26f00000 
				image name u-boot.bin
编译烧写 uboot：
	获取，用之前下载在a5d3的。拷贝过来！
	$ git branch -r		//查看版本分支
	$ git checkout origin/u-boot-2016.03-at91 -b u-boot-2016.03-at91	//选用版本分支
	make sama5d2_xplained_spiflash_defconfig	//配置 uboot放在spiflash上的
	make CROSS_COMPILE=arm-none-eabi- -j8 	//编译
	烧写可用！
	但是发现，因为这个uboot居然没有 ext4load 命令，所以，无法继续加载 linux
	所以直接到 https://github.com/linux4sam/u-boot-at91 下载了一个新版的，
	注意在 github下载u-boot-at91 时，git clone 是全部分支链都会下载下来，而直接打包zip下载，只下载到最新的分支版本。
	所以打包zip的u-boot-at91 不可以做 git xxx 其他操作
	由于git clone太慢，我直接打包zip下载uboot包了
	最后编译烧写可用，可加载 demo-linux
	补充，
	uboot-env.bin 是commandline，bootargs自定义信息的数据包，放到指定位置后，uboot会优先使用该地方的env参数内容！
	例如，把uboot-env.txt 编译成 uboot-env.bin 由于env保存在 0x6000 - 0x8000 之间，所以大小设置为 0x2000
	./tools/mkenvimage -s 0x2000 -o u-boot-env.bin u-boot-env.txt	//编译 env.bin
splflash烧录问题！！！
	烧写spiflash并不可以中途替换其中的一个模块就烧一个模块！！如果要换其中的 bootstrap，uboot，uboot-env时，
	要全部替换，erase全芯片，重新烧录
emmc文件系统分析：
	官方 demo 的文件系统是一个 .wic 镜像，
	file atmel-xplained-demo-image-sama5d2-xplained.wic //显示该镜像是 x86 boot sector（启动扇区） 不能直接 mount 镜像
	fdisk -l atmel-xplained-demo-image-sama5d2-xplained.wic	//查看整个启动扇区的 分区结构
		Disk atmel-xplained-demo-image-sama5d2-xplained.wic: 459 MB, 459705344 bytes
		4 heads, 32 sectors/track, 7014 cylinders, total 897862 sectors
		Units = 扇区 of 1 * 512 = 512 bytes
		Sector size (logical/physical): 512 bytes / 512 bytes
		I/O size (minimum/optimal): 512 bytes / 512 bytes
		Disk identifier: 0x4376234b	
		                                         设备 启动      起点          终点     块数   Id  系统
		atmel-xplained-demo-image-sama5d2-xplained.wic1               8      897861      448927   83  Linux
		可见，里面的atmel-xplained-demo-image-sama5d2-xplained.wic1 才是文件系统镜像所在！
		可见，一个扇区单元 512 bytes，只有分了一个分区atmel-xplained-demo-image-sama5d2-xplained.wic1
	mkdir test && mount -o offset=4096 atmel-xplained-demo-image-sama5d2-xplained.wic1 test/
		mount 这个分区，因为这个分区在 起点块8 开始，所以 偏移 8x512=4096
刷新emmc镜像内容方案1：
	sudo chmod 777 ./test/*   
	/*修改操作...*/
	sudo umount ./test   		
		修改权限，这样就可以直接修改镜像里的内容，比如添加一个文件，然后重新烧到板上emmc，开发板成功看到修改内容！！
刷新emmc镜像内容方案2：
	mkdir demo-emmc-rootfs && sudo cp -R ./test/* ./demo-emmc-rootfs/   
		/**/先把镜像里的东西全部拷出来
	（自己弄一个新镜像，方法待续）
刷写kernel：
	把a5d4的kernel拷过来，直接拷文件夹过来，不要压缩包，因为压缩包解压各种问题
	按a5d4的方法编译，
	使用刷新镜像内容方案1 直接把镜像里 /boot里 dtb，和zIamge 替换成自己编译的！！
	烧录 .wic 镜像！！ 成功!
	进一步修改kernel去掉之前遗留下来的调试信息！！
刷写kernel方法2，tftp下载：
	编译好kernel， 拷到tftpboot
	开发板 tftp -gl zImage 200.200.200.103	//下载
	cp zImage /boot/zImage	//替换
	重启开发板成功！！	
编辑Yocto/Poky 系统镜像
	由于，a5d2开发板 rootfs与kernel捆绑了，所以单单编译kernel，并未知道如何捆绑rootfs成一个wic整体镜像烧录！
	所以直接从 yocto 项目探索！！
	a5d4 已经下载了一个完整的yocto包，先复制一份！！








20180302
移植usb_host
官网下载iar8 安装，然后把 arm/config/devices/Microchip 拷到 7.3 对应地方去
然后7.3就支持 sama5d2了，还有，debug支持模块也是这样操作
重新建立project， 对比 张一风的项目的ewp文件， 把要用的.c.s文件add到羡慕里去
还有注意 根据张一风的项目的ewp文件在options添加宏定义的注释，不然项目编译不成功
现在出现了 static __(atrribute)__ (const) 无发编译的问题！！ 
	atrribute 是 gnu 规范， iar编译器不可通过
	__(atrribute)__ (（aligned（32））) gun的字节对齐规则，在iar编译器上好像也用不着
目前，字节对齐修改问题！！，已经可编译并烧录到spiflash上运行
手动改对齐问题！成功运行协议检测，
并未能执行文件系统的读写！继续开通文件读写功能
编译出现以下错误：
	Error[Lp011]: section placement failed 
	unable to allocate space for sections/blocks with a total estimated minimum size of 0x52658 bytes (max align 0x100) in  
	<[0x00200000-0x0021ffff]> (total uncommitted space 0x1ffc4). 
		由于 linker 是 sram.icf，即程序在sram上执行，sram空间不够大，不足够空间添加文件读写功能，
		改为 ddram.icf 就可以通过编译了，但未知烧录运行如何，
	Error[Li005]: no definition for "__write" [referenced from puts.o(dl5E_aln.a)] 
		这是iar 的公共链接库问题！！现在使用的库没有puts.o，所以无法地定位	__write
		project-options-general options-library configuration
		 -library full
		 -library lowlevel interface implementation-semihosted
基于ddram布局bin文件无法运行解决：
	之前试过编译出对应的 ddram文件后，并无法执行文件，
	张一封之所以成功并不是因为把文件拷到spiflash上，而是直接在上电情况下，在iar里通过jlink线上拷到ddram进行调试！！
	现在的一个思路是，上电先运行bootstraps，把对应的ddram文件拷贝到ddram 0x20000000 上，然后在跳转执行，之前9x35板子成功！
	在这里却失败，原因在于源代码包给的 ddram linker文件有bug！！使之只适合线上调试！！
	gnu的 ddram linker文件要这么改：
/* ddram.ld */
...
SECTIONS
{
	.fixed0 :
	{
		. = ALIGN(4);
		_sfixed = .;
		/*by william 把中断向量放在ddram地址开头*/
		KEEP(*(.vectors .vectors.*))
		*(.textEntry)
		*(.text .text.* .gnu.linkonce.t.*)
		*(.glue_7t) *(.glue_7)
		*(.rodata .rodata* .gnu.linkonce.r.*)
		*(.ARM.extab* .gnu.linkonce.armextab.*)
...	
	.relocate :
	{
		. = ALIGN(4);
		_srelocate = .;
		/*by william,不要把中断向量放在 sram上*/
		/* KEEP(*(.vectors .vectors.*)) */
		/* *(.ramfunc) */
		. = ALIGN(4);
		_erelocate = .;
	} >sram AT>ddr
/* ddram.ld */
	最后，用gnu（ubuntu，arm-gcc）编译的基于ddram布局bin文件，成功在 0x20000000 执行！
	后来发现，其实不用改，照样执行！！
尝试结合iar 和bootstrap
莫名其妙iar不能编译了，表示 unknown cpu core
(softpack软件包出错，重新解压，原来是移植张工的project时，修改了的文件导致其他example出这个错误)
还是不行，涉及到复杂的重定位，中断向量位置，和代码搬运问题！！
iar说明书 109页！，多次修改iar linker，都无法实现通过 bootstrap 搬运程序到ddram上运行
比对过iar和gnu linker，发现没有什么不一样的地方，未知为何不能成功
不成功的因素是多方面的，涉及到复杂的重定位，中断向量位置，和代码搬运问题，甚至是 gnu编译的bootstrap与iar编译的app的冲突问题！！
现在，搁置iar编app，全力使用gnu版本
官方现在只提供 gnu softpack_v2.12 之前的2.3反而没了！！
使用2.12版本，
2.12版本成功 bootstrap 搬运 app，并运行成功！！
发现2.12 make 脚本很有问题！！，不能clean!!
在gnu上移植usb_host,并掌握 makefile 
勉强在移植 usb_host 到 gnu 成功！！
	先在 V2.12 建立 examples/usb_host: 添加张工的代码后，建立makefile：
/*...examples/usb_host/Makefile*/
CONFIG_LIB_USB_HOST = y		#我们移植的usb_host为一个单独的模块

TOP := ../..			

BINNAME = usb_host

obj-y += examples/usb_host/main.o

include $(TOP)/scripts/Makefile.rules	#真正的编译脚本都在这
/*...examples/usb_host/Makefile*/
	再 V2.12 的lib添加 文件夹usb_host，把张工对应的内容都放这，然后修改Makefile.inc 添加：
		#by william
		include $(TOP)/lib/usb_host/Makefile.inc
	lib/usb_host,新建Makefile.inc
/*...lib/usb_host/Makefile.inc*/
# ----------------------------------------------------------------------------
#         SAM Software Package License
# ----------------------------------------------------------------------------
# by william
# 20180310
# ----------------------------------------------------------------------------

ifeq ($(CONFIG_LIB_USB_HOST),y)		#显然，我们在examples/usb_host下make时才加进来的LIB_USB_HOST模块

CFLAGS_INC += -I$(TOP)/lib/usb_host	#把include路径添加到编译环境里去，方便编译

lib-y += lib/usb_host.a			#编译出来的 静态库文件名

usb_host-y := lib/usb_host/fat.o	#要编译的.o 文件
usb_host-y += lib/usb_host/file.o
usb_host-y += lib/usb_host/cmd_usb.o
usb_host-y += lib/usb_host/devices.o
usb_host-y += lib/usb_host/ohci_hcd.o
usb_host-y += lib/usb_host/part.o
usb_host-y += lib/usb_host/part_dos.o
usb_host-y += lib/usb_host/usb.o
usb_host-y += lib/usb_host/usb_kbd.o
usb_host-y += lib/usb_host/usb_ohci.o
usb_host-y += lib/usb_host/usb_storage.o
usb_host-y += lib/usb_host/yf.o


USB_HOST_OBJS := $(addprefix $(BUILDDIR)/,$(usb_host-y))	#建立一个.o文件组参数

-include $(USB_HOST_OBJS:.o=.d)		#把所有.o变成.d文件

$(BUILDDIR)/lib/usb_host.a: $(USB_HOST_OBJS)	#把所有.d文件链接成usb_host.a静态库放到build/lib里 
	@mkdir -p $(BUILDDIR)/lib
	$(ECHO) AR $@
	$(Q)$(AR) -cr $@ $^
endif
/*...lib/usb_host/Makefile.inc*/
	然后，避免其他琐碎麻烦，把drivers，scripts，target，utils拷贝过来替代
	然后以sram linker编译， 以在sram运行方式。
	编译到lib/usb_host时，会出现很多说memset，strcp等等找不到的问题，认为缺少头文件，
		所以统一在yf.h添加上：
		//by wiliam
		#include <ctype.h> 
		#include <string.h>
		#include <stdio.h>
		#include <stdlib.h>		
		然后在对应的，如cmd_usb.c 添加 #include <yf.h>
		include可以用 <> 是因为 makefile.inc添加了CFLAGS_INC += -I$(TOP)/lib/usb_host 
	编译到lib/usb_host/usb_kbd.c时，出现没找到memscan，首先memscan不是标准函数，是张工在main.c上定义的函数
		但是，还没有编译main.c所以就得不到memscan，（也不知道iar是怎么编译通过的）
		于是另外在 lib/usb_host,新建yf.c,把这个函数放进去！
	编译 ohci_hcd.c 发现，没有定义 pmc_xxxx之类的函数，于是，查看pmc.h,补上没声明
		然后在 ohci_hcd.c 添加 #include <peripherals/pmc.h>
		(也不知道，iar是怎么编译通过的)
		另外pmc_enable_upll_clock() 和 pmc_enable_upll_clock() 都没有输出，所以不能嵌入if（）
		(也不知道，iar是怎么编译通过的)
	然后编译main.c,说找不到 file_detectfs, file_read, usb_display_desc, usb_dispaly_config
		在 yf.h 编译添加 file_detectfs, file_read, 声明，让main.c include
		至于usb_display_desc, usb_dispaly_config，以上做法又说会出错说conflicting type什么的
		所以直接在 main.c 开头用extern 声明！！
	然后编译又说sram空间不够，于是尝试ddram linker 编译，
		一举成功，并可bootstrap搬运，最后在 ddram上运行！！
		但是，显然卡死在初始化usb上了！！
寻找死机位置：
	usb_scan_device
		->memset没有问题,
		->usb_alloc_new_device 没有问题，
		->usb_new_device()->usb_get_descriptor
		跟踪到 usb_ohci.c->submit
	(未完)


第二次重新使用iar，发现编译成功，但不能工作，显示 ohci unrecoverable error，
	记录，之前第一次是合并文件夹的，而之后的第二次是替换文件夹的
	重新移植编译并详细记录
	重做：
	使用第二次的　examples/usb_host
	合并文件夹并把第二次重新修改好的lib/usb_host 拷过来，
	ohci unrecoverable error，
	重做：
	使用第二次的　examples/usb_host
	合并文件夹并把未修改的（张工给的）lib/usb_host 拷过来，
	swab.h:
		注释掉　__attibude__((const)) 注释替换掉
	usb_kbd:
		static unsigned char leds __attibude__((aligned (0x4)));
		改为：
		#pragma pack(4)
		static unsigned char leds;
		#pragma pack()	
	usb_ohci
		#pragma pack(16)
		struct ed {...
		};
		#pragma pack()
		...			
		#pragma pack(32)
		struct td {...
		};
		#pragma pack()
		...
		#pragma data_alignment=256
		struct ohci_hcca {
			__u32	int_table[NUM_INTS];	/* Interrupt ED table */
		#if defined(CONFIG_MPC5200)
		#pragma data_alignment=256
			__u16	pad1;			/* set to 0 on each frame_no change */
		#pragma data_alignment=256
			__u16	frame_no;		/* current frame number */
		#else
		#pragma data_alignment=256
			__u16	frame_no;		/* current frame number */
		#pragma data_alignment=256
			__u16	pad1;			/* set to 0 on each frame_no change */
		#endif
		#pragma data_alignment=256
			__u32	done_head;		/* info returned for an interrupt */
		#pragma data_alignment=256
			u8		reserved_for_hc[116];
		//} __attribute((aligned(256)));
		};
		// #pragma pack()
		...
		#pragma pack(32)
		struct ohci_regs {...
		};
		#pragma pack()
	出现 HCCA not aligned!!等．．
	usb_ohci:
		#pragma data_alignment=256
		struct ohci_hcca ghcca[1];
		#pragma data_alignment=８
		struct ohci_device ohci_dev;	
	然后就好了！！！真好了！！！，没有出现　ohci unrecoverable error，的问题
	好了;开始试错！！
	1,usb_ohci:
		#pragma data_alignment=256
		struct ohci_hcca {...
		};
		#pragma pack()
		改为：
		#pragma data_alignment=256
		struct ohci_hcca {...
		};
		并没有问题！！
	2,替换文件夹,而非合并文件夹　重新编译
		也没有问题！！
	3,替换来自linux修改后的usb.ｃ文件！！
		我去，也没有问题，那么那个　ohci unrecoverable error　怎么发生的已经成迷！！
		不管了
着手解决 iar 在ddram上运行的引导问题！！
	反汇编bin文件：arm-none-eabi-objdump -D -b binary -m arm usb_host.bin>usb_hoat.s
	查看了反汇编，发现并没有像入口不对的问题！！
	笔记　bl　指令：
		200000a4  eb002381  bl 0x8eb0  //意思是跳到　20008eb0,是i相对跳转指令,非绝对地址跳转!
		具体指令运作：
		eb002381取[23,0]即2381,
		然后扩成32位,[31,24]为0[23,0]不变,结果也是2381
		左移两位得8e04,
		加此刻pc值(200000ac)等于20008eb0
	查看中断向量的remap问题
	gnu的编译的bin可以看到:bin文件放到ddram上运行的时候,一直都是相对地址跳转,所以顺利执行
		然后运行到relocate时,把存在 _etext的标记的 _srelocate至_erelocate位置存放的中断向量拷贝到sram:0x20000位置上
		然后remap,把芯片0x0到某地址A 的这段地址对正sram: 0x20000上去!
	现在是怀疑iar的 __iar_data_init3 函数并没有好好工作!!可是找不到真正的位置
	ucos可以ddram启动,把对应的sram.ddram的linker文件代入发现,
		sram可启动,但是ddram依旧不行!!
		因为ucos的ddram是测试过可运行的,所以应该不是linker的问题, 重点看cstartup.s区别!
		uocos的那个cstartup是先remap再relocation中断向量,而2.12的相反
		uocos的那个cstartup有个low_level_init,而2.12的是board_init代替
		最后修了下v2.12的,sram可动,ddram不可动
		怀疑不是cstartup入口的问题了,而是其他!!
	最后手段建立点灯调试!!,同时了解的 a5d2 的 PIO 框架设置
		开发板led灯,相关参数
/* RGB LED index */
#define LED_RED   0
#define LED_GREEN 1
#define LED_BLUE  2

/** LED #0 pin definition (Red). */
#ifndef CONFIG_BOARD_SAMA5D2_XPLAINED_PROTO
#define PIN_LED_0 { PIO_GROUP_B, PIO_PB6, PIO_OUTPUT_1, PIO_OPENDRAIN }
#else
/* on prototype board, LED_0 shares a pin with SDMMC0 (eMMC) card detect */
#define PIN_LED_0 { PIO_GROUP_A, PIO_PA13, PIO_OUTPUT_0, PIO_OPENDRAIN }
#endif

/** LED #1 pin definition (Green). */
#define PIN_LED_1 { PIO_GROUP_B, PIO_PB5, PIO_OUTPUT_1, PIO_OPENDRAIN }

/** LED #2 pin definition (Blue). */
#define PIN_LED_2 { PIO_GROUP_B, PIO_PB0, PIO_OUTPUT_1, PIO_OPENDRAIN }

/** List of all LEDs definitions. */
#define PINS_LEDS { PIN_LED_0, PIN_LED_1, PIN_LED_2 }

#define NUM_LEDS  3
		ldr 把"内容",放入寄存器
		str 一个寄存器的装载内容, 另一个寄存器里装载的地址, 把内容放到地址里去!!
		在cstartup.s任意一段值得怀疑的地方插入这段点灯代码!
        ; by william lighting-debug
        ; dis interrupt pb0,5,6
        ldr     r0, =0xfc038064
        ldr     r1, =0x61      
        str     r1, [r0]
        ; no-secure pb0,5,6
        ldr     r0, =0xfc039070
        ldr     r1, =0x61      
        str     r1, [r0]
        ; set data be drived by output (lighting-off)
        ldr     r0, =0xfc038050
        ldr     r1, =0x61
        str     r1, [r0]
	; mask pb0,5,6
        ldr     r0, =0xfc038040
        ldr     r1, =0x61      
        str     r1, [r0]
        ; config PB output opendrain
        ldr     r0, =0xfc038044
        ldr     r1, =0x4100
        str     r1, [r0]
        ; clear data be drived by output (lighting-on)
        ldr     r0, =0xfc038054
        ldr     r1, =0x61
        str     r1, [r0]      
        b       loop4		//这是跳到死循环,看情况使用
		代码参考 pio4.c board_led.c 相关的:
        board_cfg_led();
        led_set(1);
        led_set(2);
        led_set(3); 
		先关中断
		a5d2提供了,secureio,和no-secureio,我们做led控制,只要no-secureio就好了
		a5d2设置pin脚参数的寄存器框架跟以往的不一样,设计得更加紧凑,使用了更少的寄存器
		要设置具体某些pin脚,需要先 使用mask寄存器记下要设置的脚
		然后在cfg设置的内容就仅仅会对 mask记下的pin脚生效,
		cfg 仅设置 output,和opendrain,两个属性
		set output data 等于 set data be drived by output 等于设置输出1,高电平,
		clear output data 等于 clear data be drived by output 等于设置输出0,低电平,
		set/clear output data寄存器在cfg设置前设置并没有问题!!
		据pcb,电流是从3.3V流向led流回pb0,5,6的,所以  clear output data 才是真正的开灯操作
		最后,发现不管写在哪都不亮,
		原来是运行到 board_sama5d2-xplained.c:board_init()->board_cfg_pmic() 以后,io才工作!!
	开始点灯调试
		__iar_program_start开始,先设置led并开灯,但是由于board_cfg_pmic()后的,pin脚才真正的亮起了灯?
		所以入口没有问题,在board_init开始出问题!!!!
		重点在  board_cfg_pmic() 如果在它之前做了事情,就会崩溃,怀疑进入board_init(),先做 board_cfg_pmic()
		而且不做,cfg_loelevel和dma_init时,通过 boardinit!! 成功跳到 main!!
		自console开始又开始跳不过了
		还原源代码的修改,编译选项选择不优化!! (不是优化的问题)
		怀疑是中断向量没有拷贝到位!!即使 __iar_data_init3 的问题!!,然而ucos的ddram例子可以好好工作!!
		(未完搁置)
	同样的代码,gnu编译成功,iar却出现这样难缠的问题.
		所以还是搁置了,直接把代码移植到ucos()
		原来我换 ddram.icf的方法都是错的 !!!!
		同一个.ewp文件下,有不同的workbench,我应该选ddram的workbench,
		而不是在sram的workbench里, 直接换linker文件



移植uoos
ucos官网有直接针对a5d2的版本的包，直接下载，官网的构建是基于iar7.7的，但是我们使用iar7.1可以打开
iar打开 ～～/OS3/iar/OS3.eww
project->options:
	general options: target-devices ATSAMA5d27, target-FPU(VFPUv4),
	output convert: 选择输出bin文件
	linker：选择 ucos代码包自带的 sram.icf
重点： 一定要勾上 FPU ，即使用VFP硬件浮点运算模块，不然，编译过程中*.s文件会说没有找到FPEXC
编译后，通过sam-ba3 命令烧录到 spiflash：
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c erase
	sudo sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c writeboot:OS3.bin
成功运行，演示中只有，灯在闪，没有debug串口输出！！
移植到ddram上工作:
	ucos源码有两套启动方案:
		方案1:BSP/IAR:cstartup.s和sram.icf
		方案2:BSP/Atmel/target/sama5d2/toolchain/iar: cstartup和sram.icf,ddram.icf
	注意方案要配合使用,不能交叉使用
	使用方案2 cstartup.s + ddram.icf  配合 之前gnu编写的bootstrap 成功把ucos放在ddram上启动!!
	
补充:
/* ASSIC码对照表*/
ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符
0 	NUT 	32 	(space) 	64 	@ 	96 	、
1 	SOH 	33 	！ 	65 	A 	97 	a
2 	STX 	34 	” 	66 	B 	98 	b
3 	ETX 	35 	# 	67 	C 	99 	c
4 	EOT 	36 	$ 	68 	D 	100 	d
5 	ENQ 	37 	% 	69 	E 	101 	e
6 	ACK 	38 	& 	70 	F 	102 	f
7 	BEL 	39 	, 	71 	G 	103 	g
8 	BS 	40 	( 	72 	H 	104 	h
9 	HT 	41 	) 	73 	I 	105 	i
10 	LF 	42 	* 	74 	J 	106 	j
11 	VT 	43 	+ 	75 	K 	107 	k
12 	FF 	44 	, 	76 	L 	108 	l
13 	CR 	45 	- 	77 	M 	109 	m
14 	SO 	46 	. 	78 	N 	110 	n
15 	SI 	47 	/ 	79 	O 	111 	o
16 	DLE 	48 	0 	80 	P 	112 	p
17 	DCI 	49 	1 	81 	Q 	113 	q
18 	DC2 	50 	2 	82 	R 	114 	r
19 	DC3 	51 	3 	83 	S 	115 	s
20 	DC4 	52 	4 	84 	T 	116 	t
21 	NAK 	53 	5 	85 	U 	117 	u
22 	SYN 	54 	6 	86 	V 	118 	v
23 	TB 	55 	7 	87 	W 	119 	w
24 	CAN 	56 	8 	88 	X 	120 	x
25 	EM 	57 	9 	89 	Y 	121 	y
26 	SUB 	58 	: 	90 	Z 	122 	z
27 	ESC 	59 	; 	91 	[ 	123 	{
28 	FS 	60 	< 	92 	\ 	124 	|
29 	GS 	61 	= 	93 	] 	125 	}
30 	RS 	62 	> 	94 	^ 	126 	~
31 	US 	63 	? 	95 	— 	127 	DEL

NUL 		VT 垂直制表 	SYN 空转同步
SOH 标题开始 	FF   走纸控制 	ETB 信息组传送结束
STX 正文开始 	CR   回车 	CAN 作废
ETX 正文结束 	SO   移位输出 	EM   纸尽
EOY 传输结束 	SI    移位输入 	SUB 换置
ENQ 询问字符 	DLE 空格 	ESC 换码
ACK 承认 	DC1 设备控制1 	FS   文字分隔符
BEL 报警 	DC2 设备控制2 	GS   组分隔符
BS   退一格 	DC3 设备控制3 	RS   记录分隔符
HT   横向列表 	DC4 设备控制4 	US   单元分隔符
LF   换行 	NAK 否定 	DEL 删除

键盘常用ASCII码
ESC键 		VK_ESCAPE (27)		回车键： 	VK_RETURN (13)
TAB键： 	VK_TAB (9)		Caps Lock键： 	VK_CAPITAL (20)
Shift键： 	VK_SHIFT ($10)		Ctrl键： 	VK_CONTROL (17)
Alt键： 	VK_MENU (18)		空格键： 	VK_SPACE ($20/32)
退格键： 	VK_BACK (8)		左徽标键： 	VK_LWIN (91)
右徽标键： 	VK_LWIN (92)		鼠标右键快捷键： VK_APPS (93)
Insert键： 	VK_INSERT (45)		Home键： 	VK_HOME (36)
Page Up： 	VK_PRIOR (33)		PageDown： 	VK_NEXT (34)
End键： 	VK_END (35)		Delete键： 	VK_DELETE (46)
方向键(←)： 	VK_LEFT (37)		方向键(↑)： 	VK_UP (38)
方向键(→)： 	VK_RIGHT (39)		方向键(↓)： 	VK_DOWN (40)
F1键： 		VK_F1 (112)		F2键： 		VK_F2 (113)
F3键： 		VK_F3 (114)		F4键： 		VK_F4 (115)
F5键： 		VK_F5 (116)		F6键： 		VK_F6 (117)
F7键： 		VK_F7 (118)		F8键： 		VK_F8 (119)
F9键： 		VK_F9 (120)		F10键： 	VK_F10 (121)
F11键： 	VK_F11 (122)		F12键： 	VK_F12 (123)
Num Lock键： 	VK_NUMLOCK (144)	小键盘0： 	VK_NUMPAD0 (96)
小键盘1： 	VK_NUMPAD0 (97)		小键盘2： 	VK_NUMPAD0 (98)
小键盘3： 	VK_NUMPAD0 (99)		小键盘4： 	VK_NUMPAD0 (100)
小键盘5： 	VK_NUMPAD0 (101)	小键盘6： 	VK_NUMPAD0 (102)
小键盘7： 	VK_NUMPAD0 (103)	小键盘8： 	VK_NUMPAD0 (104)
小键盘9： 	VK_NUMPAD0 (105)	小键盘.： 	VK_DECIMAL (110)
小键盘*： 	VK_MULTIPLY (106)	小键盘+： 	VK_MULTIPLY (107)
小键盘-： 	VK_SUBTRACT (109)	小键盘/： 	VK_DIVIDE (111)
Pause Break键： VK_PAUSE (19)		Scroll Lock键： VK_SCROLL (145)
/* ASSIC码对照表*/	






	

	






20180320
ucos u盘移植!
建立printf调试环境!!
	方案1:BSP/IAR:cstartup.s和sram.icf 下调试
	旧版atmel库,board_cfg_console 在 board_support:
	a5d2-xpl的 debug串口参数:
/* =================== PIN CONSOLE definition ================== */

/** CONSOLE pin definition: use UART1 IOSET1 */
/* Note that these definitions could be omitted if the console is configured in
 * the active boot config word. */
#define BOARD_CONSOLE_PINS     PINS_UART1_IOS1
#define BOARD_CONSOLE_ADDR     UART1
#define BOARD_CONSOLE_BAUDRATE 115200
	只需要 board_cfg_console 初始化,会链接到 console.c 最后链接到debug串口,完成一系列初始化,
	但是不知道为啥,printf会死机!
	由于张工提供的源码也是基于旧版旧版atmel库!!,从张工usbhost例子中回溯最终找到原因:
	除了board_cfg_console, 还有修改有关printf的重定位链接信息:
		project_option->general_options->library_configuration->library_low_level interface:none
		而不是 semohosted
		项目util中添加:自带的 syscalls.c
	printf重定位事情非常难搞,几乎不同芯片,对应的改法都不一样,引起重视
	另外:ucos没有做 board_cfg_console(0);所以printf不起作用,所以,在main函数开始初始化时要加上!!
project里driver树下的文件是芯片的外围设备的驱动文件,这个不需要为了简化项目而去掉不用的驱动,
	因为编译时,如果不需要不会链接到执行bin文件去
	而且相对用户编写的执行程序独立,用户只管调用合适函数就好了
移植到 ddram, 实现printf 
	方案2:BSP/Atmel/target/sama5d2/toolchain/iar: cstartup和sram.icf,ddram.icf
	以上情况下只转变linker文件ddram.icf,出现printf死机问题!!
	即:
		library_low_level interface:none + utils/syscalls.c + printf 死机
		library_low_level interface:none + utils/syscalls.c  闪灯
		library_low_level interface:semohosted + utils/syscalls.c  闪灯 
		library_low_level interface:semohosted + utils/syscalls.c + printf  成功通过!!
	把成功设置启发 usb_host移植ddram上,却是又失败了!
	连v2.12这样设置,也不能工作!!
	不管这些代码了!!
继续在ddram上移植 usb_host
	把main对应代码拷到 对应app.c:main对应位置上去,
	在app.c添加对应外部函数声明!!
	在app.c添加对应include
	把lib/usb_host文件夹的所有文件拷到 BSP/USB_HOST
	在BSP/USB_HOST 添加yf.c 把张工补写的代码放入!!,并在yf.h添加声明
	调试:
	出现TDS NOT aligned!!:
		usb_ohci.h: td_t gtd[NUM_TD+1] 前加 #pragma data_alignment=32
	在usb_ohci.c:hc_reset -> readl处死机了,在 (*((u32*)(0x400004))) 这种算法下死机!!
	正确是一旦读取 usb 寄存器 的时候就死机!!!,表明usb的硬件可能没电,未正确初始化
	找到了,的确是pmc的问题,对应的usb_host时钟没有开
	原因在于,ucos的atmel库与张工的库不一样,即 pmc.c和pmc.h不一样!!!
	在ohci_hcd.c:pmc_enable_system_clock(2)改为pmc_enable_system_clock(PMC_SYSTEM_CLOCK_UHP)
	因为这个枚举量的PMC_SYSTEM_CLOCK_UHP 位置变了不是2,是4
继续调试:
	usb_stor_info();有问题!!
	file_detectfs();有问题,最后发现是 part.c 的 puts()出问题,诱发了 Software interrupt 错误
	涉及puts的重定向问题!!
	看来要好好学习 puts 和 printf 的重定向问题!!!
	暂时,在yf.c加入了 #include<stdio.h>和 重写了无内容的puts()
	找不到 FAT fs !! : read_bootsectandvi()出错
	回溯 看看是哪些地方存储了 u盘信息:
		cur_dev
		cur_dev -> blockread: 把cur-dev指向的第0个block(startblock)的内容拷贝到 boot_sector *bs
		但是读出来的数据是错的??
		换成nfs系统也是错??
		怀疑存储boot_sector信息的不在block0
	其实从fat_register_device()开始,就出错了!!
	重新梳理
	usb_host应该是挂载成功了,
	part.h: block_dev_desc_t :usb_sev_desc 是usb块设备的描述结构!!
		usb_start() 里执行的usb_stor_scan已经成功读出!
	因此 usb_stor_info()可以从 usb_sev_desc 成功读出相关信息:
		Device 0: Vendor: SMI      Rev: 1100 Prod: USB DISK        
            	Capacity: 7800.0 MB = 7.6 GB (15974400 x 512)
	main函数的stor_dev就是指usb_sev_desc
	其中usb_sev_desc 有两个io接口函数,用于读写u盘物理block!!
		usb_dev_desc.block_read=usb_stor_read;  lib/usb_host/usb_storage.c:236
		block_write,未定义,功能未实现!!
	至此,usb块设备全部初始化完毕!!
	也就说,开发板到u盘的硬件通路及驱动全部打通,接下来应该就剩下建立在这之上的fatfs文件系统!!
	现在是对比 bootsector 里是内容 看看是 block_read 有问题,还是代码有问题!!
Fat32 的bootsector 一般放在 flash的第一个512字节的 block!
	FAT32 Boot Record Information
	This information is located in the first sector of every partition.
	Offset 	Description 							Size
	00h 	Jump Code + NOP 						3 Bytes
	03h 	OEM Name (Probably MSWIN4.1) 					8 Bytes
	0Bh 	Bytes Per Sector 						1 Word
	0Dh 	Sectors Per Cluster 						1 Byte
	0Eh 	Reserved Sectors 						1 Word
	10h 	Number of Copies of FAT 					1 Byte
	11h 	Maximum Root DirectoryEntries (N/A for FAT32) 			1 Word
	13h 	Number of Sectors inPartition Smaller than 32MB (N/A for FAT32) 1 Word
	15h 	Media Descriptor (F8h forHard Disks) 				1 Byte
	16h 	Sectors Per FAT in Older FATSystems (N/A for FAT32) 		1 Word
	18h 	Sectors Per Track 						1 Word
	1Ah 	Number of Heads 						1 Word
	1Ch 	Number of Hidden Sectors inPartition 				1 Double Word
	20h 	Number of Sectors inPartition 					1 Double Word
	24h 	Number of Sectors Per FAT 					1 Double Word
	28h 	Flags (Bits 0-4 IndicateActive FAT Copy) 
	        (Bit 7 Indicates whether FAT Mirroringis Enabled or Disabled ) 
	        (If FATMirroring is Disabled, the FAT Information 
	        is onlywritten to the copy indicated by bits 0-4) 		1 Word
	2Ah 	Version of FAT32 Drive (HighByte = Major Version, 
	        Low Byte = Minor Version) 					1 Word
	2Ch 	Cluster Number of the Startof the Root Directory 		1 Double Word
	30h 	Sector Number of the FileSystem Information Sector (See 
	        Structure Below)(Referenced from the Start of the Partition) 	1 Word
	32h 	Sector Number of the BackupBoot Sector 
	        (Referenced from the Start of the Partition) 			1 Word
	34h 	Reserved 							12 Bytes
	40h 	Logical Drive Number ofPartition 				1 Byte
	41h 	Unused (Could be High Byteof Previous Entry) 			1 Byte
	42h 	Extended Signature (29h) 					1 Byte
	43h 	Serial Number of Partition 					1 Double Word
	47h 	Volume Name of Partition 					11 Bytes
	52h 	FAT Name (FAT32) 						8 Bytes
	5Ah 	Executable Code 						420 Bytes
	1FEh 	Boot Record Signature (55hAAh) 					2 Bytes
对应fat.h的结构体!!
	typedef struct boot_sector {    //0x0地址开始
	__u8	ignored[3];	/* Bootstrap code */
	char	system_id[8];	/* Name of fs */
	__u8	sector_size[2];	/* Bytes/sector */
	__u8	cluster_size;	/* Sectors/cluster */
	__u16	reserved;	/* Number of reserved sectors */
	__u8	fats;		/* Number of FATs */
	__u8	dir_entries[2];	/* Number of root directory entries */
	__u8	sectors[2];	/* Number of sectors */
	__u8	media;		/* Media code */
	__u16	fat_length;	/* Sectors/FAT */
	__u16	secs_track;	/* Sectors/track */
	__u16	heads;		/* Number of heads */
	__u32	hidden;		/* Number of hidden sectors */
	__u32	total_sect;	/* Number of sectors (if sectors == 0) */

	/* FAT32 only */
	__u32	fat32_length;	/* Sectors/FAT */
	__u16	flags;		/* Bit 8: fat mirroring, low 4: active fat */
	__u8	version[2];	/* Filesystem version */
	__u32	root_cluster;	/* First cluster in root directory */
	__u16	info_sector;	/* Filesystem info sector */
	__u16	backup_boot;	/* Backup boot sector */
	__u16	reserved2[6];	/* Unused */
} boot_sector;

typedef struct volume_info		// 0x40 地址开始
{
	__u8 drive_number;	/* BIOS drive number */
	__u8 reserved;		/* Unused */
	__u8 ext_boot_sign;	/* 0x29 if fields below exist (DOS 3.3+) */
	__u8 volume_id[4];	/* Volume ID number */
	char volume_label[11];	/* Volume label */
	char fs_type[8];	/* Typically FAT12, FAT16, or FAT32 */
	/* Boot code comes next, all but 2 bytes to fill up sector */
	/* Boot sign comes last, 2 bytes */
} volume_info;


	跳过file_detectfs() -> read_bootsectandvi修改其识别成功!!,强制认为fat32, printf_26后直接return
	严重出错!! 改回来
	既然u盘的读写桥梁已经搭好,那么先检查 block_read 有没有出错!!
	开发板打印 block_read 读取第0个block的(fat bootsector) 的所有信息:
		FA 31 C0 8E D8 8E C0 8E D0 BC 00 7C FB FC 89 E6 
		BF 00 06 B9 00 01 F3 A5 EA DC 06 00 00 10 00 01 
		00 00 7C 00 00 00 00 00 00 00 00 00 00 80 3F 00 
		FF 00 E2 03 1E 0E 1F 3A 16 10 00 74 06 1F EA 36 
		E7 00 F0 3D FB 54 75 05 8C D8 FB EB 1D 80 FC 08 
		75 1B E8 81 00 8A 36 13 00 FE CE 8B 0E 15 00 86 
		CD C0 E1 06 0A 0E 11 00 31 C0 F8 EB 65 80 FC 02 
		72 CB 80 FC 04 77 C6 60 80 CC 40 50 BE 00 00 C7 
		04 10 00 30 E4 89 44 02 89 5C 04 8C 44 06 66 31 
		C0 66 89 44 0C 88 F0 F6 26 11 00 88 CF 88 EB C0 
		EF 06 81 E1 3F 00 01 C8 48 89 C7 A1 13 00 F7 26 
		11 00 F7 E3 01 F8 81 D2 00 00 89 44 08 89 54 0A 
		58 30 C0 8A 16 10 00 E8 0C 00 88 26 03 00 61 A1 
		02 00 1F CA 02 00 9C FF 1E 22 00 C3 80 FA 8F 7F 
		04 88 16 2D 06 BE 87 07 E8 8D 00 BE BE 07 31 C0
		B9 04 00 F6 04 80 74 03 40 89 F5 81 C6 10 00 E2 
		F2 48 74 02 CD 18 BF 05 00 BE 1D 06 C7 44 02 01 
		00 66 8B 46 08 66 89 44 08 B8 00 42 8A 16 2D 06 
		CD 13 73 0D 4F 74 49 30 E4 8A 16 2D 06 CD 13 EB 
		D8 A1 FE 7D 3D 55 AA 75 37 FA 66 A1 4C 00 66 A3 
		3F 06 BE 13 04 8B 04 48 89 04 C1 E0 06 8E C0 31 
		FF BE 1D 06 B9 60 00 FC F3 A5 C7 06 4C 00 17 00 
		A3 4E 00 FB 8A 16 2D 06 89 EE FA EA 00 7C 00 00 
		BE AA 07 E8 02 00 EB FE AC 20 C0 74 09 B4 0E BB 
		07 00 CD 10 EB F2 C3 53 74 61 72 74 20 62 6F 6F 
		74 69 6E 67 20 66 72 6F 6D 20 55 53 42 20 64 65 
		76 69 63 65 2E 2E 2E 0D 0A 00 42 6F 6F 74 20 66 
		61 69 6C 65 64 00 00 00 EA EB D4 CA 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 04 
		05 00 0B FE FF E1 00 01 00 00 00 BF F3 00 55 AA 
	u盘插入ubuntu,命令: dd if=/dev/sdb of=./bootsector1 count=1 bs=512 //读出一个block,block大小512字节,默认从第0个开始读取
	读出u盘block0 的信息到bootsector1这个文件!!
	用wxmedit 16进制格式的读出bootsector1这个文件!!
	比较 发现读出数据都是一样的,所以,block_read 并没有出错!
	那剩下的问题就是 u盘的 bootsector 信息不标准导致,简单的fatfs 无法识别!!!
	不,u盘插入u插入ubuntu 检查到u盘有分区,sdb 被分了个sdb4!!
	dd if=/dev/sdb4 of=./bootsector2 count=1 bs=512,打开ootsector2,发现这个才是fat32的bootsector
	那么这个block在哪:
	sudo fdisk -l /dev/sdb
		Disk /dev/sdb: 8178 MB, 8178892800 bytes
		255 heads, 63 sectors/track, 994 cylinders, total 15974400 sectors
		Units = sectors of 1 * 512 = 512 bytes
		Sector size (logical/physical): 512 bytes / 512 bytes
		I/O size (minimum/optimal): 512 bytes / 512 bytes
		Disk identifier: 0xcad4ebea
		
		   Device Boot      Start         End      Blocks   Id  System
		/dev/sdb4   *         256    15974399     7987072    b  W95 FAT32
	在第256个block上
	即 dd if=/dev/sdb4 of=./bootsector2 count=1 bs=512 等于
	   dd if=/dev/sdb of=./bootsector2 skip=256 count=1 bs=512 //跳过前面256个block,从第256个block开始读入
		EB 58 90 4D 53 44 4F 53 35 2E 30 00 02 08 60 06 
		02 00 00 00 00 F8 00 00 3F 00 FF 00 00 01 00 00 
		00 BF F3 00 D0 3C 00 00 00 00 00 00 02 00 00 00 
		01 00 06 00 00 00 00 00 00 00 00 00 00 00 00 00 
		80 01 29 A6 BF 9E 0A 4E 4F 20 4E 41 4D 45 20 20 
		20 20 46 41 54 33 32 20 20 20 33 C9 8E D1 BC F4 
		7B 8E C1 8E D9 BD 00 7C 88 4E 02 8A 56 40 B4 41 
		BB AA 55 CD 13 72 10 81 FB 55 AA 75 0A F6 C1 01 
		74 05 FE 46 02 EB 2D 8A 56 40 B4 08 CD 13 73 05 
		B9 FF FF 8A F1 66 0F B6 C6 40 66 0F B6 D1 80 E2 
		3F F7 E2 86 CD C0 ED 06 41 66 0F B7 C9 66 F7 E1 
		66 89 46 F8 83 7E 16 00 75 38 83 7E 2A 00 77 32 
		66 8B 46 1C 66 83 C0 0C BB 00 80 B9 01 00 E8 2B 
		00 E9 2C 03 A0 FA 7D B4 7D 8B F0 AC 84 C0 74 17 
		3C FF 74 09 B4 0E BB 07 00 CD 10 EB EE A0 FB 7D 
		EB E5 A0 F9 7D EB E0 98 CD 16 CD 19 66 60 80 7E 
		02 00 0F 84 20 00 66 6A 00 66 50 06 53 66 68 10 
		00 01 00 B4 42 8A 56 40 8B F4 CD 13 66 58 66 58 
		66 58 66 58 EB 33 66 3B 46 F8 72 03 F9 EB 2A 66 
		33 D2 66 0F B7 4E 18 66 F7 F1 FE C2 8A CA 66 8B 
		D0 66 C1 EA 10 F7 76 1A 86 D6 8A 56 40 8A E8 C0 
		E4 06 0A CC B8 01 02 CD 13 66 61 0F 82 75 FF 81 
		C3 00 02 66 40 49 75 94 C3 42 4F 4F 54 4D 47 52 
		20 20 20 20 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 0D 0A 52 65 
		6D 6F 76 65 20 64 69 73 6B 73 20 6F 72 20 6F 74 
		68 65 72 20 6D 65 64 69 61 2E FF 0D 0A 44 69 73 
		6B 20 65 72 72 6F 72 FF 0D 0A 50 72 65 73 73 20 
		61 6E 79 20 6B 65 79 20 74 6F 20 72 65 73 74 61 
		72 74 0D 0A 00 00 00 00 00 AC CB D8 00 00 55 AA 
	然后把block_read 第0个block的 都改为第256个! 就好了
	最好的办法是在 fat.h 添加 宏 #defing BOOT_SECTOR_LLOCATION 256
	然后把block_read为0的都改为 BOOT_SECTOR_LLOCATION
	fat_register_device()内容读取 boot_sector,然后读出partition 信息
		我们的 
		fat_register_device() 跑到 get_partition_info,然后根据设定 CONFIG_DOS_PARTITION
		跑到part_dos.c:get_partition_info_dos会执行block_read 第 0 block的操作
		改回 BOOT_SECTOR_LLOCATION


	最终fat32像是挂载成功了,开始调试读写文件 
	file_fat_read()->do_fat_read()
	发现 bootsector 获取不完整!!
	发现 read_bootsectandvi -> disk_read -> block_read:前 16个字节获取错误!!!!!
	直接调用  block_read 反而没事???
	发现对fat32不了解无法进一步调试:先学习fat32格式!!!

FAT32: http://www.cnblogs.com/fantacity/p/3895771.html
	磁盘介质一般以扇区为单位进行读写,读写字节数必须是512的倍数,即 1block=1扇区=512bytes
	分析引导区,一般是第0个block,而我们的u盘却做了分区,fat32的bootsector在第256个block
	FAT32文件系统硬盘分布:
			引导区 （BOOT区）、
			保留扇区
			文件分配表区（FAT区）: FAT1,FAT2
			数据区（DATA区）
	引导扇区后面紧跟这若干保留扇区,保留扇区的后面紧跟着的是FAT1和FAT2。
	FAT1表的起始地址并不是（引导扇区+保留扇区）*扇区字节数,注意:保留扇区数这个参数其实包含了引导扇区，
	所以计算FAT1表位置的时候直接通过保留扇区数这个参数来计算偏移。
	这一点需要特别注意(有的文献说包含,有的又说不包含!!!,注意实际验证)
	文件所占用的存储空间（簇链）及空闲空间的管理都是通过FAT实现的，
	FAT1,FAT2是相同的两个文件分配表.因为FAT重要，保存两个以便第一个损坏时，还有第二个可用

引导区 （BOOT区/bootsector）
读出的bootsector数据是:
struct boot_sector {    //0x0地址开始
	__u8	ignored[3];	/* Bootstrap code */			eb 58 90	
		//最开始3字节分别是跳转指令与空指令，因为在汇编当中0xEB是跳转指令，0x58是跳转的地址，而0x90则是空指令
		//为什么要在这里放上一句跳转指令:
		//	一般第一个扇区叫做启动区，cpu把扇区当中的数据当作指令来执行，
		//	当读取到EB 58 这个指令时，遍跳转到0x58这个地址并继续读取指令来执行，
		//	而0x58地址之后的内容通常都是载入操作系统的指令。
		//	详情参考《30天自制操作系统》这本书，第一天结尾部分有很详细的说明。
		//	总之FAT32规定这3字节的内容必须是 EB 58 90 对应汇编代码即为JUMP 0x58; NOP;)	
	char	system_id[8];	/* Name of fs */			4D 53 44 4F 53 35 2E 30 = MSDOS5.0
		//0x03~0x0A这8个字节的数据表示OEM，这里即为“MSDOS5.0”。
	__u8	sector_size[2];	/* Bytes/sector */			0x200
		//从0x000B开始的79个字节的数据叫做BPB（BIOS Paramter Block）,即至到包含全部volume_info内容
		//每扇区字数 0x200 即 512 bytes
	__u8	cluster_size;	/* Sectors/cluster */			0x8
		//每簇扇区数 0x8
	__u16	reserved;	/* Number of reserved sectors */	0x660
		//保留扇区数 0x660
	__u8	fats;		/* Number of FATs */			0x2
		//文件分配表 FAT 个数 0x2
	__u8	dir_entries[2];	/* Number of root directory entries */  0
		//根目录项数，FAT32因为突破该限制，所以弃用,为0 
	__u8	sectors[2];	/* Number of sectors */			0
		//扇区总数，硬盘空间小于32M使用,所以弃用,为0
	__u8	media;		/* Media code */			0xf8
		//存储介质描述符 0xf8 (默认)
	__u16	fat_length;	/* Sectors/FAT */			0
		//每FAT表占用扇区数，硬盘空间小于32M使用,所以弃用,为0 
	__u16	secs_track;	/* Sectors/track */			0x3f
		//逻辑每磁道扇区数 0x3f (默认,兼容磁道硬盘和flash介质)
	__u16	heads;		/* Number of heads */			0xff
		//逻辑磁头数 0xff (默认,兼容磁道硬盘和flash介质)
	__u32	hidden;		/* Number of hidden sectors */		0x100
		//系统隐含扇区数 0x100
	__u32	total_sect;	/* Number of sectors (if sectors == 0) */ 0xf3bf00
		//扇区总数，硬盘空间大于32M使用, 0xf3bf00
		//这里是整个磁盘的总扇区数,不只是data区, 
		//这里我的u盘,FAT32分区的前有256个扇区,未知是否包括!!
		//如果包括: U盘容量 = data区容量
		//	= ( 总扇区数 - 保留扇区数 - FAT32分区的前256个扇区 - FAT表扇区数 * FAT表个数 ) * 512 B
	/* FAT32 only */
	__u32	fat32_length;	/* Sectors/FAT */			0x3cd0
		//每FAT表扇区数，硬盘空间大于32M使用 
	__u16	flags;		/* Bit 8: fat mirroring, low 4: active fat */  0
		//标记 0
	__u8	version[2];	/* Filesystem version */		0
		//版本 (通常为零)
	__u32	root_cluster;	/* First cluster in root directory */	0x2
		//根目录起始簇 0x2
	__u16	info_sector;	/* Filesystem info sector */		0x1
		//bootsector占用扇区数  0x1
	__u16	backup_boot;	/* Backup boot sector */		0x6
		//备份引导扇区位置 0x6
	__u16	reserved2[6];	/* Unused */				0
		//保留 14个字节的0x00 
} boot_sector;		
typedef struct volume_info		// 0x40 地址开始
{
	__u8 drive_number;	/* BIOS drive number */			0x80
	__u8 reserved;		/* Unused */				0x1
	__u8 ext_boot_sign;	/* 0x29 if fields below exist (DOS 3.3+) */ 0x29
		//扩展引导标记 0x29 (默认)
	__u8 volume_id[4];	/* Volume ID number */			A6 BF 9E 0A = ~id[0],~id[1],~id[2],~id[3]
		//序列号: 0x0A9ebfa6
	char volume_label[11];	/* Volume label */			4E 4F 20 4E 41 4D 45 20 20 20 20 = NO NAME空格4个
		//卷标 NO NAME
	char fs_type[8];	/* Typically FAT12, FAT16, or FAT32 */  46 41 54 33 32 20 20 20 = FAT32空格3个
		//文件系统标识: FAT32		
	/* Boot code comes next, all but 2 bytes to fill up sector */
	/* Boot sign comes last, 2 bytes */
} volume_info;

FAT表:
	FAT1表偏移 = 保留扇区数 * 每扇区字节数	
	FAT2表的偏移 = FAT1+FAT表的大小 = (保留扇区数 + FAT表扇区数) * 每扇区字节数
		//如果是我的u盘,可能扇区数都要 + FAT32分区的前256个扇区
	FAT表即文件分配表(File Allocation Table)。
	FAT32文件表是由一个个32位表项组成的一张表，
	每一表项表示数据区的对应的一个族,的当前状态!!
	每个族有0x8个扇区,即每族 4kb
	一个FAT表有  (0x3cd0 * 512) / 4 
		   = (7970816 bytes) / 4
		   = 1992704 项
	表项值填写规则:
			表项数值 		对应含义
			0x00000000  		空闲簇,即表示可用
			0x00000001 		保留簇,即表示这个族被保留不可用,
			0x00000002 - 0x0FFFFFEF 族标,文件占用的data区数据族,对应的fat表,表项号
						表项里填这填这些值,表示文件接下来占用的fat表表项和对应的data区数据族
			0x0FFFFFF0 - 0x0FFFFFF6 保留值,即表示这些表项值不会填写到表项里,
			0x0FFFFFF7  		坏簇,即表示当前族是物理坏道,不可用
			0x0FFFFFF8 - 0x0FFFFFFF 文件最后一个簇,即表示个族是文件的占用的最后一个族空间
	FAT表第0项(32位offet地址:0x00000000~0x00000003): 表项值 0x0FFFFF8
	FAT表第1项(32位offet地址:0x00000004~0x00000007): 表项值 0xFFFFFFFF
		这两项不代表任何簇的使用情况，是FAT表的表头，表征了介质描述，是固定值，
		对应0x00和0x01这两个簇号是不用的，簇号的下标从2开始。
		也就是,data区开始的第0个族,标号为 2 !!!
		补充:FAT表第1项1表项可能被用于记录脏标志，以说明文件系统没有被正常卸载或者磁盘表面存在错误。
       	FAT表第2项(32位offet地址:0x00000008~0x0000000B): 表项值0x3
       	FAT表第3项(32位offet地址:0x0000000c~0x0000000f): 表项值0x0FFFFFFF
		FAT表第2项代表数据区第0族,开始存放数据的族,通常第0簇存储的是文件系统的根目录
		FAT表第2项值为0x0c ，表示根目录的数据内容还占据着FAT表第3项,即打他区的第1族
		FAT表第3项值为0x0FFFFFFF,文件占的最后一个族,可看到 根目录占用且占用了2个簇。
		虽然在FAT32文件系统中，根目录的位置不再硬性地固定，可以存储在分区内可寻址的任意簇内，
		不过通常根目录是最早建立的(格式化就生成了)目录表。
		所以，我们看到的情况基本上都是根目录首簇紧邻数据区的第0族，
		同时，FAT32文件系统将根目录当做普通的数据文件来看，
		所有没有了目录项数的限制，在需要的时候可以分配空簇，存储更多的目录项
	例子:aa.c文件占18kb,数据分布在 数据区的第 8,10,5,6 个族上面,对应的FAT表的内容是
	FAT表第10项(32位offet地址:0x00000028~0x0000002b): 表项值 0x12	//指向 FAT表第12项,即data区第10族
	FAT表第12项(32位offet地址:0x00000030~0x00000034): 表项值 0x7	//指向 FAT表第7项,即data区第5族
	FAT表第7项(32位offet地址:0x0000001c~0x0000001f): 表项值 0x8	//指向 FAT表第8项,即data区第6族
	FAT表第8项(32位offet地址:0x00000020~0x00000023): 表项值 0x0FFFFFFF //表示文件的结束!!
data区:
	由于根目录是可以在 数据区 任意族位置,而 实际数据区 是从 根目录 开始的!!
	而且 FAT表第2项 对应记录数据区的第0族位置,即表项号永远比对应的data区族号多2,
	data区数据真正开始的地方从根目录的位置开始!!!,
	起始簇标 = 根目录开始data区的族,对应的fat表表项号
	所以:
	实际数据区偏移 = 根目录位置
		  = (保留扇区数 +  FAT表扇区数 * FAT表个数(通常为2) + (起始簇号-2) * 每簇扇区数) * 每扇区字节数
	我们给u盘的修写的卷标,实际上不是 改写 volume_info ->volume_label "NO NAME"
	而是放在的 实际数据区开始 offet(0x00~0x0A)11个字节的地方,即一般都是写在根目录的下的
	规定是:根目录/实际数据区开始offet(0x0b)处的值为0x08,那么读取该项的前11个字节为卷标		
	目录数据区:
		也是以表的形式存放目录项数据,例如根目录区就是一个根目录表!
		目录表中每一个目录项占用32个字节,指向一个文件或者另一个目录.
	短文件名目录项:
		文件名短的文件/目录使用的目录项,只使用一个 32字节目录项
		offset		bytes	definition
		0x0-0x7 	8	文件名
		0x8-0xa 	3	扩展名
		0xb		1	00000000(读写)
					00000001(只读)
					00000010(隐藏)
					00000100(系统)
					00001000(卷标)
					00010000(子目录)
					00100000(归档)
		0xc		1	保留
		0xd		1	创建时间的10毫秒位
		0xe-0xf		2	创建时间 (高5位代表小时,次6位代表分钟,低5位值*2表示秒)
		0x10-0x11	2	创建日期 (这里高7位值+1980表示年,次4位代表月份,低5位代表日期)
		0x12-0x13	2	最后访问日期
		0x14-0x15	2	文件起始起始簇标 的(data区所在的族号码 + 2)高16位
		0x16-0x17	2	文件最近修改时间
		0x18-0x19	2	文件最近修改日期
		0x1A-0x1b	2	文件起始起始簇标 的低16位
		0x1c-0xaf	4	文件长度(bytes)
		文件起始地址 = (保留扇区数 + FAT表扇区数 * FAT表个数(2) + (文件起始簇标-2)
				*每簇扇区数)*每扇区字节数
	长文件名目录项:
		文件名长的文件/目录使用的目录项, 使用多个 32字节目录项组合而成!!
		前面多个 32字节目录项,都是用来存文件名的名字目录项,每个均有存储13个unicode编码的字符的能力
		最后紧跟一个 文件属性目录项.
		每个分别存长文件名的一部分,倒序存放.例如名字为"LongLengthFilenameTest"的文件(注意没有写扩展名)	
		第一个 32字节目录项 存放 最后的 enameTest
		第二个 32字节目录项 存放 13个字符 LongLengthFil
		然后紧接着的第三个 32字节目录项 是这个长文件名文件 对应的 文件属性目录项:
			这个文件属性目录项 与 短文件名目录项 结构一样,只是 文件名和扩张名区域有所规定
			文件名区 取长文件名的 前6个字符转大写再转acsii编码得到的6个字符加上"~1"形成短文件名，扩展名不变
			如果已存在这个文件名，则符号"~"后的数字递增，直到5
			32字节目录项 0xb字节的值，如果为0x0F,系统认为这是 名字目录项,
			否则,系统认为这是 文件属性目录项 或者 短文件名目录项
			0xb字节本来设计存放属性的,文件属性目录项 或者 短文件名目录项,存放0xf会出错
			所以FAT32系统认为 0xb字节的值，如果为0x0F,系统认为这是 名字目录项,
		名字目录项:
		offset		bytes	definition
		0x0	 	1	位7 保留不使用
					位6 1表示这是长文件名文件 最后一个 名字目录项
					位5 保留不使用
					位0,1,2,3,4 顺序号,表示 第几个名字目录项,从1开始数,非从0数
		0x1-0xa 	10	unicode 编码的 5 个字符空间 (存放部分文件名) 
		0xb		1	值为:0xf 标记这是 名字目录项
		0xc		1	保留
		0xd		1	检验值 根据文件属性目录i项的文件名和扩张名区计算
		0xe-0x19	12	unicode 编码的 6 个字符空间 (存放部分文件名) 
		0x1a-0x1b	2	文件起始起始簇标的一部分,文件特别大才会使用到,常置零
		0x1c-0x1f	4	unicode 编码的 2 个字符空间 (存放部分文件名) 
	分析一个例子:
		文件名字为 "LongLengthFilenameTest"的文件,(没有扩展名)
		addr\offset  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f 	
		0x00000070   42 65 00 6e 00 61 00 6d 00 65 00 0f 00 1f 54 00	
		0x00000080   65 00 73 00 74 00 00 00 ff ff 00 00 ff ff ff ff	
		0x00000090   01 4c 00 6f 00 6e 00 67 00 4c 00 0f 00 1f 65 00
		0x000000a0   6e 00 67 00 74 00 68 00 46 00 00 00 69 00 6c 00
		0x000000b0   4c 4f 4e 47 4c 45 7e 31 20 20 20 10 00 7e db 76
		0x000000c0   08 45 08 45 00 00 dc 76 08 45 04 00 00 00 00 00
		地址		值 
				//第1个目录项
		0x70 		0x42 = (01000010)位6为1，说明是文件最后一个名字目录项目
						低5位为顺序 0010(2进制) = 2(10进制)，说明这是第2个名字目录项，
		0x71~0x7A  	65 00 6e 00 61 00 6d 00 65 00 10个字节的Unicode码  	
						即字符串”ename”
		0x7B 		0xf 标记这是 名字目录项	
		0x7C		系统保留 
		0x7d  		0x1f 校验值 
		0x7E~0x89  	54 00 65 00 73 00 74 00 00 00 ff ff 12字节Unicode
						即字符串"Test" 
		0x8a~0x8B  	00 00 文件起始起始簇标的一部分 这里是0, 
		0x8C~0x8F  	ff ff ff ff 4字节Unicode  这里没有字符了,全为ff	
				//第2个目录项
		0x90 		0x01 = (00000001)位6为0，说明不是文件最后一个名字目录项目
						低5位为顺序 00001(2进制) = 1(10进制)，说明这是第1个名字目录项，
		0x91~0x9A  	4c 00 6f 00 6e 00 67 00 4c 00 10个字节的Unicode码  	
						即字符串“LongL”
		0x9B 		0xf 标记这是 名字目录项	
		0x9C		系统保留 
		0x9d  		0x1f 校验值 
		0x9E~0xa9  	65 00 6e 00 67 00 74 00 68 00 46 00 12字节Unicode
						即字符串"engthF" 
		0xaa~0xaB  	00 00 文件起始起始簇标的一部分 这里是0, 
		0xaC~0xaF  	69 00 6c 00 4字节Unicode  即字符串"il"
			 	//第3个目录项	
		0xb0-0xb7 	4c 4f 4e 47 4c 45 7e 31	长文件名的 
						前6个字符转大写再转acsii编码得到的6个字符加上"~1"
						即字符串 "LONGLE~1"
		0xb8-0xba 	20 20 20 扩展名"三个空格",即没有扩展名 (没有扩展名,并一定就是目录,注意实际情况)
		0xbb		10 =	00010000(子目录),说明这是一个子目录,不是一个文件
						非0xf所以这个是文件属性目录项
		0xbc		1	保留
		0xbd		7e	创建时间的10毫秒位
		0xbe-0xbf	db 76	创建时间 
		0xc0-0xc1	08 45	创建日期 
		0xc2-0xc3	08 45	最后访问日期
		0xc4-0xc5	00 00 	文件起始起始簇标 高16位
		0xc6-0xc7	dc 76 	文件最近修改时间
		0xc8-0xc9	08 45 	文件最近修改日期
		0xcA-0xcb	04 00 	文件起始起始簇标 低16位
		0xcc-0xcf	00 00 00 00	文件长度(bytes),因为是目录所以并没有长度
		最后是校验码计算方法:
		int i, j = 0, chksum=0;
		for (i = 11; i > 0; i--)
		chksum = ((chksum & 1) ? 0x80 : 0) + (chksum >> 1) + shortname[j++];
		这里是把 文件属性目录项的文件名区(文件名+扩展名)算出校验码,
		再存到各个 名字目录项对应位置
FAT32主体学习到此结束!
重新分析u盘:
	0x0020000:(bootsector)
		EB 58 90 4D 53 44 4F 53 35 2E 30 00 02 08 60 06 
		02 00 00 00 00 F8 00 00 3F 00 FF 00 00 01 00 00 
		00 BF F3 00 D0 3C 00 00 00 00 00 00 02 00 00 00 
		01 00 06 00 00 00 00 00 00 00 00 00 00 00 00 00 
		80 01 29 A6 BF 9E 0A 4E 4F 20 4E 41 4D 45 20 20 
		20 20 46 41 54 33 32 20 20 20 33 C9 8E D1 BC F4 
		7B 8E C1 8E D9 BD 00 7C 88 4E 02 8A 56 40 B4 41 
		BB AA 55 CD 13 72 10 81 FB 55 AA 75 0A F6 C1 01 
		74 05 FE 46 02 EB 2D 8A 56 40 B4 08 CD 13 73 05 
		B9 FF FF 8A F1 66 0F B6 C6 40 66 0F B6 D1 80 E2 
		3F F7 E2 86 CD C0 ED 06 41 66 0F B7 C9 66 F7 E1 
		66 89 46 F8 83 7E 16 00 75 38 83 7E 2A 00 77 32 
		66 8B 46 1C 66 83 C0 0C BB 00 80 B9 01 00 E8 2B 
		00 E9 2C 03 A0 FA 7D B4 7D 8B F0 AC 84 C0 74 17 
		3C FF 74 09 B4 0E BB 07 00 CD 10 EB EE A0 FB 7D 
		EB E5 A0 F9 7D EB E0 98 CD 16 CD 19 66 60 80 7E 
		02 00 0F 84 20 00 66 6A 00 66 50 06 53 66 68 10 
		00 01 00 B4 42 8A 56 40 8B F4 CD 13 66 58 66 58 
		66 58 66 58 EB 33 66 3B 46 F8 72 03 F9 EB 2A 66 
		33 D2 66 0F B7 4E 18 66 F7 F1 FE C2 8A CA 66 8B 
		D0 66 C1 EA 10 F7 76 1A 86 D6 8A 56 40 8A E8 C0 
		E4 06 0A CC B8 01 02 CD 13 66 61 0F 82 75 FF 81 
		C3 00 02 66 40 49 75 94 C3 42 4F 4F 54 4D 47 52 
		20 20 20 20 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 0D 0A 52 65 
		6D 6F 76 65 20 64 69 73 6B 73 20 6F 72 20 6F 74 
		68 65 72 20 6D 65 64 69 61 2E FF 0D 0A 44 69 73 
		6B 20 65 72 72 6F 72 FF 0D 0A 50 72 65 73 73 20 
		61 6E 79 20 6B 65 79 20 74 6F 20 72 65 73 74 61 
		72 74 0D 0A 00 00 00 00 00 AC CB D8 00 00 55 AA 	
		.....
	0x1020000:(根目录)	
		44 44 20 20 20 20 20 20 20 20 20 08 00 00 00 00 
		00 00 00 00 00 00 E7 8C 76 4C 00 00 00 00 00 00 
		E5 B0 65 FA 5E 87 65 2C 67 87 65 0F 00 D2 63 68 
		2E 00 74 00 78 00 74 00 00 00 00 00 FF FF FF FF 
		E5 C2 BD A8 CE C4 7E 31 54 58 54 20 00 36 F2 8C 
		76 4C 76 4C 00 00 F3 8C 76 4C 00 00 00 00 00 00 
		41 42 43 20 20 20 20 20 54 58 54 20 18 36 F2 8C 
		76 4C 77 4C 00 00 FC 8C 76 4C 03 00 0C 00 00 00 
		...
	0x1021000:(abc.txt文件所在区域)
		69 20 61 6D 20 77 69 6C 6C 69 61 6D 00 00 00 00 
		00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
	从bootsector知道:
		保留区0x660个扇区(包含bootsector区)		
		每个fat表3cd0个扇区,两个fat表
		根目录族标 0x2,即对应data区第0个族(从0开始数)
		每个族4个扇区.
		但是注意,这些参数都是以 FAT32文件系统开始地址为0x0 时的参数,
		然而实际上FAT32放在偏移动256个block的位置上,
		所以所有真正位置都需要额外移动 256(0x100)个扇区!!
		所以,根目录位置:
		=(实际FAT偏移扇区+保留扇区数+FAT表扇区数*FAT表个数+(根目录起始簇标-2)*每簇扇区数)*每扇区字节数 
		=(0x100+0x660+0x3cd0*2+(0x2-2)*8)*512 
		=0x1020000
		根目录中:
		第一个 32字节目录项 是一个卷标目录项,记录这个分区的信息,即不指向任何文件,子目录
		第二个 32字节目录项 0Xb字节是0xf,是一个名字目录项!!
		....
	分析代码!!!
	fat.c
	发现 disk_read 会出错!! 直接调用cur_dev->block_read
	fat.h	
	结构fsdata的 short data_begin 应该改为 __u16 data_begin
	因为,在iar的配置里 short 与 unsigned short 进行运算时,会出问题,
	我这里就出现 data_begin = 33024 - 16 = (-32528)的奇怪事,
	而这个-32528直接导致 block_read 寻址出错,读不到正确位置上的数据!!
	还有,这套fat驱动,非常简陋,因为整个 FAT32文件系统是相对位置寻址的,
	所以,默认FAT32文件系统的起始block为0,起始地址为0,
	即认为bootsector所在的block是0,开始的地址为0
	当fat32文件系统不是在物理介质0地址时,这套代码便出错,
	所以需要添加对应的偏移, 定义一个宏偏移量 BOOT_SECTOR_LOCATION 记录fat32文件系统真正开始的地方!!
	最终成功读出文件数据
至此,超简陋 fat32文件系统 读文件 调试结束
	整理一下:
		usb_start() 初始化usb_host,并枚举连接的 usb设备
		usb_stor_get_dev()从获取 usb存储设备
		fat_register_device() 登记为fat文件系统设备
		file_detectfs()检查文件系统
		file_read()读取文件!!
简单测试了下鼠标功能, 并没有反应!!!!(不弄了!!)
	










20180326
移植 学习 fatfs 库(这个fatfs库,不是上面那样简陋只为测试功能)
从sdcard 裸机代码分析:
意外地发现,v2.12 的sdcard项目可以顺利用自带 ddrm.icf和cstartup.s 编译运行成功!!
sdcard_menu t指令,在slot[0],slot[1]之间切换,即在emmc 和sdmmc 间切换,
这里是sdcard例子,只初始化了sdmmc!!,所以只有sdmmc工作,emmc不工作
所以切换到sdmmc,即sdcard时,其他指令才能执行,但是,读取文件指令并不能成功执行,原因f_open没加FA_WRITE
read中多了一步sha编解码(不要影响工作),因为sha编解码不知道哪里出错,导致死机
fatfs没有问题!可以完美写,如果要读写,必须f_open时,添加FA_READ,FA_WRITE的flag
补充移植参考:介质是sd卡
	fatfs,平台介质无关的是ff.c (一般不用改)
	配置文件一般是 ffconf.h, ff.h 和 diskio.h (据实际配置)
	物理介质与ff.c的接口: 是自定义文件,一般是diskio.c,我们例子是sdmmc_ff.c
		一定include diskio.h 和 ffconf.h
		主要接口有:
		DSTATUS disk_initialize (BYTE pdrv);
		DSTATUS disk_status (BYTE pdrv);
		DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
		DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
		DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
	而物理介质的底层驱动:sdmmc_api.c sdmmc.c









20180327
移植 学习 lwip /uip 库
从把所有 V2.12 eth例子都去看:
默认是sram启动的,同样改到ddram就崩溃了,现在怀疑是时钟冲突,怀疑要改 CONFIG_HAVE_XX之类
一开始就卡死在 mac地址 获取失败,
原来我换 ddram.icf的方法都是错的 !!!!
不是同一个.ewp文件下,有不同的workbench,我应该选ddram的workbench,而不是直接换linker
之所以不成功是因为之前把许多board_init的平屏蔽掉了,坑自己啊!
此外,board_init的 board_config_console后,就可以printf了!!
还有,把 ip 改一下成自己的,再编译
先 eth 例子:往同局域网其他电脑发arp并成功!
eth_lwip 例子:开发板实现一个http服务器,并登录成功!!
eth_uip_hello_world: 实现telnet 对话连接功能
eth_uip_telnetd: 同样实现telnet 对话连接功能,实行网络命令行控制开发板操作!!
eth_uip_webserver 例子:开发板实现一个http服务器,并登录成功!!

开始学习eth 相关架构!!
芯片自带使用的网络控制器是 gmac控制器,并不是emac
从从初始化开始分析:
board_init -> board_cfg_net(iface号,mac地址:NULL,是否block:是):
	a5d2可以接俩个phy,即有同时使用两个网络物理接口,我们iface:0
	表示使用第0个网络物理接口!! 
	->pio_configure 对应接口针
	->ethd_configure (_eth[iface=0],gamc_type,gmac控制器地址,打开caf,关闭nbc)
		定义了 _ethd[0]的 gamc = gmac控制器地址, op为 _gmac_op
		struct _ethd{
			Gmac *gmac /**< GMAC instance(addr) */
			struct _ethd_queue queues[ETH_QUEUE_COUNT];
			const struct _ethd_op *op = &_gmac_op  /*operation*/
		};
		const struct _ethd_op _gmac_op = {
			.configure = (_ethd_configure)gmacd_configure,
			.setup_queue = (_ethd_setup_queue)gmacd_setup_queue,
			.start = (_ethd_start)gmacd_start,
			.reset = (_ethd_reset)gmacd_reset,
			.set_mac_addr = (_eth_set_mac_addr)gmac_set_mac_addr,
			.get_mac_addr = (_eth_get_mac_addr)gmac_get_mac_addr,
			.start_transmission =(_eth_start_transmission)gmac_start_transmission,
			.send_sg = (_ethd_send_sg)ethd_send_sg,
			.send = (_ethd_send)ethd_send,
			.poll = (_ethd_poll)ethd_poll,
			.set_rx_callback = (_ethd_set_rx_callback)gmacd_set_rx_callback,
			.set_tx_wakeup_callback = (_ethd_set_tx_wakeup_callback)ethd_set_tx_wakeup_callback,
		};
		通过 _ethd[0]->op->configure 即 gmacd_configure 进一部初始化gmac
		gmacd_configure(_eth[0],gamc_type,gmac控制器地址,打开caf,关闭nbc)
			gmac_configure:清除各种中断,和状态寄存器,设置mdc_clock然后打开TX/RX
			添加每个gamc_queue, 对应的 irq_handler函数,每个 gamc_queue都可以有自己的 handler函数
				在这里,每个queue的 handler函数 都指向同一个函数
			配置 caf和nbc (打开caf,关闭nbc)
			最后gmacd_setup_queue初始化多个gamc_queue,(gmac_queue有多少个 已经有宏默认了数量)
				配置每条queue 的 tx/rx buffer大小,tx/rx状态(desc),
				斌不需要配置 tx_callbacks 函数
				reset每条queue 的tx/rx,和 打开每queue的tx/rx中断.
	然后建立mac地址:
	ethd_setup_queue:即调用多一次gmacd_setup_queue初始化一个特殊的queue,会配置对应的 tx_callbacks 函数
	设置 eth[0] 对应的 rx_callbacks 函数
	ethd_start: 即 gmacd_start
	phy_configure(_phy[0]);
		_phy[0]->desc->phy_if = PHY_IF_GMAC
		_phy[0]->op =_gmac_op
		_phy_find_addr //找到了,是KSZ8081 phy芯片时 在地址0x01
			gmac_enable_mdio(_phy[0]->desc->addr)
				gmac_phy_read(..GMII_PHYIDIR..)	//通过 GMII 总线 获取数据 ?
				gmac_phy_read(..GMII_PHYID2R..)
				得到的id1,id2再find_dev,最后得到 _phy[0]->dev,
				获取_phy[0]->addr
			gmac_disable_mdio(_phy[0]->desc->addr)
		phy_reset(事实上是失败的,,所以后面的检测执行phy_reset_omsor都没有干.
			gmac_enable_mdio(_phy[0]->desc->addr)
				gmac_phy_write(..GMII_BMCR,GMII_BNCR_RESET..)
				while等待,直到 gmac_phy_read(..GMII_BMCR..)读出已reset的状态!!
			gmac_disable_mdio(_phy[0]->desc->addr)
		phy_reset_omsor	//pdev->dev->model=KSZ8081 phy芯片时 ??
			gmac_enable_mdio(_phy[0]->desc->addr)
				gmac_phy_read(..GMII_OMSOR,&value..)
				value |= GMII_OMSOR_RMII_OVERRIDE;	/* Override strap-in for RMII mode */
				gmac_phy_write(..GMII_OMSOR, value..)
				while等待,直到 改写value成功
			gmac_disable_mdio(_phy[0]->desc->addr)	

		struct _phy {
			const struct _phy_desc* desc;
			const struct _phy_dev* dev;
			uint8_t phy_addr; /**< PHY address (actual) */
			const struct _eth_phy_op* op;
		};
		
		struct _phy_desc {
			void* addr;       /**< ETH instance (GMAC/EMAC) */
			enum _phy_if_eth phy_if;
			uint8_t phy_addr; /**< PHY address (configured) */
			struct {
				uint32_t idle;    /**< idle timeout */
				uint32_t autoneg; /**< auto-negociation timeout */
			} timeout;
		};
		static const struct _eth_phy_op _gmac_op = {
			.phy_read = (eth_phy_read)gmac_phy_read,
			.phy_write = (eth_phy_write)gmac_phy_write,
			.enable_mido = (eth_enable_mdio)gmac_enable_mdio,
			.disable_mido = (eth_disable_mdio)gmac_disable_mdio,
			.enable_rmii = (eth_enable_rmii)gmac_enable_rmii,
		};		
	phy_auto_negotiate (自动适配)
		gmac_enable_mdio(_phy[0]->desc->addr)
			gmac_phy_read(..GMII_ANAR..)
			value = GMII_ANAR_100BASETX_FD | GMII_ANAR_100BASETX_HD |
				GMII_ANAR_10BASET_FD | GMII_ANAR_10BASET_HD | 
				GMII_ANAR_SEL_IEEE_8023;
			gmac_phy_write(..GMII_ANAR, value..)
			gmac_phy_read(..GMII_BMCR..)
			value |= GMII_BMCR_AUTONEG | GMII_BMCR_RESTART_AUTONEG;
			gmac_phy_write(..GMII_BMCR, value..)
			phy_auto_negotiate_wait_for_completion(phy);
				....(待续)
				gmac_disable_mdio(_phy[0]->desc->addr)
从初始化发现,初始化 a5d2的gmac控制器,还有通过GMII初始化外设phy芯片!
	初始化gmac控制器时重点是 建立多个queue.用来收发数据
然后分析main函数,
	lwip_init()前的内容都是确定mac,ip地址的内容!!,与lwip无关
	lwip_init()后面的内容,看不到如何去移植!!
lwip在移植的时候分析吧!!








20180330
ucos移植lwip !!!
先移植eth
project->option添加宏!!
CONFIG_ARCH_ARM
CONFIG_ARCH_ARMV7A
CONFIG_HAVE_ETH			//不添加会说有的class没有定义
CONFIG_HAVE_GMAC		
CONFIG_HAVE_GMAC_QUEUES
CONFIG_HAVE_AIC5
CONFIG_HAVE_PMIC_ACT8945A
CONFIG_HAVE_TWI_AT24
CONFIG_DRV_AT24
CONFIG_HAVE_I2C_BUS
CONFIG_HAVE_XDMAC
CONFIG_HAVE_XDMAC_DATA_WIDTH_DWORD
CONFIG_HAVE_BUS_I2C

继续移植发现 board_cfg_eth 崩溃, 
原来需要先初始化irq,最好更换aic5驱动
尝试换成V2.12的aic5驱动:(成功在ucos3执行)
	board_lowlevel.c
		include "irq/irq.h"
		屏蔽本来的include aic!!
		low_level_init里 irq_initialize换掉 aic_initialize
	twid.c
		include "irq/irq.h"
		屏蔽本来的include aic!!
		//by william
	        //uint32_t id = aic_get_current_interrupt_identifier();
	        uint32_t id = aic_get_current_interrupt_source();
mac地址为0!!
没有初始化phy 怀疑!
board_cfg_pmic是电源管理芯片初始化,与 board_cfg_net,甚至phy无关
但一般 board_cfg_pmic在 board_cfg_net之前比较好
的确实是phy没有设置好!!
补充 (pmc.c) 即添加 pmc+.c
发现在之前,更需要设置 初始化 at24,
在board_eth.h添加
	//by william
	/* =================== AT24 device definition =================== */
	
	#define BOARD_AT24_TWI_BUS BUS(BUS_TYPE_I2C, 1)
	#define BOARD_AT24_ADDR    0x54
	#define BOARD_AT24_MODEL   AT24MAC402
在board_twi.h添加
	//by william
	/* ================== TWI bus definition ====================== */
	
	#define BOARD_TWI_BUS0      FLEXTWI4
	#define BOARD_TWI_BUS0_FREQ 400000
	#define BOARD_TWI_BUS0_PINS PINS_FLEXCOM4_TWI_IOS3
	#define BOARD_TWI_BUS0_MODE BUS_TRANSFER_MODE_DMA
	
	#define BOARD_TWI_BUS1      TWI1
	#define BOARD_TWI_BUS1_FREQ 400000
	#define BOARD_TWI_BUS1_PINS PINS_TWI1_IOS2
	#define BOARD_TWI_BUS1_MODE BUS_TRANSFER_MODE_DMA

	/* =================== AT24 device definition =================== */
	
	#define BOARD_AT24_TWI_BUS BUS(BUS_TYPE_I2C, 1)
	#define BOARD_AT24_ADDR    0x54
	#define BOARD_AT24_MODEL   AT24MAC402
还要改 io.h的 struct _buffer
还要改 component_xdmac.h的XDMAC_CH
发现又要换掉timer函数!!
换掉timer.c!! (与ucos不冲突)
补充 (tc.c) 即添加 tc+.c
又要添加bus.c!!
替换mutex.c
替换twid.c,twi.c
添加dma.c
替换 act8945a.c
终于编译成功,显然这种新旧库共用的方法必然导致冲突使ucos失败!
换回 act8945a.c
换回 twid.c,twi.c
换回 mutex.c
换回 timer.c (timer冲突了)
(算了,两个不同版本的底层库实在是太多冲突了!!!)
(在v2.12的库上移植ucos3!!)








20180330
基于a5d2新版底层库v2.12移植ucos 放在 ucos+文件夹里!!
好意外!!!只是底层库换了, 就直接成功
换库,ucos应该有很多奇奇怪怪的需要重新配置,重新写的,
但是没有,没有修改任何跟ucos接口有关的内容,直接成功.
好惊喜!!
本来还想好好学习如何配置底层移植ucos的,
继续做eth!!
注意,初始化eth时,执行到 assert出错
assert(XX) 函数作用 当XX已经被建立时,返回true,当XX未建立,出错!!并崩溃程序
发现,时间片调度的基准时钟没有设置好!!
datasheet:Peripheral Identifiers 记录中断号
暂时: AIC PIT PMC 关于时钟tick中断的设置都没发现什么问题
检查过,代表 systickHandler 的BSP_OSTickISRHAndler()正常工作 
BSP_OSTickISRHAndler() 只执行了 OSTimeTIck!!,OSTimeTick也运行良好!!!
然而好像最终并没有更新 OSTick!!
确认没有调用OS_TickTask 更ixn新时间片计数!!
OSTimeGet()是获取当前时钟节拍OSTick的, 就是获取 OSTickCtr这个值 而这个值是通过 OS_TickTask赋予的
现在是 OSTimeGet() 得到的都是0,表示没有更新时间片??
最后发现是 OS_TickTask 任务级别太低 10级!!,所以一直没被调用
现在 OS_TickTask 是有了 ,但是没有看到 倒数时间片的控制!
后民发现 TCB.TickRemain 都为0, 即时间片没有被赋值!!
首先 OS_TickTask 被 OSTask_Create 时间片设置为0
但是其他任务,我们OSTask_Create 时,是有时间片设置的!!
查看OSTask_Create发现,设置描述时间片的擦参数不是TCB.TickRemain,而是TCB.TimequantaCtr
然后的发现 要在 OSinit() 之后 打开时间片调度,
#if OS_CFG_SCHED_ROUND_ROBIN_EN  
OSSchedRoundRobinCfg(DEF_ENABLED,1,&err);  
#endif
还有就是 OS_TickTask 的优先级!!网上说最高,到例程却设置成最低!
发现在 OS_TickTask 的优先级优先级1 时
一旦切换成 ethtask ,时钟中断就再没有响应过.
最后发现是 OSIntCtxSw() 出问题!!

初步认识, OSIntCtxSw()这个是交叉环境下的 调度实现函数.ISR环境下调度 user环境的task
暂时只有 OSIntExit 执行这个函数!!
对应的 OSCtxSw(),即 OS_TASK_SW() 是 同环境下的 调度实现函数 都是 汇编asm 实现的
而唯一只有 OSSched 调用, 这个函数,所以 OSSched 是同环境下的调度实现函数
例如比较惊讶的是 ISR环境下 OS_TaskSemPost ->OSSched 调度执行 OS_TickTask,
Task一般在 user环境下运行的 但是这里却是isR里调用,表示在ISR环境中使用了 OSCtxSw() 调度

另一种说法,所有中断函数搜是在中断处理任务上运行的,
从中断任务中调度出来,通过OSIntCtxSw()
而一般任务间执行调度,执行 OSCtxSw()

调回优先级为1时,及TimeTick会调用OS_TickTask()时,注意这时不要在systickHandle 加入 IntEnter()TntExit()
	注意,systickHandle 是在优先级为0的中断task上运行
	中断task: TimeTick()->sempost->OSSched-->OS_TickTask() //这里使用OSSched切换到OS_TickTask()
	但是OS_TickTask()完了还是要回到 中断task 上来的!! 因为中断task未完成
	现在是  OS_TickTask() 跳到了 ethTask, 追溯了 OS_TickTask()发现各地方工作良好
	整个 OS_TickTask() 只有	OSSched 是跳转的!!
	但那次错误跳转是 从OS_TickTask()->OSSched 跳的,
	理论上 OS_TickTask()是由 中断task ossched到的,由于中断task未挂起,且优先级最高的0
	所以 OS_TickTask()后仍然跳回中断task
	而这里却跳到 ethTask
重新检查 OSTimeDlyHMSM() 延时工作函数,(睡眠到一定时间后醒来)
	发现需要 OS_TickTask() 更新延时!!,用回OS_TickTask默认优先级10!!
	而 OSTimeDlyHMSM() 重点,把延时写入 TCB, OS_RdyListRemove(),OSSched(),
OSSchedRoundRobinYield 也需要先 OSSchedRoundRobinCfg(DEF_ENABLED,1,&err);  打开开关
	(放弃时间片直接跳出)
	在两个Task中调用,可以工作!!!!当中调用了 OS_RdyListMoveHeadtoTail()  OSSched()
从中断Task出来,不应该调用 OSSched() 的!!,
	因为 OSSched() 是会记录当前stack并当前task换到tasklist里, 
	下次运行时从这个断开的地方开始
	而中断task执行后是睡眠的,不用记录当前stack,因为i下次运行并不从当前位置运行

现在是 OSTimeDlyHMSM() 可实现调度,
OSTaskSupend 可实现调度,


1、任务级调度 OSSched()
2、中断级调度OSIntExit()
3、运行多个任务具有相同优先级，可以被设置为循环轮转调度
4、任务发生调度的情况
     (1)任务调用提交服务函数Post，发送信号量或者消息给其它任务时调度发生，调度在Post函数的结束时发生，注意
          调度是不会发生(见OS_OPT_POST_NO_SCHED的可选参数)
     (2)任务调用OSTimeDly()或OSTimeDlyHMSM()，如果延时参数不是0，调度发生，调度会在该任务被放入挂起队列
          后马上执行
     (3)任务所等待的事件发生或超时，当Pend()被调用时，接收到该事件的任务或者超时的任务就会被移出等待队列。然
          后调度器选择就绪列表中优先级最高的任务执行。移出等待队列的任务不一定就绪状态，因为它还可能在停止队列。
     (4)任务取消挂起，一个任务可以被取消挂起，若另一个任务调用PendAbort()，当任务被移出等待列表中时调度发生。
     (5)新任务被创建
     (6)用户调用OSSched
     (7)调用OSSchedRoundRobinYield任务放弃分配给它的时间片
     (8)通过调用OSSchedUnlock调度器被解锁
     (9)退出中断服务程序，OSIntExit
     (10)OSTaskSupend (挂起一个task)或 OSTaskResume(点亮一个task)，调度发生


整理: 
首先怀疑 BSP_OSTickISRHandler 不是一个硬件级别的终端函数,即没有运行在所谓的cpu 的ISR或者SVC模式上
而是一个 在中断列表Task上运行的的 队列任务函数, 中断列表Task优先级别为0,最优级别
最后发现 BSP_OSTickISRHandler 是一个硬件级别的终端函数 运行在cpu 的ISR模式,
这时发生的任务调度是一个非常巧妙的机制
现象(和假设):
	1,BSP_OSTickISRHandler 只用一个 OStimeTick,却没有作为一个中断函数该有的 OSIntEnter()和OSIntExit()
	2,原来默认 OS_TickTask 默认优先级别是 10 的,比较低,当我调到比较高的优先级1时,出现以下奇怪动作!!!
	  BSP_OSTickISRHandler->OStimeTick 执行了 OSTaskSemPost()给OS_TickTask 发送信号,
	  OSTaskSemPost()还顺利执行了 OSSched(),直接跳到的 OS_TickTask 执行!!
		理论上应在 BSP_OSTickISRHandler 结束后, 才有机会调度到 OS_TickTask(), 而且不是用 OSSched()调度
		因为 OSSched() 调用 OSCtxSw 会把当前Task内容压入栈,后把下一个Task内容释放!!
		而在 运行在硬件中断函数时,应该没有没有处于任何的Task里,所以没有当前Task一说
	  OS_TickTask 执行完执行 OSSched(),这时返回到 BSP_OSTickISRHandler->OStimeTick 继续执行余下中断任务!!
	3,还发现在 BSP_OSTickISRHandler工作期间时,中断是被锁住的.
	  就是说,从 OStimeTick 跳到 OS_TickTask 时,中断依然没有解锁,
	  直到 OS_TickTask 跳回 OStimeTick 执行完余下的任务, 退出 BSP_OSTickISRHandler 后,中断才被解锁!!
	  即: 中断锁住 -> BSP_OSTickISRHandler -> OS_TickTask -> BSP_OSTickISRHandler -> 中断解锁
	4,这样就有一个严重错误发发生了!!
	  我开了时间片模式, 导致一个普通任务A,在某一刻处于很高的执行级别,
	  还有OS_TickTask()优先级1,
	  这时有:	
	  时刻1:中断锁住 -> BSP_OSTickISRHandler -> OS_TickTask -> BSP_OSTickISRHandler -> 中断解锁
	  时刻2:中断锁住 -> BSP_OSTickISRHandler -> OS_TickTask -> BSP_OSTickISRHandler -> 中断解锁
	  .....
	  时刻x:中断锁住 -> BSP_OSTickISRHandler -> OS_TickTask -> 普通任务A(永远执行)
	  由于中断被锁,所以这时就永远执行普通任务A
	  除非普通任务A主动放弃:OS_RdyListMoveHeadtoTail()+OSSched() 或者 OS_RdyListRemove(),OSSched()
	  才有机会回到还没有执行完毕的 BSP_OSTickISRHandler 然后 中断解锁
	所以,深入 中断是如何实现的!!!
	由于能够调用 OSSched() 所有中断Task 应该有初始化,有堆栈信息!!
修正,这个ucos案例里没有所谓的中断任务task!!
	BSP_OSTickISRHandler 是真实的 中断服务函数, 注意!!但没有运行在cpu的ISR模式上(不知为何)
	真实情况应该是这样子的!!
	任务A在正常执行,这时来了时钟中断, cpu 把当前 内容的地址写如lr pc直接跳到 irqhandler
	这时,其他通用寄存器上的内容暂且保持原样,
	这是 堆栈指针仍然指向 任务A的堆栈,意味着接下来的中断函数工作会在 任务A的堆栈下工作
	所以我们可以认为 现在是仍处于 任务A 下 工作, 
	irqhandler 做了一些处理 跳到了 BSP_OSTickISRHandler,
	即可认为 BSP_OSTickISRHandler,是当前任务A正在运行的函数.
	BSP_OSTickISRHandler->OStimeTick 执行了 OSTaskSemPost()给OS_TickTask 发送信号,
	由于设了 OS_TickTask 优先级1,所以 OSTaskSemPost()还顺利执行了 OSSched(),直接跳到的 OS_TickTask 执行!!
	OSSched(),
		会把 任务A 的TCB保存, 然后把 任务 OS_TickTask的TCB放入ucos3环境,
		然后把当前 ISR:R0-R14 压入 任务A 的堆栈, 把 任务 OS_TickTask 堆栈内容放入 ISR:R0-R14
		这样就实现切换到 任务 OS_TickTask 
	即 BSP_OSTickISRHandler 执行到半路,突然间,全换成 任务 OS_TickTask 的环境,
	使用任务 OS_TickTask 的堆栈,然后 执行任务 OS_TickTask.
	也就说,我们的中断还没有执行完,就直接从中断工作内容 跳到 任务 OS_TickTask
	任务 OS_TickTask内容后,又执行了 OSSched() 回到了 任务A
	但并不是,任务A被中断的工作, 
	而是,任务A被中断后,执行的 BSP_OSTickISRHandler->OStimeTick->OSTaskSemPost()->OSSched()后的内容.
	即 之前 BSP_OSTickISRHandler 还没做的一些收尾工作
	而且,从任务B的堆栈 回到 使用 任务A的堆栈
	BSP_OSTickISRHandler 结束后,回到 irqhandler 做收尾工作
	最后回到 任务A原本的工作上去.
	重新解释第 4 现象: 
	4,开了时间片模式, 导致一个普通任务B,在某一刻处于很高的执行级别,还有OS_TickTask()优先级1,
	  这时:	
	  时刻1: 任务A执行XXX
		->中断来了
		->irqhandler 插入到 当前任务A的内容中 优先执行 
		->irqhandler 跳到 BSP_OSTickISRHandler
		->BSP_OSTickISRHandler->OStimeTick->OSTaskSemPost()->OSSched() 转到了 任务OS_TickTask 
		->转回任务A,即回到任务A的堆栈, 执行之前 余下BSP_OSTickISRHandler
		->执行 余下irqhandler
		->回到 任务A被中断的位置 继续执行XXX
	  时刻2: 任务A执行XXX
		->中断来了
		->irqhandler 插入到 当前任务A的内容中 优先执行 
		->irqhandler 跳到 BSP_OSTickISRHandler
		->BSP_OSTickISRHandler->OStimeTick->OSTaskSemPost()->OSSched() 转到了 任务OS_TickTask 
		->任务OS_TickTask->OSSched() 转回任务A,即回到任务A的堆栈, 执行之前 余下BSP_OSTickISRHandler
		->执行 余下irqhandler
		->回到 任务A被中断的位置 继续执行XXX
	  .....
	  时刻1: 任务A执行XXX
		->中断来了
		->irqhandler 跳到 BSP_OSTickISRHandler
		->BSP_OSTickISRHandler->OStimeTick->OSTaskSemPost()->OSSched() 转到了 任务OS_TickTask 
		->任务OS_TickTask OSSched() 转到 任务B
		->任务B 没有调用 OSSched()的地方,
		->由于 执行的一半的 irqhandler, 没有机会执行余下irqhandler
		->就是说中断开关一直被挂起,没有重新打开
		->最后cpu 永远处于 ISR模式,永远执行 任务B
	  除非任务B主动放弃:OS_RdyListMoveHeadtoTail()+OSSched() 或者 OS_RdyListRemove(),OSSched()
	  才有机会回到任务A 执行余下BSP_OSTickISRHandler,有机会执行余下irqhandler 重新打开 中断开关
现在大致知道如何实现时间片调度了(要自己加OSSched(),半自动)
	要在 OSinit() 之后 打开时间片调度,
	#if OS_CFG_SCHED_ROUND_ROBIN_EN  
	OSSchedRoundRobinCfg(DEF_ENABLED,1,&err);  
	#endif	
	然后在 各个任务的while循环里 加入一句 OSSched() 就好了.
	因为 TimeTick 会递减每个任务时间片并更新 readylist
	时间未到 readylist未改变,OSSched()不发生什么,
	时间到了 readylist改变,OSSched()就会调度一个新任务
如何实现在中断离开时调度,即如何使用 OSIntEnter,OSIntExit,
	一并讨论中断嵌套!!
	特别注意到,运行OSCtxSw OSIntCtxSw(),OSSched() OSIntExit()的工作原理
	例子:
		任务A主动OSSched().OSCtxSw()后,直接跳到任务B执行
		任务B主动OSSched().OSCtxSw()后,跳回任务A的OSSched().OSCtxSw()之后的代码
	        任务A->OSSched(){            任务B->OSSched(){
	                ......                       ......
	                OSCtxSw()；   ------|        OSCtxSw()；   -----| 
	              ______________	    |      ______________	|
	                                    |                           |
	                CPU_INI_EN(); <--|  |----->  CPU_INI_EN();      |
	                .......          |           .......            |
	                }                |           }                  |
	                                 |                              |
	                                 |------------------------------|
	OSIntExit() 的 OSIntCtxSw() 也一样意思,
	即当前中断调用 OSIntCtxSw() 就跑到别处了,并没有执行 OSIntExit()最后的CPU_INI_EN()操作!!
	但是会在别处 补 执行 CPU_INI_EN()
	别处 经 OSIntCtxSw() 跑回来当前,别处并没有执行 OSIntExit()最后的CPU_INI_EN()操作!!
	但是会在当前 补 执行 CPU_INI_EN()	
	OSIntEnter,OSIntExit一般用法是每次进中断服务函数时先OSIntEnter,退出时OSIntExit
	当多次嵌套中断时,会有一个OSIntNestingCtr统计嵌套中断次数,
	当最后一次嵌套中断退出时,最后一次OSIntExit会执行 OSIntCtxSw()进行调度!!
	但是针对这个a5d2的板子,OSIntEnter,OSIntExit 并不能顺利使用!!
	对比stm32的例子,真的是很不一样!!! stm32中断有NVIC机构,架构不一样,能用 OSIntEnter,OSIntExit 跳转!!
开启时间片调度下:实现延时工作
	开启时间片调度后,延时工作变得比较不可靠,
	由于 TickTask 的优先级为10,比较低,
	参加 时间片调度的 任务一般不会 把自己从rdylist挂起,只会放到队尾
	所以迟迟无法执行 TickTask 更新计时器!! TickTask永远没机会执行的话,
	时间片调度模式下, 执行 OSTimeDlyHMSM() 等延时工作相当慎重,
	因为 OSTimeDlyHMSM() 会挂起当前任务!!,
	ickTask永远没机会执行的话,意味着被挂起的延时任务永远都不会返回工作!!
由于 OSIntCtxSw() 鸡肋,真正行使调度的只有 OSSched()->OSCtxSw().
	而且避免在 中断过程中执行 OSSched()
	要实现全部功能 ,需要修改 OSIntCtxSw();
暂时凑合用:添加eth成功,开始移植 lwip 
	就是把一堆eth_lwip工程相关的东西全塞到ucos3工程,修改 include路经 就是了
	中间没有什么大波澜,小改了一些冲突内容就成功了,所以没来得及学习 lwip 相关内容
必须验证中断处理 和 中断嵌套相关内容!!!
	现有情况下把adc加过去了,成功运行adc和lwip共存,
	虽然有中断,但是不能实行中断嵌套的极端情况,所以没有参考意义

着手修改 OSIntCtxSw() 实现中断调度!!
分析 a5d2_AIC:
	127个中断源 datasheet:Peripheral Identifiers 记录中断源号号码
	可以设置优先级:
		Each interrupt source has a programmable priority level of 7 to 0,
		which is user-definable by writing AIC_SMR.PRIOR. 
		Level 7 is the high-est priority and level 0 the lowest.
	中断嵌套:Interrupt Nesting:
		The priority controller utilizes interrupt nesting
			in order for the high priority interrupt to be handled
			during the service of lower priority inter-rupts. 
		This requires the interrupt service routines of the lower interrupts
			to re-enable the interrupt at the processor level.
		When an interrupt of a higher priority happens 
			during an already occurring interrupt service routine, 
			the nIRQ line is re-asserted. 
		If the interrupt is enabled at the core level, 
			the current execution is interrupted and the new interrupt service routine should read AIC_IVR. 
		At this time, the current interrupt number and its priority level 
			are pushed into an embedded hardware stack(硬件堆栈), 
			so that they are saved and restored when the higher priority interrupt servicing 
			is finished and AIC_EOICR is written.
		The AIC is equipped with an 8-level wide hardware stack 
			in order to support up to eight interrupt nestings to match the eight priority levels.
	也就是,硬件自己处理中断嵌套,但是我们使用ucos时,如果要加入 中断调度, 
		就必须使用中断服务函数添加 OSIntEnter 让ucos系统统计中断嵌套数,
		离开中断服务函数时,要调用 OSIntExit 释放一次中断嵌套数
		当中断嵌套数为0时,即说明我们在最后一个中断, 
		于是就是执行 OSIntCtxSw() 调度
	现在的问题是:
		这中断调度 是直接把新Task 内容拷到 ISR模式下的 cpu:R0-R14 ,
		也就说 cpu 自此永远在 ISR模式下运行
		先写一个汇编 读取cpsr 内容 
		发现无法读取 cpsr 的 内容,
///////// 这段汇编的理解是错的
	复习下:汇编 
            EXTERN cpsrA
            EXTERN BiliA	
	    ;     
	    LDR     R1, =cpsrA	       把地址变量变量 cpsrA 存的地址 读入到R1
	    LDR     R0, =BiliA         把变量 BiliA 读入到R0
	    STR     R0, [R1]	       把变量 BiliA 写入 地址变量cpsrA所指向的地址 里
	    ;     
	    LDR     R1, =cpsrA         把地址变量 cpsrA 存的地址 读入到R1
	    LDR     R0, =BiliA         把地址变量 BiliA 存的地址 读入到R0
	    LDR     R2, [R0]           把地址变量 BiliA 所指向的地址 的内容,读入到R2
	    STR     R2, [R1]           把地址变量 BiliA 所指向地址的内容 写入 地址变量 cpsrA 所指向地址 里
	    ;    
	    LDR     R1, =cpsrA         把地址变量变量 cpsrA 存的地址 读入到R1
	    LDR     R0, =BiliA         把变量 BiliA 读入到R0
	    MOV     R2, R0             把 R0 的内容 放入 R2
	    STR     R2, [R1]           把变量 BiliA 写入 地址变量cpsrA所指向的地址 里
		特别注意, 这款芯片不能做立即数的操作!!
		例如,我们知道 BiliA 值是 0x23,但是我们不能直接用这个句子 LDR     R1, =0x23
		这是因为 a5d2 处理器有加密模块!!
		LDR     R0, =BiliA 的 BiliA值 是加密了的 0x23
		如果用直接数,系统认为 0x23 是某个数被加密过后的到的值,所以接着就出错了!!
		cpsrA BiliA 是要有 EXTERN 声明的!
	发现汇编还有些操作是不一样的 LDR 是一个相对操作, LDR     R1, =cpsrA 其实是错误操作
	未知道如何导致出错
	还有就是 MRS 读取寄存器内容后,无法顺利 STR 写入到内存里
///////// 这段汇编的理解是错的
	LDR     R0, =cpsrA	//把 cpsrA 的内容放入 R0
	MRS     R1, CPSR	//把 CPSR 的内容放入 R1
	STR     R1, [R0]	//把 R1 的内容放入 R0的内容所在的地方 cpsrA
				//即用 R1 的内容 替换掉 cpsrA 里的内容
				//即把 CPSR 的内容,放入 cpsrA 里
	直接把 cpsr的值 发到了 cpsrA里了,而不是发到 cparA里存着的地址的那个地方
	即 cpsrA 内容 B 为cpsrV的地址
	这里 LDR 是把 B 放到了 R0,而不是把 内容为cpsrV的地址 放到R0

The core contains one CPSR, and six SPSRs for exception handlers to use. The program status registers:

User and
System	 Monitor Supervisor Abort Undefined Interrupt Fast Interrupt
R0 R0 R0 R0 R0 R0 R0
R1 R1 R1 R1 R1 R1 R1
R2 R2 R2 R2 R2 R2 R2
R3 R3 R3 R3 R3 R3 R3
R4 R4 R4 R4 R4 R4 R4
R5 R5 R5 R5 R5 R5 R5
R6 R6 R6 R6 R6 R6 R6
R7 R7 R7 R7 R7 R7 R7
R8 R8 R8 R8 R8 R8 R8_FIQ
R9 R9 R9 R9 R9 R9 R9_FIQ
R10 R10 R10 R10 R10 R10 R10_FIQ
R11 R11 R11 R11 R11 R11 R11_FIQ
R12 R12 R12 R12 R12 R12 R12_FIQ
R13 R13_MON R13_SVC R13_ABT R13_UND R13_IRQ R13_FIQ
R14 R14_MON R14_SVC R14_ABT R14_UND R14_IRQ R14_FIQ
PC PC PC PC PC PC PC
CPSR CPSR CPSR CPSR CPSR CPSR CPSR
SPSR_MON SPSR_SVC SPSR_ABT SPSR_UND SPSR_IRQ SPSR_FIQ


21.8.3.3
Interrupt Handlers
This section gives an overview of the fast interrupt handling sequence when using the AIC. It is assumed that the programmer understands
the architecture of the ARM processor, and especially the Processor Interrupt modes and the associated status bits.
It is assumed that:
1. The Advanced Interrupt Controller has been programmed, AIC_SVR registers are loaded with corresponding interrupt service rou-
   tine addresses and interrupts are enabled.
2. The instruction at the ARM interrupt exception vector address is required to work with the vectoring. Load the PC with the absolute
   address of the interrupt handler.
When nIRQ is asserted, if the bit “I” of CPSR is 0, the sequence is as follows:
1. The CPSR is stored in SPSR_irq, the current value of the Program Counter is loaded in the Interrupt link register (R14_irq) and the
   Program Counter (R15) is loaded with 0x18. In the following cycle during fetch at address 0x1C, the ARM core adjusts R14_irq,
   decrementing it by four.
2. The ARM core enters Interrupt mode, if it has not already done so.
3. When the instruction loaded at address 0x18 is executed, the program counter is loaded with the value read in AIC_IVR. Reading
   AIC_IVR has the following effects:
-Sets the current interrupt to be the pending and enabled interrupt with the highest priority. The current level is the priority level of
 the current interrupt.
-De-asserts the nIRQ line on the processor. Even if vectoring is not used, AIC_IVR must be read in order to de-assert nIRQ.
-Automatically clears the interrupt, if it has been programmed to be edge-triggered.
-Pushes the current level and the current interrupt number on to the stack.
-Returns the value written in AIC_SVR corresponding to the current interrupt.
4. The previous step has the effect of branching to the corresponding interrupt service routine. This should start by saving the link
   register (R14_irq) and SPSR_IRQ. The link register must be decremented by four when it is saved if it is to be restored directly into
   the program counter at the end of the interrupt. For example, the instruction SUB PC, LR, #4 may be used.
5. Further interrupts can then be unmasked by clearing the “I” bit in CPSR, allowing re-assertion of the nIRQ to be taken into account
   by the core. This can happen if an interrupt with a higher priority than the current interrupt occurs.
6. The interrupt handler can then proceed as required, saving the registers that will be used and restoring them at the end. During this
   phase, an interrupt of higher priority than the current level will restart the sequence from step 1.
Note:  If the interrupt is programmed to be level-sensitive, the source of the interrupt must be cleared during this phase.
7. The “I” bit in CPSR must be set in order to mask interrupts before exiting to ensure that the interrupt is completed in an orderly
   manner.
8. AIC_EOICR must be written in order to indicate to the AIC that the current interrupt is finished. This causes the current level to be
popped from the stack, restoring the previous current level if one exists on the stack. If another interrupt is pending, with lower or
equal priority than the old current level but with higher priority than the new current level, the nIRQ line is re-asserted, but the inter-
rupt sequence does not immediately start because the “I” bit is set in the core. SPSR_irq is restored. Finally, the saved value of the
link register is restored directly into the PC. This has the effect of returning from the interrupt to whatever was being executed
before, and of loading the CPSR with the stored SPSR, masking or unmasking the interrupts depending on the state saved in
SPSR_irq.
Note:  The “I” bit in SPSR is significant. If it is set, it indicates that the ARM core was on the verge of masking an interrupt when the
mask instruction was interrupted. Hence, when SPSR is restored, the mask instruction is completed (interrupt is masked).
	上面是截取的是 a5d2芯片 的 AIC 和中断IRQ 如何工作.







20180416
	基本捋清 中断工作的基本脉络,
	先纠正, ARM 架构 的通用寄存器 的错误 思维
User and
System	 Monitor  Supervisor Abort    Undefined Interrupt Fast-Interrupt
(USER)   (MON)    (SVC)      (ABT)    (UND)     (IRQ)     (FIQ)
R0       R0       R0         R0       R0        R0        R0
R1       R1       R1         R1       R1        R1        R1
R2       R2       R2         R2       R2        R2        R2
R3       R3       R3         R3       R3        R3        R3
R4       R4       R4         R4       R4        R4        R4
R5       R5       R5         R5       R5        R5        R5
R6       R6       R6         R6       R6        R6        R6
R7       R7       R7         R7       R7        R7        R7
R8       R8       R8         R8       R8        R8        R8_FIQ
R9       R9       R9         R9       R9        R9        R9_FIQ
R10      R10      R10        R10      R10       R10       R10_FIQ
R11      R11      R11        R11      R11       R11       R11_FIQ
R12      R12      R12        R12      R12       R12       R12_FIQ
R13      R13_MON  R13_SVC    R13_ABT  R13_UND   R13_IRQ   R13_FIQ
R14      R14_MON  R14_SVC    R14_ABT  R14_UND   R14_IRQ   R14_FIQ
PC       PC       PC         PC       PC        PC        PC
CPSR     CPSR     CPSR       CPSR     CPSR      CPSR      CPSR
         SPSR_MON SPSR_SVC SPSR_ABT   SPSR_UND SPSR_IRQ  SPSR_FIQ
	7种模式 : USER,MON,SVC,ABT,UND,IRQ,FIQ
	r0-r7 寄存器 7种模式共用
	r8-r12寄存器 除FIQ 的 6种模式模式共用
	pc    寄存器 7种模式共用
	cpsr  寄存器 7种模式共用
	其他寄存器 各模式有自己专属的
	USER 模式 没有 SPSR 寄存器
然后纠正之前假设的中断运行过程 
典型的中断过程:
	中断触发时, 通用寄存器的内容保持不变,
	把执行内容的当前位置放入lr后, pc直接跳到 irqHandler 
	这时,sp 指针不变,还是指着当前Task_A,的堆栈.
	还有关键的,并没有执行在所谓的IRQ模式下,因为读取CPSR内容时,发现 mode 没有设置 IRQ
	即我们依然处于 当前Task环境,然后做了一些处理后,
	bx r0  跳去执行真正的中断服务函数!!
	执行完,回到 irqHandler 完成余下的收尾工作.
	然后把之前的 lr 内容 放入 pc 回到 Task_A 本来的内容上去.
	整个过程 都是在 Task_A环境下, 和使用着 Task_A 的堆栈 下 完成整个中断内容!!
中断过程后,执行 Task 调度!
	按照 原本 代码,中断服务函数的最后部分是 任务调度内容.
	调度:置换 sp指针位置,到 Task_B堆栈的位置, 把Task_B 的内容换到 通用寄存器上来,
	直接跳到 Task_B 位置 执行工作
	这种情况下, 完全,不可能 跳回到 irqHandler 完成余下的工作,
	相当于, 中断还没有完全执行完,就跳到了 Task_B 运行,环境堆栈都变成Task_B的
	这时比较麻烦的原因之一是,irqHandler 的收尾工作.通知中断功能重新启动的命令,
	而跳到 Task_B 工作后, Task_B 没有意识,也不会去 通知中断功能重新启动!
假如我们,修改 中段调度时前通知中断功能重新启动!
	中断服务函数的最后部分是 任务调度内容.
	调度:	把当前环境内容推入Task_A的堆栈,
		通知中断功能重新启动, 置换 sp指针位置,到 Task_B堆栈的位置, 
		把Task_B 的内容换到 通用寄存器上来,
		直接跳到 Task_B 位置 执行工作
	下次 中断来了,Task_B 会调度 Task_A,
	这时并不是直接跳回Task_A本来被中断的工作内容.
	跳回的是, Task_A被中断后执行的中断服务函数中,调度内容以后余下的内容,
	即会跳回, Task_A被中断后,中断还没有执行完的 irqHandler 余下的收尾工作,
	收尾工作完成了,才会到 Task_A本来被中断的工作内容.
	irqHandler 余下的收尾工作,包含的中断嵌套的处理内容
	这样在中断强加调度的行为,并不推荐.
	如果 Task_A,Task_B 本身没有什么复杂的,其他功能, 勉强可以使用,
	但如果, Task 有 以太网协议工作的,有ADC工作的 就很容易冲突出问题.
如果真想 中断中实现调度,
	需要 统筹 AIC 重新设计 irqHandler 和 OSIntctSw
	特别注意:
	通知中断功能重新启动的工作:
	//by william
	msr         CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
	msr         CPSR_c,  #0x12 | 0x80 | 0x40
	//Acknowledge interrupt
	ldr         lr, =AT91C_BASE_AIC
	str         lr, [r14, #AIC_EOICR]
最后,做阶段性总结后,ucos3移植 暂时告一段落:
	由于 a5d2 的中断架构原因,
	很难做到中断结束那刻调度任务 的功能,
	因此 中断无法调用 OSIntEnter(),OSIntExit()
	也因此无法 很好使用 时间片轮寻调度!!
	如果要做时间片轮询调度,
	要在 OSinit() 之后 打开时间片调度,
	#if OS_CFG_SCHED_ROUND_ROBIN_EN  
	OSSchedRoundRobinCfg(DEF_ENABLED,1,&err);  
	#endif
	要在 bsp_os 的时基中断函数 BSP_OSTickTSHandler 添加 OSIntEnter(),OSIntExit()
	还得进一步修改 调度函数的 实际操作函数 OSTntCtxSw
	OSIntCtxSw
	    ;by william  这段是 重新启动中断的内容,但这里只演示不执行!!
	    ;msr         CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
	    ;msr         CPSR_c,  #0x12 | 0x80 | 0x40
	    ; Acknowledge interrupt
	    ;ldr         lr, =AT91C_BASE_AIC
	    ;str         lr, [r14, #AIC_EOICR]
	    
	    ;by william 这段是 保存当前任务环境的内容
	    ; SAVE CURRENT TASK'S CONTEXT:
	    STMFD   SP!, {LR}                                           ;     Push return address,
	    STMFD   SP!, {LR}
	    STMFD   SP!, {R0-R12}                                       ;     Push registers,
	    MRS     R0, CPSR                                            ;     Push current CPSR,
	    TST     LR, #1                                              ;     See if called from Thumb mode,
	    ORRNE   R0, R0, #OS_CPU_ARM_CONTROL_THUMB                   ;     If yes, set the T-bit.
	    STMFD   SP!, {R0}
	    ?OS_CPU_ARM_FP_REG_PUSH  R0
	    CLREX                                                       ; Clear exclusive monitor.
	    MOV32   R0, OSTCBCurPtr                                     ; OSTCBCurPtr->StkPtr = SP;
	    LDR     R1, [R0]
	    STR     SP, [R1] 
	  
	    ;by william  这段是 重新启动中断的内容,
	    ldr         lr, =0xFC020000
	    str         lr, [r14, #0x38]
	
	    ;by william  这段是 OSIntCtxSw原有内容,
	    BL      OSTaskSwHook                                        ; OSTaskSwHook();
	    MOV32   R0, OSPrioCur                                       ; OSPrioCur = OSPrioHighRdy;
	    MOV32   R1, OSPrioHighRdy
	    LDRB    R2, [R1]
	    STRB    R2, [R0]
	    MOV32   R0, OSTCBCurPtr                                     ; OSTCBCurPtr = OSTCBHighRdyPtr;
	    MOV32   R1, OSTCBHighRdyPtr
	    LDR     R2, [R1]
	    STR     R2, [R0]
	    LDR     SP, [R2]                                            ; SP = OSTCBHighRdyPtr->OSTCBStkPtr;
	    ?OS_CPU_ARM_FP_REG_POP R0	                                                                ; RESTORE NEW TASK'S CONTEXT:
	    LDMFD   SP!, {R0}                                           ;    Pop new task's CPSR,
	    MSR     SPSR_cxsf, R0
	    LDMFD   SP!, {R0-R12, LR, PC}^                              ;    Pop new task's context.
	然后就可以做一些 简单的 Task 时间片, 然而复杂的Task并不能很好执行
	主要还是 OSIntCtxSw, irqhandler 和 AIC控制器的关系
	上述修改,实现时间片中断调度 还是有很多问题的.需要重先写整个中断系统才有意义!!
	所以 目前 系统比较稳定的是做 主动调度 即不使用 OSIntEnter(),OSIntExit()
	即 Task 主动在合适的位置 执行 OSSched(),或者延时函数!!
	移植过程中遇到的一些主要内容:
	OSIntNestingCtr 全局变量,记录中断嵌套!!
	OSSSchedLockNestingCtr 全局变量,调度嵌套锁,每执行一次OSSchedLock()就上一次锁,目的是标记禁止调度
	OSTickCtr 全局变量 时基中断计数变量,统计系统时钟滴答次数,
		  理应该,每次时钟中断都得执行一次,但是由于在 TickTask 里更新,
		  而TickTask优先级又相当低,而且是sem信号通知的,即 TickTask 不一定会及时执行,
		  甚至不一定会执行,这就比较尴尬,就不知道有什么意义的
	还有建立任务时,会给每个任务配置一个TCB结构,OSTickCtr在
	TCB的u一些重要内容内容:
	tcb->TimeQuanta : 任务被设置的时间片大小,与时间片调度有关
	tcb->TimeQuantaCtr : 时间片计时 的操作变量
	tcb->TickRemain , tcb->TickCtrPrev : 都是关于 Task 延时执行用到的延时计数器变量,
					     根据不同操作模式,使用不同 计数器变量
					     还有 要配合 OSTickCtr 使用!!
	这里有个很严重的问题,TickTask 执行的时机问题
	首先 TickTask 优先级过低, 系统不能比较准确地去执行 TickTask
	TickTask 优先级比较高时, 时钟中断的sem信号一发出就直接调度去执行 TickTask,
		也就中断函数,做了一半,叫跑到 TickTask
		TickTask跑完,又没有调回到没有完成的中断函数,调到别处任务.
		导致 系统崩溃, 芯片在别处任务死循环!
	问题描述,
		当芯片当前执行任务A时,时钟中断,插入执行 OSTimeTick()
		OSTimeTick() 发出sem信号给 TickTask,
		如果此刻 TickTask的优先级 比 任务A优先级 高
		当场转到 TickTask执行 ,	
		TickTask执行完,执行 Ossched() 调度.
		如果 发现 比 任务A优先级 高 的任务B在就绪队列,就跳去任务B执行
		如果 发现 与任务A优先级相同优先级的任务C,在任务A前面,就跳去任务C执行
		不管那个,都没有回到 任务A把余下的时钟中断任务执行完.
		即没有回去 把中断开关重新打开,所以 芯片就会在任务B/C里死循环
	官方建议 一般设置 TickTask 优先级是 比所有重要任务的优先级低, 
	而 a5d2 这里不一样, TickTask 优先级一定要比其他所有任务的优先级别都要低,不然一定会出现上述问题!!
	这同样是由于 移植的不完全性,要彻底解决这个问题,跟解决时间片调度一样
	需要 重新设计 OSIntCtxSw, irqhandler 和 AIC控制 
	添加一个功能,不管什么时候调度,调度后到达的新任务,一定要先检查中断总开关是否已经打开!!
	这是迄今发现 的 中断总开关 重新打开的方法
	    ;by william  这段是 重新启动中断的内容,但这里只演示不执行!!
	    ;msr         CPSR_c, #ARM_MODE_IRQ | I_BIT | F_BIT
	    ;msr         CPSR_c,  #0x12 | 0x80 | 0x40
	    ; Acknowledge interrupt
	    ;ldr         lr, =AT91C_BASE_AIC
	    ;str         lr, [r14, #AIC_EOICR]










20180416
移植QRCode
使用 openqr 和 opencv 解码
	IplImage  *camera; //opencv的数据格式 , 帧图片属性
	Cvsize size;	//opencv的数据格式 , 帧图片大小
	size.height = IMAGE_HEIGHT;
	size.width  = IMAGE_WIDTH;
	type = IPL_DEPTH_8U;	//图像深度,指每个像素点是所用位数!!这里是8位像素点意思,0-255取值	   
  	camera = cvCreateImageHeader(size,type,1);
		//初始化一个 IplImage 数据变量 (opencv 数据结构)
  	camera->imageData = camera->imageDataOrigin = (char*)cap_dest_buf;
		//设置 帧图片地址.
	QrdecoderHandle decoder = qr_decoder_open()	
		//openqr 的函数 建一个 QRhandle
		// QrdecoderHandle 是一个 void 指针,所以不代表任何数据结构
		// qr_decoder_open() 得到一个ImageReader 类变量,(openqr的数据结构)
		// 把地址传给了 QrdecoderHandle
	qr_decoder_set_image_buffer( QrdecoderHandle decoder, _IplImage camera) 
		//openqr 的函数 (用到了 opencv的数据结构)
		//设置 imagebuffer
	qr_decoder_is_busy(QrdecoderHandle decoder)
		//检查 decoder 是否忙碌,如果空闲,就可以接下来讨论的decode工作!!
	int flag = qr_decoder_detect(decoder);
		//查看图片中是否有 QR图
	if ((flag & QR_IMAGEREADER_NOT_FOUND_FINDER_PATTERN) ==0)
		//这句话的意思是 如果发现了图片中有 QR 位图时!!
	for(sz=25,flag=0; (sz>=19)&&((flag&QR_IMAGEREADER_DECODED)==0); sz-=2)
	{flag= qr_decoder_decode(decoder,sz);}
		//decode QR
		//首先,通过给 cvAdaptiveThreshold 某程度值sz,把图片转成没噪点的黑白图片
		//然后解码这张图片,
		//假如解码不成功,
		//用别的 sz 值,重复上述过程
	QrCodeHeader header;
	if((flag == 0x2000) || (flag == 0x2008)){	//如果成功 decode
	  if( qr_decoder_get_header(decoder,&header)){
	    if(text_size<header.byte_size+1){
	      if(text)
	         delete text;
	      text_size=header.byte_size+1;
	      text=new unsigned char[text_size];
	    }
	    qr_decoder_get_body(decoder,text,text_size);
	    printf("QR Scanner Result:%s\n\r",text);
	  }
	}
		//如果成功 decode 就返回 解码得到的数据
学习建立 动态，静态软件库！！ (IAR)	
	没什么特别就是 creat new project -> Externally built executable 新建一个空白工程
	project -> options -> General Options -> output -> output_file -> Library
	project -> options -> General Options -> target
		大小端模式,一般是小端模模式,
		处理器架构,设备无关时一般选 none,否则选合适处理器 和 合适浮点运算器.
	project -> options ->library builder 设置 库文件最终的生成路径
	然后就额可以了
	然后添加自己的 c文件, h文件!!
	最好,把h文件添加到 库项目的项目树里,而不是仅仅在project -> options 添加include路径
	最后用一个 总 h 文件,囊括所有 h文件!!
	写 配对的 h c文件有以下通用注意事项,以 abc.c abc.h 为例:
	abc.c上定义函数和变量
	abc.h上 extern声明 函数和变量, 还有定义一些宏 和 typedef
	定义变量 的 书写习惯!!	






20180417
opencv学习: https://blog.csdn.net/w_k_l/article/details/74887145
	分 2.4+ 和 3.0+ 两个不同框架的版本
以2.4.13.6 为例子分析:
	include目录，可以看到有opencv和opencv2这两个文件夹
	opencv这个文件夹里面包含着旧版的头文件。
	opencv2这个文件夹里面包含着具有时代意义的新版OpenCV2系列的头文件。
modules包含着 opencv 基本模块:
    	【calib3d】——其实就是就是Calibration（校准）加3D这两个词的组合缩写。
		这个模块主要是相机校准和三维重建相关的内容。基本的多视角几何算法，
		单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等等。
	【contrib】——也就是Contributed/Experimental Stuf的缩写， 
		该模块包含了一些最近添加的不太稳定的可选功能，不用去多管。
		2.4.8里的这个模块有新型人脸识别，立体匹配，人工视网膜模型等技术。
	【core】——核心功能模块，包含如下内容：
                OpenCV基本数据结构
                动态数据结构
                绘图函数
                数组操作相关函数
                辅助功能与系统函数和宏
                与OpenGL的互操作
	【imgproc】——Image和Processing这两个单词的缩写组合。图像处理模块，这个模块包含了如下内容：
                线性和非线性的图像滤波
                图像的几何变换
                其它（Miscellaneous）图像转换
                直方图相关
                结构分析和形状描述
                运动分析和对象跟踪
                特征检测
                目标检测等内容
	【features2d】 ——也就是Features2D， 2D功能框架 ，包含如下内容：
                特征检测和描述
                特征检测器（Feature Detectors）通用接口
                描述符提取器（Descriptor Extractors）通用接口
                描述符匹配器（Descriptor Matchers）通用接口
                通用描述符（Generic Descriptor）匹配器通用接口
                关键点绘制函数和匹配功能绘制函数
	【flann】—— Fast Library for Approximate Nearest Neighbors，高维的近似近邻快速搜索算法库，包含两个部分：
                快速近似最近邻搜索
                聚类
	【gpu】——运用GPU加速的计算机视觉模块
	【highgui】——也就是high gui，高层GUI图形用户界面，
		包含媒体的I / O输入输出，视频捕捉、图像和视频的编码解码、图形交互界面的接口等内容
	【legacy】——一些已经废弃的代码库，保留下来作为向下兼容，包含如下相关的内容： 
                运动分析
                期望最大化
                直方图
                平面细分（C API）
                特征检测和描述（Feature Detection and Description）
                描述符提取器（Descriptor Extractors）的通用接口
                通用描述符（Generic Descriptor Matchers）的常用接口
                匹配器
	【ml】——Machine Learning，机器学习模块， 基本上是统计模型和分类算法，包含如下内容：
                统计模型 （Statistical Models）
                一般贝叶斯分类器 （Normal Bayes Classifier）
                K-近邻 （K-NearestNeighbors）
                支持向量机 （Support Vector Machines）
                决策树 （Decision Trees）
                提升（Boosting）
                梯度提高树（Gradient Boosted Trees）
                随机树 （Random Trees）
                超随机树 （Extremely randomized trees）
                期望最大化 （Expectation Maximization）
                神经网络 （Neural Networks）
                MLData
	【nonfree】，也就是一些具有专利的算法模块 ，包含特征检测和GPU相关的内容。最好不要商用，可能会被告哦。
	【objdetect】——目标检测模块，包含Cascade Classification（级联分类）和Latent SVM这两个部分。
	【ocl】——即OpenCL-accelerated Computer Vision，运用OpenCL加速的计算机视觉组件模块
	【photo】——也就是Computational Photography，包含图像修复和图像去噪两部分
	【stitching】——images stitching，图像拼接模块，包含如下部分：
                拼接流水线
                特点寻找和匹配图像
                估计旋转
                自动校准
                图片歪斜
                接缝估测
                曝光补偿
                图片混合
	【superres】——SuperResolution，超分辨率技术的相关功能模块
	【ts】——opencv测试相关代码，不用去管他
	【video】——视频分析组件，该模块包括运动估计，背景分离，对象跟踪等视频处理相关内容。
	【Videostab】——Video stabilization，视频稳定相关的组件，官方文档中没有多作介绍，不管它了。	
OpenCV的命名空间
	OpenCV中的C++类和函数都是定义在命名空间cv之内的，有两种方法可以访问。
	第一种是，在代码开头的适当位置，加上 using namespace cv; 这句。
	另外一种是在使用OpenCV类和函数时，都加入cv::命名空间。
	不过这种情况难免会不爽，每用一个OpenCV的类或者函数，都要多敲四下键盘写出cv::，很麻烦。
	所以，浅墨推崇大家在代码开头的适当位置，加上using namespace cv;这句。于是和opencv命名空间一了百了了。
opencv2版本 重要的基本数据类型 Mat
	cv::Mat类是用于保存图像以及其他矩阵数据的数据结构。默认情况下，其尺寸为0，
	我们也可以指定初始尺寸,比如定义一个Mat类对象，就要写cv::Mat pic(320,640,cv::Scalar(100));
	Mat类型作为OpenCV2新纪元的重要基本数据类型 ,它是对应于OpenCV1.0时代的IplImage,主要用来存放图像的数据结构
	例子:
		Mat myMat= imread("dota.jpg"); //从工程目录下把一幅名为dota.jpg的jpg类型的图像载入到Mat类型的myMat中
OpenCV2版本中，最简单的图像载入和显示只需要3个函数，非常便捷。imread( ), namedWindow( )以及imshow( )	
	imread( ) 图[片读入
	namedWindow( ) 定义窗口
	imshow( ) 显示图片
roi 感兴趣的局部领域






20180417
移植 Qr 库到 e70
首先 e70 摄像头的项目是 c项目,奇怪的是, 把他换成 C++ 标准编译时,却跑不了
用到的 cv QR 单独生成库后在 用到摄像头项目
cv qr 是C++ 标准编写的,所以必须 C++ 标准编译时,
即: 
	e70 摄像头的项目 C 标准编译,
	cv qr 是C++ 标准编译
e70 摄像头的项目 要用 cv qr 库,难免有 C 与C++ 冲突的地方
cv qr 库接入 e70 摄像头的项目时
	cxtypes.h
		会用到 math.h 库, e70-softpack有个math.h 与cv qr要真正用到的math.h 冲突
		cv qr要真正用到的math.h 是 IAR 自带的 C库 math.h
		所以吧 e70-softpack有个math.h 屏蔽掉
		还有 C++ 类型转换与 C类型转换 之间有 区别!!
		C++ :  int (floor(value))
		C   :  (int) (floor(value))
	cxmisc.h
		C 没有 函数默认参数的 规则;C++ 有
		C++ : CV_INLINE void* cvAlignPtr( const void* ptr, int align=32 )
		C   : CV_INLINE void* cvAlignPtr( const void* ptr, int align )
		CvMat 定义 为 C++ 与 C 设置了 不同变量, 需要改成一至的!
QR库完完全全是 C++项目,	e70 摄像头的项目要使用的话,必须 变成 C++规范的编译项目!!
	
使用 automode,即 c 文件用 c标准编译,cpp文件用c++标准编译
如果能使 C++ 调用 C 的内容:
在对应 .h文件 添加
#ifdef __cplusplus
extern "C"
{
#endif
///////////////////////
代码段
////////////////////
#ifdef __cplusplus
extern "C"
{
#endif
	现在添加了的有:
	USBD_HAL.h,  
	USBD.h,  
	USBRequests.h,  
	USBDDriver.h, 
	USBDescriptors.h
	usbhs.h
	USBLib_Types.h
	USBVideo.h 
	timetick.h, 
	.c文件也加上!!
	board_memories.h,  isi.h,  image_sensor_inf.h,  xdmad.h, 
换到 iar8 jlink-swd调试,可用,auto模式编译也没问题问题!!
说到底还是 iar7 垃圾的问题!!
开始调试,cvCreatseq
	->Cvseq* = cvMemStorageAlloc( CvMemStorage*,sizeof( Cvseq) )	//申请一个Cvseq结构数据
	->memset( Cvseq*, 0, sizeof( Cvseq) )				//给清空数据内容
	
	cvMemStorageAlloc 出问题!! 
	由于 CvMemStorage ->free_space 小于 sizeof( Cvseq), 所以需要 icvGoNextMemblock 分配空间
	icvGoNextMemblock 分配空间 是以 4096 每block算!! 明显就没有这么大的空间!!
	所以要看初始化 CvMemStorage 时 free_space 设置大小
	heap设置太小 所以 malloc 分配失败
	该linker文件 icf 改heap 大小
usb-video 与 cv库冲突, 所有cv操作在 usb等硬件初始化以后!! 
由于没有处理好 isi取图像的方式, 所以 heap放在sram会与heap冲突
所以 把heap暂时放回 inter-ram,
开始检测 QR解码程序 在 qr_decoder_detect() 死循环:
	会调用 cvCopy(),cvSmoth(),cvCopy() 就是在这里出问题了,导致死在后面 find_finder_pattern 的 for循环
	继续追 发现是 刚开始初始化时 qr_decode_set_image_buffer()的错
	由于我们的图片是 640x480, 16位像素点 yuv格式,
	而 qr 库 是基于 320x240, 8位像素点,yuv格式, 这就大麻烦了!!
	首先,重新 处理 usbvideo 问题,原来是 VIDD_PayloadSent() 的 IsiPrevBuffIndex
		导致不能设置只有一张图片的缓存区时的uvc显示, 屏蔽了就好
	qr库 imagereader类成员 有 5 个 iplimage图片缓存结构数据:
		_img_src_internal, _img_src, _img_transformed
		_img_binarized, _img_tem_lc
		这样就起码有 缓存 5张图片的空间才行!!即要有 5 X 600 kb 空间
	然后 qr_decoder_set_image_buffer() 会指定这几个空间!!!
		然而我的sram只有 2mb 空间.....所以某几个要共用空间!!!
	分析后面的 qr_decoder_detect 和 qr_decoder_decode 分析哪些空间可以共用!!!!
	还有的是先测试使用 opencv 的函数!!
	16位像素点改为 8位!! 因为 cv库只支持8位像素点!!
		usb描述符数据 要改
		isi 通讯 方式要改
		sensor 图像格式要改
	现在很迷的默认情况是这样子的:
		senseor 是 YUV输出的
		isi却以RGB的标准输入!!!
		然后也不知道以什么标准发送数据到上位机了
		反正就是成功了!
		sensor:
			0x12 0x00  //VGA YUV		
			[0x0c 0x50][0x66 0x00]  //{COM3[4], DSP_Ctrl3[7]}=10 -> U0Y0, V1Y1, U2Y2, V3Y3, ...
						//最后我怎么改都没有什么差别,最后我改成这样:
						//[0x0c 0x40][0x66 0x00]
						//{COM3[4], DSP_Ctrl3[7]}=00 -> Y0U0, Y1V1, Y2U2, Y3V3, ...
			0x67 0x00  //表示 yuv或者RGB 格式输出,不是RAW格式输出		
		UVC descriptor:
			USBDDriverDescriptors:
			VS Fromat Uncompressed -> PlayLoad uncompressed format:
				guidYUY2,  //不知道是什么,好像相关的,其实并不相关
				FRAME_BPP, //bits per-pixl  默认16位每像素点 
					   //修改时,直接修改 FRAME_BPP 这个宏定义,因为要把相关参数也改变	
		isi: 
			ISI_setInputStream(RGB_INPUT) //为什么是RGB.难道不是YUV么
			ISI_RgbpixelMapping(ISI_CFG2_RGB_CFG_MODE3) //RGB的模式
	开始改参数看看:
		没有什么意义.
YUV:4:2:2 一定是16位prepixel的,现在我们用到 opencv 处理 要的是 8bit像素点!!
观察了很多,发现 上述的 sensor: UVC descriptor: isi: 都不能轻松改变
	不过确认了,isi设为RGB的方式很迷,但是 获取的视频流 和 usb 传送的视频流都是 YUV422
	sensor:[0x0c 0x40][0x66 0x00] 设定了流格式是 Y0U0, Y1V1, Y2U2, Y3V3, ...
	即单数字节是 Y 亮度  双数字节是 UV 参数
		//把 Y信息拷出来
                pict = (uint8_t *)(ISI_BASE + 0x96000);
                pict2 = (uint8_t *)(ISI_BASE);
                for( i=0; i < (640*480); i++ ){
                       *pict = *pict2;
                       pict++;
                       pict2 += 2;
                }
                //对信息做 smooth 处理
                cvSmooth(picture,picture2,CV_MEDIAN,3);
                //把Y信息拷回去
                pict = (uint8_t *)(ISI_BASE);
                pict2 = (uint8_t *)(ISI_BASE + 0xe1000);
                printf("cvtest\n\r" );
                for( i=0; i < (640*480); i++ ){
                       *pict = *pict2;
                       pict +=2;
                       pict2++;
                }
	我们知道 cvSmooth(..,CV_MEDIAN,..); 只能对 8bits-pixel 做处理
	这里,我们就把 Y 信息当作为 8bits-pixel 做smooth处理了
	这种做法可行!!
	此外开启 cverror显示,在cverror.cpp的cvStdError()添加printf
	发现 cvAdaptiveThreshold 内存溢出,linker文件 icf 增加 heap大小!!
	至此,opencv测试比较成功!!
	开始调试QR,发现 set_Image 还是直接用数字初始化帧缓存地址比较好
	find_finder_pattern()有内存泄漏嫌疑!!
	后面发现,吃内存吃太多了!!
现在尝试降低 图片像素到 320x240
	查看以前的内容 ,其实只改 ov7725 i2c控制的某个地方
	修改main.cpp 之前320x240的地方都被备注了,现在是反过来备注 640x480的,释放320x240的
	修改 usb设备描述符 的 一个默认帧格式内容
	最后成功, 也成功地decode图片,只可惜识别率太低,而且这个使用的库有内存泄漏的毛病!!


	
	






20180504
尝试移植其他库例如 zbar 参考:http://www.cnblogs.com/greyorbit/p/8444961.html
	下载了zbar-0.10
	linux上解压, ./configure
./configure出错:configure: error: test for video support failed! 
	头文件检测问题，2.4以上内核中没有/usr/include/linux/videodev.h，
	只有/usr/include/libv4l1-videodev.h,/usr/include/linux/videodev2.h，
	解决方法如下:
	修改configure.ac
	AC_CHECK_HEADERS([linux/videodev.h] 改为 AC_CHECK_HEADERS([libv4l1-videodev.h]
	修改zbar/video/v4l1.c
	#include <linux/videodev.h> 改为 #include <libv4l1-videodev.h>
	参考:ZBar在Windows上的使用（2）-OpenCV: https://blog.csdn.net/sunflower_boy/article/details/49275439
	修改configure
	for ac_header in linux/videodev.h 为 for ac_header in libv4l1-videodev.h 
	参考:https://blog.csdn.net/s8848/article/details/46485307
重新./configure 出错:configure: error: Unable to find ImageMagick >= 6.2.6:
	安装 ImageMagick
	...有什么缺的 装什么!!
然后把得到config.h拷贝到win7下的codeblock IDE 的zar项目使用
	zar里的源码虽然都是 .c 文件,却有大量 c++ 的语法,比如 inline namespace什么的
	所以需要 把编译器编译c的工具改为 g++,而不是gcc
	还有 zbar 源码 
	codeblock 使用 GCC 编译器,编译 zbar 比较磨人
	主要是 zbar明明是 c 语言,c文件,却用了大量的 C++ 语法, 所以必须用 g++ 编译
	至于 compiler flags 选择C99
	zbar里 大量代码没有按规范的标准写,但是许多 变量赋值格式不对的问题,需要强制转换格式
	测试时生成的 是 win32 命令窗程序,需要用到 win的标准头文件说什么的,
	比如 inttypes.h 但是不能很好识别,所以只能手动改适配内容
	这次例子 仅仅需要zbar的:
		zbar-0.10\zbar\decoder和zbar-0.10\zbar\qrcode
		zbar-0.10\zbar\目录下的config.c,decoder.c,error.c,image.c, 
		img_scanner.c, refcnt.c. scanner.c，symbol.c
	添加时需要注意,避免无关紧要的内容加入,避免不必要的不必要的编译错误扰乱
	添加库时,需要注意以下几点
		最好把不同的库分别独立到一个一个文件夹里,包含 .h,.dll,.lib 等文件
		需要添加 .h路径, 还要添加库路径,不然不能编译通过
		特别是 当库文件是 .dll 形式存在时,.dll 不是 codeblock默认的库文件,
		所以寻选择dll库路径时,需要换上allfile选项才可以看到 dll文件
		此外,还要把所有 dll文件都拷贝到 bin/debug 里
		这样,调试时, bin/debug的.exe文件执行时,程序才会找到dll里对应的函数内容执行
	目前pc的 demo 只识别 条行码,未实现二维码的例子
	换了一张 二维码的 图片, 原来demo例子也能直接识别二维码!!
	添加 实现中文识别:http://www.cnblogs.com/greyorbit/p/8446382.html
codeblock: 搭建opencv: https://blog.csdn.net/goomaple/article/details/45649305
	使用cmake MinGW 重新编译 opencv24136 库
	使用 cmake 出现 libintl-8.dll missing!!: 添加 MinGW/bin 路径到系统变量
	cmake其实就是编译一个 MinGW 编译器的 makefile文件
	而这个 MinGW 编译器 是装 codeblock 自带的, 需要把 MinGW 编译器 的路径加到系统变量上去!!
	cmake后 既可以 使用 cmd 到指定位置 执行 mingw32-make 开始编译opencv库
	make出错: modules\highgui\src\window_w32.cpp:2023:81: error: 'BTNS_AUTOSIZE' was not declared
	修复:
	"commctrl.h" in MinGW directory and something like
	#if 0
	#define _WIN32_IE   0x0300
	#endif
	//then change it to
	#if 1
	#define _WIN32_IE   0x0500
	#endif
	遇到了 编译perf_stitching 时 出现 g++: recipe for target fail, no input files 错误
	并不是真的找不到文件,g++命令行 编译的路径太长了,
	我去,把编译文件夹的路径改回 E盘上直接编译通过
	最后 mingw32-make install 生成库和头文件包
	最后在codeblock里的配置:
		添加所有 include 路经
		project build option->search direction->linker 添加库文件搜索路径
		project build option->linkersettings 添加所有要用到的库
		把 .dll动态库拷贝到 项目生成文件夹bin/debug上去
 		或者把 .dll 文件夹所在路径添加到 win7环境变量 path
	注意,一旦出现 无法找到 cstdlib 等 一般是 编译器出问题了
	因为这些都是 C++的语法,但是去写在.c文件上,所以需要把 c文件的编译器也换成 g++
opencv打开摄像头!!
	编译opencv时,添加 with_opengl	只是支持gl,但是并没有gl的内容!!
	重新cmake,mingw32-make编译opcv24136,添加所有项,无法编译 opencv_world??
	使用新版本mingw 也无法通过opencv_world编译
	
添加opengl:
	gl glu  基础库 这几个好像是 系统硬件自带的 ????
	glut:	opengl unity toolkit gl超集, 一个opengl实现窗口的辅助库
	glew	不能用 mingw32-make ,反而是网上找了个脚本生成了必要的lib
	freeglut :发现使用codeblock自带mingw无法比编译,下载了一个新版本的MinGW编译通过
		MinGW 在win上有一个专门的套装管理软件,通过软件更新 MinGW 工具
		所以 要替换 codeblock的 mingw 务求编译工具统一!!
	mesa: 相当麻烦:
		先安装python2.7
		安装python套件Mako :python setup.py install
		安装python套件scon
		安装python套件pywin32
		安装 mingw 的 flex bison,在mysy终端里命令安装 其实套件已经捆绑安装了!!
		按炸安装 win_flex_bison
		还是失败!!
使用opengl 比我想i想象中要复杂!! :http://www.sci.brooklyn.cuny.edu/~goetz/codeblocks/glut/
	原来最基础的 gl glu 并不能通过编译得到,而是硬件自带的,
	我尝试编译的还编译不成功的glu,只不过是gl库的窗口显示实现库
	codeblock如果要实现opengl项目,需要建议一个 glut 项目, 而不是在一个空白项目里移植opengl
	这样就只需要解决 glut库的问题,而不需要处理 glu32.lib opengl32.lib等 gl,glu级别库的问题!!

使用opencv 问题
	主流 例子都是基于 opcv2.4.9 - 2.4.11
	我去 用了 2.4.13 变化居然这么大 findcontours 机制直接换了, qnmb 

凑齐代码片,可以对组装 二维码识别程序,但是定位代码还是不理想!!












20180517
opengl基本认识
配置参数
	编译参数加 -DGLUT_DISABLE_ATEXIT_HACK（也可以在代码里#define GLUT_DISABLE_ATEXIT_HACK），
	链接参数加上-lopengl32 -lglu32 -lglut32
	mingw 本身就是 32 位，所以不需要特别设置。如果是用的 mingw-w64，需要在参数里加上 -m32
	但是我是在 codeblock 上的,而不是ubuntu的编译环境上,所以需要 在一个glut 项目下执行
OpenGL函数库相关的API有核心库(gl)，实用库(glu)，辅助库(aux)、实用工具库(glut)，窗口库(glx、agl、wgl)和扩展函数库等。
	gl是核心，
	glu是对gl的部分封装。
	glx、agl、wgl 是针对不同窗口系统的函数。
	glut是为跨平台的OpenGL程序的工具包，比aux功能强大（aux很大程度上已经被glut库取代。）。
	扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。
	gl 和 glu 都是 硬件平台相关的,可以认为编译工具,win7 ubuntu等等自带的!!
	glut就得自己去编译安装了!! 
OpenGL的竞争对手是Direct3D；OpenGL对应的开源实现是mesa 3D。
glut：OpenGL工具库 OpenGL Utility Toolkit
	这部分函数以glut开头，主要包括窗口操作函数，窗口初始化、窗口大小、窗口位置等函数；
	回调函数：响应刷新消息、键盘消息、鼠标消息、定时器函数等；创
	建复杂的三维物体；菜单函数；程序运行函数。
	gult对应的开源实现是freegult。
窗口库GLX
	对于X窗口系统，它所使用的的OpenGL扩展（GLX：OpenGL extension for X.）是作为OpenGL的一个附件提供的，
	所有的GLX函数都使用前缀glX。
	apl、wgl分别用于apple、windows。
glew
	GLUT或者FREEGLUT主要是1.0的基本函数功能；GLEW是使用OPENGL2.0之后的一个工具函数。
	不同的显卡公司，也会发布一些只有自家显卡才支 持的扩展函数，
	你要想用这数涵数，不得不去寻找最新的glext.h,有了GLEW扩展库，你就再也不用为找不到函数的接口而烦恼，
	因为GLEW能自动识别你的平台所支持的全部OpenGL高级扩展函数。也就是说，
	只要包含一个glew.h头文件，你就能使用gl,glu,glext,wgl,glx的全部函数。
glfw
	GLFW无愧于其号称的lightweight的OpenGL框架，的确是除了跨平台必要做的事情都没有做，
	所以一个头文件，很少量的API，就完成了任务。
	GLFW的开发目的是用于替代glut的，从代码和功能上来看，我想它已经完全的完成了任务。
	一个轻量级的，开源的，跨平台的library。支持 OpenGL及OpenGL ES，用来管理窗口，读取输入，处理事件等。
	因为OpenGL没有窗口管理的功能，
	所以很多热心的人写了工具来支持这些功能，比如早期的glut，现在的freeglut等。
	那么GLFW有何优势呢？glut太老了，最后一个版本还是90年代的。
	freeglut完全兼容glut，算是glut的代替品，功能齐全，但是bug太多。稳定性也不好（不是我说的啊），
	GLFW应运而生。







20180518
opencv学习:
	目前网上最广泛的是 2.4.9 版本
	做二维码的时候 发现 opencv 很多基本内容还是需要掌握比较好!!
	1.x版本 基本数据类型是 Iplimgge
	2.x后 基本数据类型是 Mat
Mat
	通用矩阵类, 创建函数有
	Mat::Mat()      //无参数构造方法
	Mat::Mat(int rows, int cols, int type)  /*创建行数为rows，列数为cols，类型为type的图像*/
	Mat::Mat(Size size, int type) /*创建大小为size，类型为type的图像*/
	/*创建行数为rows，列数为cols，类型为type的图像并将所有元素初始化为s*/
	Mat::Mat(int rows, int cols, int type, const Scalar& s)
	ex:Mat(3,2,CV_8UC1, Scalar(0))  //三行两列所有元素为0的一个矩阵
	Mat::Mat(Size size, int type, const Scalar& s) /*创建大小为size，类型为type，初始元素为s*/
	Mat::Mat(const Mat& m)  //将m赋值给新创建的对象,此处不会发生数据赋值，而是两个对象共用数据
	/*创建行数为rows，列数为cols，类型为type的图像
	此构造函数不创建图像数据所需内存而是直接使用data所指内存
	图像的步长由step指定*/
	Mat::Mat(int rows, int cols, int type, void* data, size_t step = AUTO_STEP)
	Mat::Mat(Size size, int type, void* data, size_t step = AUTO_STEP)  //同上
	/*创建新的图像为m数据的一部分，其具体的范围由rowRange和colRange指定
	此构造函数也不进行图像数据的复制操作，与m共用数据*/
	Mat::Mat(const Mat& m, const Range& rowRange, const Range& colRange)
	/*创建新的矩阵为m的一部分，具体的范围由roi指定
	此构造函数同样不进行数据的复制操作与m共用数据*/
	Mat::Mat(const Mat& m, const Rect& roi)
	在构造函数中很多都涉及到type，type可以是:CV_8UC1, CV_8UC3, …，CV_64FC4等。这些type中:
	8U表示8位无符号整数(unsigned int), 
	16S表示16位有符号整数，
	64F表示64位浮点数即double类型,
	C表示channel表示图像通道，C后面的数字表示通道数。如C1表示单通道图像，C4表示4通道图像，以此类推。
	如果需要更多的通道数，需要使用宏CV_8UC(n)重定义，其中n是需要的通道数。例如:
		Mat M(3, 2, CV_8UC(5));     //创建3行2列通道为5的图像
	也可以使用create()函数创建对象,值得注意的是使用create()函数无法初始化Mat类 例如:
		M1.create(4,4,CV_8UC(2));
	opencv也可以使用Matlab的风格创建函数如：zeros(),ones()和eyes()。
	这些方法使得代码非常简洁，使用也非常方便。在使用这些函数时需要指定图像的大小和类型。例如	
		Mat M1 = Mat::zeros(2,3,CV_8UC1); //0矩阵
		Mat M2 = Mat::ones(2,3,CV_32F);	//1矩阵
		Mat M3 = Mat::eye(4,4,CV_64F); //对角线为1的矩阵
	在已有Mat类的基础上创建一个Mat类，即新创建的类是已有Mat类的某一行或某一列，可以使用clone()或copyTo()，
	这样的构造方式不是以数据共享方式存在。可以利用setTo()函数更改矩阵的值进行验证， 例如
		    Mat M1=(Mat_<double>(3,3) << 0,-1,0,-1,5,-1,0,-1,0);
			    cout << "M1 = " << endl << " " << M1 << endl << endl;
		    Mat M2 = M1;
			    cout << "M2 = " << endl << " " << M2 << endl << endl;
		    Mat RowClone = M1.row(0).clone();
			    cout << "RowClone = " << endl << " " << RowClone << endl << endl;	
		    Mat ColClone = M1.col(1).clone();
			    cout << "ColClone = " << endl << " " << ColClone << endl << endl;
		    Mat copyToM;
		    M1.row(1).copyTo(copyToM);
			    cout << "copyToM = " << endl << " " << copyToM << endl << endl;
		
		    //验证数据的共享方式		
		    RowClone.setTo(1);
			    cout << "M1(更改RowClone的值) = "<< endl  << " " << M1 << endl << endl;	
		    ColClone.setTo(2);
			    cout << "M1(更改ColClone的值) = "<< endl << " " << M1 << endl << endl;		
		    M2.setTo(1);
			    cout << "M1(更改M2值) = " << endl << " " << M1 << endl << endl;
imread 图片加载   Mat imread( const String& 图片路径名, int flags = IMREAD_COLOR );
	flags是一个枚举类型。对各个参数简单解释一下：
	IMREAD_UNCHANGED:已经废除，不再使用
	IMREAD_GRAYSCALE=0:将加载的图像转换为单通道灰度图。
	IMREAD_COLOR=1:函数默认值，将图像转化为三通道BGR彩色图像
	IMREAD_ANYDEPTH=2:若载入图像深度为16位或32为就返回其对应深度，否则将图像转换为8位图像
	IMREAD_ANYCOLOR=4:保持图像原格式，可以读取任意可能的彩色格式
	IMREAD_LOAD_GDAL=8:使用文件格式驱动加载图像，在现阶段用处不多。 
	在使用flags时可能会同时使用多种flags，如果发生冲突，函数将自动采用较小数字值对应的加载方式。
	如：IMREAD_COLOR | IMREAD_ANYCOLOR，
	则imread()函数将自动载入IMREAD_COLOR所对应的3通道彩色图。
	如果要载入图像原本的彩色格式和深度，则可以使用: IMREAD_ANYCOLOR | IMREAD_ANYDEPTH。
	也可以利用flags是int类型的变量输入其他值以达到加载特定图像格式的目的，但符合一下标准：
	flags > 0:返回一个三通道的彩色图像
	flags = 0: 返回灰度图像
	flags < 0: 返回包含Alpha通道的图像。
	图像在默认情况下不是从Alpha通道进来的，如果需要载入Alpha通道的话就取负值
namedwindow 创建窗口   void namedWindow(const String& 窗口名 int flags = WINDOW_AUTOSIZE);	
	flags是一个枚举类型。对各个参数简单解释一下：
	WINDOW_NORMAL:可以改变窗口大小（无限制），也可将一个满屏窗口转换成常用大小；
	WINDOW_AUTOSIZE：程序会根据呈现内容自动调整大小且不能手动更改窗口大小；
	WINDOW_OPENGL：创建支持OpenGL的窗口；
	WINDOW_FULLSCREEN：创建一个充满屏幕的窗口；
	WINDOW_FREETATIO：图像将尽可能展开;
	WINDOW_KEEPRATIO：图像比例受到约束。
	namedWindow()函数是通过指定的名字创建一个作为图像和进度条显示的窗口，
	如果有相同名称的窗口已经存在，则函数不会重复创建窗口，而是什么都不做。
	可以调用destroyWindows()或者destroyAllWindows()函数来关闭窗口并取消之前分配的与窗口相关的所有内存空间。
imshow 显示图片   void imshow(const String& 窗口名, InputArray mat(要显示的图片的Mat矩阵));
	如果没有对应窗口会自动建立一个
imwrite 图片写入文件  bool imwrite( const String& 被保存的文件路径名(注意符号要用\引用), InputArray 被保存图片mat, 
				const std::vector<int>& params = std::vector<int>());
	const std::vector…:表示为特定保存格式的参数编码，在一般情况下不需要更改。
	如果需要更改的话，对于不同的图片格式，其对应的值由不同功能。如下：
	JPEG：这个参数表示从0-100的图片质量(CV_IMWRITE_JPEG_QUALITY),默认值是95.
	PNG: 这个参数表示压缩级别(CV_IMWRITE_PNG_COMPRESSION)，范围为0-9，
		数值越高说明压缩程度越大即尺寸更小，所花费的时间更长。默认值是3
	PPM,PGM,PBM: 这个参数表示一个二进制标志(CV_IMWRITE_PXM_BINARY)，取值为0或1，而默认值为1。
opencv计时函数:
	double t = (double)getTickCount();
	//...program....
	t = ((double)getTickCount()-t)/getTickFrequency();
opencv Mat 图像数据位置模型,例如:
	(单通道)
		column0 column1 column2 column3	...
	row0	2	9	9	9
	row1	7	7	7	5
	row2	8	8	8	8
	...
	(多通道例如 3通道RGB, 不过是以BGR排序存储)
		column0 column1 column2 column3	...
	row0	b2g1r4	b2g1r6	b2g1r4	b2g4r49
	row1	b2g1r4	b2g1r6	b2g1r4	b2g4r49
	row2	b2g1r4	b2g1r6	b2g1r4	b2g4r49
	...
	很多情况下可以如果内存足够大可以实现连续存储。
	连续存储有助于提升图像扫描速度，可以使用 isContinuous() 来判断矩阵是否是连续存储
	一个遍历例子 看穿 图像数据存储框架结构
	    Mat colorImage;
	    for(int i = 0; i < colorImage.rows; ++i)         //遍历行
	        for(int j = 0; j < colorImage.cols; ++j)     //遍历列
	        {
	            Vec3b pixel;            //定义三通道像素值变量
	            pixel[0] = i % 255;     //Blue
	            pixel[1] = j % 255;     //Green
	            pixel[2] = 0;           //Red	

	            colorImage.at<Vec3b>(i, j) = pixel;
	        } 
	  imshow("test",colorImage);
	使用迭代器 iterator 的遍历例子更安全,
	    Mat colorImage;
	    int i = 0;
	    MatIterator_<Vec3b> colorit, colorend;
	    for(colorit = colorImage.begin<Vec3b>(), colorend = colorImage.end<Vec3b>(); colorit != colorend; ++colorit)
	    {
		i += 1
	        (*colorit)[0] = i % 255;       //Blue
	        (*colorit)[1] = rand() % 255;       //Green	rand()是随机数生成函数
	        (*colorit)[2] = rand() % 255;       //Red
	    }
	使用指针遍历  时间最快
	    for(int i = 0; i < colorImage.rows; ++i)
	    {
	        Vec3b* p = colorImage.ptr<Vec3b>(i);
	        for(int j = 0; j < colorImage.cols; ++j)
	        {
	            p[j][0] = i % 255;      //Blue
	            p[j][1] = j % 255;      //Gree
	            p[j][2] = 0;            //Red
	        }
	     }

卷积过滤运算: void filter2D( InputArray src(原图), OutputArray dst(目标图), int ddepth(图像深度),
                            InputArray kernel(卷积核), Point anchor=Point(-1,-1),
                            double delta=0, int borderType=BORDER_DEFAULT );
	ddepth输入值为-1时，目标图像和原图像深度保持一致
	InputArray kernel: 卷积核（或者是相关核）,一个单通道浮点型矩阵。
		如果想在图像不同的通道使用不同的kernel，可以先使用split()函数将图像通道事先分开
	Point anchor: 内核的基准点(anchor)，其默认值为(-1,-1)说明位于kernel的中心位置。
		基准点即kernel中与进行处理的像素点重合的点。	
	double delta: 在储存目标图像前可选的添加到像素的值，默认值为0
	int borderType: 像素向外逼近的方法，默认值是BORDER_DEFAULT,即对全部边界进行计算。
		该函数使用于任意线性滤波器的图像，支持就地操作。当其中心移动到图像外，
		函数可以根据指定的边界模式进行插值运算。函数实质上是计算kernel与图像的相关性而不是卷积
		也就是说kernel并不是中心点的镜像，
	如果需要一个正真的卷积，使用函数flip()并将中心点设置为(kernel.cols - anchor.x - 1, kernel.rows - anchor.y -1).
	该函数在大核(11x11或更大)的情况下使用基于DFT的算法，而在小核情况下使用直接算法(使用createLinearFilter()检索得到). 
图像叠加:  void addWeighted(InputArray src1, double alpha, InputArray src2,
                              double beta, double gamma, OutputArray dst, int dtype=-1);
	src1: 第一幅输入图像
	alpha: 线性混合时第一幅图像的权重
	src2: 第二幅输入图像
	beta: 第二幅输入图像的权重
	dst: 图像线性混合后的目标图像
	gamma: 添加到每一个线性叠加总和的gamma值
	dtype: 目标图像深度，当两幅图像深度相同时可以将dtype置为-1,这样目标图像的深度将与输入图像相同
	其中 beta = (1.0 - alpha);
	dst = alpha*src1 + beta*src2 + gama
	注意：两幅图像混合时必须要求两幅图像的尺寸和类型完全相同。
ROI区域(感兴趣区域)
	从图像左上角(100,100)的位置 获得ROI
	ROIImage = srcImage(Rect(100,100,smallImage.cols,smallImage.rows));
		从把整张 smallImage 作为一个区域,
		在 srcImage 划分了一个 ROi区域 
		得到 一张 ROI区域图,
		ROI区域图 与 srcImage 的这个ROI区域 共用一个矩阵数据空间
	ROIImage = srcImage(Range(100,smallImage.rows),Range(100,smallImage.cols));
		Range()指定的区域是一个连续的存储序列。
		同理也是的得到一个 ROI区域图, 与srcImage 的这个ROI区域共用矩阵空间
	例子1:
	Mat imageROI = srcImage(Rect(50,50,addImage.cols,addImage.rows));//得到 ROI区域图
	addWeighted(imageROI,0.7,addImage,0.3,0,imageROI); //给这个ROI区域图 叠加效果
	imshow("混合后图像",srcImage);//可以看到,先当于在 srcImage的 ROI区域做了叠加效果
	例子2:
	Mat imageROI = srcImage(Range(50,50+addImage.rows), Range(50,50+addImage.cols));//得到 ROI区域图
	addImage.copyTo(imageROI,maskImage); //直接把addImage拷贝到这个ROI区域图,
					     //maskImage是addImage的灰度图,这是copyto的规则
	imshow("混合后图像",srcImage);//可以看到,先当于在 srcImage的 ROI区域做了叠加了addImage图片
变化滑条观察参数变化: int createTrackbar(const string& trackbarname, const string& winname,
                              int* value, int count,
                              TrackbarCallback onChange = 0,
                              void* userdata = 0);
	const string& trackname: 滑动条名字
	const string& winname: 想要把该滑动条依附到的窗口名字，在程序中可能该窗口名称由namedWindow()声明。
	int* value: 创建滑动条时，滑动条的初始值
	int count: 滑动条的最大值，即所有滑动条的数据变动都要在0-count之间，滑动条最小值为0
	TrackbarCallback onChange = 0: 这是指的回调函数，每次滑动条数据变化时都对该函数进行回调
	void* userdata = 0: 这个是用户传给回调函数的数据，用来处理滑动条数值变动。如果在创建滑动条时，
		输入value实参是全局变量，则本参数userdata可使用默认值0.
	例子:
	const int g_nTrackbarMaxValue = 100;     //滑动条最大值
	int g_nTrackbarValue;                    //滑动条对应的值
	char trackBarName[100];
	double g_dAlphaValue;                   //第一幅图权重
	double g_dBetaValue;                    //第二幅图权重
	Mat g_srcImage1, g_srcImage2, g_distImage;
	main{
		g_srcImage1 = imread("forest.jpg");
		g_srcImage2 = imread("rain.jpg");	
		sprintf(trackBarName, "透明度 %d", g_nTrackbarMaxValue); //滑条名字
		namedWindow("混合后图像",WINDOW_NORMAL);     //滑动条依附的窗口
		g_nTrackbarValue = 20;                      //设置滑动条初始值
		createTrackbar(trackBarName, "混合后图像", &g_nTrackbarValue, g_nTrackbarMaxValue, on_Trackbar);
		on_Trackbar(g_nTrackbarValue, 0);           //主动调用一次回调函数,开始实现on_Trackbar功能
		waitkey(0)
	}
	on_Trackbar(int, void*)	{ //回调函数参数类型必须是(int滑动条位置,void*用户数据)
		//滑动条变化时,createTrackbar的int* value也对应发生变化,即g_nTrackbarValue 变化
		//然后会触发 on_Trackbar 并把int* value 传递到这里的 int
		//用户数据是 是 createTrackbar的 void* userdata 传递过来的数据
		//createTrackbar的 void* userdata 默认一直传递0,
		//所以 on_Trackbar void* 也一直得到 0
		//图像融合的权重在0-1之间，转换输入值和权重之间的比例
		g_dAlphaValue = (double) g_nTrackbarValue / g_nTrackbarMaxValue;
		g_dBetaValue = 1.0 - g_dAlphaValue;     //第二幅图像权重	
		//使用addWeighted函数对图像进行线性混合
		addWeighted(g_srcImage1, g_dAlphaValue, g_srcImage2, g_dBetaValue, 0.0, g_distImage);
		imshow("混合后图像", g_distImage);
	}
int getTrackbarPos(const string& trackbarname, const string& winname);
	获取当前轨迹条的位置并返回
	const string& trackbarname: 滑动条名称
	const string& winname: 滑动条所依附窗口的名称
常见数据类型:
	Point 点
		template<typename _Tp> class Point_
		typedef Point_<int> Point2i;
		typedef Point2i Point;
		Point_与Point2i和Point是等价的
		例子:
			Point pt = Point(10,8);
	Scalar 颜色
		template<typename _Tp> class Scalar_ : public Vec<_Tp, 4> {
			public:
			    //! various constructors
			    Scalar_();
			    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);
			    Scalar_(const CvScalar& s);
			    Scalar_(_Tp v0);
			...
		从定义语句Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);中
		可以看出Scalar最后两个参数都有默认值，故在不适用第四个参数时可以直接忽略。
		typedef Scalar_<double> Scalar;
		例子:
			Scalar colr = Scalar(a, b, c);
			//Scalar代表了一个四元素的vector容器，在opencv中常用来传递像素值。
			//本例子将主要用来表示BGR三个像素的值。如果不使用则最后一个参数不用设置。
	Size 尺寸
		template<typename _Tp> class Size_{
			public:
			    typedef _Tp value_type;			
			    //! various constructors
			    Size_();
			    Size_(_Tp _width, _Tp _height);
			    Size_(const Size_& sz);
			    Size_(const CvSize& sz);
			    Size_(const CvSize2D32f& sz);
			    Size_(const Point_<_Tp>& pt);
			....
		typedef Size_<int> Size2i;
		typedef Size_<double> Size2d;
		typedef Size2i Size;
		例子:	
			Size s = Size(20,50);
基本图形绘画: https://blog.csdn.net/keith_bb/article/details/53313202
文字处理: https://blog.csdn.net/keith_bb/article/details/53366674

split()函数 颜色通道分离函数，其定义如下所示：(两种形式)
	CV_EXPORTS void split(const Mat& src, Mat* mvbegin);
	CV_EXPORTS void split(const Mat& m, vector<Mat>& mv );
		第一个参数是输入分离通道的图像
		第二个参数是一个Mat类型的vector容器，用来存放分离后的通道
	例子:
		vector<Mat>channels;
		split(srcImage, channels);
		Mat imageBlueChannel;
		imageBlueChannel = channels.at(0);  //提取蓝色通道
merge()函数 颜色通道合并函数 (两种形式)
	CV_EXPORTS void merge(const Mat* mv, size_t count, OutputArray dst);
	CV_EXPORTS void merge(const vector<Mat>& mv, OutputArray dst );
		第一个参数是一个Mat类型的vector容器，
		第二个参数是合并通道后的图像
	例子:
		vector<Mat>channels;
		split(srcImage, channels);
		Mat imageBlueChannel;
		imageBlueChannel = channels.at(0);  //提取蓝色通道
		//在提取的蓝色通道上，指定ROI区域叠加logoImage
		addWeighted(imageBlueChannel(Rect(50, 50, logoImage.cols, logoImage.rows)), 1.0, logoImage, 0.7,
			0.0, imageBlueChannel(Rect(50, 50, logoImage.cols, logoImage.rows)));
		//把 imageBlueChannel 区域图 + logo图后,还是赋值回 imageBlueChannel 区域图 里
		//注意, 两次调用的 imageBlueChannel(Rect(50, 50, logoImage.cols, logoImage.rows)) 
		//得到的是两个 独立的 ROI区域图,但是他们和imageBlueChannel 共用 imageBlueChannel的一个区域
		//所以在,其中一个区域图修改这个空间,相当于修改  imageBlueChannel 的这个区域!!
		merge(channels, image); //将叠加logo后的蓝色通道与另外两个颜色通道重新融合

图像傅里叶变换dft https://blog.csdn.net/keith_bb/article/details/53389819 
	具体未清晰 dft 的应用领域!!
颜色空间转换 void cvtColor(InputArray src, OutputArray dst, int code, int dstCn=0 );
	大多数彩色图片都是RGB类型，而图像处理时，需要用到灰度图、二值图、HSV、HSI等颜色制式
	InputArray src: 输入图像即要进行颜色空间变换的原图像，可以是Mat类
	OutputArray dst: 输出图像即进行颜色空间变换后存储图像，也可以Mat类
	int code: 转换的代码或标识，即在此确定将什么制式的图片转换成什么制式的图片，
	int dstCn = 0: 目标图像通道数，如果取值为0，则由src和code决定
	在opencv中，其默认的颜色制式排列是BGR而非RGB
	对于24位颜色图像来说，前8-bit是蓝色，中间8-bit是绿色，最后8-bit是红色。
	常见的R,G,B通道的取值范围为：
		0-255 :CV_8U类型图片
		0-65535: CV_16U类型图片
		0-1: CV_32F类型图片 
	需要注意的是cvtColor()函数不能直接将RGB图像转换为二值图像(Binary Image)，
	需要借助threshold()函数，其具体用法请查阅threshold().
	例子:
		//将图像转换为灰度图，采用CV_前缀
		Mat grayImage;
		cvtColor(srcImage, grayImage, CV_BGR2GRAY);     //将图像转换为灰度图
		//将图像转换为HSV，采用COLOR_前缀
		Mat HSVImage;
		cvtColor(srcImage, HSVImage, COLOR_BGR2HSV);    //将图像转换为HSV图
XML和YAML文件:训练人脸模型进行人脸识别时会用得特别多
	opencv提供了对XML和YAML文件进行读写操作的FileStorage类
	FileStorage::FileStorage()
	FileStorage::FileStorage(const string& source, int flags, const string& encoding=string())
	两种构造 FileStore类型数据 方法 :
	一:
		FileStorage fs;
		fs.open("123.xml",FileStorage::WRITE);		
	二:	
		FileStorage fs("123.xml",FileStorage::WRITE)
	写入变量内容:
		fs << "iterationNr" << 100; //值100赋给变量 iterationNr 然后写入 文件
	读取变量内容:
		int itNr;
		fs["iterationNr"] >> itNr;	//读取方式1
		itNr = (int)fs["iterationNr"];	//读取方式2
	例子:
		Mat R = Mat_<uchar>::eye(3, 3);
		T = Mat_<double>::zeros(3, 1);
		fs << "R" << R;     //将R数据写入文件
		fs << "T" << T;     //将T数据写入文件
		fs["R"] >> R;           //从文件中读取数据R
		fs["T"] >> T;           //从文件中读取数据T
	如果数据类型是vector和array类，要在元素前面加上”[“在元素后面加上”]”符号，如下：
		fs << "string" << "[";
		fs << "image1" << "Awesomeness" << "baboon";
		fs << "]";
		//有三个成员的 string 数组
	对于数据结构是maps类型，需要在元素前面和最后加上”{“和”}”符号，如下：
		fs << "Mapping";
		fs << "{" << "One" << 1;
		fs        << "Two" << 2 <<"}"; 
		//一个 Maping (结构体/类)数据的存储
	从文件中读取这些数据的时候我们需要用到 FileNode和FileNodeIterator 数据结构。
	FileStorage类操作符”[]”返回的是一个FileNode数据类型，
	对于连续的节点，可以通过FileNodeIterator进行迭代遍历，其函数功能和C++中iterator一样。
		FileNode n = fs["string"];
		if(n.type() != FileNode::SEQ){
		    cerr << "string is not a sequence! FAIL" << endl;
		    return 1;
		}
		FileNodeIterator it = n.begin(), it_end = n.end();
		for(; it != it_end; ++it)
		{
		    cout << (string)*it << endl;
		}
	对于maps类型的数据结构可以再次使用”[]”操作符来访问给定的变量对象如下：
		n = fs["Mapping"];
		cout << "Two " << (int)(n["Two"]) << "; ";
		cout << "One " << (int)(n["One"]) << endl << endl;
	其他补充: https://blog.csdn.net/keith_bb/article/details/53576453
初步认识 opencv中imgproc库,顾名思义就是image process包括:
	图像处理，像图像滤波、图像形态学（膨胀腐蚀、开运算、闭运算等）、图像缩放等一些图像处理相关知识。
	图像平滑(smoothing)也称为图像模糊(blurring),这里重点介绍使用平滑操作降低图片噪声。
	因为在图像中，噪声的能量大都集中在幅度谱的低频和中频部分，
	而在较高的频段，一些重要的细节信息往往被噪声淹没。
	在一幅图像中，所谓的高频部分是指图像中像素值落差很大的部分，
	而低频则是指像素值与旁边的像素值相差不大甚至相同，
	图像的一些细节的部分往往由高频信息来展现，图像中掺杂的噪声往往也处于高频段，
	这就造成了一些细节信息被噪声淹没，可以根据不同的噪声类型用不同的滤波器进行处理。
	滤波的目的有两个即：
		1.抽出对象的特征作为图像识别的特征模式；
		2.为适应图像处理要求，消除数字图像所混入的噪声 
平均滤波,即模糊滤波,即方框滤波 
	void boxFilter(InputArray src, OutputArray dst, int ddepth, 
		Size ksize, Point anchor=Point(-1,-1), bool normalize=true, int borderType=BORDER_DEFAULT )
	InputArray src: 输入图像，可以是Mat类型
	OutputArray dst: 经滤波后输出图像
	int ddepth: 目标图像的深度，若设置为-1,则深度与原图像深度相同
	Size ksize: Size类型，内核的大小，一般用Size(w, h)表示，如Size(3, 3)表示kernel窗口大小为3x3
	Point anchor = Point(-1,-1): 进行滤波操作的点，如果是默认值(-1, -1)说明对上述窗口中心点所对应的像素点进行操作
		这里anchor就是滤波操作的位置点,就是滤波卷积核卷积得到的结构,替换卷积核那个位置上对应的图像的像素点
		Point(-1,-1) 指结果替换 卷积核中心位置对应的像素点
	bool normalize = true: 内核是否被归一化处理，有默认值true
	int borderType = BORDER_DEFAULT: 用于腿短图像外部像素的某种便捷模式，有默认值BORDER_DEFAULT. 	
	其实就是求像素点与周边像素点算出的平均值 取代当前 像素点值
平均滤波还有一个成员 blur , 
	发现 blur 与 bocFillter 应该工作内容是一样的,不知道为啥要分别写出两个独立函数
	void blur(InputArray src, OutputArray dst, Size ksize, 
		Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
	InputArray src: 输入图像，可以是Mat类型，图像深度是CV_8U、CV_16U、CV_16S、CV_32F以及CV_64F其中的某一个。
	OutputArray dst: 输出图像，深度和类型与输入图像一致
	Size ksize: 滤波模板kernel的尺寸，一般使用Size(w, h)来指定，如Size(3,3)
	Point anchor=Point(-1, -1): 字面意思是锚点，也就是处理的像素位于kernel的什么位置，
		默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改
	int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT
	例子: 变化滑动条演示滤波效果
	Mat g_srcImage;         //定义输入图像
	Mat g_dstImage;         //定义目标图像
	const int g_nTrackbarMaxValue = 9;      //定义轨迹条最大值
	int g_nTrackbarValue;                   //定义轨迹条初始值
	int g_nKernelValue;                     //定义kernel尺寸
	void on_kernelTrackbar(int, void*);     //定义回调函数
	int main()
	{
	    g_srcImage = imread("lena.jpg");
	    //判断图像是否加载成功
	    if(g_srcImage.empty())
	    {
	        cout << "图像加载失败!" << endl;
	        return -1;
	    }
	    else
	        cout << "图像加载成功!" << endl << endl;	
	    namedWindow("原图像",WINDOW_AUTOSIZE);     //定义窗口显示属性
	    imshow("原图像",g_srcImage);	
	    g_nTrackbarValue = 1;
	    namedWindow("均值滤波", WINDOW_AUTOSIZE);   //定义滤波后图像显示窗口属性	
	    //定义轨迹条名称和最大值
	    char kernelName[20];
	    sprintf(kernelName, "kernel尺寸 %d", g_nTrackbarMaxValue);    	
	    //创建轨迹条
	    createTrackbar(kernelName, "均值滤波", &g_nTrackbarValue, g_nTrackbarMaxValue, on_kernelTrackbar);
	    on_kernelTrackbar(g_nTrackbarValue, 0);	
	    waitKey(0);	
	    return 0;
	}	
	void on_kernelTrackbar(int, void*)
	{
	    //根据输入值重新计算kernel尺寸
	    g_nKernelValue = g_nTrackbarValue * 2 + 1;	
	    //均值滤波函数
	    blur(g_srcImage, g_dstImage, Size(g_nKernelValue, g_nKernelValue));	
	    imshow("均值滤波", g_dstImage);
	}
高斯滤波: void GaussianBlur(InputArray src, OutputArray dst, Size ksize, 
		double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT )	
	InputArray src: 输入图像，可以是Mat类型，图像深度为CV_8U、CV_16U、CV_16S、CV_32F、CV_64F。
	OutputArray dst: 输出图像，与输入图像有相同的类型和尺寸。
	Size ksize: 高斯内核大小，这个尺寸与前面两个滤波kernel尺寸不同，
		ksize.width和ksize.height可以不相同但是这两个值必须为正奇数，如果这两个值为0，他们的值将由sigma计算。
	double sigmaX: 高斯核函数在X方向上的标准偏差
	double sigmaY: 高斯核函数在Y方向上的标准偏差，
		如果sigmaY是0，则函数会自动将sigmaY的值设置为与sigmaX相同的值，
		如果sigmaX和sigmaY都是0，这两个值将由ksize.width和ksize.height计算而来。
		具体可以参考getGaussianKernel()函数查看具体细节。建议将size、sigmaX和sigmaY都指定出来。
	int borderType=BORDER_DEFAULT: 推断图像外部像素的某种便捷模式，
		有默认值BORDER_DEFAULT，如果没有特殊需要不用更改，具体可以参考borderInterpolate()函数。	
中值滤波:
	中值滤波是一种典型的非线性滤波，是基于排序统计理论的一种能够有效抑制噪声的非线性信号处理技术，
	基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值，让周围的像素值接近真实的值从而消除孤立的噪声点。
	该方法在取出脉冲噪声、椒盐噪声的同时能保留图像的边缘细节。这些优良特性是线性滤波所不具备的。
	中值滤波首先也得生成一个滤波模板，将该模板内的各像素值进行排序，
	生成单调上升或单调下降的二维数据序列，二维中值滤波输出为g(x, y)=medf{f(x-k, y-1),(k, l∈w)}，
	其中f(x,y)和g(x,y)分别是原图像和处理后图像, w为输入的二维模板，能够在整幅图像上滑动，
	通常尺寸为3*3或5*5区域，也可以是不同的形状如线状、圆形、十字形、圆环形等。
	通过从图像中的二维模板取出奇数个数据进行排序，用排序后的中值取代要处理的数据即可。
	中值滤波对消除椒盐噪声非常有效，能够克服线性滤波器带来的图像细节模糊等弊端，
	能够有效保护图像边缘信息，是非常经典的平滑噪声处理方法。
	在光学测量条纹图像的香味分析处理方法中有特殊作用，但在条纹中心分析方法中作用不大。
	中值滤波相较于线性滤波中的均值滤波优点在前面已经提到，取得良好滤波效果的代价就是耗时的提升，
	可能达到均值滤波的数倍，而且对于细节较多的图像也不太适用。
	void medianBlur(InputArray src, OutputArray dst, int ksize)
	InputArray src: 输入图像，图像为1、3、4通道的图像，当模板尺寸为3或5时，
		图像深度只能为CV_8U、CV_16U、CV_32F中的一个，如而对于较大孔径尺寸的图片，图像深度只能是CV_8U。
	OutputArray dst: 输出图像，尺寸和类型与输入图像一致，可以使用Mat::Clone以原图像为模板来初始化输出图像dst
	int ksize: 滤波模板的尺寸大小，必须是大于1的奇数，如3、5、7……
双边滤波:
	void bilateralFilter(InputArray src, OutputArray dst, int d, double sigmaColor, 
		double sigmaSpace, int borderType=BORDER_DEFAULT )
	InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。
	OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。
	int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。
	double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，
		表明该像素邻域内有月宽广的颜色会被混合到一起，产生较大的半相等颜色区域。
	double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，
		则意味着颜色相近的较远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。
		当d>0时，d指定了邻域大小且与sigmaSpace五官，否则d正比于sigmaSpace.
	int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT.
	双边滤波器可以很好的保存图像边缘细节而滤除掉低频分量的噪音，
	但是双边滤波器的效率不是太高，花费的时间相较于其他滤波器而言也比较长。
	对于简单的滤波而言，可以将两个sigma值设置成相同的值，如果值<10，则对滤波器影响很小，
	如果值>150则会对滤波器产生较大的影响，会使图片看起来像卡通。 
各滤波比较: https://blog.csdn.net/keith_bb/article/details/54429750
通用滤波算法:
	从上面的滤波算法知道,滤波几乎计划就是通过 卷积核对图片执行卷积操作的算法,
	所以这里给出了通用的卷积算法
	void cv::filter2D  ( InputArray  src,  
	  OutputArray  dst,  
	  int  ddepth,  
	  InputArray  kernel,  
	  Point  anchor = Point(-1,-1),  
	  double  delta = 0,  
	  int  borderType = BORDER_DEFAULT  
	 )  
	InputArray src: 输入图像
	OutputArray dst: 目标图像，其尺寸和通道与输入图像一致
	int ddepth: 期望的目标图像类型，其对应关系如下：
		inputdepth		ddepth
		CV_8U		->	-1,CV_16S,CV_32F,CV_64F
		CV_16U,CV_16S	->	-1,CV_32F,CV_64F
		CV_32F		->	-1,CV_32F,CV_64F
		CV_64F		->	-1,CV_64F
	InputArray kernel: 自定义的卷积核kernel，单通道浮点型矩阵， 如果想在不同的通道使用不同的卷积kernel，
		可以将图像首先使用split函数将不同的颜色通道分离，然后对每个颜色通道单独进行处理。
	Point anchor = Point(-1, -1): 锚点，要进行处理的像素值位于kernel中的相对位置，有默认值(-1, -1)位于模板中心。
		即将kernel的锚点放置到目标像素点上方，kernel其他部分覆盖像素点领域
	double delta = 0: 在存入目标图像之前可以增加的常数
	int borderType = BORDER_DEFAULT: 用于推断图像外部像素的边界模式，详细信息可以查看cv::BorderTypes.
	该函数适用于任意的线性滤波器，支持就地操作，涉及到图像外部像素计算则按照指定的边界模式插入异常像素值。
	kernel不是锚点周围的镜像。如果需要真正的卷积运算，使用cv::flip将内核翻转并将新的锚点设置为：
		(kernel.cols-anchor.x-1, kernel.rows-anchor.y-1).
	如果大尺寸(11或以上)kernel函数使用DFT-based算法(离散傅里叶算法)，
	而对于较小的尺寸函数使用这个函数直接算法进行计算


初步认识形态学
	例如 基本操作膨胀和腐蚀，
	高级的形态学操作，例如建立在膨胀和腐蚀操作基础之上,的操作
	首先形态学的主要用途是获取物体拓扑和结果信息，
	它通过物体和结构元素的某些运算，得到物体更本质的形态，在图像处理中的主要应用有：
		(1). 利用形态学的基本运算对图像进行观察和处理，从而达到改善图像质量的目的
		(2). 描述和定义图像的各种几何参数和特征如面积、周长、连通、颗粒度、骨架和方向性
	通过腐蚀和膨胀两种基本的形态学操作实现开运算、闭运算、形态梯度、顶帽、黑帽五种形态学操作。 
膨胀:
	膨胀(dilate)就是求局部最大值的操作，
	从数学的角度来讲膨胀或者腐蚀就是将一幅二维图像或图像的一部分(称之为A)与一个模板也就是核(称为B)进行卷集运算的过程。
	核可以是任何形状和大小，与之前介绍的模板一样，核有一个可定义的锚点。
	膨胀操作是将图像A与任意形状的内核B(通常为正方形或者圆形)进行卷集
	内核B中可定义的锚点通称定义为内核中心点
	进行膨胀操作时，将内核B在图像A上进行滑动操作，将内核B覆盖的区域的最大像素值提取并提到内核B锚点位置的像素。 
	例如 粗体黑字经膨胀处理后会变细体黑字,
	因为膨胀将会导致图像中的亮区开始扩展，因为白色的像素值要远远大于黑色的像素值。
	void dilate(InputArray src, OutputArray dst, InputArray kernel, 
		Point anchor=Point(-1,-1), int iterations=1, int borderType=BORDER_CONSTANT, 
		const Scalar& borderValue=morphologyDefaultBorderValue() )
	InputArray src: 输入图像，可以是Mat类型，对于图像通道数量没有要求，
		但是图像深度应为CV_8U、CV_16U、CV_16s、CV_32F或CV_64F其中之一。
	OutputArray dst: 输出图像，与原图像有相同的尺寸和类型。
	InpurArray kernel: 用于膨胀操作的kernel，当参数Mat()=NULL时，
		kernel是一个锚点位于中心的3x3模板。
	Point anchor = Point(-1, -1): 锚点位置
	int iterations=1: 迭代使用膨胀的次数
	int borderType = BORDER_CONSTANT: 用于推断图像外部像素的某种边界模式，
		其有默认值BORDER_CONSTANT,可以通过cv::BorderTypes查询其他的方法。
	const Scalar & borderValue = morphologyDefaultBorderValue() : 边界为常数时的边界值，
		有默认值morphologyDefaultBorderValue()，一般不用进行设置，
		如果有特殊需要，可以查看 createMorphologyFilter()函数得到详细信息。
	其中,可以通过getStructuringElement函数来制定 kernel 的形状和尺寸，其函数原型如下：
	Mat cv::getStructuringElement   (   int     shape,
	        Size    ksize,
	        Point   anchor = Point(-1,-1) 
	    ) 
		int shape: kernel的形状，由cv::MorphShapes指定，如下 
			分别是矩形(MORPH_RECT)、交叉形(MORPH_CROSS)、椭圆形(MORPH_ELLIPSE)
		Size ksize: kernel的尺寸
		Point anchor = Point(-1, -1): 锚点位置
腐蚀 
	腐蚀是提取内核覆盖下的像素最小值
	进行腐蚀操作时，将内核窗口在图像A上进行滑动，将内核B覆盖的区域最小像素值提取并代替锚点位置的像素值
	例如 粗体黑字经腐蚀处理后会变 加粗粗体黑字,
	因为腐蚀操作将会导致图像中像素值较低的元素进行扩展，造成黑色部分加粗
	void cv::erode  (   InputArray      src,
	        OutputArray     dst,
	        InputArray      kernel,
	        Point   anchor = Point(-1,-1),
	        int     iterations = 1,
	        int     borderType = BORDER_CONSTANT,
	        const Scalar &      borderValue = morphologyDefaultBorderValue() 
	    )  
	InputArray src: 输入图像可以是Mat类型，可以是任意通道图像，
		图像深度只能是CV_8U、CV_16U、CV_16S、CV_32F或CV_64F其中的一个。
	OutputArray dst: 输出图像，与输入图像尺寸类型一致。
	Input Array kernel: 用于腐蚀操作的kernel，当参数=Mat()即NULL时，kernel是一个锚点位于中心的3x3模板。
		可以通过getStructuringElement函数来制定kernel的形状和尺寸，具体用法请参考对膨胀的表述
	Point anchor = Point(-1, -1): 锚点位置
	int iterations = 1: 迭代腐蚀操作次数，有默认值1
	int borderType = BORDER_CONSTANT: 用于推断图像外部像素的某种边界模式，
		其有默认值BORDER_CONSTANT,可以通过cv::BorderTypes查询其他的方法。
	const Scalar & borderValue = morphologyDefaultBorderValue(): 
		边界为常数时的边界值，有默认值morphologyDefaultBorderValue()，
		一般不用进行设置，如果有特殊需要，可以查看 createMorphologyFilter()函数得到详细信息。
开运算(Opening) 
	通过先对图像腐蚀再膨胀实现
	能够排除小团块物体(假设物体较背景明亮)，开运算的结果删除了不能包含结构元素的对象区域，
	平滑了对象的轮廓，断开了狭窄的连接，去掉了细小的突出部分，
	例如 一张黑色图中有许多 白色噪点,开运算后可以消除白色噪点
闭运算(Closing)
	闭运算在数学上是先膨胀再腐蚀的结果
	能够排除小型黑洞(黑色区域)，能够平滑对象的轮廓，
	但是与开运算不同的是闭运算一般会将狭窄的缺口连接起来形成细长的弯口，
形态梯度(Morphological Gradient)
	形态梯度是膨胀图与腐蚀图之差
	比如可以使用其实现 抓取轮廓
顶帽(Top Hat)
	顶帽操作是原图像与开运算结果图之差
	开运算的结果是放大了裂缝或局部降低亮度的区域，
	因此从原图中减去开运算后的图得到的效果图能够突出比原图轮廓周围的区域更明亮的区域，
	且这一操作与选择的核的大小有关。
	顶帽操作往往用来分离比邻近点亮一些的板块，
	在一幅图像具有大幅背景而微小物品比较有规律的情况下，可以使用顶帽运算进行背景提取。
黑帽(Black Hat)
	黑帽运算是闭运算结果图与原图像之差，
	黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，
	这一操作也与选择的核尺寸有关。所以黑帽运算用来分离比邻近点暗一些的斑块，效果图有着非常完美的轮廓
morphologyEx() opencv中提供了形态学操作函数, 
	可以实现开运算、闭运算、形态学梯度、顶帽、黑帽等五种相对高级的操作，
	也可以实现膨胀核腐蚀两种基本的形态学操作
	void cv::morphologyEx   (InputArray src,
	        OutputArray dst,
	        int op,
	        InputArray kernel,
	        Point anchor = Point(-1,-1),
	        int iterations = 1,
	        int borderType = BORDER_CONSTANT,
	        const Scalar & borderValue = morphologyDefaultBorderValue() 
	)   
	InputArray src: 输入图像，可以是Mat类型，对于图像通道数无要求，但图像深度必须是CV_8U、CV_16U、CV_16S、CV_32F或CV_64F
	OutPutArray dst: 目标图像，与原图像尺寸核类型相同
	int op: 形态学运算的类型，可以通过MorphTypes查看，如下所示：
		标识符 | 运算类型
		MORPH_OPEN： 开运算
		MORPH_CLOSE ：闭运算
		MORPH_GRADIENT： 形态学梯度
		MORPH_TOPHAT：顶帽运算
		MORPH_BLACKHAT： 黑帽运算
		MORPH_ERODE ：腐蚀运算
		MORPH_DILATE ：膨胀运算
		MORPH_HITMISS: 击中击不中运算(只支持CV_8UC1类型的二值图像)
	InputArray kernel: 形态学运算的内核，如果是Mat()则表示的是参考点位于内核中心3x3的核，
		前面也提到一般使用前需要定义一个Mat变量结合getStructuringElement()函数使用，
		getStructuringElement会返回指定形状和尺寸的结构元素，
	Point anchor=Point(-1, -1): 锚点位置
	int iterations=1: 迭代使用函数的次数，默认值为1
	int borderType=BORDER_CONSTANT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_CONSTANT
	const Scalar & borderValue=morphologyDefaultBorderValue(): 
		当边界为常数时的边界值，可以通过createMorphologyFilter() 查看更多细节。
	这些形态学操作都是可执行就地操作(in-place)，对于多通道图像，每个图像通道进行单独操作。
	更多内容: https://blog.csdn.net/keith_bb/article/details/54578186
图片是缩放:
	高斯金字塔:向下采样 缩小 信息丢失
		void cv::pyrDown ( 
			InputArray src,
			OutputArray dst,
			const Size & dstsize = Size(),
			int borderType = BORDER_DEFAULT 
		)
		InputArray src: 输入图像，可以是Mat类型
		OutputArray dst: 输出图像，尺寸由第三个参数指定，类型与输入图像一致
		const Size & dstsize=Size(): 输出图像的尺寸，有默认值Size()，
			在默认情况下将会由Size((src.cols+1)/2, (src.rows+1)/2)计算得到并且还要满足以下条件
			|dstsize.width*2-src.cols|<=2
			|dstsize.height*2-src.rows|<=2
		int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT
	拉普拉斯金字塔:向上采样 放大图像 信息基本不变
		void cv::pyrUp  (   InputArray      src,
		        OutputArray     dst,
		        const Size &    dstsize = Size(),
		        int     borderType = BORDER_DEFAULT 
		    )   
		InputArray src: 输入图像
		OutputArray dst: 输出图像
		const Size & dstsize=Size(): 输出图像尺寸，有默认值Size()，在使用默认值的情况下，
			输出图像的尺寸由Size((src.cols*2),(src.rows*2))计算得到，但是必须满足以下条件
			|dstsize.width - src.cols*2|<=(dstsize.width mod 2)
			|dstsize.height - src.rows*2|<=(dstsize.height mod 2)
			其中mod时求余函数，即dstsize.width mod 2是dstsize.width除以2的余数。
		int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT，
			具体可以查看函数BorderTypes获取详细信息(需要注意的是与膨胀腐蚀不同，这里不支持BORDER_CONSTANT模式) 
	通用的缩放函数	
		void cv::resize  ( InputArray  src,  
		  OutputArray  dst,  
		  Size  dsize,  
		  double  fx = 0,  
		  double  fy = 0,  
		  int  interpolation = INTER_LINEAR  
		 ) 
		InputArray src: 输入图像，可以是Mat类型
		OutputArray dst: 输出图像，其尺寸由第三个参数dsize(如果dsize不为0)，当dsize为0，
			输出图像的尺寸由src.size()、fx和fy计算得到，但是输出图像类型与输入图像一致
		Size dsize: 输出图像的尺寸，如果dsize设置为0，则dsize的值将由下式计算得到
		dsize=Size(round(fx*src.cols), round(fy*src.rows))
			需要注意的是dsize和fx、fy不能同时为0
		double fx = 0: 水平方向上的缩放系数，当fx为0时，将由如下公式计算得到
			(double)dsize.width/src.cols
		double fy = 0: 垂直方向上的缩放系数，如果fy为0，将由如下公式计算得到
			(double)dsize.height/src.rows
		int interpolation=INTER_LINEAR: 图像缩放的插值算法类型，默认是INTER_LINEAR(线性插值)，
			在opencv3.2中通过查看InterpolationFlags查看详细信息，
		以上的情况是没有初始化目标图像的类型和尺寸也就是没有提前设置好目标图像的类型和尺寸
		而是由函数根据size.size，dsize,fx和fy计算得到，
		如果想调整输入图像适应已经创建好的目标图像的时候应该这样调用resize()函数：
		resize(src, dst, dst.size(), 0, 0, interpolation);
		如果指定图像在水平方向和垂直方向的缩放系数，则调用方式如下：
		resize(src, dst, Size(), 0.5, 0.5, interpolation);
		一般情况下，如果要缩小图像用cv::INTER_AREA算法实现，
		而放大图像如果想取得较好的效果则使用cv::INTER_CUBIC，此插值算法效果好但是速度慢，
		而cv::INTER_LINEAR插值相对较快而且效果也是可以接受						
图像阈值操作threshold
	double cv::threshold  ( InputArray  src,  
	  OutputArray  dst,  
	  double  thresh,  
	  double  maxval,  
	  int  type  
	 ) 
	InputArray src: 输入图像，可以是Mat类型，图像必须为单通道8位或32位浮点型图像
	OutputArray dst: 输出图像，与输入图像尺寸和类型相同
	double thresh: 设定的阈值
	double maxval: 使用THRESH_BINARY和THRESH_BINARY_INV类型时,需要用到的最大值
	int type: 阈值化类型，可以通过ThresholdTypes查看，
		THRESH_BINARY 二进制阈值化
			像素点与thresh比较,>thresh,像素点值改为maxval,否则改为0
		THRESH_BINARY_INV 反二进制阈值化
			像素点与thresh比较,>thresh,像素点值改为0,否则改为maxval
		THRESH_TRUNC 截断阈值化
			像素点与thresh比较,>thresh,像素点值改为thresh,否则像素点值不变
		THRESH_TOZERO 阈值化为0
			像素点与thresh比较,>thresh,像素点值不变,否则改为0
		THRESH_TOZERO_INV 反阈值化为0
			像素点与thresh比较,>thresh,像素点值改为0,否则像素点值不变
	一般图像执行 threshold处理前,需要 需要先转成灰阶图
	例子:
		cvtColor(g_srcImage, g_srcGrayImage, COLOR_RGB2GRAY);   //将图像转化为灰度图
		threshold(g_srcGrayImage,thresholdimage,20,255,THRESH_BINARY);
自适应阀值的图像阀值操作 adaptiveThreshold
	void cv::adaptiveThreshold  ( InputArray  src,  
	  OutputArray  dst,  
	  double  maxValue,  
	  int  adaptiveMethod,  
	  int  thresholdType,  
	  int  blockSize,  
	  double  C  
	 ) 
	InputArray src: 输入图像，8位单通道图像
	OutputArray dst: 目标图像，与输入图像有相同的尺寸和类型
	double maxValue: 给像素赋予的满足阈值类型的非零值
	int adaptiveMethod: 用于指定自适应阈值的算法，具体可以查看adaptiveThresholdTypes给出的具体内容，
		ADAPTIVE_THRESH_MEAN_C方法的阈值时由blockSize确定的像素(x, y)
		在blockSize x blockSize范围内的邻域像素值减参数C得到的平均值，
		ADAPTIVE_THRESH_GAUSSIAN_C中阈值是blockSize x blockSize领域范围内减去C后的加权和。
		默认的sigma用于指定的blockSize，可通过getGaussianKernel查看详细信息。
	int thresholdType: 阈值类型，其取值有两种类型分别是：
		THRESH_BINARY 二进制阈值化
			像素点 与 自适应阀值 比较,大于自适应阀值,像素点值改为maxValue,否则改为0
		THRESH_BINARY_INV 反二进制阈值化
			像素点 与 自适应阀值 比较,大于自适应阀值,像素点值改为0,否则改为maxValue
		int blockSize: 用于计算阈值大小的像素邻域尺寸，取值为3\5\7……
		double C: 自适应阈值算法中减去的常数值，通常是正数，在极少情况下式0或负值。
	同样 一般图像执行 threshold处理前,需要 需要先转成灰阶图
	例子:
		cvtColor(g_srcImage, g_srcGrayImage, COLOR_RGB2GRAY);   //将图像转化为灰度图
		adaptivethreshold(g_srcGrayImage,thresholdimage,255,
			ADAPTIVE_THRESH_MEAN_C,THRESH_BINARY,5);
边界检测
	一般边界地方是 像素值变化率最大的地方,也就是说傅立叶变换后,频率比较高的地方,梯度最大的地方
	最多高频简谐波叠加的地方!!
	canny算子 Laplacian算子 Sobel算子
	详细: https://blog.csdn.net/keith_bb/article/details/56008306
霍夫变换 从图像中识别几何形状的基本方法之一
	标准霍夫变换(Standard Hough Transform, SHT)、
	多尺度霍夫 变换(Multi-Scale Hough Transform, MSHT)
	累计概率霍夫变换(Progressive Probabilistic Hough Transform, PPHT).
	霍夫线变换是用来寻找直线的方法，在使用霍夫线变换之前首先要对图像进行边缘检测的处理，
	也即霍夫线变换的直接输入只能是边缘二值图像
	在opencv中标准霍夫变换(SHT)和多尺度霍夫变换(MSHT)是由HoughLines函数调用的。其定义如下：
	void cv::HoughLines  ( InputArray  image,  
	  OutputArray  lines,  
	  double  rho,  
	  double  theta,  
	  int  threshold,  
	  double  srn = 0,  
	  double  stn = 0,  
	  double  min_theta = 0,  
	  double  max_theta = CV_PI  
	 ) 
	image: 8位单通道二进制图像，可以载入任意图像由函数修改成此格式
	lines: 输出直线矢量，每一条线有两个元素的矢量(ρθ)表示，
		ρ是离坐标原点(0, 0)也就是图像左上角的距离，
		θ是弧度线条旋转角度(0度表示垂直线，π/2度表示水平线)。
	rho: 以像素为单位的距离精度，其它表述还有是直线搜索时的进步尺寸的单位半径
	theta: 以弧度为单位的角度精度。其它表述还有是直线搜索时的进步尺寸的单位角度。
	threshold: 累加平面的阈值参数，即识别某部分为图中的一条直线时它在累加平面中必须达到的值。
		大于阈值threshold的直线才可以被检测通过并返回到结果中。
	srn: 对于多尺度的霍夫变换，这是第三个参数进步尺寸rho的除数距离。
		粗略的累加器进步尺寸直接是第三个参数rho， 而精确的累加器进步尺寸为rho/srn。有默认值0
	stn对于多尺度霍夫变换，stn表示第四个参数进步尺寸的单位角度theta的除数距离。
		且如果srn和stn同时为0， 就表示使用经典的霍夫变换，扶着这两个参数都应该为正数。
		经典霍夫变换和多尺度霍夫变换就是在这进行区分的。有默认值0
	例子片段:
	    Canny(srcImage, midImage, 50, 200, 3);        //首先对图像进行边缘检测
	    cvtColor(midImage, dstImage, COLOR_GRAY2BGR);
	    //进行霍夫变换
	    vector<Vec2f> lines;            //定义一个矢量结构用于存放得到的线段矢量集合
	    HoughLines(midImage, lines, 1, CV_PI/180,230, 0, 0);
	    //在图中绘出线段
	    for(size_t i = 0; i < lines.size(); i++)
	    {
	        float rho = lines[i][0];
	        float theta = lines[i][1];
	        Point pt1, pt2;
	        double a = cos(theta), b = sin(theta);
	        double x0 = a * rho, y0 = b * rho;
	        pt1.x = cvRound(x0 + 1000*(-b));
	        pt1.y = cvRound(y0 + 1000*(a));
	        pt2.x = cvRound(x0 - 1000*(-b));
	        pt2.y = cvRound(y0 - 1000*(a));
	        line(dstImage, pt1, pt2, Scalar(0, 0, 255), 1, LINE_AA);
	    }
	    imshow("霍夫线变换", dstImage);
	
	针对PPHT:	
	void cv::HoughLinesP    (   InputArray      image,
	        OutputArray     lines,
	        double      rho,
	        double      theta,
	        int     threshold,
	        double      minLineLength = 0,
	        double      maxLineGap = 0 
	    )   
	image: 8位单通道二进制图像，可以载入任意图像由函数修改成此格式
	lines: 线段输出矢量，每一条之先都由四个矢量元素(x1, y1, x2, y2)表示，
		其中(x1, y1)和(x2, y2)分别是检测到直线线段的两个端点。
	rho: 以像素为单位的直线搜寻步长
	theta: 以弧度为单位的直线搜寻步长
	threshold: 累加器阈值参数，只有大于threshold的直线结果才能被检测通过并返回到结果中
	minLineLength: 线段长度最小值，如果线段长度小于这个值则线段结果不显示，有默认值0
	maxLineGap: 允许点连接到相同直线的中间距离的最大值，
		如果超过这个最大值则点不会被划分到该直线。有默认值0
	例子片段:
	    Canny(srcImage, midImage, 50, 200, 3);        //首先对图像进行边缘检测
	    cvtColor(midImage, dstImage, COLOR_GRAY2BGR);
	    //进行霍夫变换
	    vector<Vec4i> lines;
	    HoughLinesP(midImage, lines, 1, CV_PI/180, 200, 30, 10);
	    for(size_t i = 0; i < lines.size(); i++)
	    {
	        line(dstImage, Point(lines[i][0], lines[i][1]), Point(lines[i][2], lines[i][3]),
	            Scalar(0, 0, 255), 1, 8);
	    }	
	    imshow("霍夫线变换", dstImage);

	霍夫圆变换
	出于对运算效率的考虑，opencv实现的是一个比标准霍夫圆变换更为灵活的检测方法：
	霍夫梯度法，也叫2-1霍夫变换(21HT)
	void cv::HoughCircles   (   InputArray      image,
	        OutputArray     circles,
	        int     method,
	        double      dp,
	        double      minDist,
	        double      param1 = 100,
	        double      param2 = 100,
	        int     minRadius = 0,
	        int     maxRadius = 0 
	    )   
	image: 输入图像为8位单通道灰度图
	circles: 检测到圆的输出矢量，每个矢量都是三个浮点元素构成(x,y,radius)
	method: 检测方法，可以查看HoughModes查看具体细节，但目前只有HOUGH_GRADIENT(霍夫梯度)一种方法可以使用。
	dp: 用来检测圆心的累加器图像的分辨率与输入图像之比的倒数，
		且此参数允许创建一个比输入图像分辨率低的累加器。
		例如，如果dp=1，累加器和输入图像具有相同的分辨率，
		如果dp=2累加器便有输入图像一半那么大的宽度和高度。
	minDist: 霍夫检测到的圆的圆心之间的最小距离，即让算法能明显区分的两个不同圆之间的最小距离。
		这个参数如果太小的话，多个相邻的圆可能被错误的检测成了一个重合的圆。
		繁殖这个参数设置太大，某些圆就不能被检测出来了。也就是超过这个距离就是两个圆，否则是一个圆。
	param1: 指定检测方法的第一个参数，当前可用方法是HOUGH_GRADIENT,
		它表示传递给Canny边缘检测算子的高阈值(低阈值是高阈值的一半)，有默认值100
	param2: 指定检测方法的第二个参数，对于HOUGH_GRADIENT方法，它表示在检测阶段圆心的累加器阈值。
		它越小就越可以检测到更多根本不存在的圆，而它越大的话能通过检测的圆就更加接近完美的圆形了。有默认值100
	minRadius: 圆的最小半径
	maxRadius: 圆的最大半径
	例子片段:
	    cvtColor(srcImage, grayImage, COLOR_BGR2GRAY);	//转灰度图
	    GaussianBlur(grayImage, grayImage, Size(3, 3), 2, 2);       //高斯滤波
	    //霍夫圆检测
	    HoughCircles(grayImage, circles, CV_HOUGH_GRADIENT, 1, minDist, param1, param2, 0, 0);
	    //绘制检测到的圆
	    for(size_t i = 0; i < circles.size(); i++)
	    {
	        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
	        int radius = cvRound(circles[i][2]);
	        circle(srcImage, center, 3, Scalar(0, 0, 255), -1, 8, 0);
	        circle(srcImage, center, radius, Scalar(0, 0, 255), 3, 8, 0);
	    }
	    imshow(windowName, srcImage);
图像重映射: remap 
	比如现象变换,上下翻转等等,,
	详细: https://blog.csdn.net/keith_bb/article/details/56295873
仿射变换warpAffine
	仿射变换是指在向量空间中进行一次线性变换(乘以一个矩阵)并加上一个平移(加上一个向量)，
	变换为另一个向量空间的过程
	仿射变换可以通过一系列的原子变换的复合来实现包括：
	平移(Translation)、缩放(Scale)、翻转(Flip)、旋转(Rotation)和错切(Shear).
	void cv::warpAffine     (   InputArray      src,
	        OutputArray     dst,
	        InputArray      M,
	        Size    dsize,
	        int     flags = INTER_LINEAR,
	        int     borderMode = BORDER_CONSTANT,
	        const Scalar &      borderValue = Scalar() 
	    )
	src: 输入图像
	dst: 输出图像，尺寸由dsize指定，图像类型与原图像一致
	M: 2X3的变换矩阵
	dsize: 指定图像输出尺寸
	flags: 插值算法标识符，有默认值INTER_LINEAR，如果插值算法为WARP_INVERSE_MAP, 
		warpAffine函数使用如下矩阵进行图像转换
	borderMode: 边界像素模式，有默认值BORDER_CONSTANT
	borderValue: 边界取值，有默认值Scalar()即0
	其中会搭配使用 变换矩阵
	getRotationMatrix2D函数	:获得旋转变换需要用到的 变换矩阵
	Mat cv::getRotationMatrix2D     (   Point2f     center,
	        double      angle,
	        double      scale 
	    )   
		center: Point2f类型，表示原图像的旋转中心
		angle: double类型，表示图像旋转角度，角度为正则表示逆时针旋转，角度为负表示逆时针旋转（坐标原点是图像左上角）
		scale: 缩放系数 
	还有getAffineTransform()获得指定的仿射变换需要的变换矩阵
	详细:图像直方图均衡化equalizeHist

图像直方图 及 均衡化equalizeHist
	所谓图像直方图是统计图像的像素值分布的的一种统计图!!
	绘画图像直方图: https://blog.csdn.net/keith_bb/article/details/56680997
	equalizeHist()函数实现的图像直方图均衡化算法就是把直方图的每个灰度级进行归一化处理，
	求每种灰度的累积分布，得到一个映射的灰度映射表，然后根据相应的灰度值来修正原图中的每个像素的像素值。
	是一种增强图像对比度的一种算法!!
	详情:https://blog.csdn.net/keith_bb/article/details/56510842
图像模板匹配matchTemplate()
	基本方法就是 通过一小块图片片段,扫描匹配未知图片探索是否找到吻合的部分!!
	详情: https://blog.csdn.net/keith_bb/article/details/70050080
反向投影calcBackProject()	
	先得到 反映 图像的 像素值区间分布 的直方图, 
	然后 直方图投影回到图片上来,直观像素值区间 在图像上的直观分布
	详情:https://blog.csdn.net/keith_bb/article/details/70154219
寻找图像轮廓:findContours()
	特别注意参数hierarchy:
	可选的输出向量(std::vector)，包含了图像的拓扑信息，作为轮廓数量的表示hierarchy包含了很多元素，
	每个轮廓contours[i]对应hierarchy中hierarchy[i][0]~hierarchy[i][3],
	分别表示后一个轮廓，前一个轮廓，父轮廓，内嵌轮廓的索引，如果没有对应项，则相应的hierarchy[i]设置为负数。
	mode轮廓检索模式，可以通过cv::RetrievalModes()查看详细信息，
	就是说用来存储 父子关系的拓扑信息
	注意,所得到的 是物理逻辑轮廓,
	比如 用圆珠笔勾画一个圆圈, 然后拍下图片,再findContours() 会得到的是4条轮廓, 而不是1条!!!
	因为是在黑白交接处 找出轮廓的,而且黑白交界处分别在黑白两处各有一条轮廓
	那么圆圈这条黑色闭合线在白纸上,意味着有两处黑白交接,所以有4条轮廓
	还例如说, 一个白纸上的一个黑色圆形,有两条轮廓
	还例如说, 白纸上一条直线,线段有 两条轮廓
	详情还是 网上自己找找
寻找凸包convexHull()
	概念比较模糊!!,大概知道,但例程结果令人困惑
多边形包围图像轮廓
	根据得到 的轮廓 绘制 圆或者矩阵 包住
	典型的 强调图像主要特征的的 一个辅助方法
	详情: https://blog.csdn.net/keith_bb/article/details/70194821
	



20180523
整理:
实现了 opengl + opencv的 AR 
	具体指向 other/opencv+opengl/实践项目/gl/main3.cpp
实现了 opencv + zbar 的 二维码识别  
	具体指向 other/opencv+opengl/实践项目/qr/lelimg_qrdet.cpp
注意都是 win 上codeblock上实践的项目!! 这里做充分备份!!
掌握了如何使用 opencv opengl zbar
	具体内容都在 other/opencv+opengl/实践项目 上
	
glut使用基础笔记!!
void display (void)  //glut显示函数
{....
    glFlush();	//把缓冲内容送到硬件更新显示
    glutSwapBuffers  //如果开启了 GLUT_DOUBLE 双缓冲区,则可调用,更换缓冲区
		     //因为 glFlush() 只是发出了指令,缓冲内容送到硬件更新显示是一个耗时过程
		     //所以最好使用双缓冲, 切换到新缓冲,开始执行新图像处理工作,
		     //而不用害怕冲突,或者等待而耗时!!
}

static void key(unsigned char key, int x, int y)  //glut按键事件
{
    switch (key)
    {
        case 27 :
        case 'q':
            exit(0);
            break;
    }
    glutPostRedisplay();	//执行 glut显示函数 更新显示内容

}

void idle(void)
{
    glutPostRedisplay();	//执行 glut显示函数 更新显示内容
}
main{
...
    glutInit(&argc,argv);	//初始化
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGBA);	//初始化显示模式
    glutInitWindowPosition(100,100);	//初始化窗口模式
    glutInitWindowSize(imagewidth,imageheight);	//初始化窗口大小
    glutCreateWindow("bilibili");	//窗口名字
    glutDisplayFunc(&display);	//注册 glut显示函数
    glutKeyboardFunc(key);	//注册 glut按键事件
    glutIdleFunc(&idle);	//注册 glut 空闲处理
    glutMainLoop();	//开始 glut 消息处理主循环,
			//并执行了一次 glut显示函数
...
}
期中 AR项目里 使用了 相机内参数,现在还不知道是啥?











20180524
win装python 共存安装python2,python3
	分别按装 python2.7,python3.6 到 c:\python27, c:\python36
	添加环境变量 : c:\python27;c:\python36;c:\python27\scripts;c:\python36\scripts
	修改 c:\python27的python.exe,pythonw.exe 为 python2.exe,pythonw2.exe
	同理修改 c:\python36的python.exe,pythonw.exe
	更新pip:
		python3 -m pip install --upgrade pip
		python2 -m pip install --upgrade pip
添加python虚拟环境
	pip3 install virtualenv
	跑到要放置虚拟环境的目录:cd /d c:\python36\virtual_env
	virtualenv RL
	RL\Scripts\activate	//激活
在分析学习RL前还是先好好熟悉 openaigym
	从gym官网知道, mujoco 是付费的,robotics 基于mujoco
	要使用 robotics 不只是完整安装了openaigym就可以,还要配置安装mujoco
	还有安装openaigym 需要好多以依赖包,当更新了swig工具时
	gym[box2d] 要重新安装能工作,不然出现所谓RAMLIST错误
	所以现在只能 使用 artari 和 普通的 classical control 来做研究

http://lib.csdn.net/article/aimachinelearning/68113










20180604
linux 实现 qr opgl opcv
使用 codeblock
	glut等opengl工具,ubuntu 本身就有,不需要去安装
	只需要在 Linker settings : Other linker options 上添加 -lGL -lGLU -lglut 就好了
	还有,不需要专门去建立glut.project,直接empty.project就可以了
	就这样 gl+cv 成功实现了AR demo
zbar前准备:
	编译安装 libiconv : https://blog.csdn.net/chqiwei/article/details/53559306
	下载http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.14.tar.gz
	前需要打补丁:(补丁内容)
		--- a/srclib/stdio.in.h
		+++ b/srclib/stdio.in.h
		@@ -695,8 +695,10 @@ _GL_CXXALIASWARN (gets);
		 /* It is very rare that the developer ever has full control of stdin,
		    so any use of gets warrants an unconditional warning.  Assume it is
		    always declared, since it is required by C89.  */
		+#if defined(__GLIBC__) && !defined(__UCLIBC__) && !__GLIBC_PREREQ(2, 16)
		 _GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
		 #endif
		+#endif
	配置编译安装 zlib
		$ ./configure --prefix=/xxx/aaa     make_install的安装路径
		$ make
		$ make install
	编译安装 libpng  
		$ ./configure --prefix=/xxx/aaa     make_install的安装路径
		$ make
		$ make install
		(.config 会检测系统是否有 zblib,然而使用了系统自带的,而不是我们专门编译的!!)
编译zbar demo
	首先使用 GCC 比起 针对win的mingw32_gcc 还是有点区别的,
	比如 在.hpp 文件里定义的 class :
		class XXX.hpp
		{....}		//错误声明
		class XXX
		{....};		//错误声明	
	还有使用了独立的 libiconv 和 libpng 库, 因为用了最新版,所以一些函数样式需要改变
	比如 iconv(..)的参数
	比如没有 png_set_to_gray_1_2_4_to_8
	只有 png_set_expand_to_gray_1_2_4_to_8
	还有 由于 ubuntu本身有 libiconv,libpng ,
	编译时,头文件#include <png.h> #include <iconv.h>自动链接到系统的,
	但是比编译demo时,我们用到的是另外独立编译的库,所以需要把头文件改了,改到独立库的目录去
	比如 #include "install/include/png.h"
	可以看出.codeblock 编译的一般会链接到系统里的头文件.
	还有处理动态库的问题,ubuntu动态库.so与win的.dll有些许区别
实现摄像头抓捕识别qr
	注意在 linux环境下使用 opencv waitkey 与在 win的区别
	在linux 上严格 输出 类型规范为 char !!还要加上强制转置(char)
学会了源码补丁的制作和 缝补操作
	https://blog.csdn.net/qq_22918577/article/details/49103865
	原始的源码目录为src_code，修改后的源码目录为src_code_new。	
	diff  -urN    src_code  src_code_new   > changes.patch	//制作出补丁 changes.patch
	补丁 changes.patch 内容:
		diff -urN src_code/srclib/stdio.in.h src_code_new/srclib/stdio.in.h
		--- src_code/srclib/stdio.in.h	2011-08-07 21:42:06.000000000 +0800
		+++ src_code_new/srclib/stdio.in.h	2018-06-04 13:37:36.116935888 +0800
		@@ -695,8 +695,10 @@
		 /* It is very rare that the developer ever has full control of stdin,
		    so any use of gets warrants an unconditional warning.  Assume it is
		    always declared, since it is required by C89.  */
		+#if defined(__GLIBC__) && !defined(__UCLIBC__) && !__GLIBC_PREREQ(2, 16)
		 _GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
		 #endif
		+#endif
	这时,我们把源码目录src_code里的所有内容,拷贝一份到 OOXX目录里
	即 src_code 与 OOXX 目录里的内容完全一样
	我们给 OOXX 打补丁
	cd OOXX
	patch -p1 <../changes.patch	//给OOXX打上 changes.patch 补丁
	这时就会发现: 
		本来
		OOXX/srclib/stdio.in.h 和 src_code/srclib/stdio.in.h 是一样的
		后来
		OOXX/srclib/stdio.in.h 和 src_code_new/srclib/stdio.in.h 一样
		695 行内容做过了修改
	去除补丁恢复旧文件:
	patch -RE -p1 <../change.patch //去除 changes.patch 补丁
	这时就会发现: 
		本来
		OOXX/srclib/stdio.in.h 和 src_code_new/srclib/stdio.in.h 一样
		后来
		OOXX/srclib/stdio.in.h 和 src_code/srclib/stdio.in.h 一样
		695 行内容恢复原样	
	diff 命令:
		diff的功能就是用来比较两个文件的不同，然后记录下来，也就是所谓的diff补丁。
		语法格式：diff 【选项】 源文件（夹） 目的文件（夹），>补丁
			-r 是一个递归选项，设置了这个选项，
			   diff会将两个不同版本源代码目录中的所有对应文件全部都进行一次比较，
			   包括子目录文件。 
			-N 选项确保补丁文件将正确地处理已经创建或删除文件的情况。
			-u 选项以统一格式创建补丁文件，这种格式比缺省格式更紧凑些。
	patch 命令:
		patch就是利用diff制作的补丁来实现源文件（夹）和目的文件（夹）的转换。
		这样说就意味着你可以有源文件（夹）――>目的文件（夹），也可以目的文件（夹）――>源文件（夹）。
		参数:
		-p0 选项要从当前目录查找目的文件（夹）
		-p1 选项要忽略掉第一层目录，从当前目录开始查找。
	    	实例说明：
		--- old/modules/pcitable Mon Sep 27 11:03:56 1999
		+++ new/modules/pcitable Tue Dec 19 20:05:41 2000
		---开头表示旧文件
		+++开头表示新文件
	    	如果使用参数-p0，那就表示从当前目录找一个叫做old的文件夹，在它下面寻找modules下的pcitable文件来执行patch操作。
	    	如果使用参数-p1，那就表示忽略第一层目录（即不管old），从当前目录寻找modules的文件夹，
		在它下面找pcitable。这样的前提是当前目 录必须为modules所在的目录。
		而diff补丁文件则可以在任意位置，只要指明了diff补丁文件的路径就可以了。
		当然，可以用相对路径，也可以用绝 对路径。不过我一般习惯用相对路径。
		-E  选项说明如果发现了空文件，那么就删除它
		-R  选项说明在补丁文件中的“新”文件和“旧”文件现在要调换过来了（实际上就是给新版本打补丁，让它变成老版本）
学习了动态库 .so 的链接 : https://blog.csdn.net/csdnxw/article/details/1650650
	一般应用程序执行,不会从应用程序所在目录寻找需要用到的动态库
	一般会根据系统设置的路径寻找必要动态库
 	关于 error while loading shared libraries: libXXX.so.1.2.3: 
		cannot open shared object file: No such file or directory
	如果libXXX.so.1.2.3的确存在，就把libXXX.so.1.2.3所在的目录加入到 /etc/ld.so.conf 中，
	或者在 /etc/ld.so.conf.d/ 下新建一文件，如 XXX.conf ，其内容是libXXX.so.1.2.3所在的目录
	如 /home/kingders/xxpp (不用分号,一行一个路径, 可以用 # 号注释内容)
	如果提示是error while loading shared libraries: libXXX.so，但你的系统上有libXXX.so.5，
	你可以为libXXX.so.5做一个软链接  ln -s libXXX.so.5 libXXX.so.









20160612
花了两天时间,把 cmake 学了,基本够用
主要例子有两个, 一个是简单的,一个是多文件目录的!!
项目源码放在 (    )
简单的: 
cmaketest 只有一个 main.cpp 文件
	同级目录建立一个CMakeLists.txt,内容如下:
	# 惯例,指定最低版本
	cmake_minimum_required(VERSION 2.8)
	# 惯例,项目名字
	PROJECT(hello)
	# 换成 G++ 编译器
	set(CMAKE_CXX_COMPILER "/usr/bin/g++")  
	# 指定最终生成可执行文件 地方 
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)
	# 设置变量, 可以允许 换行 缩进 空格 来分割参数
	set(OPCV249_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_output/install_usr_local/include/opencv-2.4.9)
	set(OPCV249_LIB_DIR /home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)
	set(OPCV249_LIBS  LINK_PRIVATE 
		libopencv_calib3d.so libopencv_flann.so libopencv_legacy.so
		libopencv_ocl.so libopencv_ts.a libopencv_video.so libopencv_contrib.so libopencv_gpu.so
		libopencv_ml.so libopencv_photo.so libopencv_videostab.so libopencv_core.so libopencv_highgui.so
		libopencv_stitching.so libopencv_features2d.so libopencv_imgproc.so
		libopencv_objdetect.so libopencv_superres.so libopencv_nonfree.so)
	# 把 ./ 路径的所有源码文件路径作为参数 压入 指定变量
	aux_source_directory(./ DIR_SRC)
	# 添加 头文件搜索路径
	include_directories(${OPCV249_INCLUDE})

	# 寻找 库文件 如成功 库文件的完整路径 压入变量, 只能单个寻找,不能批量寻找 
	#find_library(LIBPATH "libopencv_calib3d.so.2.4" "libopencv_flann.so.2.4" 
	#	/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)
	#错误语法:不能批量寻找 find_library(LIBPATH ${OPCV249_LIBS} /home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)
	#IF(NOT LIBPATH)
	#MESSAGE(FATAL_ERROR "libopencv not found")
	#ENDIF(NOT LIBPATH)

	# 添加 外部库文件链接路径,不保证链接的库都来来自这里的独立库
	link_directories(${OPCV249_LIB_DIR})
	#也可以: link_directories(/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)

	# 编译所有 .o文件, 并链接最后生成可执行文件 hello
	add_executable(hello ${DIR_SRC})

	# 链接可执行文件过程,用到的补充cmake工具 target_link_libraries()
	# 一定在 add_executable 之后!!
	# 指定了把哪些库链接进来
	# 还有,库文件名参数 不能含有非 .so .a 后缀名的文件,否则不能使用 -l参数识别
	# 例如 libopencv_calib3d.so.2.4.9 并不能使用 -l识别
	# 会说 -llibopencv_calib3d.so.2.4.9 找不到
	# .so 动态库, .a静态库
	target_link_libraries(hello ${OPCV249_LIBS})
	#如果使用了find_library,用这句: target_link_libraries(hello ${LIBPATH})
	# 这种链接的方式无法确保 100% 链接自己的独立库!!
	# 因为 使用了 -l 参数链接库文件,会优先自动搜索系统路径,然后才搜索自定义库文件路径
然后 mkdir build && cd build  建立并进入子目录build在这里执行编译生成过程
cmake .. 搜索上级的 CMakeLists.txt,然后在现处的 build 建立 makefile 等文件
make 编译生成 可执行文件 
最后再build/bin下得到 hello可执行文件
如上面所说,编译的链接过程不能保证 链接库是自己编译的还是系统的,所以有第二种方法!
	同样,在main.cpp 文件
	同级目录删除旧的CMakeLists.txt,重新建立一个内容如下:	
	同级目录建立一个CMakeLists.txt,内容如下:
	# 惯例,指定最低版本
	cmake_minimum_required(VERSION 2.8)
	# 惯例,项目名字
	PROJECT(hello)
	# 换成 G++ 编译器
	set(CMAKE_CXX_COMPILER "/usr/bin/g++")  
	# 指定最终生成可执行文件 地方 
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)
	# 设置 变量, 可以允许 换行 缩进 空格 来分割参数
	set(OPCV249_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_output/install_usr_local/include/opencv-2.4.9)
	set(OPCV249_LIB_DIR /home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)
	set(OPCV249_LIBS  
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_calib3d.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_flann.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_legacy.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ocl.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ts.a 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_video.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_contrib.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_gpu.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ml.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_photo.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_videostab.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_core.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_highgui.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_stitching.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_features2d.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_imgproc.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_objdetect.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_superres.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_nonfree.so.2.4.9
	)
	
	# 把 ./ 路径的所有源码文件路径作为参数 压入 指定变量
	aux_source_directory(./ DIR_SRC)
	# 添加 头文件搜索路径
	include_directories(${OPCV249_INCLUDE})
	
	# 直接 指定所需要库文件 及其 给出绝对文件路径
	LINK_LIBRARIES(${OPCV249_LIBS})  
	# 编译所有 .o文件, 并链接最后生成可执行文件 hello
	add_executable(hello ${DIR_SRC})
	# 这种情况下,直接100% 与自己编译的独立库链接.
然后 mkdir build && cd build  建立并进入子目录build在这里执行编译生成过程
cmake .. 搜索上级的 CMakeLists.txt,然后在现处的 build 建立 makefile 等文件
make 编译生成 可执行文件 
最后再build/bin下得到 hello可执行文件,
#-------补充学习
	#告知当前使用的是交叉编译方式  
	# SET(CMAKE_SYSTEM_NAME Linux)  
	#设置c编译器  
	# SET(CMAKE_C_COMPILER "arm-none-linux-gnueabi-gcc")  
	#设置c++编译器  
	# SET(CMAKE_CXX_COMPILER "arm-none-linux-gnueabi-g++")  
	
	#设置编译器查找路径以及库位置信息
	#不一定需要设置  
	# SET(CMAKE_FIND_ROOT_PATH "/home/test/Develop/arm-none-linux-gnueabi-4.4.0_ARMv5TE/arm-none-linux-gnueabi")  
	# SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)  
	# SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)  
	# SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) 

复杂例子:cmake_pjt -> qr
qr
├── build
│   └── ...
│
├── include
│   ├── config.h.in
│   ├── Makefile.am.inc
│   └── zbar
│       ├── Decoder.h
│       ├── Exception.h
│       ├── Image.h
│       ├── ImageScanner.h
│       ├── Processor.h
│       ├── QZBar.h
│       ├── QZBarImage.h
│       ├── Scanner.h
│       ├── Symbol.h
│       ├── Video.h
│       ├── Window.h
│       └── zbargtk.h
│
├── libiconv
│   └── install
│       ├── include
│       │   ├── iconv.h
│       │   ├── libcharset.h
│       │   └── localcharset.h
│       └── lib
│           ├── charset.alias
│           ├── libcharset.a
│           ├── libcharset.la
│           ├── libcharset.so -> libcharset.so.1.0.0
│           ├── libcharset.so.1 -> libcharset.so.1.0.0
│           ├── libcharset.so.1.0.0
│           ├── libiconv.la
│           ├── libiconv.so -> libiconv.so.2.5.1
│           ├── libiconv.so.2 -> libiconv.so.2.5.1
│           ├── libiconv.so.2.5.1
│           └── preloadable_libiconv.so
│   
├── libpng
│   └── install
│       ├── include
│       │   ├── libpng16
│       │   │   ├── pngconf.h
│       │   │   ├── png.h
│       │   │   └── pnglibconf.h
│       │   ├── pngconf.h -> libpng16/pngconf.h
│       │   ├── png.h -> libpng16/png.h
│       │   └── pnglibconf.h -> libpng16/pnglibconf.h
│       └── lib
│           ├── libpng16.a
│           ├── libpng16.la
│           ├── libpng16.so -> libpng16.so.16.32.0
│           ├── libpng16.so.16 -> libpng16.so.16.32.0
│           ├── libpng16.so.16.32.0
│           ├── libpng.a -> libpng16.a
│           ├── libpng.la -> libpng16.la
│           └── libpng.so -> libpng16.so
├── zbar
│   ├── CMakeLists.txt
│   ├── config.c
│   ├── config.h
│   ├── debug.h
│   ├── decoder
│   │   ├── code128.c
│   │   ├── code128.h
│   │   ├── code39.c
│   │   ├── code39.h
│   │   ├── ean.c
│   │   ├── ean.h
│   │   ├── i25.c
│   │   ├── i25.h
│   │   ├── pdf417.c
│   │   ├── pdf417.h
│   │   ├── pdf417_hash.h
│   │   ├── qr_finder.c
│   │   └── qr_finder.h
│   ├── decoder.c
│   ├── decoder.h
│   ├── error.c
│   ├── error.h
│   ├── event.h
│   ├── image.c
│   ├── image.h
│   ├── img_scanner.c
│   ├── img_scanner.h
│   ├── libzbar.rc
│   ├── Makefile.am.inc
│   ├── mutex.h
│   ├── processor.h
│   ├── qrcode
│   │   ├── bch15_5.c
│   │   ├── bch15_5.h
│   │   ├── binarize.c
│   │   ├── binarize.h
│   │   ├── isaac.c
│   │   ├── isaac.h
│   │   ├── qrdec.c
│   │   ├── qrdec.h
│   │   ├── qrdectxt.c
│   │   ├── rs.c
│   │   ├── rs.h
│   │   ├── util.c
│   │   └── util.h
│   ├── qrcode.h
│   ├── refcnt.c
│   ├── refcnt.h
│   ├── scanner.c
│   ├── svg.h
│   ├── symbol.c
│   ├── symbol.h
│   ├── thread.h
│   ├── timer.h
│   ├── video.h
│   ├── window.h
│   └── zbar.h
├── zlib
│   └── install
│      ├── include
│      │   ├── zconf.h
│      │   └── zlib.h
│      └── lib
│          ├── libz.a
│          ├── libz.so -> libz.so.1.2.11
│          ├── libz.so.1 -> libz.so.1.2.11
│          └── libz.so.1.2.11
│ 
├── CMakeLists.txt
├── CMakeLists.txt_for_main_backup
├── main.cpp_backup
├── lelimg_qrdet.cpp
├── Levels.cpp
├── Levels.hpp
└── readme	
基本上 zbar子文件夹是源码目录 其他是 指定库目录,真正需要编译的是根目录的源码和 zbar里的源码,
所以这两个目录下都有 CMakeLists.txt 配置文件
(注意没有自编编译的opencv库,因为太大了,没放这了)
然后这里有两个不一样的项目,一个 main.cpp,一个是 lelimg_qrdet.cpp,因为两个main函数,
所以比如如果要使用其中 lelimg_qrdet.cpp 时,既要把 main.cpp 与其对应的 CMakeLists.txt 注释掉
	qr目录下的 CMakeLists.txt:
	cmake_minimum_required(VERSION 2.8)
	PROJECT(qr)
	# .c和.cpp都用 G++ 编译, zbar的源码很奇怪.c++的标准,却是.c文件的名字
	set(CMAKE_CXX_COMPILER "/usr/bin/g++")  
	SET(CMAKE_C_COMPILER "/usr/bin/g++")  
	# 改 bin文件的执行地
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)
	# 设置 变量 可以允许 换行 缩进 空格 来分割参数
	set(BASE_INCLUDE 
	#c++标准头文件路径 与编译器版本相关 例如 cstdlib,我们用的是系统4.8.5版本的g++
		/usr/include/c++/4.8.5
	)
	set(OPCV249_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_output/install_usr_local/include/opencv-2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_output/install_usr_local/include/opencv-2.4.9/opencv2
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_output/install_usr_local/include/opencv-2.4.9/opencv
	)
	set(ZBAR_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/zbar
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/include/
	)
	set(ZLIB_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/zlib/install/include)
	set(LIBPNG_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libpng)
	set(LIBICONV_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libiconv)
	set(QR_INCLUDE ${BASE_INCLUDE} ${LIBICONV_INCLUDE} ${OPCV249_INCLUDE} ${ZBAR_INCLUDE} ${ZLIB_INCLUDE} ${LIBPNG_INCLUDE} )
	
	# set(OPCV249_LIB_DIR /home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib)
	set(OPCV249_LIBS  
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_calib3d.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_flann.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_legacy.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ocl.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ts.a 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_video.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_contrib.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_gpu.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_ml.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_photo.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_videostab.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_core.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_highgui.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_stitching.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_features2d.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_imgproc.so.2.4.9
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_objdetect.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_superres.so.2.4.9 
		/home/infortech-ubuntu-1404/1tb_disk/install_usr_local/lib/libopencv_nonfree.so.2.4.9
	)
	set(LIBICONV_LIBS  
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libiconv/install/lib/libcharset.so.1.0.0
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libiconv/install/lib/libiconv.so.2.5.1
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libiconv/install/lib/libcharset.a   
	        /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libiconv/install/lib/preloadable_libiconv.so
	)
	set(ZLIB_LIBS
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/zlib/install/lib/libz.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/zlib/install/lib/libz.so.1.2.11
	)
	set(LIBPNG_LIBS
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libpng/install/lib/libpng16.so.16.32.0
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/cmake_pjt/qr/libpng/install/lib/libpng16.a
	)
	set(QR_LIBS ${LIBPNG_LIBS} ${OPCV249_LIBS} ${ZLIB_LIBS} ${LIBICONV_LIBS} )
	# 链接库先后顺序非常讲究 比如说这里在链接 OPCV249_LIBS 之前先接 自编译的libpng,不然会自动取系统的libpng 
	# png 链接只静态库没有问题,如果有动态库,会优先链接动态库!!

	# 包含子文件夹 这里说明这个CMakeLists.txt 的变量 可以传递到子目录的CMakeLists.txt使用
	add_subdirectory(zbar)

	# 把 ./ 路径的所有源码文件路径作为参数 压入 指定变量
	aux_source_directory(./ DIR_SRC)
	# 添加 头文件搜索路径
	include_directories(${QR_INCLUDE})
	# 直接 指定所需要库文件 及其 给出绝对文件路径 
	LINK_LIBRARIES(${QR_LIBS})  
	# 编译所有 .o文件, 并链接最后生成可执行文件 qr
	add_executable(qr ${DIR_SRC})

	# 这里给链接成可执行文件qr 附加补充条件
	# 因为是补充命令target_link_libraries 只能在add_executable 命令之后
	# 除了 LINK_LIBRARIES 指定的链接库外, 还需要通过 -l 参数链接 libzbar 这个库
	# 这个变量 libzbar 并没有被这个CMakeLists.txt定义,
	# 但它是 zbar 子目录的CMakeLists.txt 传递上来的变量
	target_link_libraries(qr libzbar)
然后 子目录zbar 的配置文件 CMakeLists.txt:
	# cmake的最低版本号还是要填的
	cmake_minimum_required(VERSION 2.8)

	# 这个子目录的 CMakeLists.txt, 可继承使用 父文件夹 CMakeLists.txt的头文件定义的变量
	# 因为 父文件夹 CMakeLists.txt 使用 add_subdirectory(zbar) 建立了关系
	# 添加头文件路径 库路径 
	include_directories(${QR_INCLUDE})
	LINK_LIBRARIES(${ZLIB_LIBS} ${LIBICONV_LIBS})  
		
	# 把当前目录的 所有源码路径都 压入 ZBAR_ROOT变量
	aux_source_directory(. ZBAR_ROOT)
	# zbar又有两个子目录,难道还要做一次 add_subdirectory,然后在两个子目录里再做一次 CMakeLists.txt 么?
	# 其实并不需要,也可以直接这种方法,
	# 分别把 不同子目录下的源码都压入 指定 变量
	aux_source_directory(./qrcode QRCODE_SUB)
	aux_source_directory(./decoder DECODER_SUB)
	
	# 编译所有源码生成.o文件, 并链接最后生成一个 库文件  libzbar
	# 这个 libzbar 除了是一个实体库文件外,也是一个传递给父文件夹CMakeLists.txt使用的一个变量
	add_library(libzbar ${QRCODE_SUB} ${DECODER_SUB} ${ZBAR_ROOT})
然后跑到 qr->build
cmake ..
make
最后生成可执行的 qr 







20180613
先移植 zbar 到 a5d4
新建的 arm_pjt -> qr 同样 lelimg_qrfet 和 main 两个项目共用资源
先移植 main 简单实现 zbar 识别
编译必要的库:
iconv:
	./configure --host=arm-linux-gnueabihf --enable-shared --enable-static --prefix=/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv/install
	make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm
	make install
zlib
	./configure --prefix=/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install
	主动修改 makefile 文件,把所有编译工具换成 arm-linux-gnueabihf-XX
	由于 makefile 并没有使用 CROSS_COMPILE ARCH,所以 make CROSS_COMPILE=arm-linux-gnueabihf- ARCH=arm 没有作用
	make
	make install
libpng
	export LDFLAGS="-L/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install/lib"
	export CPPFLAGS="-I/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install/include"
	./configure --host=arm-linux-gnueabihf --prefix=/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libpng/install 
	make
	make install
使用cmake 编译项目,
同样地,main.cpp 对应的 CMakeLists.txt内容为:
	cmake_minimum_required(VERSION 2.8)
	# 这也是一种习惯,表明我们 项目对应linux系统,不管是不是嵌入式
	set(CMAKE_SYSTEM_NAME Linux)	
	PROJECT(qr)


	#由于是 arm 环境,所以要指定 对应的 环境,以这个目录为开始,让项目优先再这里查询需要的头和库
	#这里有必要重点讨论!!
	#这个目录一般是 指定到 交叉编译环境安装目录...
	set(CMAKE_FIND_ROOT_PATH 
		"/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf"
	)  
	#从来不在指定目录下查找工具程序
	set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
	#只在指定目录下查找库文件
	set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
	#只在指定目录下查找头文件
	set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
	#这里有必要重点讨论!!
	#如果项目是面向 pc机子本身, CMAKE_FIND_ROOT_PATH 一般默认是 / ,
	#	编译后的项目运行时,一般会在使用 /usr/lib/libxx.so 路径下的动态库工作
	#如果项目是面向 某嵌入式机子, CMAKE_FIND_ROOT_PATH 一般默认是编译工具路径例如:
	#	/opt/gcc-linaro-arm-linux-gnueabihf-4.7/arm-linux-gnueabihf ,
	#	而编译器也有 arm 格式的 libxx.so, 一般放在:
	#	/opt/gcc-linaro-arm-linux-gnueabihf-4.7/arm-linux-gnueabihf/usr/lib/libxx.so
	#	编译后的项目在嵌入式平台工作时,也会寻找 /usr/lib/libxx.so 路径下的libxx.so工作
	#如果项目是面向 某嵌入式机子, 而编译器也有 arm 格式的 libxx.so, 放在:
	#	/opt/gcc-linaro-arm-linux-gnueabihf-4.7/arm-linux-gnueabihf/bilibili/libxx.so
	#	编译后的项目在嵌入式平台工作时,也会寻找 /bilibili/libxx.so 路径下的libxx.so工作
	#就是所 编译器文件夹的文件布局基本上应该等于对应嵌入平台的根文件系统的文件布局
	#但是很多时候来两者布局并不一致,所以就得再嵌入平台上做好多匹配库路径的工作!!


	# 全换成 G++,因为zbar虽然.c文件但使用了c++标准来写
	set (CMAKE_CXX_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-g++")  
	set(CMAKE_C_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-g++") 
	# 改 bin文件的执行地
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)
	# 设置 变量 可以允许 换行 缩进 空格 来分割参数 注意没有使用到opencv,所以opencv的内容都删了
	set(BASE_INCLUDE 
		#c++标准头路径 与编译器版本相关 例如 cstdlib
		#这里就是 编译工具路径下的文件布局还是很不统一规范的,
		#即使设置了CMAKE_FIND_ROOT_PATH,也难免也有找不到头和库的问题,
		#那就需要自己额外补充
		#/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf/libc/usr/include
	)
	set(ZBAR_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zbar
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/include/
		)
	set(ZLIB_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install/include)
	set(LIBPNG_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libpng)
	set(LIBICONV_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv)
	set(QR_INCLUDE ${BASE_INCLUDE} ${LIBICONV_INCLUDE} ${ZBAR_INCLUDE} ${ZLIB_INCLUDE} ${LIBPNG_INCLUDE} )
	
	#嵌入平台一般缺各种动态库,所以避免麻烦,项目直接链接静态库.a 把所有用到的都绑到程序里比较快捷
	set(BASE_LIBS
		#即使设置了CMAKE_FIND_ROOT_PATH,也难免也有找不到头和库的问题,
		#那就需要自己额外补充
		# 解决 undefined reference to `clock_gettime' 缺库
		/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf/libc/usr/lib/arm-linux-gnueabihf/	librt.a
		# 解决 undefined reference to `__libc_do_syscall' 缺库
		/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf/libc/usr/lib/arm-linux-gnueabihf/libc.a
	)
	set(LIBICONV_LIBS  
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv/install/lib/libiconv.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv/install/lib/libcharset.a   
	)
	set(ZLIB_LIBS
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install/lib/libz.a
	)
	set(LIBPNG_LIBS
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libpng/install/lib/libpng16.a
	)
	set(QR_LIBS ${BASE_LIBS} ${LIBPNG_LIBS} ${ZBAR_LIBS} ${ZLIB_LIBS} ${LIBICONV_LIBS} )
	# 链接库先后顺序非常讲究 比如说这里在链接 ZBAR_LIBS 之前先接 自编译的libpng,不然会自动取系统的libpng 
	# png 链接只静态库没有问题,如果有动态库,会优先链接动态库!!
	

	add_subdirectory(zbar)
	aux_source_directory(./ DIR_SRC)
	include_directories(${QR_INCLUDE})
	LINK_LIBRARIES(${QR_LIBS})  
	add_executable(qr ${DIR_SRC})
	target_link_libraries(qr libzbar)
同样地,zbar子目录 对应的 CMakeLists.txt内容为:	
	cmake_minimum_required(VERSION 2.8)
	# 继承 父文件夹 CMakeLists.txt set的所有变量,这里直接使用
	# 添加头文件路径 库路径
	include_directories(${QR_INCLUDE})
	LINK_LIBRARIES(${BASE_LIBS} ${ZLIB_LIBS} ${LIBICONV_LIBS} ${LIBPNG_LIBS})  

	aux_source_directory(. ZBAR_ROOT)
	aux_source_directory(./qrcode QRCODE_SUB)
	aux_source_directory(./decoder DECODER_SUB)

	add_library(libzbar ${QRCODE_SUB} ${DECODER_SUB} ${ZBAR_ROOT})
然后回到 arm_pjt/qr/build
cmake ..
make
在 build/bin 得到 qr 可执行程序
然后 a5d4:
udhcpc
tftp -gl qr 200.200.200.100  //下载可执行程序
tftp -gl though.png 200.200.200.100	//下载图片
chmod 777 qr	//改权限
./qr	//执行


回顾架设 a5d4-ov640 环境,测试 qr-det!!
at91-sama5d4_xplained.dts:
	sp2519与ov2640 共用了 i2c 0x30的六位地址,把sp2519 改其他地址
内核编译
	make ARCH=arm menuconfig	//注意不是 make menuconfigure
lcd 显示:
	lcd framebuffer 驱动初始化没有问题,但是不显示,,
	设置 menuconfig:
		Graphaics Support -> Frame buffer Devices -> AT91/AT32 LCD Controler support
				  -> Blacklight & LCD device support -> Lowlevel LCD controls
								     -> Lowlevel Backlight controls
								     -> Generic PWM based Backlight Driver
	10分钟自动关屏幕:
		直接在此 log grep 10分钟自动关屏幕 查看解决方法!!
摄像头,使用了蓝色版本的模块
	基本上改了 dts 就能用!!
	rootfs 带有 gstreamer0.1 所以以下指令测试:
	gst-launch v4l2src device="/dev/video0" ! video/x-raw-yuv,width=640,height=480 ! ffmpegcolorspace ! fbdevsink		
	lcd 可以看到采集图像!!
交叉编译 opencv
使用 cmake_gui cmake opencv 项目
设置好 source 和 build 路径
configure 选 specify options for cross-compiling
	targetsystm 随便填,一般填 linux 即可
	version processor 不用管
	targetroot 就是 CMAKE_FIND_ROOT_PATH 
  	targetroot 相关的对应 CMAKE_FIND_ROOT_PATH_MODE_PROGRAM
		CMAKE_FIND_ROOT_PATH_MODE_LIBRARY
		CMAKE_FIND_ROOT_PATH_MODE_INCLUDE
 	search in targetroot then native system 等于 ONLY
	其他选项分别对应 BOTH NEVER
	C 和 C++ 编译器需要选 arm-linux-gnueabihf-的
	然后configure出错 因为用不着 CUDA 所以 with CUDA 剔除
	更改 安装目录: CMAKE_INSTALL_PREFIX
	特别注意!!
	BUILD_SHARED_LIBS 设置生成的是静态库还是动态库!!!
然后开始 make 编译: 
	错误1
	Linking CXX shared library ../../lib/libopencv_core.so
	/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/../lib/gcc/arm-linux-gnueabihf/4.7.3/../../../../arm-linux-	gnueabihf/bin/ld: ../../3rdparty/lib/libzlib.a(inflate.c.obj): relocation R_ARM_THM_MOVW_ABS_NC against `a local symbol' can not be used when making a shared object; recompile with -fPIC
../../3rdparty/lib/libzlib.a: could not read symbols: Bad value
	当一个动态库liba.so需要 链接上libusb-1.0.a时，出现如下错误
	推测是因为指编译libusb时需要加上-fPIC参数 注意,是 CFLAGS 和CXXFLAGS 都加 -fPIC 不是其他地加,对应gcc g++
	错误2
	../../lib/libopencv_core.so: undefined reference to `pthread_spin_init'
	../../lib/libopencv_core.so: undefined reference to `pthread_spin_unlock'
	../../lib/libopencv_core.so: undefined reference to `pthread_spin_lock'
	../../lib/libopencv_core.so: undefined reference to `pthread_spin_destroy'
	../../lib/libopencv_core.so: undefined reference to `pthread_once'
	../../lib/libopencv_core.so: undefined reference to `clock_gettime'
	找不到pthread链接库，打开文件夹下的CmakeCache.txt进行修改
	CMAKE_EXE_LINKER_FLAGS:STRING=-lpthread -lrt
	错误3
	后来发现 需要用摄像头,需要支持v4l2 但是 编译opencv时,没有假加入 with _libv4l with_v4l 的 configure
	原因是 specify options for cross-compiling 时,没有填写正确的 targetsystm 和 processor
	先 file -> delete cache,然后重新configure 选 specify options for cross-compiling
	targetsystm 填 LINUX 不能填linux !!!  processor 填 arm 
	然后就出来了!!
这里必须深入 认识 cmake 一番,cmake的 通用变量
	CMAKE_AR : 指定 ar 工具 如 arm-linux-gnueabihf-ar
	CMAKE_CXX_COMPILER : 指定 c++ 编译工具 如 arm-linux-gnueabihf-g++
	CMAKE_CXX_FLAGS: c++编译时 添加的 通用变量项 如 -fPIC -lpng
	CMAKE_CXX_FLAGS_DEBUG: c++编译debug分支时 一般添加上的变量项 如 -g
	CMAKE_C_COMPILER : 指定 c 编译工具 如 arm-linux-gnueabihf-gcc
	CMAKE_C_FLAGS: c编译时 添加的 通用变量项 如 -fPIC -lpng
	CMAKE_C_FLAGS_DEBUG: c编译debug分支时 一般添加上的变量项 如 -g
	CMAKE_EXE_LINKER_FLAGS: 链接成可执行文件时需要用到的 变量 如 -lpthead -lrt
	CMAKE_FIND_ROOT_PATH: 编译过程中用到的所有头和库都从这个文件夹或其子文件夹里找
	CMAKE_FIND_ROOT_PATH_MODE_PROGRAM:编译使用到的工具 是否从CMAKE_FIND_ROOT_PATH里找,一般填never,即否定
	CMAKE_FIND_ROOT_PATH_MODE_LIBRARY:编译使用到的库 一般填only,仅从CMAKE_FIND_ROOT_PATH及子文件夹里找
	CMAKE_FIND_ROOT_PATH_MODE_INCLUDE:编译使用到的头 一般填only,仅从CMAKE_FIND_ROOT_PATH及子文件夹里找
	CMAKE_INSTALL_PREFIX: 编译后文件的安装目录
	CMAKE_LINKER: 链接工具 例如: arm-linux-gnueabihf-ld
	CMAKE_MAKE_PROGRAM: make 工具,这是个读取makefile的统筹工具,所以不是交叉编译工具,
		所以做交叉编译时,完全可以用系统PC自带的
	CMAKE_NM: nm工具	
	CMAKE_OBJCOPY: objcopy工具
	CMAKE_OBJDUMP:objdump 工具
	CMAKE_RANLIB:ranlib 工具 
	CMAKE_STRIP:strip 工具
		nm objcopy objdump ranlib strip 工具 都与c,c++工具同配置例如 arm-linux-gnueabihf-
	CMAKE_EXE_LINKER_FLAGS: 编译生成 可执行文件 用到的 变量参数 如 -lpthead -lrt
	CMAKE_MODULE_LINKER_FLAGS: 编译生成 module模块 用到的 变量参数
	CMAKE_SHARED_LINKER_FLAGS: 编译生成 动态库 用到的 变量参数
	CMAKE_STATIC_LINKER_FLAGS: 编译生成 静态库 用到的 变量参数
	CMAKE_SYSTEM_NAME: 系统名字 一般 linux 这个没有多大用处
开始测试 opencv 
	经过折腾,认识到两个要点, 
	一定要静态编译,动态编译要不就是缺库,要不就是版本不对,要不就是路径冲突
		要静态编译,首先opcv库必须是静态库,那么就要重新编译opcv
		特别地 BUILD_SHARED_LIBS 这个cmake参数 设置生成的是静态库还是动态库
		要编译成静态库, BUILD_SHARED_LIBS=0
	静态编译 库参数在编译命令上的位置顺序比较敏感,一般,越基础的库越放在最后面
arm_pjt -> cv 项目实例
	只有一个 main.cpp ,从图片中提取边框然后输出结果图片
	其CMakeLists.txt 内容为:

	#解说过的必要设置	
	cmake_minimum_required(VERSION 2.8)
	PROJECT(cv)
	set(CMAKE_FIND_ROOT_PATH 
		"/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf"
	)  
	set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
	set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
	set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
	set (CMAKE_CXX_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-g++")  
	set(CMAKE_C_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-gcc") 
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)

	#网上说明的全静态库链接 注意 是 -pthread 不是 -lpthread 未完全理解参数设置的方法
	#这个地方是全静态链接生成 可执行文件的重点, 需要好好分析
	set(CMAKE_EXE_LINKER_FLAGS "-static -pthread -lstdc++ ")

	# 头 和 库参数设置
	set(OPCV249_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include/opencv2
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include/opencv
	)
	set(CV_INCLUDE ${OPCV249_INCLUDE} )

	set(BASE_LIBS /opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf/libc/usr/lib/arm-linux-gnueabihf/librt.a)
	set(OPCV249_LIBS  
		#静态链接,越基础的库放在越后面	
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_imgproc.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_highgui.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_core.a	
	)
	set(3RDPARTY_LIBS
		#opcv静态库 需要用到的 第三方静态库,越基础的库放在越后面		
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/libIlmImf.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibjasper.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibjpeg.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibpng.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibtiff.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/libzlib.a
	)
	set(CV_LIBS ${OPCV249_LIBS} ${3RDPARTY_LIBS} ${BASE_LIBS} )

	# 曾经解说过的
	aux_source_directory(./ DIR_SRC)
	include_directories(${CV_INCLUDE})
	LINK_LIBRARIES(${CV_LIBS})  
	add_executable(cv ${DIR_SRC})

最后make 编译出可执行文件 cv 通过:
	arm-linux-gnueabihf-ldd --root /opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux  cv
	查看发现没有链接到任何一个动态库,这样才算前静态链接编译成功!!!

	



20180621
中途总结,成功拼接 cam opcv zbar 静态编译成bin 并在 开发板上执行!!
CmakeLists.txt
	# 上述分析过
	cmake_minimum_required(VERSION 2.8)
	set(CMAKE_SYSTEM_NAME Linux)
	PROJECT(qr)
	set(CMAKE_FIND_ROOT_PATH 
		"/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf"
	)  
	set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
	set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
	set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
	set (CMAKE_CXX_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-g++")  
	set(CMAKE_C_COMPILER "/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/bin/arm-linux-gnueabihf-g++") 
	set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ./bin)
	#全静态库链接 注意 是 -pthread 不是 -lpthread
	set(CMAKE_EXE_LINKER_FLAGS "-static -pthread -lstdc++ ")


	# 设置 变量 可以允许 换行 缩进 空格 来分割参数
	set(OPCV249_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include/opencv2
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/include/opencv
	)
	set(ZBAR_INCLUDE 
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zbar
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/include/
	)
	set(ZLIB_INCLUDE 
		#使用 opcv249 的 zlib, opcv与zbar共用同一个库
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opencv-2.4.9/3rdparty/zlib
	)
	set(LIBPNG_INCLUDE 
		#使用 opcv249 的 libpng, opcv与zbar共用同一个库
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opencv-2.4.9
	)
	set(LIBICONV_INCLUDE /home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv)
	set(QR_INCLUDE ${OPCV249_INCLUDE} ${LIBICONV_INCLUDE} ${ZBAR_INCLUDE} ${ZLIB_INCLUDE} ${LIBPNG_INCLUDE})

	set(BASE_LIBS
		#有clock_getime unreference 的错误,需要链接 rt库 (realtime库) 
		/opt/gcc-linaro-arm-linux-gnueabihf-4.7-2013.04-20130415_linux/arm-linux-gnueabihf/libc/usr/lib/arm-linux-gnueabihf/librt.a)
	set(OPCV249_LIBS  
		#静态链接,越基础的库放在越后面              
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_imgproc.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_highgui.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/lib/libopencv_core.a	
	)
	set(LIBICONV_LIBS  
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv/install/lib/libiconv.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/libiconv/install/lib/libcharset.a   
	)
	set(ZLIB_LIBS
		#使用 opcv249 的 zlib, opcv与zbar共用同一个库
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/arm_pjt/qr/zlib/install/lib/libz.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/share/OpenCV/3rdparty/lib/libzlib.a	
	)
	set(LIBPNG_LIBS
		#使用 opcv249 的 libpng, opcv与zbar共用同一个库
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/install/share/OpenCV/3rdparty/lib/liblibpng.a
	)
	set(3RDPARTY_LIBS
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/libIlmImf.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibjasper.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibjpeg.a
		/home/infortech-ubuntu-1404/1tb_disk/qr+opencv+gl/opcv_arm/3rdparty/lib/liblibtiff.a
	)
	set(QR_LIBS ${LIBPNG_LIBS} ${OPCV249_LIBS} ${3RDPARTY_LIBS} ${ZLIB_LIBS} ${LIBICONV_LIBS} ${BASE_LIBS} )
	# 链接库先后顺序非常讲究 比如说这里在链接 ZBAR_LIBS 之前先接 自编译的libpng,不然会自动取系统的libpng 
	# png 链接只静态库没有问题,如果有动态库,会优先链接动态库!!

	# 上述 也分析过,不再说明
	add_subdirectory(zbar)
	aux_source_directory(./ DIR_SRC)
	include_directories(${QR_INCLUDE})
	LINK_LIBRARIES(${QR_LIBS})  
	add_executable(qr ${DIR_SRC})
	target_link_libraries(qr libzbar)
接下来就是优化算法,和处理内存泄露的问题!!
	zbar解码太慢,发现是 二维码图片的大小问题, 本来是500x500的, 要降到150x150,比较合适,
	再降下去,解码错误率会增大
	长期工作 解码函数zbar_scan_image速度越慢的问题,本质是 qr_thres 的分配问题!!这里应该出现了泄漏问题!!!
	还有 warpPerspective() 也愈来越耗时!!! 也是与 qr_thres 再分配有关系!!
	也可能是跟堆栈有关系!!
	先不处理,先解决图像预处理时间

获取图片后:
	cvtColor + invalidate  89ms
色即处理寻找 mark: 200ms
	channelwrite 80ms
	targetcopy 1ms
	threshold  3ms
	canny	60ms
	findcontour 20ms
	两个for循环找 mark 10ms	
变换 qr图: 43ms
解码 qr图: 106 ms
	zbar_scan_image 106ms
最后发现, 其实不使用 channelwrite或者invalidate 并没有什么大问题,
现在关键看主预处理函数 threshold()
	重点 parallel_for_ 这是一个并行算法器
	往里面添加需要并行的任务, 提高任务速度
	threshold,我们这里的主要任务是 ThresholdRunner-> thesh_8u
	这个函数也没有多少核心内容,主要还是按像素地改变数据!!
	然而自己写的threshold用了20ms,opcv的却只要3ms??
	疑点1: 使用了 parallel_for_ 从20ms 降到16ms,并没有降到4ms!!
	疑点2: 使用了 HAVE_TEGRA_OPTIMIZATION,但这是针对英伟达gpu的芯片,并没有用到!!
	疑点3: CV_SSE2	这是intel扩充指令集,并没有用到
	疑点4: CV_ENABLE_UNROLLED 使用了,不过只降了1ms
	后面怀疑 TBB ,但是TBB 只针对多核.
	后面 怀疑是, 生成多个线程,然后工作时完全占用cpu资源,
	怀疑使用了 优化的编译选项:使用 CMAKE_CXX_FLAGS : -fpermissive -O3 -DNDEBUG,后降到 5ms!! 
所有图像前期处理去掉,只剩下zbar也是可以工作的,
	zbar本身也做了简单的图像预处理!!	










20180710
a5d4 gcc环境实现裸机移植zbar程序
先实现裸机包程序
	cd examples/isi
	由于isi只能在 ddram上工作,所以默认就是以ddram环境来编译程序的
	而我使用一个现成的 bootstrap: 把 0x40000 开始 0x80000个字节数据 送到 0x26f00000 地址执行
	而且还会对这 0x80000 字节,执行 ecc 校对
	所以需要对 链接脚本, target/sama5d4/toolchain/gnu/ddram.ld 修改:
		ddr (W!RX) : ORIGIN = 0x26f00000, LENGTH = 32m
	make TARGET=sama5d4-ek 		//默认以ddram环境来编译程序
	由于生成 bin文件没有 0x80000 个字节那么大,为了通过ecc检测,需要,erase all 才烧写程序
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c writeboot:build/at91bootstrap-sama5d4_xplained.bin
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c writeboot:build/isi_sama5d4-ek_ddram.bin:0x40000
	成功烧写运行
但是由于移植使用 zbar opencv ,所以使用 atmel 的裸机包,无法写大型裸机软件,
需要另外使用 camke 框架
	一直说没有找到标志, 发现不是 加上-Wl,-Map,xx.map 的问题,而是链接库先后顺序的问题
	最后还有 汇编 问题 ...,还有 c库链接问题
	反正最后 全部用 gcc 编译时, 成功.
	最后测试 g++ 和 gcc 编译的内容混用的问题!!!
	其实就是 .c .cpp .s 混编译的问题
	g++ 编译 .c .cpp时,都当作 c++ 格式编译, 编译,S时, 按 c 格式,
	gcc 只能编译 .c .S, 按 c 格式编译,
	以下是 g++ 编译 .c .s .cpp 的情况下:
		.cpp 调用 .s:  在.cpp上声明 要调用的.s函数 extern "C" void xxx(void);
		.s 调用 .cpp:  在.cpp用 extern "C"{....}包含 .s要调用到的函数
		注意到,
			被 .cpp 用 extern "C"{....}包含的函数,可能不能调用其他的 .cpp 函数
			如果要调用其他 .cpp 函数,如下例子:
			BB.cpp: extern "C"{ 
				include "AA.h"
				void KK(void){.. XAXA() ..}  
				}
			AA.h:   extern "C" void XAXA(void);	//这一步是重点
			AA.cpp: void XAXA(void){...}
	还有 .cpp struct 初始化变量的问题!!!!不能乱序,只能顺序,隔着不需要初始化的也不能落下,也需要给初始值
	假设 g++ 编译 .cpp , gcc编译 .c 的情况下
		在一些 .cpp 用到 .c 对应 .h 文件,以链接.c对应的函数时, .h要添加以下包含代码
		#ifdef __cplusplus
		extern "C"
		{
		#endif
		.....
		#ifdef __cplusplus
		}
		#endif
		这时 gcc 编译时, 自动忽略,仍然按 c 格式编译
		g++ 编译时,会识别到需要链接 c 标准接口函数
	总结一下 extern "C" 的作用:
	g++ 编译含 extern "C" 声明的 函数, 会编译出 c 标准接口函数 , 这些函数 可以直接被 其他c函数直接调用
	g++ 要链接到 c 标准接口函数时,需要在 .cpp 使用 extern "C" 声明要用到的外部 c 标准接口函数
使用 arm-none-eabi-g++: 链接自己的 libc.a 时,总是连不上还有 syscall.c 的 c 标准接口库
当把 syscalls.c取出来编译成.o直接连接时反而成功!!
但是不管.o文件是gcc还是g++编译, 最后一步链接成文件, 使用 arm-none-eabi-gcc 可以链接通过
	











20180716
分析裸机码移植zbar !!
使用isi codec 通道 和 lcd high-end layer
转换一张yuv图片 在 裸机上显示!!,注意 uyvy 和 yuyv 分布都是 yuv422 格式,
然后,测试显示yuv422-uyvy 图片,成功!!
移植 zbar 到单机, qrdectxt 用到 iconv库,试图修改 qrdectxt 去掉!!
img_scanner.c : 去掉 getimeofday... http://www.cnblogs.com/greyorbit/p/8456814.html
syscalls.c 补充了 两个没有用的函数 _open _gettimeofday
发现其实 calloc可用, 是 arm-none-eabi 自带的库
后来发现 调用 zbar/image.c 的函数时,莫名要链接 libc 的 _open_r 和 _open,
	但,zbar/image.c 的函数并没有要打开文件的操作,所以非常诡异!!
	最后,发现,虽然某个地方莫名其妙要链接上,但是实际上并没有使用
接下来最麻烦的是 calloc 函数,貌似并不在堆里申请内存,而是破坏了栈结构,导致系统崩溃
最终查到是 .ld文件路径错了.所以 堆大小一直没有改变!!!!,所以一直出同样错!!
	arm-none-eabi-提供的库函数 malloc..并没有问题,但是他们最终要链接到一个针对板级的函数
	就是 utils/syscalls.c:_sbrk()
	由于堆大小一直没有改变 只有0x200,非常小,导致 _sbrk()出错!!最后导致malloc,calloc 出错!!
	然而并未成功精确定位 arm-none-eabi-里 malloc 源代码位置
	必须 学习写一个自己的 通用的 的 malloc calloc 程序
可能要重构 alloc 和 free 还要学习 链接文件.ld
裸机程序, gcc 的 ld 文件规范:
	定义 存储空间:
	MEMORY
	{
		sram        (W!RX) : ORIGIN = 0x200000,   LENGTH = 128K /* sram */
		ddr         (W!RX) : ORIGIN = 0x26f00000, LENGTH = 128M  /* ddr */
		ddr_nocache  (RWX) : ORIGIN = 0x24000000, LENGTH = 16M  /* ddr (non-cached) */
	}
	这里定义了3个空间: W!RX RWX 是对空间属性的描述, 然后就是空间的始地址,和大小
	W: 空间可供 读写section 使用
	R: 可供 读section 使用
	x: 可供 执行section 使用
	!: 可做 其他分配使用
经过 codeblock 端的 lnx_project/qr 验证, yuv 的y分量可以被读取作为解码数据rawdata!!
qr解码主要在 qrdec.c/_zbar_qr_decode 执行!!就是再一次处理图片然后再解码!!
最后通过 qrdectxt.c/qr_code_data_list_extract_text,处理文本信息
	注意由于去掉了iconv,所以 临时修改 case QR_MODE_BYTE 的内容,以显示qr数据
接下来要解决的是速度问题!!











20180723
最后发现,zbar在 arm-none-eabi 的编译下出了很多问题
首先,不能很好地执行g++的 -O3 优化, 编译时会出现各种标签缺失
然后,不能直接开 VFU 浮点运算器, -mcpu=cortex-a5 -mfpu=vfpv4-d16 (-mfloat-abi=softfp / -mfloat-abi=hard )
变通过 但是运行会崩溃
抛开 zbar 模块, 直接比较, 不上系统的 none-eabi编译器,和上系统的 linux-gnueabihf编译器 对浮点运算的优化
gnueabihf 居然比 eabi 还要快些!!
eabi 要手动添加编译选项 VFU 浮点运算器 和 -O3, gnueabihf 只需要 -O3
当要用到 处理器的 VFP 模块处理浮点运算时,添加编译选项,便会自动把浮点运算的内容转到专门的寄存器处理!!
裸机编译图片, 跑得居然比上系统的还要慢.
还有裸机关了 mmu ,跑浮点的速度才 比得上上系统的速度
裸机编译zbar 加上了 vfp 遇到的问题!!居然是 memcpy 出错??
跟踪记录:(跟踪函数名)
_zbar_qr_decode 1 
_zbar_qr_decode 2 
_zbar_qr_decode 3 
_zbar_qr_decode 31 
_zbar_qr_decode 32 
match_centers 1 
match_centers 2 
try_configuration 1 
try_configuration 2 
try_configuration 3 
try_configuration 4 
try_configuration 5 
try_configuration 6 
try_configuration 7 
try_configuration 8 
try_configuration 9 
try_configuration 10 
try_configuration 11 
try_configuration 12 
qr_code_decode 1 
qr_code_decode 2 
qr_code_decode 3 
qr_code_decode 4 
qr_code_decode 5 
qr_code_decode 6 
qr_code_decode 7 
qr_code_decode 8 
qr_code_decode 9 
qr_code_decode 10 
qr_code_decode 11 
qr_code_decode 111 
rs_correct 1 
rs_correct 2 
berlekamp_massey 1 
berlekamp_massey 2 
rs_poly_copy 1 
嫁了 vfp后, memcpy 只能拷贝一个数据
找到了问题症结: 当使用 vfp4 时, memcpy 不能拷贝 3 的倍数的数据量
最终处理后, 没有mmu,dcache, 开了icache, -O3优化,上浮点运算, 3s处理300k灰度图片,比600ms长
怀疑 ddram 速度没有配置好,尝试使用getting-start demo
使用sram,算浮点 不开mmu,慢,开了mmu快, 但是并不比 no_os_qr2 最佳状态的算浮点快!!!









20180801
bootstrap 的ddram 初始化 面向 200mhz_mck ??
sama5d4 ddram 寄存器 笔记
MR: 0   //普通模式
RTR:30030e  //ram refresh cout 每64ms 刷新一次ram 根据64ms,200mhz_mck,和ram的大小,得到cout大小: 30e:
	REF_PB:0 //刷新所有 bank,即刷新整个ram
	ADJ_REF:0 //不使用调节 刷新率
	ME$_VALUE:3 //默认值3
CR:d0003d //configure register
	NC:0b01 //col地址长度10位
	NR:0b11 //row地址长度13位
	CAS:3 //DDR2/LPDDR2/LPDDR1 CAS Latency 3
	DIS_DLL:0 //enable DLL
	OCD:0 // ddr2 Exit from OCD Calibration mode and maintain settings
	NB:1 // 8 banks
	NDQS:0 //Not DQS is enabled
	DECOD:1 //ethod for address mapping where banks alternate at each DDR-SDRAM end of page of the current bank.
	UNAL:1 //Unaligned access is supported.
TPR0:2233b338 // Timing Parameter 0 Register
	TRAS:8 //Active to Precharge Delay between 0 and 15 ddrck
	TRCD:3 //Row to Column Delay between 0 and 15 ddrck
	TWR:3 //Write Recovery Delay between 0 and 15 ddrck
	TRC:b //Row Cycle Delay between 0 and 15 ddrck
	TRP:3 //Row Precharge Delay between 0 and 15 ddrck
	TRRD:3 //Active BankA to Active BankB between 1 and 15 ddrck
	TWTR:2 //Internal Write to Read Delay between 1 and 7 ddrck
	TMRD:2 //Load Mode Register Command to Activate or Refresh Command between 0 and 15 ddrck
	ddrck 一般就是 mck ?? 未确认
TPR1:b20a928 // Timing Parameter 1 Register
	TRFC:0x28 //Row Cycle Delay between 0 and 127 ddrck
	TXSNR:0xa9 //Exit Self-refresh Delay to Non-Read Command between 0 and 255 ddrck
	TXSRD:0x20 //Exit Self-refresh Delay to Read Command between 0 and 255 ddrck
	TXP:0xb //Exit Powerdown Delay to First Command between 0 and 15 ddrck
TPR2:92328 // Timing Parameter 2 Register
	TXARD:8 //Exit Active Powerdown Delay to Read Command in Mode “Fast Exit” between 0 and 15 ddrck
	TXARDS:2 //Exit Active Powerdown Delay to Read Command in Mode “Slow Exit” between 0 and 15 ddrck
	TRPA:3 //Row Precharge All Delay between 0 and 15 ddrck
	TRTP:2 //Read to Precharge between 0 and 7 ddrck
	TFAW:9 //Four Active Windows between 0 and 15 ddrck
LPR:10000 //low power register
	LPCB:0 //禁止 low-power
	APDE:1 //poewrdown时,快速离开??
MD:6 //Memory Device Register
	MD:6 //选择 DDR2_sdram 模式
	DBW:0 //32位数据模式
LPDDR2_LPR:0	 //不起作用 ,因为选择了DDR2_sdram 而不是 Low-power DDR2-SDRAM
LPDDR2_CAL_MR4:0 //不起作用
LPDDR2_TIM_CAL:6 //不起作用,ZQCS:Reset value is 6 DDRCK
IO_CALIBR:140514 // I/O Calibration Register io阻抗校准
	RDIV:4  // 输出阻抗 DDR2/LPDDR1 serial impedance line = 40 ohms
	EN_CALIB:1 //使能校准
	TZQIO:5 //IO Calibration 不知怎么用
	CALCODEP:4 //This value gives the number of transistor P to perform the calibration. (read-only)	
	CALCODEN:1 //This value gives the number of transistor N to perform the calibration. (read-only)
OCMS:0  // Disables “Off-chip” scrambling for SDRAM access. 
CONF_ARBITER:0  // 访问仲裁设置?  感觉没用上
TIMEOUT:0	// 由于访问仲裁 使用 round-robin 形式, 所以这里不起作用
REQ_PORT_0123:0	// In case of round-robin arbitration, this field is not used
REQ_PORT_4567:0 // In case of round-robin arbitration, this field is not used
BDW_PORT_0123:0 // 貌似也没有用上
BDW_PORT_4567:0	// 貌似没有用上
RD_DATA_PATH:2 // Sampling point is shifted by two cycles. 
	//This sampling point depends on the external bus frequency.
	//The higher the frequency, the more the sampling point will be shifted.
	//设置采样时间? 使用两个时钟周期采样??,时钟越快,采样周期越多
WPMR: //读写保护模式寄存器,可以不管
WPSR: //读写保护状态寄存器,可以不管
DLL_OS: 0 //The hardcoded offsets are selected
DLL_MAO: 0 //也是 The hardcoded offsets are selected ???
发现,真正初始化时间的也就 TRP0,1,2, 其他都是 设置模式!! 











20180802
	勉强确认了解码速度问题
	boorstrap -> uboot -> qr (注意,若要成功,把qr 对应的官方api的 lowlevel的所有初始化去掉)
	640*480 灰阶 250ms 解码时间
	320*240 灰阶 60~80ms 解码时间
	
	测试了解码时间没有什么问题,现在是把摄像头装上
	通过uboot后,qr程序貌似不能很好更改 cp15 寄存器
	例如 cpsr_c 修改会崩溃
	例如  asm("CPSIE   I")   // c中插入的汇编语句 CPSIE  I  使能全局中断指令, 会崩溃!!








20180806
	c与汇编互嵌的参数传递问题!!
	arm 的 15个通用寄存器 标准内容:
		用途	
	r0	argument 1 / result 1 / scratch register 1	
	r1	argument 2 / result 2 / scratch register 2
	r2	argument 3 / scratch register 3
	r3	argument 4 / scratch register 4
	r4	Variable register 1
	r5	Variable register 2
	r6	Variable register 3
	r7	Variable register 4
	r8	Variable register 5
	r9	Variable register 6 / 平台相关寄存器 (SE TR), 与平台相关
	r10	Variable register 7
	r11	Variable register 8
	r12	Intra-Procedure-call scratch register (IP)
	r13	stack point (SP)
	r14	link register (LR)
	r15	program counter (PC)
	1. 父函数与子函数间的入口参数依次通过R0~R3这4个寄存器传递。父函数在调用子函数前先将参数存入到R0~R3中，
		若只有一个参数则使用R0传递，2个则使用R0和R1传递，依次类推，
		当超过4个参数时，其它参数通过栈传递。
		当子函数运行时，根据自身参数个数自动从R0~R3或者栈中读取参数。
	2. 子函数通过R0寄存器将返回值传递给父函数。子函数返回时，将返回值存入R0，当返回到父函数时，父函数读取R0获得返回值。
	3. 发生函数调用时，R0~R3是传递参数的寄存器，即使是父函数没有参数需要传递，子函数也可以任意更改R0~R3寄存器，
		无需考虑会破坏它们在父函数中保存的数值，返回父函数前无需恢复其值。
		AAPCS规定，发生函数调用前，由父函数将R0~R3中有用的数据压栈，然后才能调用子函数，以防止父函数R0~R3中的有用数据被子函数破坏。
	4. R4~R11为普通的通用寄存器，若子函数需要使用这些寄存器，则需要将这些寄存器先压栈然后再使用，
		以免破坏了这些寄存器中保存的父函数的数值，子函数返回父函数前需要先出栈恢复其数值，然后再返回父函数。
		AAPCS规定，发生函数调用时，父函数无需对这些寄存器进行压栈处理，
		若子函数需要使用这些寄存器，则由子函数负责压栈，以防止父函数R4~R11中的数据被破坏。
	5. 编译器在编译时就确定了函数间的调用关系，它会使函数间的调用遵守3、4条规定。但编译器无法预知中断函数的调用，
		被中断的函数无法提前对R0~R3进行压栈处理，因此需要在中断函数里对它所使用的R0~R11压栈。
		对于中断函数，不遵守第3条规定，遵守第5条规定。
	6. R12寄存器在某些版本的编译器下另有它用，用户程序不能使用，因此我们在编写汇编函数时也必须对它进行压栈处理，确保它的数值不能被破坏。
	7. R13寄存器是堆栈寄存器（SP），用来保存堆栈的当前指针。
	8. R14寄存器是链接寄存器（LR），用来保存函数的返回地址。
	9. R15寄存器是程序寄存器（PC），指向程序当前的地址。	
	例子:
	cpsr.S:
		.section .text.v_arm_clr_cpsr_bits
		.global v_arm_clr_cpsr_bits
	v_arm_clr_cpsr_bits:
		push	{r1}
		mrs	r1, cpsr
		mvn	r0, r0
		and	r1, r1,r0
		msr	CPSR_c, r1
		pop	{r1}
		bx	lr
	
		.section .text.v_arm_set_cpsr_bits
		.global v_arm_set_cpsr_bits
	v_arm_set_cpsr_bits:
		push	{r1}
		mrs	r1, cpsr
		orr	r1, r1, r0
		msr	cpsr_c, r1
		pop	{r1}
		bx	lr

		.section .text.v_arm_read_cpsr
		.global v_arm_read_cpsr
	v_arm_read_cpsr:
		mrs	r0, cpsr
		bx	lr
	
		.section .text.v_arm_write_cpsr
		.global v_arm_write_cpsr
	v_arm_write_cpsr:
		msr	cpsr_c, r0
		bx	lr	
	
	cpar.h
	如果是g++编译器:
	extern "C" void v_arm_clr_cpsr_bits(uint32_t mask);
	extern "C" void v_arm_set_cpsr_bits(uint32_t mask);
	extern "C" unsigned int v_arm_read_cpsr(void);
	extern "C" void v_arm_write_cpsr(uint32_t mask);
	如果是gcc编译器
	extern void v_arm_clr_cpsr_bits(uint32_t mask);
	extern void v_arm_set_cpsr_bits(uint32_t mask);
	extern unsigned int v_arm_read_cpsr(void);
	extern void v_arm_write_cpsr(uint32_t mask);
	
	以上声明定义了c函数接口的 4 个 全局的汇编函数
	
	main.c
	#if 1
		unsigned int stat,stat1;
		stat1 = 0x13;
		v_arm_write_cpsr(stat1);	//stat1内容被放在 r0 然后传到 v_arm_write_cpsr 
		stat = v_arm_read_cpsr();	//v_arm_read_cpsr 处理后, 把 r0 的内容传回来 赋值到 stat 上 
		printf("stat %x\n\r",stat);	
	#endif







20180807
	继续探索为什么出现 访问 CSPIE I 崩溃的现象
	初步怀疑是 速度 不一致的问题!!必须追 uboot

	 -> init_sequence_r[] -> run_main_loop -> main_loop
	不追了,后来发现 自己编译过的 at91bootstarp 也做了那个不知名的加速配置,达到与uboot转移一样速度
	然后做了一个 union 的类型处理,图片缓存流数据
	typedef union qr{
		uint8_t *qr1;
		uint8_t (*qr2)[640*2];
	}qrn;
	qrn kkl;
	kkl.qr1=picdata
	那么 kkl.qr2[4][6] 也就指向了对应位置上的数据
	如何使得 130ms 退到 80ms?







20180807
	zxing 可以处理 艺术二维码
	zbar只能方块,正统黑白二维码
	zbar 处理艺术二维码还是很勉强的,zxing听说很好,但是速度不高
	现在终于相当完美地解码极大部分的二维码,最高解码速度可达70ms,一般130ms
	320*240 的窗口.
	可以处理艺术二维码.
	注意 使用 code通道 ,不要使用preview 通道的数据,因为 preview 通道的数据比较差,不好做阈值处理
	面对着艺术类及一些黯淡的二维码,单靠zbar的能力不能很好处理的,所以还得人工预处理
	关于如何快速取一个很好阈值,减少轮询次数,普遍提高解码速度,这里有几条经验
	只针对大部分二维码情况,所以 根据经验选取灰度阈值 90 120 150 180 220
	只在这 5个值上轮询,已经囊括,灰暗低对比度, 高亮低对比度,渐变彩色 大部分情况
	一般难解码的二维码,
		通过换个位置角度,换张采样图片的方式,
		而不是死扣一张采样图片,不停换预处理阈值
		这样子的解码效率是最高的!!
		所以,最合理的解码方法是,
			每张采样图片只解码一次,
			每张采样图片都只做一次阈值处理.最后解码不成功,直接丢弃获取下张采样图片
			就是說一张张接连取得到的采样图片都轮流只取 5个灰度阈值中的一个.然后解码,
			由于解码时,二维码大多数都以一个固定的位置,所以每张接连取得的采样图片其实都是差不多一样的
			但是如果使用者要变换位置时,程序也能及时取得新位置解码
			所以这种解码方法效率比较高!
额外:
科学上网 关于 火狐 foxyProxy 模式订阅:
订阅网址: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt
60分钟更新, autoProxy base64 编码 使用127.0.0.1:1080 代理
验证id 中国嫩否访问: ping.chinaz.com
购买 vultr 代理服务器!!

其他:
舵机接线 : +,-,pwm信号
舵机组成 : 直流碳刷电机,控制电路,减速机,
舵机控制原理:
	舵机的控制一般需要一个20ms的时基脉冲，该脉冲的高电平部分一般为0.5ms~2.5ms范围内的角度控制脉冲部分。
	以180度角度舵机为例，那么对应的控制关系是这样的：
		0.5ms--------------0度；
		1.0ms------------45度；
		1.5ms------------90度；
		2.0ms-----------135度；
		2.5ms-----------180度； 		
舵机属于位置状态电机,一般速度是不可控制的,所以舵机与伺服电机不一样!!
步进电机和伺服电机本质上的最大区别在于，一个是开环控制，一个是闭环控制
	所谓开环，就是只管控制，不管反馈
	一般工业用的伺服电机都是三环控制，即电流环、速度环、位置环，分别能反馈电机运行的角加速度、角速度和旋转位置。
	伺服电机能保证只要负载在额定范围内，就能达到很高的精度，具体精度首先受制于编码器的码盘，与控制算法也有很大关系。
伺服电机控制原理:
		











20180828
芯片商:
    1.存储芯片厂家：
	    韩系：三星，海力士（现代）
	    欧美系：美光，ST，恩智浦，英特尔，英飞凌，SANDISK(闪迪)，TI（德州仪器）,ADI(亚德若)，
	           AMD(超威)，SKYWORKS（思佳讯），Spansion(飞索半导体)，Kingston（金士顿）
	    日系：尔必达(被美光收购)，东芝，瑞萨，松下(Panasonic)
	    台湾：华亚科技（美光合资厂），南亚科技，瑞晶（尔必达合资厂），华邦，MTK（联发科），MXIC(旺宏),Etron(钰创),Zentel(力积,力晶投资)
    2.内存颗粒厂家：
	    韩系：Samsung(三星)，Hynix(海力士)
	    日系：NEC(恩益禧)，Hitachi(日立)，ELPIDA(尔必达)，
	    欧美系：Micron(美光)，siemens(西门子)，Infineon （英飞凌，德国，由西门子内存重组），Qimonda（奇梦达 ，德国，由英飞凌内存重组）
	    台湾：Nanya(南亚） ，Winbond(华邦） ，PSC(力晶），ProMos(茂德)
    3.终端存储模块及产品厂家：
	    勤茂(上海)，Kingmax(胜创，台湾)，Corsair（海盗旗）--DDR4，Apacer（宇瞻），金邦，威刚（ADATA）
    4.NAND Flash芯片厂家：
	    三星，东芝，美光(收购了尔必达)，SK海力士，闪迪(SanDisk)
    5.DRAM芯片厂家：
	    三星，SK海力士，美光三足鼎立
    6.eMMC控制IC厂家：
	    慧荣，群联，擎泰，鑫创3S
着手开发硬件模块:
	计划使用 sp2519 , 和a5d2!!
	a5d2 512MB ddr空间 0x20000000, 另外 512MB AESB ddr空间 (空置,没有用到)
	xpl 并联了两块 MT41K128M16 ddr3l sdram (镁光)
		芯片参数是: 128Meg x 16
			单元是 16 bit的一个单元
			(16K row-addr) x (1k col-addr) X (8 banks) = 128Meg
			1k 即 1024
			128Meg x 16 = 2Gb = 2Gbits
			(16 x 1024 x 1 x 1024 x 8 x 16) / 1024 / 1024 / 1024 = 2Gb
			2Gb = 256 Mbytes = 256MB
			所以并联了 两块 组成 512MB
			ddr_A[13:0] : row_addr
			ddr_A[9:0] : col_addr
			ddr_ba[2:0] : banks
			ddr_d[31:0] : 分成 31:16, 15:0 并接到 两块ddr上	
		就是说 ram 单元一定要 32 bits 用上全部 ddr_d[31:0]
	xpl 用的是emmc : MTFC4GLDEA-0M WT 4GB a5d2支持 emmc4.51 , 未知如何选择 emmc芯片!!
		emmc > 4.51 的闪存也可以接,只是只能使用4.51的功能而已 			
	内存闪存一体封装 ram,flash一体 MCP
		三星mcp : K524G2GACB, 
		金士顿mcp : KSLCMBL2VA2M2C :4Gb SLC nand + 2Gb lpddr2ram  12刀
		镁光: MT29AZ5A3CHHWD 18AIT 4Gb nand + 2Gb lpddr2 
		南亚: 有mcp  没有emcp
		华邦: 有mcp  没有emcp
	减少开发程度,因为xpl接的是 ddr3l和emmc, 所以选用 eMCP emmc+ddr 
		emcp主要规格: 4+4:6.4刀  4+8:11~12刀  8+8:12.5~13.5刀 16+8:16-~17刀 (f+d, GB+Gb)
		ddr 尽量 ddr3l 如果是 lpddr3 则需要???? 
		金士顿:04EMCP04-NL3DM627 4GB MLC emmc + 4Gb LPDDR3 40rmb 6.8刀/个 一盘1520个
		深圳 spectek 比较大
		micron  太大
		hynix  没有
		sandisk 没有ddr
		issi : lpddr2+nor  256Mb ddr + 128Mb nor
		samsung : 许多 4Gb ddr + 4GB flash
		东芝:没有
		国产BIWIN:好像没有4Gb ddr
		samsung: KMN5W000ZM-B207  /  KMN5W000RM-B207  /  KMN5U000ZA-B205  4GB+4Gb
初步用 金士顿的吧
摄像头确定 sp2519
电源:分析
	TPS2113 : 多路电源的自动切换 ,开发板两个usb都可以供电,所以有多路电源,我们只用一个usb所以不需要这个
		  但是如果是接pc, tps2113两路供电可以一起用,这样可以提供超过 500ma 电流
	FAN486 :  从pmic获得电源只有 4.8V ,这里是补偿确保输出真正 5V 给元器件使用	
	ACT8945AQJ405-T : PMIC sama5dx 专门 
		VBAT 是电池 / 电源 提供的电压
		wakeup reset : 通过 mpu 的 SHDN 信号控制 pmic 的 pwrhld,
			pnic 通过 pwrhld 和 npbin 的状态来处理 rst,或者wakeup 的内容
			reset a5d2,是通过 pmic的 nrst 发信号
			npbin 也会 影响到 npbstat 的信号 从而 通知 mpu 的 wkup 实现wakeup
		acin chglev chgin 这个是电池充电相关!! 基本不需要的!!
		有一些链接到 mpu 的控制线 ,可以忽略,也可以接上!!看情况
	现在先统筹一下需要用到的 电源:
	pmic I/O 电源:
		5v_ext_inp: 另外外部电源, pmic 输入电源
		VDD_5V_IN: usb电源, pmic 输入电源
		VSYS_5V: pmic 基本 输出电源 基本 4.6-4.8V,有的会转成标准5V VDD_5V_IN后,对有需要外围供电  没有直接对 ddr mpu 直接供电
		VDD_1V35: 对ddr3l供电, 对mpu ddr_resetn针作用, 对 VDDIODDR 供电 
		VDD_1V2: 对 VDDCORE, VDDPLLA, VDDUTMIC, VDDHSIC 供电
		VDD_3V3: 供电 VDDBU, VDDIOP2, VDDIOP!, VDDIOP0, VDDISC,VDDSDHC, emmc,等基本供电源, 没有对 mpu直接供电
		VDDFUSE: 2.5v 给 mpu 的
		VDD_3V3_LP: 供电 VDDOSC,VDDUTMII, VDDANA, VDDAUDIOPLL, VDDSDHC
		VDDSDHC1V8: emmc 相关
	其他供电源:

	mpu电源:
		VDD_5V_IN:接 ACP,ACN 信号??
		VDDIODDR: VDDDDR上的供电 还有 供电ddr量标电压 DDR_VREF
		VDD_1V35: 供电 ddr_resetn针
		DDR_VREF: 分别接到 mpu 和 ddr 作为量表
		VDDCORE: 供电 mpu, 
		VDDPLLA: 供电 mpu,
		VDDUTMIC: 供电 mpu,
		VDDHSIC: 供电 mpu,
		VDDBU:	供电 mpu, 主要是backup模式下用电,所以要么使用,VCC_3V3要么超级电容,绝不断电
		VDDIOP_X, 供电 mpu
		VDDISC: 供电 mpu
		VDDFUSE: 2.5v 给 mpu 的
		VDDOSC: 供电MPU
		VDDUTMII: 供电mpu
		VDDANA: 供电 mpu
		VDDAUDIOPLL: 供电 mpu
		VDDSDHC: 可以是 3v3 可以是1v8 ,要具体分析!!
		其中 GMDUTMII 接地注意!!			
网口:
	RMII: KSZ8081RNB
	贴片磁珠 180ohm 100mhz 时 , 就是 impedence ohm in 100mhz 是180, 很多!!
	发现有 RJ45 connector 有三种地 EARTH_ETH GND_ETH 普通GND 
		EARTH_ETH 是 通过 l24 接到 普通GND 的之子形状大长条
		GND_ETH 是 一丁点 导线,也通过0R电阻接到 普通GND
LCD:
	还行
usb 和 uart串口信息:
	uabA 是直接接到芯片上的,所以通过 usbA 和 sam-ba 烧录 问题不大!
	不论是 ebug 使用的调试串口 还是 ddl电平直接俩连接,都是连接到  pd02, pd03 的针!
5d2-xpl电路板的层数与布局:
	GERBER 是板层布局!!
		lyr: cs 顶层!! 布线
		lyr: sig2t 地层  (普通GND)
		lyr: sig3b 布线,部分铺铜
			   底下,一大片地!!
			   1字块    (左边地块紧靠近) 也是GND
			   丿字块   (1字块上紧靠近)  未知
			   丿字块2  (丿字块旁)	    未知
			   ddr背部  		    未知
			   倒L字块  (右上方)	    5V
			   一字块   (ddr背部块左边)  3V3
		lyr: sig4t 布线,部分铺铜
			   底块 普通GND
			   L字块供电 (地块之上) 5V_EXT_INP (5V)
			   U字块供电 (右侧大块) 普通 GND
			   j字块供电 (上方的)   5V_EXT_INP (5V)
			   上括号块  (j字块沟部分对应) 3V3
			   一字块    (最上方)   非GND, 非5V, 未知
			   1字块     (上括号下) 非5V, 非3V3, 未知
			   点字块    (L字块旁边) 未知.
			   ddr背面块及旁边碎块, 未知
		lyr: sig5b 主要供电层
			   中间一大片是 3.3v 供电, 
			   最下面是 普通GND
			   L字块供电 (这片3v3 与普通GND 夹着的) 非3v3
			   r字块供电 (L字块顶上的), 非3v3, 非电池VBAT电压, 非L字电压, 是VSYS_5V
			   I字块供电 (r字块顶上的). 非3v3, 非VSYS_5V
 			   v字块供电 (3V3半围着的小块), 非3V3, 未知,可能GND
			   丿字块供电 (v字块上), 非3v3, 未知, 可能GND
			   ddr背块 (ddr背后), 非VSYS_5V,未知. 可能GND
			   r和 3V3 包围的许多小块, 未知. 可能GND
				
		lyr: ss 底层 布线 sd所在下面一片是普通GND 中间在 ddr背后的是 VDD_1V35
			r字块 (ddr背后VDD_1V35右下方一小块) VDDIODDR
			VDDIODDR 上面一小片是 VDD5V , VDDIODDR左边的 也是普通GND!! 
重点布线分析. 接出检测点技巧	
	高速元器都放在顶层, 然后 下一层直接是地层,屏蔽所有信号间的干扰
	第三层 主要是 lcd排线 sd卡的 ddr emmc 片
	第四层 主要是 cam排线(与第三层lcd部分重叠) ddr布线(与第三层ddr布线互相垂直), 其他外设线!!
	第5层就是 主要的 供电层了!!
	最后一层是 其他补全布线和各种 耦合 去耦,阻抗匹配 电容电阻
	ddr布线分析: 顶层竖向布线, 二层GND屏噪,三层竖向布线和部分屏噪,四层横向布线,5层电源屏噪??,竖向布线,部分屏噪
		大量蛇线
	emmc:除了第一层,最后一层布线后,几乎都是铺桐屏噪
		

开始pcb:
	kingston Nl3DM627: 接口分布: LPDDR3 interface  
		DNU : do not use
		NC  : no connection 
		VSS : ddr ground
		VSSm: eMMC ground
		还有 ddr 地: VSS 直接代表包含 ddd的 VSS VSSQ VSSCA 	
		    eMMC 地: VSSm 直接代表包含 emmc的 VSS VSSQ
	AD 多原理图 pcb 除了之前画 e70 模块提供接口方式外, 
		也可以默认模式: 多张原理图,使用 netlabel 名字相同,那么多张原理图的元器件是相互链接的!! 


DDR 布线:		
时钟线，射频线，几G高速线走弧线控阻抗，沿线铺地铜皮或地线，沿线打密密麻麻的地孔实现包地屏蔽。为实现走线阻抗，可能沿线隔层掏空。
布线最重要的不仅是清晰好看，而是信号完整性。
VSS为数字地，VSSQ为信号地，若无特别说明，两者是等效的。VDD为器件内核供电，VDDDQ为器件的DQ和I/O供电，若无特别说明，两者是等效的。

对于DRAM来说，定义信号组如下：

数字信号组DQ，DQS，xDM，其中每个字节又是内部的一个信道Lane组，如DQ0~DQ7，DQS，LDM为一个信号组。

地址信号组：ADDRESS

命令信号组：CAS#，RAS#，WE#

控制信号组：CS#，CKE

时钟信号组：CK，CK#

印制电路板叠层，PCB Stackups

推荐使用6层电路板，分布如下：
	0.7mil	signal1
	4.5mil  隔层
	1oz	vss(gnd)
	6.5mil	隔层
	1oz	隔层 + 顶signal2 (其中signal线厚度 0.7mil)
	30mil	隔层 + 底signal3 (其中signal线厚度 0.7mil)
	5mil	隔层
	1oz     vdd	
	4.5mil	隔层
	0.7mil	signal4
电路板的阻抗控制在50~60ohm

印制电路板的厚度选择为1.57mm(62mil)

填充材料Prepreg厚度可变化范围是4~6mil

电路板的填充材料的介电常数一般变化范围是3.6~4.5，它的数值随着频率，温度等因素变化。FR-4就是一种典型的介电材料，在100MHz时的平均介电常数为4.2。推荐使用FR-4作为PCB的填充材料，因为它便宜，更低的吸湿性能，更低的电导性。

一般来说，DQ，DQS和时钟信号线选择VSS作为参考平面(靠近vss层!!)，因为VSS比较稳定，不易受到干扰，地址/命令/控制信号线选择VDD作为参考平面，因为这些信号线本身就含有噪声。

电路板的可扩展性

根据JEDEC标准，不同容量的内存芯片一般引脚兼容，为了实现电路板的可扩展性，可以做如下处理，如128Mb与256Mb的兼容应用。
未用的DQ引脚

对于x16的DDR器件来说，未用的引脚要作一定的处理。例如x16的DDR来说，DQ15：DQ8未用，则处理如下，将相关的UDM/DQMH拉高用来屏蔽DQ线，DQ15：DQ8通过1~10k的电阻接地用来阻止迸发写时的噪声。

端接技术

串行端接，主要应用在负载DDR器件不大于4个的情况下。

对于双向I/O信号来说，例如DQ，串行端接电阻Rs放置在走线的中间，用来抑制振铃，过冲和下冲。

对于单向的信号来说，例如地址线，控制线，串行端接电阻放置在走线中间或者是信号的发送端，推荐放置在信号的发送端。

等长理论: http://www.elecfans.com/article/80/114/2017/20170901543518.html
内存一般为 32位 或 16位,使用一片或两片芯片组成 数据线可以分为 一组,两组或4组	
	一组: data0-31 dqs0-3 dqm0-3 为一组
	二组: data0-15 dqs0-1 dqm0-1 为一组, 
	      data16-31 dqs2-3 dqm2-3 为另一组
	四组: data0-7 dqs0 dqm0 为一组, data8-15 dqs1 dqm1 为一组
	      data16-23 dqs2 dqm2 为一组, data24-31 dqs3 dqm3 为一组
时钟组: DQ_CLOCK,SCLK SCLKN  
地址组:DQ_ADDR0-15, CASN, CKE0, CSN0, RASN, WEN, (BA0,BA1,CSN1/BA2)
数据线组 data dqs dqm 以 dqs 为等长目标	误差(+/-5mm)
时钟线和地址组 时钟信号 地址信号 其他控制信号 以时钟信号为等长目标 误差(+/-1mm)
数据组 和 时钟,地址组 的等长误差(+/-10mm)
线间距 起码 1W (一倍线宽),推荐 2W, 3W 可以减少串绕
同组数据data线 可以任意交换改善布线
确定阻抗以 确定阻抗匹配的方式
同组过孔次数一致!








20181030
	ACT8945AQJ405-T
	LBI 监测供电 主要是监测电池供电,检测结果通过 LBO输出 可以不接
	然后 BAT12,TH 关于电池的也可以不接.
	ISET 通过与地串联合适电阻控制板载电流!
	REFBP 与pmic整体噪音相关,必须通过旁路电容接地,可有效控制pmic输出噪音,和远离高噪声地区,例如远离dc/dc
	ACIN:1, CHGLEV:1, 使得PMIC允许 2A电流
	nPBIN 获得的按键信号输入会, 导致nPBSTAT的信号输入, 两者共同控制按键信号, nPBIN 是被内置上拉到VSYS电压
	注意:nPBIN有跟多功能, 通过50k电阻接地会,pmic,是 enable pmic?? 这里作wakeup
	     而直接 接地, 则会实现 reset
	所以可以直接抄原图 设置 nPBIN nPBSTAT PWRHLD nRSTO 保留实现 reset wackup 功能 
	VSEL 选择 dc/dc 方式
	VP123,INL,都是pmic内部逻辑需求,需要 VSYS提供供电

分析板子 和 eMMC LPDDR3 布线遇到困难,需要学习 eMMC LPDDR3
	发现 emmc 信号线都要 外接上下拉电阻, 上下拉电阻的目的是防止线路出现瞬间漂浮电信号, 
	通过拉电阻控制固定在一个电平(VCCQ)上,不容易出现漂浮信号!!
	VDDCORE 开发板上的连接参考
	电源处的滤波电容并没有为每一针都配备一颗 而是共用的性质,
	在多个相同意义的电源 ball 背后会有一块电源铺铜,在这块铺铜上会并联多个电容来分担滤波效果
	但是条件允许,还是应该做到 每个ball旁边都有对应的滤波电容
	开发板: c28/c27(10uF), c29/c31(100nF), c30(1nF) 靠近 电源 源头滤波
		c143/100nf/H3, c137/1nF/N5, c122/1nF/N9, c108/100nF/K13, c119/100nF/D9, c132/100nF/D7
	ddr 分析
	支持 16/32bit, 8bank, LPDDR3
	DDR_CAL: 串联 24Kohm for LPDDR3
		     24Kohm
	DDR_CAL -- /|/|/|-- GND
	 	|   22pF
		----| |---- GND
	MPDDRC: 0XF000C000
	page492: 接线参考
	page497:
	要使用LPDDR3 寄存器是要修改的
	VDD1.8v, VDDQ1.2v
	VDDIODDR 对应也要 1.2v
	VREFCA =< 0.6 X 1.2v = 0.72v
	VREFDQ =< 0.7 X 1.2v = 0.84v
	统一使用 0.6v
	6.8K/4.7K 可以构建分压1.2v 得到 0.59V
	7.5k/5.1k
	8.2k/5.6k

	6.8k/3k 可以构建分压1.2v 得到 0.69V
	8.2/3.6k 

	ddr的差分时钟信号: clk+ 高电平, clk-低电平时, 整体时钟信号是 positive edge
		所有信号,控制线 都在 整体时钟信号为positive edge 时 使能或数据有效 !
		信号线, 同时也使用到 整体时钟信号为negative edge 状态 是数据有效, 实现 double data rate,提高速度
		NL3DM627: clk+: CK_t  clk-: CK_c
	ddr CKEn CSn# : 之所以有多个,是应为可能有多个 独立的ddr块, 每个 CKEn 控制一个ddr块(piece) 的时钟使能!! CSn# 用于片选ddr块(piece)
		注意这里 的 块(piece) 与 块内的区间(banks) 指代不一样!!
		参考 MT42L128M16D1KL-25-IT_A-Micron datasheet 会 知道 CKE CS# 的含义:
		回到 NL3DM627: ddr是  16M words X 32bits X 8 banks 
				      只有 1 piece 4Gb in 1 package
				即 16M X 8 banks = 128M
				即 16M words X 32bits X 8 banks === 128Meg x 32
				128Meg x 32 = 4Gbit
		整个 NL3DM627 的LPDDR3 只有 1 piece 4Gb, 所以 NL3DM627 只用到 CKE0 和 CS0#, CKE1和CS1#不作为!  
		a5d2 只有 一针 CKE 和 一针 cs ,所以意味着 
			a5d2 只能并接 两块 16bit数据线的ddr 
			或者 只能接一块 32bit数据线的ddr
		lpddr3 地址线只有 ca[0-9] 但是却可以实现 row[0-13], column[0-9],,
	ddr ZQ 一般用来内部稳定和匹配的配置针.很多产品是 串接 240r 到GND
		但是 NL3DM627 是的 ZQ 却有好多解释可以配置 上拉还是 下拉,,,,,,都不知到怎么弄这个!!!
	    ODT 主要用来消耗 芯片内部的有害信号反射
		ODT 和 ZQ 都不知道如何接,所以用一个万能的接法,
		ZQ 默认串联240R 到 GND ,但留出 上拉到 VDDQ的通道
		ODT 默认串联 0R 到 GND ,但露出 上拉到 VDDQ的通道 
	eMMc CLK 注意阻抗匹配.现在是在近MPU处串接了39R
	eMMc DS HS400模式下才会用到的线,但是a5d2不支持,所以不接!!
		DS是eMMc发到 host端 的 时钟线!!
		

接下来就是 lcd加触控 摄像头 
	LCD 有PB PC 两条总线, 按照参考,使用 PC 的DATA口, 不使用PB的
	注意高频规律线的阻抗匹配,例如是时钟线 data addr并线 的高2,3,4位置和低2,3,4位
	还有一般为了空间和成本, 只选两端的单侧匹配,条件允许可以双侧匹配!!
cam:
	PD16 VS peripheral_E	
	PD17 HS peripheral_E
	PD2 Mck peripheral_E (被取缔)	PD11 MCK PERIPHERAL_F (改后)	
	PD15 pck peripheral_E
	PD18 FIELD peripheral_E
	PB11 RST output1     
	PB12 PWD output1    
	PD3 D11 peripheral_E (被取缔)	PB25 D11 PERIPHERAL_F (改后)
	PD4 D10 peripheral_E
	PD5 D9 peripheral_E
	PD6 D8 peripheral_E
	PD7 D0 peripheral_E
	PD8 D1 peripheral_E
	PD9 D2 peripheral_E
	PD10 D3 peripheral_E
	PD11 D4 peripheral_E (被取缔)	PB30 D4 PERIPHERAL_F (改后)
	PD12 D5 peripheral_E
	PD13 D6 peripheral_E
	PD14 D7 peripheral_E

	PC6 TWD peripheral_C
	PC7 TCK peripheral_C















20181114
usb phy debug串口,debug演示灯,按键  


差分信号之间接电阻问题!!
	在高速PCB理论上面有提到，
	差分线中间的电阻是用作差模信号的匹配
	差分线分别接电阻到地是用作共模信号的匹配
	如果差分线分别接电阻，而2个电阻的另一端同时接一个电容，电容另一端接地，这是同时做差模和共模匹配用的
ACC 模拟比较器
	本质就是比较 两个信号源,哪个信号源比哪个高的问题!!
由于 PD2,3 isc 与 dbug uart 共线,所以要做修改!!!
DEBUG UART1
	PD2 URXD1 PERIPHERAL_A
	PD3 UTXD1 PERIPHERAL_A









20181116
拍照补光灯,标识led 然后把 剩下的 12c, spi, uart, pwm拉出
统计分配了使用针口
UART0
	PB26 URXD0 PERIPHERAL_C
	PB27 UTXD0 PERIPHERAL_C
UART2
	PD23 URXD2 PERIPHERAL_A
	PD24 UTXD2 PERIPHERAL_A
SPI1
	PD26 MOSI PERIPHERAL_A
	PD27 MISO PERIPHERAL_A
	PA25 CS0 PERIPHERAL_D
	PC5 CS1 PERIPHERAL_D
	PD30 CS2 PERIPHERAL_A
	PD25 SPCK PERIPHERAL_A
QSPI0
	PA15 CS PERIPHERAL_C
	PA16 IO0 PERIPHERAL_C
	PA17 IO1 PERIPHERAL_C
	PA26 IO2 PERIPHERAL_F
	PA27 IO3 PERIPHERAL_F
	PA14 SCK PERIPHERAL_C
I2C0
	PC0 CLK PERIPHERAL_D
	PD29 DA PERIPHERAL_E
IRQ/FIQ
	PB4 FIQ PERIPHERAL_C
	PB3 IRQ PERIPHERAL_C 	/兼 PWMEXTRG1 PERIPHERAL_D
	PA12 IRQ PERIPHERAL_B
	PD31 IRQ PERIPHERAL_C	/兼 ADTRG PERIPHERAL_A
	PB2 PWMFI0 PERIPHERAL_D
TIME COUNTER
	PA11 TCLK4 PERIPHERAL_D
	PB24 TCLK2 PERIPHERAL_D
	PB28 TIOA5 PERIPHERAL_D
	PB29 TIOB5 PERIPHERAL_D
ADC
	PD19-22 AD0-3 PERIPHERAL_X1	/与电阻触摸共用 adc 信号功能,所以用电阻触摸就不要用adc了!!
	PD28 AD9 PERIPHERAL_X1
pwm
	PA30 PWMH0 PERIPHERAL_D		
	PA31 PWML0 PERIPHERAL_D	/兼 usb_bus_5v (普通的i/o)检测,另外引出一路i/o代替,原线路保留,当用pwm时,可以用双 0R 去耦截断线路
	PB0 PWMH1 PERIPHERAL_D  /虽然接到了led灯,但是可以共用pwm信号, pwm信号越满,led越暗
	PB1 PWML1 PERIPHERAL_D
	PB5 PWMH2 PERIPHERAL_C  /虽然接到了led灯,但是可以共用pwm信号, pwm信号越满,led越暗
	PB6 PWML2 PERIPHERAL_C  /虽然接到了led灯,但是可以共用pwm信号, pwm信号越满,led越暗
	PB7 PWMH3 PERIPHERAL_C  /兼 LCD_IRQ (普通的OUTPUT), 应该另外引出一路i/o代替, 可以用一个 0R 去耦截断线路
	PB8 PWML3 PERIPHERAL_C  /兼 LCD_IRQ (普通的OUTPUT), 应该另外引出一路i/o代替, 可以用一个 0R 去耦截断线路
最后就是普通的i/o
	PC8, PA13, PB13, PA23, PA24
	实现: 补光灯控制, 定位灯/指示灯(共用), usb_bus_5V检测, 2xlcd_irq/通用io(共用!)
	











20181120
检查原理图!!
bga封装, 丝印边界不能与芯片的边界重合!!!!!
已买:(*已收货)	
*	mic5339	
*	32.768khz 12.5pF mc146
*	12mhz 15pF 3325
*	13F-64GYD2PL2NL RJ45带灯
*	KSZ8081RNB
*	25mhz 20pF 3325
	RB160M-60TR 丝印76  SOD-123
	BAT54C	SOT-23
	BSS138	sot-23
	ADG849yksz
	TLV431A sot-23-3
	sp2525A-1en-l
	prtr5v0u2x
未购买芯片:
	ts2113
	fan48610	



	ACT8945AQJ405-T
	2.2uh 贴片点电感


附加补充:特殊符号:http://w13.loxa.edu.tw/ctjh930220/

重点检查对象:
	pmic 关于电池电路不接没有问题, 关于reset wakeup,按原线路接合
	检查了 eMcp 和 mpu 的封装,注意所有bga封装的,边框丝印线不能与芯片的面有面积上重合,刚刚结合最好,方便定位!!
	检查 emcp 的差分信号例如 CK_t 就是 CK+, CK_c 就是 CK- 
	检查每一个复用 GPIO 针
		pb13 是 pmic_irg 不能复用!!! 	
		pb13 接口冲突 优先处理 ! 先取消补光灯
		PD22:TWCK0 PD21:TWD0  
		PC7:TWCK1 PC6:TWD1
		已经有两组 TWI 在工作, 可以释放 PC0:TWCK0 PD29:TWD0 两针!!
			空出了 pc0 pd29
		pb7 pb8 / pa24 pa23 默认78当lcd_irq, 当78做pwm时, 2423当lcd_irq
		已经有一组spi1了,也用了cs0, 
			空出 PA25 PD25 PD26 PD27
		lcd数据线还是全部串 22R 吧!!
		lcd_sys_id 可以跟 rgb_blue ,pwmh1 共存,而不需要断开其中一路,
		rgb_green red 可以与pwm共存,而不需要断开其中一路,
			AREF 是外接参照电压
			关注 PB9, PA13 能不能去复用
	多图项目的严谨原理图思路,
		先局部画出各个部分, 然后检查,然后收集余下未分配针重新分配
		最后补全编号,每个编号都确保唯一!!!
		然后画pcb的经验步骤,把每个子部分器件摆放好!!
		
	pcb-tips
		点击按住元器件,l快捷键 可以快速元器件换层!!
		pcb元器件间距 rules-placement-componont clearance 控制
		Q快捷键 切换 mil mm 

	加工工艺 
		一般工艺
			孔 0.2mm 
			丝印 5mil
			10mil 理论可走1A
			5mil 作为信号足以!!
			0.15孔径过孔,不要超过1.2mm板厚
			0.2mm孔径最好配合0.4盘经,配合0.3也可以,不过偏极限
		过孔盲埋孔类型:
		https://zhidao.baidu.com/question/1987998141612946107.html      过孔设置问题
			普通孔, 压合一次,然后全部通孔,也可以对 最外围层做激光镭射孔,(镭射的能立只能穿一层孔)
			一阶孔, 压合一次,做通孔或者镭射孔, 然后再 补压合一次外层,然后做通孔或者镭射孔
			二阶孔, 压合一次,做通孔或者镭射孔, 补压合一次外层,然后做通孔或者镭射孔, 再补压合一次外层,然后做通孔或者镭射孔
			三阶孔, 压合一次,做通孔或者镭射孔, 补压合一次外层,然后做通孔或者镭射孔, 
				再补压合一次外层,然后做通孔或者镭射孔,再补压合一次外层,然后做通孔或者镭射孔,
			四阶孔, .......以此类推
			也就是, 压合的次数决定了是多少阶孔, 每次压合的层数没有规定,每次压合多少层都打算压合一次!!
		注意工艺与成本的问题
			6层板,通孔,100x100 mm^2 加工 1000多
			6层板,一阶孔, 100X100 mm^2  淘宝5000多, 加上盘中孔, 6000多 
				遇到一个全自己生产不外包的 汇合 pcb 3600 可以做 
			6层板,二阶孔以上 ,不敢想

	多层pcb布线:
	1.先把bga 的针的线引出,注意, 外层两排可以直接引出,内层,必须即时过孔到别层引出
	  必须分好理清线路的出走区域!!!一般 bga的引线都有一定的布置规律,
	  比如 左上方是 普通通讯线,右上方是lcd,cam,左下方是sdcard 一般gpio
	  右下方是 ddr 
	  最后 bottom 层,尽量不要布线!!	
	2,优先 ddr 布线, 注意严格控制等长的线路,过孔的高度页次数都与等长有影响,等长线路应该严控对等过空次数或者总高度
	  因为成本问题,必选向通孔板看齐,不做复杂盲埋孔的板,要做最多也只能是一阶孔的板子
	  布线,主要找出最大长度线作为其他喜爱线路等长的参照,
	  布线时结合等长一起操作 !!!,具体情况具体分析,也可以先布后等长
	  最后 bottom 层,尽量不要布线!!
	3,需要放置电源滤波电容,因此 bga背后尽量不布线, 还要划分出电源区域!!!
	4,布线等长 emmc, sdcard camera lcd 模块!!
	5,布线一般线路 和电源
	6,检查和铺桐













20190406
树莓派3b+
本地电脑作为 dhcp 节点 连接 树莓派:
	sudo apt-get install isc-dhcp-server
	sudo vi /etc/default/isc-dhcp-server 添加:网卡
		INTERFACES="enp0s25"
	sudo vi /etc/dhcp/dhcpd.conf 修改
		# A slightly different configuration for an internal subnet.
		subnet 10.5.5.0 netmask 255.255.255.0 {
		  range 10.5.5.26 10.5.5.30;
		#  option domain-name-servers ns1.internal.example.org;
		#  option domain-name "internal.example.org";
		  option subnet-mask 255.255.255.0;
		  option routers 10.5.5.1;
		  option broadcast-address 10.5.5.255;
		  default-lease-time 600;
		  max-lease-time 7200;
		}
	sudo service isc-dhcp-server restart	启动
	sudo netstat -uap 查看 端口
	发现 没有 dhcpd 失败!!

ubuntu下如何扫描局域网下的ip地址
sudo apt-get install nmap
nmap -v -sP 192.168.100.0/24


官方镜像烧写命令:
sudo apt-get install gddrescue xz-utils
unxz ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img.xz
sudo ddrescue -D --force ubuntu-mate-18.04.2-beta1-desktop-armhf+raspi-ext4.img /dev/sdb
通用烧写命令:
sudo dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdb


关于安装镜像和 hdmi lcd 驱动的问题!!!!!
ubuntu18(x64) 可成功 安装hdmilcd驱动, (只是配置而已,不是真正意义上的安装)
	参考 7inch hdmi dispaly-B 用户手册
	config.txt
	max_usb_current=1
	hdmi_force_hotplug=1
	config_hdmi_boost=7
	hdmi_group=2
	hdmi_mode=1
	hdmi_mode=87
	hdmi_drive=1
	hdmi_cvt 800 480 60 6 0 0 0
ubuntu18 虽然已安装了ssh,但是默认是不可用的!!!, 需要首次启动重新配置ssh 才可以使用
	sudo systemctl enable ssh.service
	sudo dpkg-reconfigure openssh-server
	sudo service sshd start
目前新版kali(x64) ssh默认可用,但是添加了一般不完整的配置信息 hdmi lcd 后会崩溃 
	最新测试,config.txt 完整添加后 可以运行 (未接hdmi测试)
	max_usb_current=1
	hdmi_force_hotplug=1
	config_hdmi_boost=7
	hdmi_group=2
	hdmi_mode=1
	hdmi_mode=87
	hdmi_drive=1
	hdmi_cvt 800 480 60 6 0 0 0
	注意到,首次启动,不能接着 hdmi启动,不然崩溃 !!必须开机稳定以后,插入hdmi 便看到输出
	首次启动之后就可以 接着hdmi上电板子了
kali设置 蓝牙键盘!!
	远程ssh root toor后,	
	sudo service bluetooth start 开启蓝牙服务,  kali默认不开启蓝牙
	bluetoothctl	打开蓝牙命令窗
		power on  蓝牙模块上电
		agent on  蓝牙设备的代理服务启动,就是负责管理多个蓝牙链接设备同时运作的后台功能
		default-agent  默认代理功能,就是说 service bluetooth start 自动启动 power on, agent on
		sacn on  扫描蓝牙设备
		pair  60:73:00:0D:0E:51 配对蓝牙设备,然后设备输入pin码配对. 注意 配对成功不意味 就是链接可用
		connect 60:73:00:0D:0E:51 连接设备 , 当设备还处于配对广播时,才有机会链接成功
			链接成功时,  ServicesResolved: yes   Connected: yes
			[bluetooth] 命令行前缀会变成 链接设备的 [bluetooth 3.0 keyboard] 的前缀 
		pairable on 设备处于可接受外部配对的请求 的状态
		discoverable	设备处于可被外部设备发现 的状态
		remove 60:73:00:0D:0E:51 移除配对成功的设备
			注意当设备处于 非配对广播期, 连接成功的设备很容易下线,下线后,设备主动连接回来会被拒绝
			导致超时低功耗后,重新工作的蓝牙建键盘无法连接回来
			需要 让外部设备 开配对广播, kali再主动 connect 回去,非常不合理
		trust 60:73:00:0D:0E:51 把外部设备假如信任名单,这时,如果跟外部设备断开,外部设备主动接回来将允许
			这样就不怕意外断开,因为会自动重链成功
		exit 会离开bluetoothctl 并关闭蓝牙
		quit 只是推出 bluetoothctl 蓝牙后台运行
	然而 sudo service bluetooth start , bluetoothctl  这些设置都不会 让蓝牙开机默认启动, 
	蓝牙开机启动 设置 update-rc.d bluetooth enable
		这意味着 开机自动 sudo service bluetooth start 因为设置过 default-agent
		所以 自动 power on, agent on
		由于 pair 成功的设备 又加入了 trust 名单
		所以外部设备在非配对广播期间 要 连接到 kali ,kali 允许
		例如, 板子上电后,不一会 蓝牙键盘就自动可用了!!!!!
	
备份已有的 sd 卡镜像!!! (备份ubuntu18mate为例子)
不是 传统的 dd 操作,而是巧妙地把有效数据拉出来 备份!!
https://blog.csdn.net/zhufu86/article/details/78821056  通过 pc 来备份 sd卡
http://www.cnblogs.com/haochuang/p/6066532.html	在树莓派自身上进行备份!!
我们通过 pc 来备份!!!
首先需要 工具:
	sudo apt-get install dosfstools
	sudo apt-get install dump
	sudo apt-get install parted
	sudo apt-get install kpartx
建立一个backup文件目录
sudo fdisk -l	 查看sd卡挂载 /dev/sdx
df -h 查看实际sd卡有效内容大小
一般 树莓派 的 sd卡有 连两个分区!! 放置/boot 内容分区 和 根目录/分区!
一般 插入电脑时,会自动挂载,没有就自己手动挂载例如:
	yang@debian:~/backupimg$ sudo mount -t vfat -o uid=yang,gid=yang,umask=0000 /dev/sdb1 ./src_boot/ 
	yang@debian:~/backupimg$ sudo mount -t ext4 /dev/sdb2 ./src_Root/
	注意 uid gid 是把这个分区的读写权限赋予 uid gid 对应用户
生成一个空镜像 bs=1M 表示 1024KB 大小的块 bs=1MB 表示 1000KB 大小的块 , 我们要6G的镜像, 所以count=6000 :
	sudo dd if=/dev/zero of=ubuntu18-20190408-backup.img bs=1M count=6000
给img文件分区
注意 从 之前的 fdisk -l  df -h 获得 基本的块信息,扇区信息
	sudo parted ubuntu18-20190408-backup.img --script -- mklabel msdos		
	sudo parted ubuntu18-20190408-backup.img --script -- mkpart primary fat32 2048s 409599s
	sudo parted ubuntu18-20190408-backup.img --script -- mkpart primary ext4 409600s -1	//注意ext4 不要写错
	//由于分区大小小于2TB 所以使用 msdos 分区表,>2TB 使用 gpt 分区表
	我们 fdisk -l  df -h 看到的分区信息, 备份镜像分区最好严格跟随
	第一个分区 从 sector2048 到 sector409599   数字加s 表示以sector(扇区)为单位分区,一sector等于512KB
	剩下的 sector 都为第二分区
	查看分区情况:
	sudo parted raspberrypi.img     进入命令行
	(parted) print free   查看分区
	(parted) quit	离开命令行
挂载这个img
	sudo losetup -f --show ubuntu18-20190408-backup.img
	/dev/loop1
获取挂载分区:
	yang@debian:~/backupimg$ sudo kpartx -va /dev/loop1 
		add map loop1p1 (252:0): 0 407552 linear /dev/loop1 2048
		add map loop1p2 (252:1): 0 11878400 linear /dev/loop1 409600
	ls /dev/mapper/loop0p*
		/dev/mapper/loop1p1  /dev/mapper/loop1p2
格式化挂载分区:
	sudo mkfs.vfat -n system-boot /dev/mapper/loop1p1	//vfat设置 LABEL 参数 -n
		mkfs.fat 3.0.26 (2014-03-07)
		mkfs.fat: warning - lowercase labels might not work properly with DOS or Windows
		unable to get drive geometry, using default 255/63	
			//这里只是说ioctl获取不到HDIO_GETGEO命令之后参数,所以固定每磁道63个扇区
			//应该没有什么大问题
	sudo mkfs.ext4 -L writable /dev/mapper/loop1p2		//vfat设置 LABEL 和 ext4 的 的参数不一样,草 这里是 -L
		mke2fs 1.42.9 (4-Feb-2014)
		Discarding device blocks: 完成                            
		文件系统标签=
		OS type: Linux
		块大小=4096 (log=2)
		分块大小=4096 (log=2)
		Stride=0 blocks, Stripe width=0 blocks
		371680 inodes, 1484800 blocks
		74240 blocks (5.00%) reserved for the super user
		第一个数据块=0
		Maximum filesystem blocks=1522532352
		46 block groups
		32768 blocks per group, 32768 fragments per group
		8080 inodes per group
		Superblock backups stored on blocks: 
			32768, 98304, 163840, 229376, 294912, 819200, 884736
		
		Allocating group tables: 完成                            
		正在写入inode表: 完成                            
		Creating journal (32768 blocks): 完成
		Writing superblocks and filesystem accounting information: 完成 
挂载分区:
	~~/backup$ sudo mount -t vfat -o uid=infortech-ubuntu-1404,gid=infortech-ubuntu-1404,umask=0000 /dev/mapper/loop1p1 ./system-boot/ 
	~~/backup$ sudo mount -t ext4 /dev/mapper/loop1p2 ./writable/
备份boot: 单纯 cp
	~~/backup$ sudo cp -rfp /media/infortech-ubuntu-1404/system-boot/* ./system-boot/
备份根目录/: dump/restore方法
	 首先对目标挂载点设置合适的权限，并清空
	~~/backup$ sudo chmod 777 writable
	~~/backup$ sudo chown infortech-ubuntu-1404.infortech-ubuntu-1404 writable
	~~/backup$ sudo rm -rf ./writable/*
	~~/backup$ cd writable/
	dump/restore备份过程, dump 会提取合法的文件, restore到当前文件夹
	~~/backup/writable$ sudo dump -0uaf - /media/infortech-ubuntu-1404/writable | sudo restore -rf -
  DUMP: Date of this level 0 dump: Mon Apr  8 15:07:20 2019
  DUMP: Dumping /dev/sdc2 (/media/infortech-ubuntu-1404/writable) to standard output
  DUMP: Label: writable
  DUMP: Writing 10 Kilobyte records
  DUMP: mapping (Pass I) [regular files]
  DUMP: mapping (Pass II) [directories]
  DUMP: estimated 4469782 blocks.
  DUMP: Volume 1 started with block 1 at: Mon Apr  8 15:08:06 2019
  DUMP: dumping (Pass III) [directories]
  DUMP: dumping (Pass IV) [regular files]
  DUMP: Volume 1 completed at: Mon Apr  8 15:09:52 2019
  DUMP: Volume 1 4481330 blocks (4376.30MB)
  DUMP: Volume 1 took 0:01:46
  DUMP: Volume 1 transfer rate: 42276 kB/s
  DUMP: 4481330 blocks (4376.30MB)
  DUMP: finished in 106 seconds, throughput 42276 kBytes/sec
  DUMP: Date of this level 0 dump: Mon Apr  8 15:07:20 2019
  DUMP: Date this dump completed:  Mon Apr  8 15:09:52 2019
  DUMP: Average transfer rate: 42276 kB/s
  DUMP: DUMP IS DONE	//表示备份成功!!
备份根目录/: tar 方法 (当dump/restore失败时可选): https://blog.csdn.net/zhufu86/article/details/78821056
这时候整个备份就已经完成了。不过此时的img文件即使写入到空白SD卡里面也是无法启动的，因为Raspbian启动要对应分区的PARTUUID，
所以我们还要修改目标img文件里的如下两个文件：
	~~/backup/writable$ cd ../
	~~/backup/$ sudo blkid
	.....
/dev/sdc1: SEC_TYPE="msdos" LABEL="system-boot" UUID="842D-48B7" TYPE="vfat" 
/dev/sdc2: LABEL="writable" UUID="7505d087-bb96-4d42-8d51-a146069608c7" TYPE="ext4" 
/dev/mapper/loop1p1: SEC_TYPE="msdos" LABEL="boot" UUID="C998-E14D" TYPE="vfat" 
/dev/mapper/loop1p2: UUID="ab9f42bb-bb7f-48f5-956a-2c4eb1ecd284" TYPE="ext4" 
	对比 sdc 和 loop1 的 各个标签 !!!!!
	修改 两个文件:
	sudo vi system-boot/cmdline.txt 
		的 root=LABEL=
	sudo vi writable/etc/fstab
	(由于我 分区的时候 LABEL搜设置后原来的,所以 并不用改,但这里必须重视!!)
	
最后卸载 所有加载:
	sudo umount system-boot/ writable/	//卸载分区路径映射
	sudo kpartx -d /dev/loop1	//卸载分区信息
	sudo losetup -d /dev/loop1	//卸载 img 镜像的加载!!!!
备份完成!!!
成功测试, 成功显示, 成功实现之前ubuntu18设置的 william ssh hdmi 等等
注意此刻备份系统根目录只有 备份镜像设置的6GB 但是可以通过 raspi-config先未使用的分区空间expand 扩展进来 

备份kali镜像:
发现有不小不一样的地方:
直接从分区直接从 速sd卡 sector 1 开始使用,按道理应该是 sector 2048 等以后的!!
分区都没有laber 直接使用 /dev/mmcblk0 挂载!! mkfs 不需要加 label
成功测试,注意,需要使用 raspi-config 扩容分区, kali没有这指令,需要安装
参考 https://www.cnblogs.com/small-gray/p/5392044.html   //还有其他kali的必要工作!!!
首次安装东西,需要下update 软件源
apt-get update
apt-get install triggerhappy lua5.1  alsa-utils		//raspi-config
wget http://archive.raspberrypi.org/debian/pool/main/r/raspi-config/raspi-config_20151019_all.deb
dpkg -i raspi-config_20151019_all.deb		//注意 只有 20151019 功能齐全,新版本都没有扩容功能!!!!
还是安装了 kaii 全家桶后重新备份一次吧,,,,
apt-get install kali-linux-all
出错:
错误:1 http://mirrors.neusoft.edu.cn/kali kali-rolling/main arm64 webshells all 1.1-0kali0
  无法连接上 localhost:80 (::1)。 - connect (111: 拒绝连接) 无法连接上 localhost:80 (127.0.0.1)。 - connect (111: 拒绝连接)
E: 无法下载 http://localhost/  无法连接上 localhost:80 (::1)。 - connect (111: 拒绝连接) 无法连接上 localhost:80 (127.0.0.1)。 - connect (111: 拒绝连接)
E: 有几个软件包无法下载，要不运行 apt-get update 或者加上 --fix-missing 的选项再试试？
其实安装包已经下载完了,就是莫名要连接本地的:80端口? 跳不过去
网上说要加代理: 才可以连接 本地:80端口
vi /etc/apt/apt.conf  添加
	Acquire::http::proxy "http://localhost:80/";
然后 apt-get upgrade 出错,,,还是无法连接本地:80端口,所以 怀疑不是所谓代理问题,撤回代理设置重新 upgrade
然后重新 apt-get install kali-linux-all 居然跳过去了!!!

备份 raspiberry 自带系统
我操,使用GPT分区表 和 PARTUUID 挂载 的内容, 改过来msdos分区表 和 LABEL 挂载的不知道能否成功
proc            /proc           proc    defaults          0       0
LABEL=boot  /boot           vfat    defaults          0       2
LABEL=rootfs  /               ext4    defaults,noatime  0       1
# a swapfile is not a swap partition, no line here
#   use  dphys-swapfile swap[on|off]  for that
估计就是 rootfs 分区表的问题, 换了fstab  cmdline.txt  LABEL 加载 不成功
换了 /dev/mmcblk0 加载成功,但是 卡在了 w1 驱动的加载!!!!, 但是系统已经起来,可以使用ssh了!!!
注意,桌面也启动了,但是只能通过远程桌面登录: 自带的vnc 好像是不能启动的!!!
远程桌面启动问题:
	树莓派安装 rdp 协议的远程桌面!!!
	sudo apt-get install xrdp tightvncserver
	安装后 sudo /etc/init.d/xrdp restart 
	netstat -tnl  3350 3380 22 三个端口
ubuntn 使用自带的运程桌面软件即可 注意是 rdp 协议!!





git断点续存(没有用貌似):
git clone获取比较大的源码时, 不能断点续传, 比较恼火.
可以使用 git fetch 解决:

     mkdir common

     cd common

     git init

     git fetch http://android.git.kernel.org/common.git

     传完后,

     git branch -a

     git checkout remotes/....

如果中间断掉了, 可以直接进入common目录, 继续git fetch就可以续传了.
git clone --depth 1 http......		//表示取得最新分支的代码 !!!!

直接修改 kernel 内核驱动 似乎相当困难,
需要 知道 树莓派提供的 gpio接口 并认识 驱动使用的方法,寻找修改驱动的机会
树莓派不提供 硬件资料,所以看起来无法二次开发驱动
	通用 gpio 树莓派似乎,做了一套通用接口 gpiozero python软件来控制!!
	所以去掉了繁琐的 设备驱动加载调用操作等!!!!
	还有所有通用针都支持pwm输出,pwm输出并不存在与几个特定的针上!!! 这个非常惊讶!!
	gpio zero 允许二次开发参考: https://gpiozero.readthedocs.io/en/stable/development.html
	感觉还是没有找到改驱动的突破口!!
不知道启动流程, 无法二次开发 bootloader uboot
目标知道 多核启动的驱动,多核发工作驱动,
还有需要好好巩固学过的驱动知识,似乎忘了好多!!


编译内核, 期待获得更多有效信息!!!!
官方github 提供的 编译工具:
如果pc机是64位,就用 64位的编译工具链,
如果pc机是32位,就用 32位的编译工具链,
但是!!官方提供的工具链都是编译出 32位树莓派内核的,不能编译出64位树莓派内核!!!
使用官方 4.9 的工具 可以成功编译,成功运行,注意编译出来的 zImage 名字改为 kernel.img 放入 /boot区
按照官方教程编译内核,成功!!!!!
https://www.raspberrypi.org/documentation/linux/kernel/building.md
官方还有一个叫 kernel7.img的内核镜像,不知道是什么鬼,

编译 x64 系统 重点参考
https://github.com/pluhuxc/pluhuxc.github.io/blob/master/_posts/2018-12-18-make-a-raspberrypi64system.md




扩容 sd 分区!!!
步骤1: 重新启动你的电脑，不要启动X windows
步骤2: $ sudo df -h
你应该会看到/ 挂载于rootfs（已使用97％左右）。
步骤3: $ sudo fdisk /dev/mmcblk0
命令：按P（印刷）
你应该会看到三个分区，现在把分区2的信息写下来（/dev/mmcblk0p2）。
命令：按d（删除分区2）
命令：按p（印刷）
现在应该会看到2个分区
命令：按n（加分区）
选择P (主要)
於分区2选择2
第一空格输入原来分区2的开始位置
最后的空格输入默认值
命令：按p（印刷）
你应该會看到分区2填满所有空间
命令：按w（保存）

步驟4: $sudo reboot
重新启动后，使用resize2fs来修复分区2

步驟5: $ sudo resize2fs /dev/mmcblk0p2
等待约2-3分钟

步驟6: $ sudo df -h
你应该會看到 / 挂载於rootfs（如果你使用8G SD卡，现在只会有22％的使用）

这样你便可以善用SD卡余下的空间了。



















20190504 
harmony !! 问题
重新编译 bootstrap
	sudo /opt/sam-ba_3.1.4/sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c erase

	sudo /opt/sam-ba_3.1.4/sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c writeboot:/home/infortech-ubuntu-1404/1tb_disk/SAMA5D2/source/at91bootstrap/binaries/sama5d2_xplained-dataflashboot-uboot-3.8.7.bin

	sudo /opt/sam-ba_3.1.4/sam-ba -p serial:ttyACM0:115200 -b sama5d2-xplained -a serialflash -c write:/home/infortech-ubuntu-1404/1tb_disk/temp/harmony.bin:0x00008000
重新编译 bootstrap make ARCH=arm menuconfig  可以设置烧录地址 0x26f00000












??????????????????



	

	



待处理
重新建立emmc镜像
移植 ucos 和 usb_host  在  ubuntu环境上，
ucos3 需要知道 中断处理和调度的关系!!

学习建立 动态，静态软件库！！
统筹，可用 adc pwm 资源，因为以开发板标准 开设项目 所以先开 简单变阻，霍尔，磁电传感器测试板！！






 VBLANK: 显示器扫描线完成最后一行后,需要重返左上角,这个过程叫做: vblank,也叫VBI(vertical blank interval) ,因为扫描线变得blank,以防止看到一个斜线显示在屏幕上.?????
开机没有出现小企鹅问题!!
开发板的中断号与linux中断号的兑换表!!		 

使用 bitbake 工具链???
	另外,如何 更改内核配置!!! 而bitbake 又可以通过!!!
	
























































////////////////////////////// regmap 模块概念
3.0linux内核版本中，codec driver是直接调用i2c的i2c_master_send函数与i2c_transfer函数来实现i2c的读写，
3.3版本，codec driver通过调用snd_soc_read和snd_soc_write函数来实现i2c的读写，
	这两个函数内部包裹了codec->read和codec->write，而codec->read和codec->write的赋值是在snd_soc_codec_set_cache_io中，
	最终也是调用了i2c_master_send函数与i2c_transfer函数
3.10版本开始出现了regmap的接口，这个regmap将i2c、spi、mmio、irq都抽象出统一的接口regmap_read、regmap_write、regmap_update_bits等接口
例如对于i2c接口
devm_regmap_init_i2c(i2c, &regmap_i2c);或者使用
devm_regmap_init(&i2c->dev, &regmap_i2c, &i2c->dev, config)
|
devm_regmap_init(struct device *dev, struct regmap_bus *bus, void *bus_content, struct regmap_config *config);
1）注册方法regmap_bus和对象i2c：
通过把struct regmap_bus regmap_i2c和i2c->dev注册到regmap模块中去，而regmap_bus中已经实现了read和write函数（调用的就是i2c_master_send与i2c_transfer）
2）使用注册的对象和方法
当调用regmap_read或者regmap_write的时候，这两个函数会取出struct regmap中的content即i2c，并调用之前注册的regmap_bus中的read和write函数来实现读和写。
regmap_update_bit内部调用了regmap_read和regmap_write
我觉得以上的原理挺重要的，我们可以自己实现类似的接口：提供注册的机制，能够将对象以及对象的方法注册进去；当需要调用的时候，取出对应的对象和方法。










////////////////////////////// linux 4.1 流程
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


setup+_arch->setup_arch->unflatten_device_tree (将DTB二进制文件转换成节点是device_node的树状结构)


板级初始化前，先挂载安装各种 bus设备（包括platform—bus设备）到linux上，
然后挂载各种设备驱动信息到 对应的总线设备上，挂载各个platform设备的驱动信息到 platform总线上

板级初始化：（重的说，从dtb处获得 各platform设备的设备信息内容，注册platform设备的设备信息到 platform总线上）
sama5_dt_device_init DT_MACHINE_START(sama5_dt, "Atmel SAMA5")：.init_machine
	at91_soc_init	//得到 soc，信息
	soc_device_to_device
	of_platform_populate(NULL, of_default_bus_match_table, NULL, soc_dev);		//应该只注册platform设备信息到 platform总线上
		of_find_node_by_path("/")
		of_platform_bus_create
			of_get_property(bus, "compatible", NULL)
			auxdata = of_dev_lookup(lookup, bus);
			of_device_is_compatible(bus, "arm,primecell")			//比较compatible
			of_amba_device_create(bus, bus_id, platform_data, parent);	//amba还是属于注册platform设备信息到 platform总线上）
				dev = amba_device_alloc(NULL, 0, 0);
					amba_device_initialize(dev, name);	
						device_initialize(&dev->dev);		//device_initialize	
				irq_of_parse_and_map
				ret = of_address_to_resource(node, 0, &dev->res);
					addrp = of_get_address(dev, index, &size, &flags);
					__of_address_to_resource(dev, addrp, size, flags, name, r);
						taddr = of_translate_address(dev, addrp);
						port = pci_address_to_pio(taddr);
				ret = amba_device_add(dev, &iomem_resource);
					ret = request_resource(parent, &dev->res);
					ret = amba_get_enable_pclk(dev);
					amba_put_disable_pclk(dev);
					ret = device_add(&dev->dev);		//device_add（还是属于注册platform设备信息到 platform总线上）
			dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
				dev = of_device_alloc(np, bus_id, parent);
					dev = platform_device_alloc("", -1);
					。。。
				of_dma_configure(&dev->dev, dev->dev.of_node);
				int of_device_add(struct platform_device *ofdev)
					device_add(&ofdev->dev)				//device_add
			for_each_child_of_node(bus, child) {
				rc = of_platform_bus_create(child, matches, lookup, &dev->dev, strict);
			of_node_set_flag(bus, OF_POPULATED_BUS);
		of_node_set_flag
		of_node_put
	at91sam9x5_pm_init	//这里是启动电源
		at91_dt_ramc();
		at91_pm_init();
		at91_pmc_fast_startup_init();
	
总的来说，板级初始化的 显性做法就是 把platform设备的设备信息挂到 platform总线上
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


 	
platform设备会执行probe，probe会把对应的具体设备的设备信息，挂入对应子系统的bus设备，
诱发bus：match，诱发具体设备驱动probe，初始化具体设备驱动 注册并挂载设备到linux上！！

例如 i2c-platform设备的probe
static int at91_twi_probe(struct platform_device *pdev)		//i2c_at91.c
	rc = i2c_add_numbered_adapter(&dev->adapter);
		__i2c_add_numbered_adapter
			i2c_register_adapter
				{ dev_set_name(&adap->dev, "i2c-%d", adap->nr);
				adap->dev.bus = &i2c_bus_type;
				adap->dev.type = &i2c_adapter_type;
				res = device_register(&adap->dev);  }	//把i2c adapter的设备信息 挂入 i2c bus
				bri->recover_bus--int (*recover_bus)(struct i2c_adapter *)	//从dtb中读取 具体其他外接从设备信息 挂入 i2c bus
					//只有一个指针，实际函数在哪还不知道！！
	
	
	
	
	
例如 spi-platform设备的probe	
static int atmel_spi_probe(struct platform_device *pdev)	//Spi_atmel.c
	int devm_spi_register_master(struct device *dev, struct spi_master *master)
		ret = spi_register_master(master);	
			status = of_spi_register_master(master);	//从dtb得到一些信息
			{ dev_set_name(&master->dev, "spi%u", master->bus_num);
			status = device_add(&master->dev); }		//把spi master设备信息 挂入 spi bus
			of_register_spi_devices(master);		//从dtb中读取 具体其他外接从设备信息 挂入 spi bus
	
	
	
	
注意到，对于芯片的所有功能模块，指定子系统的 platform设备只是一个桥接的左右，并没有实际操作算法！！！
而实际访问控制芯片寄存器的api 是又 主机设备提供的，
例如i2c adapter spi master 才是真正操作芯片寄存器的挂载在linux上的设备
而其他外接功能芯片的设备是通过有组织调用 主机设备的操作函数的 “虚拟”设备而已	

主机设备与万能设备的区别？？
看到主机设备的 device_register,但是没看到主机设备的 driver_register？
主机设备是platform设备本身，还是另外靠xx bus match后初始化的另一个设备？？



注意：of_xxxx_put()或者xxxx_put()是卸载未完全加载的 模块



////////////////////////////// dts学习

关于旧版内核板级信息,与新版dts的对比:
	http://blog.csdn.net/sinat_26600745/article/details/47345257 


基本知识
http://blog.csdn.net/21cnbao/article/details/8457546

1,
#address-cells
#size-cells
描述子节点级的可寻址的 reg变量数量
例如:
{
	#address-cells = <3>;	//表示 reg 有3个address内容
	#size-cells = <2>;	//表示 reg 有2个size内容
	a@0 {
		device_type = "cpu";
		compatible = "arm,cortex-a5";
		reg = <1 78 0x67 88 1023 >;	//1,78,0x67为3个address内容, 88,1023为2个size内容
		next-level-cache = <&L2>;
	};
};

2,
interrupt-parent
interrupts =
interrupt-controller
/*遍历所有的node，寻找定义了interrupt-controller属性的node，如果定义了interrupt-controller属性则说明该node就是一个中断控制器。*/
interrupt controller的处理
初始化是通过start_kernel->init_IRQ->machine_desc->init_irq()实现的


http://www.cnblogs.com/aaronLinux/p/5496559.html

例子:
http://www.cnblogs.com/aaronLinux/p/5551441.html
此篇源文件arch/arm/boot/dts/imx6sx.dtsi
uart5: serial@021f4000 {
    compatible = "fsl,imx6sx-uart",
                "fsl,imx6q-uart", "fsl,imx21-uart";
    reg = <0x021f4000 0x4000>;
    interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6SX_CLK_UART_IPG>,
            <&clks IMX6SX_CLK_UART_SERIAL>;
    clock-names = "ipg", "per";
    dmas = <&sdma 33 4 0>, <&sdma 34 4 0>;
    dma-names = "rx", "tx";
    status = "disabled";
};
以上这段代码更多出现在*.dtsi中
如uart5作为该外设的label，node-name@unit-address作为设备的名称，node-name只是设备类型，
	uart1/uart2/uart3等可以都是serial名称，而@后面则跟着设备寄存器起始地址。
interrupts对应的中断号和中断出发方式，uart5的父节点为aips2，而aips2的父节点为soc，soc节点定义了interrupt-parent = <&intc>;
	给出了节点所依附的中断控制器，如果节点没有指定interrupt-parent，那么就从父节点继承，所以该uart5节点继承了soc的中断控制器，即intc. 
	而intc节点的#interrupt-cells = <3>;所以就有了该节点中interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;三个字段，
	具体这三个字段的含义可以参考芯片文档的描述。其中GIC_SPI定义在include/dt-bindings/interrupt-controller/arm-gic.h值为0，　
clock外设时钟，在include/dt-bindings/clock/imx6sx-clock.h，指定设备工作时钟
status一般会设为disabled。
&uart5 {
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_uart5>;
    fsl,uart-has-rtscts;
    status = "okay";
};
以上这段代码更多出现在*.dts中
注：如果看过内核/arch/arm/boot/dts目录的读者看到这可能有一个疑问。在每个.dsti和.dts中都会存在一个“/”根节点，
	那么如果在一个设备树文件中include一个.dtsi文件，那么岂不是存在多个“/”根节点了么。
	其实不然，编译器DTC在对.dts进行编译生成dtb时，会对node进行合并操作，最终生成的dtb只有一个root node。
	Dtc会进行合并操作这一点从属性上也可以得到验证。这个稍后做讲解。
在*.dts中如果想对该设备进行操作，需要进行override，至少status需要从disabled设置为okay, 
	当然也有可能需要对compatible属性进行重写(为了和自己的driver匹配)，另外需要使用&label首先引用该设备，
使用pinctrl-names和pinctrl-0进行引脚的配置，当然这里可能出现多组引脚的配置，例如:
&usdhc3 {
    pinctrl-names = "default", "state_100mhz", "state_200mhz";
    pinctrl-0 = <&pinctrl_usdhc3>;
    pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
    pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
    bus-width = <8>;
    cd-gpios = <&gpio2 10 GPIO_ACTIVE_HIGH>;
    wp-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
    keep-power-in-suspend;
    enable-sdio-wakeup;
    vmmc-supply = <&vcc_sd3>;
    status = "okay";
};

pinctrl_usdhc3: usdhc3grp {
    fsl,pins = <
        MX6SX_PAD_SD3_CMD__USDHC3_CMD        0x17069
        MX6SX_PAD_SD3_CLK__USDHC3_CLK        0x10071
        MX6SX_PAD_SD3_DATA0__USDHC3_DATA0    0x17069
        MX6SX_PAD_SD3_DATA1__USDHC3_DATA1    0x17069
        MX6SX_PAD_SD3_DATA2__USDHC3_DATA2    0x17069
        MX6SX_PAD_SD3_DATA3__USDHC3_DATA3    0x17069
        MX6SX_PAD_SD3_DATA4__USDHC3_DATA4    0x17069
        MX6SX_PAD_SD3_DATA5__USDHC3_DATA5    0x17069
        MX6SX_PAD_SD3_DATA6__USDHC3_DATA6    0x17069
        MX6SX_PAD_SD3_DATA7__USDHC3_DATA7    0x17069
        MX6SX_PAD_KEY_COL0__GPIO2_IO_10        0x17059 /* CD */
        MX6SX_PAD_KEY_ROW0__GPIO2_IO_15        0x17059 /* WP */
        >;
};
这种pinctrl的设置可参照/Documentation/devicetree/bindinsg/pinctrl下示例代码













////////////////////////////// sama5d4 mmap 结构

/*
 * Internal Memory.		//
 */
#define ATMEL_BASE_ROM		0x00000000	片上rom始地址
#define ATMEL_BASE_NFC		0x00100000	片上SRAM始地址
#define ATMEL_BASE_SRAM		0x00200000	第二块片上ROM始地址,
#define ATMEL_BASE_VDEC		0x00300000	/* Video Decoder Controller */
#define ATMEL_BASE_UDPHS_FIFO	0x00400000	/* USB Device HS controller */
#define ATMEL_BASE_OHCI		0x00500000	/* USB Host controller (OHCI) */
#define ATMEL_BASE_EHCI		0x00600000	/* USB Host controller (EHCI) */
#define ATMEL_BASE_AXI		0x00700000
#define ATMEL_BASE_DAP		0x00800000
#define ATMEL_BASE_SMD		0x00900000

/*
 * External memory
 */
#define ATMEL_BASE_CS0		0x10000000
#define ATMEL_BASE_DDRCS	0x20000000
#define ATMEL_BASE_CS1		0x60000000
#define ATMEL_BASE_CS2		0x70000000
#define ATMEL_BASE_CS3		0x80000000






////////////////////////////// TFT_lcd

SAMA5D4 : default lcd 接口  (对应RGB88的,注意,物理接口不能其他兼容RGBXXX,详细看pdf)
1:	EDBG_ID_01		ID_SYS not connect
2:	GND
3:	LCD_DAT0_PA0		LCDDAT0 	Blue	
5:	LCD_DAT0_PA1		LCDDAT1 
5:	LCD_DAT0_PA2		LCDDAT2 
6:	LCD_DAT0_PA3		LCDDAT3
7:	GND
8:	LCD_DAT0_PA4		LCDDAT4 	
9:	LCD_DAT0_PA5		LCDDAT5 
10:	LCD_DAT0_PA6		LCDDAT6 
11:	LCD_DAT0_PA7		LCDDAT7
12:	GND
13:	LCD_DAT0_PA8		LCDDAT8		GREEN
14:	LCD_DAT0_PA9		LCDDAT9 
15:	LCD_DAT0_PA10		LCDDAT10 
16:	LCD_DAT0_PA11		LCDDAT11
17:	GND
18:	LCD_DAT0_PA12		LCDDAT12	
19:	LCD_DAT0_PA13		LCDDAT13
20:	LCD_DAT0_PA14		LCDDAT14 
21:	LCD_DAT0_PA15		LCDDAT15
22:	GND
23:	LCD_DAT0_PA16		LCDDAT16	RED
24:	LCD_DAT0_PA17		LCDDAT17
25:	LCD_DAT0_PA18		LCDDAT18 
26:	LCD_DAT0_PA19		LCDDAT19
27:	GND
28:	LCD_DAT0_PA20		LCDDAT20
29:	LCD_DAT0_PA21		LCDDAT21
30:	LCD_DAT0_PA22		LCDDAT22 
31:	LCD_DAT0_PA23		LCDDAT23
32:	GND
33:	LCD_PCK_PA28		LCDPCK
34:	LCD_VSYNC_PA26		LCDVSYNC
35:	LCD_HSYNC_PA27		LCDHSYNc 
36:	LCD_DEN_PA29		LCDDEN
37:	AD3_YM_PC30		YM 即 Y- 是并联到GND的一端
38:	AD2_YP_PC29		YP 即 Y+ 是并联到VCC的一端
39:	AD1_XM_PC28		XM 即 X- 是并联到GND的一端
40:	AD0_XP_PC27		XP 即 X+ 是并联到VCC的一端
41:	LCD_DISP_PA25		LCDDISP
42:	LCD_TWD0_PA30		not connect
43:	LCD_TWCK0_PA31		not connect
44:	LCD_PE9			IRQ1 not connect
45:	LCD_PE10		IRQ2 not connect
46:	LCD_PWM_PA24		not connect
47:	NRST_3V3		not connect
48:	VCC_5V
50:	GND

裸屏!!
1:	VLED-		LED Ground	//另外接 TPS61040 模块
2:	VLED+		LED Power
3:	DGND		Digital Ground
4:	VCC		Power Supply (+3.3 V)
5:	R0		Red Data Bit0
6:	R1		Red Data Bit1
7:	R2		Red Data Bit2
8:	R3		Red Data Bit3
9:	R4		Red Data Bit4
10:	R5		Red Data Bit5
11:	R6		Red Data Bit6
12:	R7		Red Data Bit7
13:	G0		Green Data Bit0
14:	G1		Green Data Bit1
15:	G2		Green Data Bit2
16:	G3		Green Data Bit3
17:	G4		Green Data Bit4
18:	G5		Green Data Bit5
19:	G6		Green Data Bit6
20:	G7		Green Data Bit7
21:	B0		Blue Data Bit0
22:	B1		Blue Data Bit1
23:	B2		Blue Data Bit2
24:	B3		Blue Data Bit3
25:	B4		Blue Data Bit4
26:	B5		Blue Data Bit5
27:	B6		Blue Data Bit6
28:	B7		Blue Data Bit7
29:	DGND		Digital Ground
30:	DCLK		Dot Data Clock
31:	DISP		Display On/Off		Usually pull high. High: Display On / Low: Display Off
32:	Hsync		Horizontal Sync Input
33:	Vsync		Vertical Sync Input
34:	DE		Data Enable Control	DE=” H “: data can be access, DE=” L “: data cannot be access
35:	N.C		N.C
36:	DGND		Digital Ground
37:	X-		触摸控制
38:	Y-		触摸控制
39:	X+		触摸控制
40:	Y+		触摸控制

XPT2046触摸控制芯片,
ssd1960 单片机mcu 与 lcd裸屏 之间的转接芯片,(一般单片机本身没有lcd控制模块时才去使用有转接芯片的方案)

adc touchscreen page1537


////////////////////////////// linux 启动流程




arch/arm/kernel/head.s: _INIT

init/main.c:  asmlinkage __visible void __init start_kernel(void)






////////////////////////////// linux 启动流程
at91Tbootstep会把全局物理地址 0x40000 (nandflash空间)的0x80000字节内容拷到全局物理地址 0x26f00000 (对应ram空间)去,
就是uboot内容
uboot从 arch/arm/lib/veters.s -> _start -> b reset
-> arch\arm\cpu\armv7\start.S:reset -> 



////////////////////////////// linux 

kset kobject :
kobject 是抽象的通用数据结构,每一个linux内容 例如 device信息,drive信息 等等,都分得一个通用数据,主要用于内容的引用计数,
当linux内容没有使用时,引用计数为0,linux内容会删除,kobject会从系统释放,
kset是一个特殊的kobject 指向内容是一个许多kobject指针的链表
kset 与 kobject 的关系就像 文件夹 和 文件,但文件夹本身是一个有列表信息的文件
每个 kobject kset  在sys/里都有响应的文件夹,而 kobject 的 attrs属性内容以文件的形式存在这些文件夹里





#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
owner = ACCESS_ONCE(lock->owner); //ACCESS_ONCE表示一定要从实际内存地址访问这个变量lock->owner,不要被优化,不要从cpu_cache缓存里读出而不访问内存












GPIO 通用相关:
pin control subsystem的文件列表

1、源文件列表

我们整理linux/drivers/pinctrl目录下pin control subsystem的源文件列表如下：
文件名 	描述
core.c core.h 	pin control subsystem的core driver
pinctrl-utils.c pinctrl-utils.h 	pin control subsystem的一些utility接口函数
pinmux.c pinmux.h 	pin control subsystem的core driver(pin muxing部分的代码，也称为pinmux driver)
pinconf.c pinconf.h 	pin control subsystem的core driver(pin config部分的代码，也称为pin config driver)
devicetree.c devicetree.h 	pin control subsystem的device tree代码
pinctrl-xxxx.c 	各种pin controller的low level driver
在pin controller driver文档中 ，我们以2416的pin controller为例，描述了一个具体的low level的driver，这个driver涉及的文件包括pinctrl-samsung.c，pinctrl-samsung.h和pinctrl-s3c24xx.c。

2、和其他内核模块接口头文件
很多内核的其他模块需要用到pin control subsystem的服务，这些头文件就定义了pin control subsystem的外部接口以及相关的数据结构。我们整理linux/include/linux/pinctrl目录下pin control subsystem的外部接口头文件列表如下：
文件名 	描述
consumer.h 	其他的driver要使用pin control subsystem的下列接口：
a、设置引脚复用功能
b、配置引脚的电气特性
这时候需要include这个头文件
devinfo.h 	这是for linux内核的驱动模型模块（driver model）使用的接口。struct device中包括了一个struct dev_pin_info    *pins的成员，这个成员描述了该设备的引脚的初始状态信息，在probe之前，driver model中的core driver在调用driver的probe函数之前会先设定pin state
machine.h 	和machine模块的接口。

3、Low level pin controller driver接口
我们整理linux/include/linux/pinctrl目录下pin control subsystem提供给底层specific pin controller driver的头文件列表如下：
文件名 	描述
pinconf-generic.h 	这个接口主要是提供给各种pin controller driver使用的，不是外部接口。
pinconf.h 	pin configuration 接口
pinctrl-state.h 	pin control state状态定义
pinmux.h 	pin mux function接口 











device tree 与gpio 设置:
    device-node-name { 
            定义该device自己的属性  

            pinctrl-names = "sleep", "active";－－－－－－（1）
            pinctrl-0 = <pin-config-0-a>;－－－－－－－－－－－－－－（2）
            pinctrl-1 = <pin-config-1-a pin-config-1-b>;        
        };

 （1）pinctrl-names定义了一个state列表。那么什么是state呢？具体说应该是pin state，对于一个client device，它使用了一组pin，这一组pin应该同时处于某种状态，毕竟这些pin是属于一个具体的设备功能。state的定义和电源管理关系比较紧密，例如当设备active的时候，我们需要pin controller将相关的一组pin设定为具体的设备功能，而当设备进入sleep状态的时候，需要pin controller将相关的一组pin设定为普通GPIO，并精确的控制GPIO状态以便节省系统的功耗。state有两种，标识，一种就是pinctrl-names定义的字符串列表，另外一种就是ID。ID从0开始，依次加一。根据例子中的定义，state ID等于0（名字是active）的state对应pinctrl-0属性，state ID等于1（名字是idle）的state对应pinctrl-1属性。具体设备state的定义和各个设备相关，具体参考在自己的device bind。 
（2）pinctrl-x的定义。pinctrl-x是一个句柄（phandle）列表，每个句柄指向一个pin configuration。有时候，一个state对应多个pin configure。例如在active的时候，I2C功能有两种配置，一种是从pin ID{7,8}引出，另外一个是从pin ID{69,103}引出。 

serial@50000000 { 
        ……
        pinctrl-names = "default";
        pinctrl-0 = <0x2 0x3>;
    }; 
该serial device只定义了一个state就是default，对应pinctrl-0属性定义。pinctrl-0是一个句柄（phandle）列表，每个句柄指向一个pin configuration。0x2对应上节中的uart0-data节点，0x03对应uart0-fctl 节点，也就是说，这个串口有两种配置，一种是从gph bank中的第一个和第二个GPIO pin引出，另外一个是从gph bank中的第8个和第9个GPIO pin引出。

（5）一个pin configuration的device tree node被解析成两个描述符，一个是samsung pin group的描述符，另外一个是samsung pin mux function描述符。这两个描述符的名字都是根据dts file中的pin configuration的device node name生成，只不过pin group的名字附加-grp的后缀，而function描述符的名字后面附加-mux的后缀。 
    struct of_device_id
    {
        char    name[32];－－－－－－要匹配的device node的名字
        char    type[32];－－－－－－－要匹配的device node的类型
        char    compatible[128];－－－匹配字符串（DT compatible string），用来匹配适合的device node
        const void *data;－－－－－－－－对于GIC，这里是初始化函数指针
    };

这个数据结构主要被用来进行Device node和driver模块进行匹配用的。从该数据结构的定义可以看出，在匹配过程中，device name、device type和DT compatible string都是考虑的因素。更细节的内容请参考__of_device_is_compatible函数。 












Linux kernel的中断子系统 gic模块
gic控制所有中断,外部中断先通过gic distributor 选择由哪一个cpu处理这次这个中断行为,然后通过cpu interface 传递到中断该cpu当前运作,让其执行这次中断任务!!!!!
中断虽然发生了，但软件不一定立刻响应，可能由于在内核态执行的某些操作不希望被外部事件打断而主动关闭了中断（或是关闭了CPU的中断，或者MASK了该IRQ number），这时候，中断信号没有立刻得到响应，软件仍然在内核态执行低优先级任务系统调用的代码。

2.6内核和2.4内核显著的不同是提供了一个CONFIG_PREEMPT的选项，打开该选项后，linux kernel就支持了内核代码的抢占（当然不能在临界区）
所谓抢占式就是中断任务处理完后,重新调度,而不是回到之前被打断的进程
 （1）为了同步，内核中总有些代码需要持有自旋锁资源，或者显式的调用preempt_disable来禁止抢占，这时候不允许抢占 
 （2）中断上下文（并非只是中断handler，还包括softirq、timer、tasklet）总是可以抢占进程上下文 
因此，即便是打开了PREEMPT的选项，实际上linux系统的任务响应时间仍然是不确定的。一方面内核代码的临界区非常多，我们需要找到，系统中持有锁，或者禁止抢占的最大的时间片。另外一方面，在上图的T4中，能顺利的调度高优先级任务并非易事，这时候可能有触发的软中断，也可能有新来的中断，也可能某些driver的tasklet要执行，只有在没有任何bottom half的任务要执行的时候，调度器才会启动调度。 

ARM处理器有多种processor mode，例如user mode（用户空间的AP所处于的模式）、supervisor mode（即SVC mode，大部分的内核态代码都处于这种mode）、IRQ mode（发生中断后，处理器会切入到该mode）等。对于linux kernel，其中断处理处理过程中，ARM 处理器大部分都是处于SVC mode。但是，实际上产生中断的时候，ARM处理器实际上是进入IRQ mode，因此在进入真正的IRQ异常处理之前会有一小段IRQ mode的操作，之后会进入SVC mode进行真正的IRQ异常处理。由于IRQ mode只是一个过度，因此IRQ mode的栈很小，只有12个字节，
struct stack {
    u32 irq[3];
    u32 abt[3];
    u32 und[3];
} ____cacheline_aligned; 
 static struct stack stacks[NR_CPUS]; 
除了irq mode，linux kernel在处理abt mode（当发生data abort exception或者prefetch abort exception的时候进入的模式）和und mode（处理器遇到一个未定义的指令的时候进入的异常模式）的时候也是采用了相同的策略。也就是经过一个简短的abt或者und mode之后，stack切换到svc mode的栈上，这个栈就是发生异常那个时间点current thread的内核栈。anyway，在irq mode和svc mode之间总是需要一个stack保存数据，这就是中断模式的stack，系统初始化的时候，cpu_init函数中会进行中断模式stack的设定
 嵌入式汇编的语法格式是：asm(code : output operand list : input operand list : clobber list);大家对着上面的code就可以分开各段内容了。在input operand list中，有两种限制符（constraint），"r"或者"I"，"I"表示立即数（Immediate operands），"r"表示用通用寄存器传递参数。clobber list中有一个r14，表示在汇编代码中修改了r14的值，这些信息是编译器需要的内容。

对于SMP，bootstrap CPU会在系统初始化的时候执行cpu_init函数，进行本CPU的irq、abt和und三种模式的内核栈的设定，具体调用序列是：start_kernel--->setup_arch--->setup_processor--->cpu_init。对于系统中其他的CPU，bootstrap CPU会在系统初始化的最后，对每一个online的CPU进行初始化，具体的调用序列是：start_kernel--->rest_init--->kernel_init--->kernel_init_freeable--->kernel_init_freeable--->smp_init--->cpu_up--->_cpu_up--->__cpu_up。__cpu_up函数是和CPU architecture相关的。对于ARM，其调用序列是__cpu_up--->boot_secondary--->smp_ops.smp_boot_secondary(SOC相关代码)--->secondary_startup--->__secondary_switched--->secondary_start_kernel--->cpu_init。 
在使用了MMU之后，具体异常向量表放在那个物理地址已经不重要了，重要的是把它映射到0xffff0000的虚拟地址就OK了，具体代码如下：

    static void __init devicemaps_init(const struct machine_desc *mdesc)
    {
        ……
        vectors = early_alloc(PAGE_SIZE * 2); －－－－－分配两个page的物理页帧
        early_trap_init(vectors); －－－－－－－copy向量表以及相关help function到该区域
        ……
        map.pfn = __phys_to_pfn(virt_to_phys(vectors));
        map.virtual = 0xffff0000;
        map.length = PAGE_SIZE;
    #ifdef CONFIG_KUSER_HELPERS
        map.type = MT_HIGH_VECTORS;
    #else
        map.type = MT_LOW_VECTORS;
    #endif
        create_mapping(&map); －－－－－－－－－－映射0xffff0000的那个page frame
        if (!vectors_high()) {－－－如果SCTLR.V的值设定为low vectors，那么还要映射0地址开始的memory
            map.virtual = 0;
            map.length = PAGE_SIZE * 2;
            map.type = MT_LOW_VECTORS;
            create_mapping(&map);
        }
        map.pfn += 1;
        map.virtual = 0xffff0000 + PAGE_SIZE;
        map.length = PAGE_SIZE;
        map.type = MT_LOW_VECTORS;
        create_mapping(&map); －－－－－－－－－－映射high vecotr开始的第二个page frame
    ……
    }

当外设（SOC内部或者外部都可以）检测到了中断事件，就会通过interrupt requestion line上的电平或者边沿（上升沿或者下降沿或者both）通知到该外设连接到的那个中断控制器，而中断控制器就会在多个处理器中选择一个，并把该中断通过IRQ（或者FIQ，本文不讨论FIQ的情况）分发给该processor。ARM处理器感知到了中断事件后，会进行下面一系列的动作：
1、修改CPSR（Current Program Status Register）寄存器中的M[4:0]。M[4:0]表示了ARM处理器当前处于的模式（ processor modes）。ARM定义的mode包括： 
处理器模式 	缩写 	对应的M[4:0]编码 	Privilege level
User 		usr 	10000 			PL0
FIQ 		fiq 	10001 			PL1
IRQ 		irq 	10010 			PL1
Supervisor 	svc 	10011 			PL1
Monitor 	mon 	10110 			PL1
Abort 		abt 	10111 			PL1
Hyp 		hyp 	11010 			PL2
Undefined 	und 	11011 			PL1
System 		sys 	11111 			PL1 
 一旦设定了CPSR.M，ARM处理器就会将processor mode切换到IRQ mode。 

2、保存发生中断那一点的CPSR值（step 1之前的状态）和PC值
ARM处理器支持9种processor mode，每种mode看到的ARM core register（R0～R15，共计16个）都是不同的。每种mode都是从一个包括所有的Banked ARM core register中选取。全部Banked ARM core register包括

Usr 	System 	Hyp 	Supervisor 	abort 	undefined 	Monitor 	IRQ 	FIQ
R0_usr 	  	  	  	  	  	  	  	 
R1_usr 	  	  	  	  	  	  	  	 
R2_usr 	  	  	  	  	  	  	  	 
R3_usr 	  	  	  	  	  	  	  	 
R4_usr 	  	  	  	  	  	  	  	 
R5_usr 	  	  	  	  	  	  	  	 
R6_usr 	  	  	  	  	  	  	  	 
R7_usr 	  	  	  	  	  	  	  	 
R8_usr 	  	  	  	  	  	  	  				R8_fiq
R9_usr 	  	  	  	  	  	  	  				R9_fiq
R10_usr 	  	  	  	  	  	  	  			R10_fiq
R11_usr 	  	  	  	  	  	  	  			R11_fiq
R12_usr 	  	  	  	  	  	  	  			R12_fiq
SP_usr 	  	SP_hyp 	SP_svc 		SP_abt 	SP_und 		SP_mon 		SP_irq 	SP_fiq
LR_usr 	  	  	LR_svc 		LR_abt 	LR_und 		LR_mon 		LR_irq 	LR_fiq
PC 	  	  	  	  	  	  	  	 
CPSR 	  	  	  	  	  	  	  	 
  	  	SPSR_hyp SPSR_svc 	SPSR_abt SPSR_und 	SPSR_mon 	SPSR_irq SPSR_fiq
  	  	ELR_hyp 	  	  	  	  	  	  
在IRQ mode下，CPU看到的R0～R12寄存器、PC以及CPSR是和usr mode（userspace）或者svc mode（kernel space）是一样的。不同的是IRQ mode下，有自己的R13(SP，stack pointer）、R14（LR，link register）和SPSR（Saved Program Status Register）。 
CPSR是共用的，虽然中断可能发生在usr mode（用户空间），也可能是svc mode（内核空间），不过这些信息都是体现在CPSR寄存器中。硬件会将发生中断那一刻的CPSR保存在SPSR寄存器中（由于不同的mode下有不同的SPSR寄存器，因此更准确的说应该是SPSR-irq，也就是IRQ mode中的SPSR寄存器）。 
PC也是共用的，由于后续PC会被修改为irq exception vector，因此有必要保存PC值。当然，与其说保存PC值，不如说是保存返回执行的地址。对于IRQ而言，我们期望返回地址是发生中断那一点执行指令的下一条指令。具体的返回地址保存在lr寄存器中（注意：这个lr寄存器是IRQ mode的lr寄存器，可以表示为lr_irq）：
 （1）对于thumb state，lr_irq ＝ PC
（2）对于ARM state，lr_irq ＝ PC － 4 

contex-A9 的中断管理器gic模块
 GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。 
自外设的interrupt source输入信号。分成两种类型，分别是PPI（Private Peripheral Interrupt）和SPI（Shared Peripheral Interrupt）。其实从名字就可以看出来两种类型中断信号的特点，PPI中断信号是CPU私有的，每个CPU都有其特定的PPI信号线。而SPI是所有CPU之间共享的。通过寄存器GICD_TYPER可以配置SPI的个数（最多480个）。GIC-400支持多少个SPI中断，其输入信号线就有多少个SPI interrupt request signal。同样的，通过寄存器GICD_TYPER也可以配置CPU interface的个数（最多8个），GIC-400支持多少个CPU interface，其输入信号线就提供多少组PPI中断信号线。一组PPI中断信号线包括6个实际的signal：
（a）nLEGACYIRQ信号线。对应interrupt ID 31，在bypass mode下（这里的bypass是指bypass GIC functionality，直接连接到某个processor上），nLEGACYIRQ可以直接连到对应CPU的nIRQCPU信号线上。在这样的设置下，该CPU不参与其他属于该CPU的PPI以及SPI中断的响应，而是特别为这一根中断线服务。
（b）nCNTPNSIRQ信号线。来自Non-secure physical timer的中断事件，对应interrupt ID 30。
（c）nCNTPSIRQ信号线。来自secure physical timer的中断事件，对应interrupt ID 29。
（d）nLEGACYFIQ信号线。对应interrupt ID 28。概念同nLEGACYIRQ信号线，不再描述。
（e）nCNTVIRQ信号线。对应interrupt ID 27。Virtual Timer Event，和虚拟化相关，这里不与描述。
（f）nCNTHPIRQ信号线。对应interrupt ID 26。Hypervisor Timer Event，和虚拟化相关，这里不与描述。
对于Cortex A15的GIC实现，其PPI中断信号线除了上面的6个，还有一个叫做Virtual Maintenance Interrupt，对应interrupt ID 25。
对于Cortex A9的GIC实现，其PPI中断信号线包括5根：
（a）nLEGACYIRQ信号线和nLEGACYFIQ信号线。对应interrupt ID 31和interrupt ID 28。这部分和上面一致
（b）由于Cortext A9的每个处理器都有自己的Private timer和watch dog timer，这两个HW block分别使用了ID 29和ID 30
（c）Cortext A9内嵌一个global timer为系统内的所有processor共享，对应interrupt ID 27
关于private timer和global timer的描述，请参考时间子系统的相关文档。
关于一系列和虚拟化相关的中断，请参考虚拟化的系列文档。
（3）输出信号
所谓输出信号，其实就是GIC和各个CPU直接的接口，这些接口包括：
（a）触发CPU中断的信号。nIRQCPU和nFIQCPU信号线，熟悉ARM CPU的工程师对这两个信号线应该不陌生，主要用来触发ARM cpu进入IRQ mode和FIQ mode。
（b）Wake up信号。nFIQOUT和nIRQOUT信号线，去ARM CPU的电源管理模块，用来唤醒CPU的
（c）AXI slave interface signals。AXI（Advanced eXtensible Interface）是一种总线协议，属于AMBA规范的一部分。通过这些信号线，ARM CPU可以和GIC硬件block进行通信（例如寄存器访问）。
（4）中断号的分配
GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。
为了标识这些interrupt source，我们必须要对它们进行编码，具体的ID分配情况如下：
（a）ID0~ID31是用于分发到一个特定的process的interrupt。标识这些interrupt不能仅仅依靠ID，因为各个interrupt source都用同样的ID0~ID31来标识，因此识别这些interrupt需要interrupt ID ＋ CPU interface number。ID0~ID15用于SGI，ID16~ID31用于PPI。PPI类型的中断会送到其私有的process上，和其他的process无关。SGI是通过写GICD_SGIR寄存器而触发的中断。Distributor通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。
（b）ID32~ID1019用于SPI。 这是GIC规范的最大size，实际上GIC-400最大支持480个SPI，Cortex-A15和A9上的GIC最多支持224个SPI。 

不同的GIC-V2的实现总会有一些不同，这些信息可以通过Device tree的机制来传递。Device node中定义了各种属性，其中就包括了memory资源，IRQ描述等信息，这些信息需要在初始化的时候传递给具体的驱动，因此需要一个Device node和driver模块的匹配过程。在Device Tree模块中会包括系统中所有的device node，如果我们的系统使用了GIC-400，那么系统的device node数据库中会有一个node是GIC-400的，一个示例性的GIC-400的device node（我们以瑞芯微的RK3288处理器为例）定义如下：
    gic: interrupt-controller@ffc01000 {
        compatible = "arm,gic-400";
        interrupt-controller;
        #interrupt-cells = <3>;
        #address-cells = <0>;

        reg = <0xffc01000 0x1000="">,－－－－Distributor address range
              <0xffc02000 0x1000="">,－－－－－CPU interface address range
              <0xffc04000 0x2000="">,－－－－－Virtual interface control block
              <0xffc06000 0x2000="">;－－－－－Virtual CPU interfaces
        interrupts = ;
    };
     void __init irqchip_init(void)
    {
        of_irq_init(__irqchip_begin);
    }
__irqchip_begin就是内核irq chip table的首地址，这个table也就保存了kernel支持的所有的中断控制器的ID信息（用于和device node的匹配）。of_irq_init函数执行之前，系统已经完成了device tree的初始化，因此系统中的所有的设备节点都已经形成了一个树状结构，每个节点代表一个设备的device node。of_irq_init是在所有的device node中寻找中断控制器节点，形成树状结构（系统可以有多个interrupt controller，之所以形成中断控制器的树状结构，是为了让系统中所有的中断控制器驱动按照一定的顺序进行初始化）。之后，从root interrupt controller节点开始，对于每一个interrupt controller的device node，扫描irq chip table，进行匹配，一旦匹配到，就调用该interrupt controller的初始化函数，并把该中断控制器的device node以及parent中断控制器的device node作为参数传递给irq chip driver。。具体的匹配过程的代码属于Device Tree模块的内容，
 我们首先看看这个函数的参数，node参数代表需要初始化的那个interrupt controller的device node，parent参数指向其parent。在映射GIC-400的memory map I/O space的时候，我们只是映射了Distributor和CPU interface的寄存器地址空间，和虚拟化处理相关的寄存器没有映射，因此这个版本的GIC driver应该是不支持虚拟化的（不知道后续版本是否支持，在一个嵌入式平台上支持虚拟化有实际意义吗？最先支持虚拟化的应该是ARM64+GICV3/4这样的平台）。

要了解cpu-offset属性，首先要了解什么是banked register。所谓banked register就是在一个地址上提供多个寄存器副本。比如说系统中有四个CPU，这些CPU访问某个寄存器的时候地址是一样的，但是对于banked register，实际上，不同的CPU访问的是不同的寄存器，虽然它们的地址是一样的。如果GIC没有banked register，那么需要提供根据CPU index给出一系列地址偏移，而地址偏移=cpu-offset * cpu-nr
 每个interrupt controller都会形成一个irq domain，负责解析其下游的interrut source。如果interrupt controller有级联的情况，那么一个非root interrupt controller的中断控制器也是其parent irq domain的一个普通的interrupt source。struct irq_domain定义如下：
    struct irq_domain {
    ……
        const struct irq_domain_ops *ops;
        void *host_data;
    ……
    };
 对于GIC支持的IRQ的数目，这里还要赘述几句。实际上并非GIC支持多少个HW interrupt ID，其就支持多少个IRQ。对于SGI，其处理比较特别，并不归入IRQ number中。因此，对于GIC而言，其SGI（从0到15的那些HW interrupt ID）不需要irq domain进行映射处理，也就是说SGI没有对应的IRQ number。如果系统越来越复杂，一个GIC不能支持所有的interrupt source（目前GIC支持1020个中断源，这个数目已经非常的大了），那么系统还需要引入secondary GIC，这个GIC主要负责扩展外设相关的interrupt source，也就是说，secondary GIC的SGI和PPI都变得冗余了（这些功能，primary GIC已经提供了）。这些信息可以协助理解代码中的hwirq_base的设定。
（d）通过Distributor中的寄存器可以控制送达CPU interface，中断来到了GIC的CPU interface是否可以真正送达CPU呢？也不一定，还有一道关卡，也就是CPU interface中的Interrupt Priority Mask Register。这个寄存器设定了一个中断优先级的值，只有中断优先级高过该值的中断请求才会被送到CPU上去。我们在前面初始化的时候，给每个interrupt ID设定的缺省优先级是0xa0，这里设定的priority filter的优先级值是0xf0。数值越小，优先级越过。因此，这样的设定就是让所有的interrupt source都可以送达CPU，在CPU interface这里不做控制了。 
 对于GIC而言，其中断状态有四种：
中断状态 	描述
Inactive 	中断未触发状态，该中断即没有Pending也没有Active
Pending 	由于外设硬件产生了中断事件（或者软件触发）该中断事件已经通过硬件信号通知到GIC，等待GIC分配的那个CPU进行处理
Active 	CPU已经应答（acknowledge）了该interrupt请求，并且正在处理中
Active and Pending 	当一个中断源处于Active状态的时候，同一中断源又触发了中断，进入pending状态
processor ack了一个中断后，该中断会被设定为active。当处理完成后，仍然要通知GIC，中断已经处理完毕了。这时候，如果没有pending的中断，GIC就会将该interrupt设定为inactive状态。操作GIC中的End of Interrupt Register可以完成end of interrupt事件通知。 
4、BSP（bootstrap processor）之外，其他CPU的callback函数
对于multi processor系统，不可能初始化代码在所有的processor上都执行一遍，实际上，系统的硬件会选取一个processor作为引导处理器，我们称之BSP。这个processor会首先执行，其他的CPU都是处于reset状态，等到BSP初始化完成之后，release所有的non-BSP，这时候，系统中的各种外设硬件条件和软件条件（例如per CPU变量）都准备好了，各个non-BSP执行自己CPU specific的初始化就OK了。
上面描述的都是BSP的初始化过程，具体包括：
    ……
        gic_dist_init(gic);－－－－－－初始化GIC的Distributor
        gic_cpu_init(gic);－－－－－－初始化BSP的CPU interface
        gic_pm_init(gic);－－－－－－初始化GIC的Power management
    ……
对于GIC的Distributor和Power management，这两部分是全局性的，BSP执行初始化一次就OK了。对于CPU interface，每个processor负责初始化自己的连接的那个CPU interface HW block。我们用下面这个图片来描述这个过程： 
 booting
  假设CPUx被选定为BSP，那么第三章描述的初始化过程在该CPU上欢畅的执行。这时候，被初始化的GIC硬件包括：root GIC的Distributor、root GIC CPU Interface x（连接BSP的那个CPU interface）以及其他的级联的非root GIC（上图中绿色block，当然，我偷懒，没有画non-root GIC）。
BSP初始化完成之后，各个其他的CPU运行起来，会发送CPU_STARTING消息给关注该消息的模块。毫无疑问，GIC driver模块当然要关注这样的消息，在初始化过程中会注册callback函数如下：
    register_cpu_notifier(&gic_cpu_notifier);
GIC相关的回调函数定义如下：

    static struct notifier_block gic_cpu_notifier = {
        .notifier_call = gic_secondary_init,
        .priority = 100,
    };

    static int gic_secondary_init(struct notifier_block *nfb, unsigned long action,  void *hcpu)
    {
        if (action == CPU_STARTING || action == CPU_STARTING_FROZEN)
            gic_cpu_init(&gic_data[0]);－－－－－－－－－初始化那些非BSP的CPU interface
        return NOTIFY_OK;
    }

因此，当non-BSP booting up的时候，发送CPU_STARTING消息，调用GIC的callback函数，对上图中的紫色的CPU Interface HW block进行初始化，这样，就完成了全部GIC硬件的初始化过程。 
 
当网卡控制器的FIFO收到的来自以太网的数据的时候（例如半满的时候，可以软件设定），可以将该事件通过irq signal送达Interrupt Controller。Interrupt Controller可以把中断分发给系统中的Processor A or B。
NIC的中断处理过程大概包括：mask and ack interrupt controller-------->ack NIC-------->copy FIFO to ram------>handle Data in the ram----------->unmask interrupt controller
我们先假设Processor A处理了这个网卡中断事件，于是NIC的中断handler在Processor A上欢快的执行，这时候，Processor A的本地中断是disable的。NIC的中断handler在执行的过程中，网络数据仍然源源不断的到来，但是，如果NIC的中断handler不操作NIC的寄存器来ack这个中断的话，NIC是不会触发下一次中断的。还好，我们的NIC interrupt handler总是在最开始就会ack，因此，这不会导致性能问题。ack之后，NIC已经具体再次trigger中断的能力。当Processor A上的handler 在处理接收来自网络的数据的时候，NIC的FIFO很可能又收到新的数据，并trigger了中断，这时候，Interrupt controller还没有umask，因此，即便还有Processor B（也就是说有处理器资源），中断控制器也无法把这个中断送达处理器系统。因此，只能眼睁睁的看着NIC FIFO填满数据，数据溢出，或者向对端发出拥塞信号，无论如何，整体的系统性能是受到严重的影响。
注意：对于新的interrupt controller，可能没有mask和umask操作，但是原理是一样的，只不过NIC的handler执行完毕要发生EOI而已。
要解决上面的问题，最重要的是尽快的执行完中断handler，打开中断，unmask IRQ（或者发送EOI），方法就是把耗时的handle Data in the ram这个步骤踢出handler，让其在bottom half中执行。  

 三、理解softirq需要的基础知识（各种context）
1、preempt_count
为了更好的理解下面的内容，我们需要先看看一些基础知识：一个task的thread info数据结构定义如下（只保留和本场景相关的内容）：

    struct thread_info { 
        ……
        int            preempt_count;    /* 0 => preemptable, <0 => bug */
        ……
    };

preempt_count这个成员被用来判断当前进程是否可以被抢占。如果preempt_count不等于0（可能是代码调用preempt_disable显式的禁止了抢占，也可能是处于中断上下文等），说明当前不能进行抢占，如果preempt_count等于0，说明已经具备了抢占的条件（当然具体是否要抢占当前进程还是要看看thread info中的flag成员是否设定了_TIF_NEED_RESCHED这个标记，可能是当前的进程的时间片用完了，也可能是由于中断唤醒了优先级更高的进程）。 具体preempt_count的数据格式可以参考下图：
preempt_count:
reservebits	bit21		bit20		bit16~19	bit9~15	bit8	bit0~7
		preempt_active	NMI_flag	hardirq_count	softing_count	preemption_count
preemption count用来记录当前被显式的禁止抢占的次数，也就是说，每调用一次preempt_disable，preemption count就会加一，调用preempt_enable，该区域的数值会减去一。preempt_disable和preempt_enable必须成对出现，可以嵌套，最大嵌套的深度是255。
hardirq count描述当前中断handler嵌套的深度。对于ARM平台的linux kernel，其中断部分的代码如下：
    void handle_IRQ(unsigned int irq, struct pt_regs *regs)
    {
        struct pt_regs *old_regs = set_irq_regs(regs);

        irq_enter(); 
        generic_handle_irq(irq);

        irq_exit();
        set_irq_regs(old_regs);
    }
通用的IRQ handler被irq_enter和irq_exit这两个函数包围。irq_enter说明进入到IRQ context，而irq_exit则说明退出IRQ context。在irq_enter函数中会调用preempt_count_add(HARDIRQ_OFFSET)，为hardirq count的bit field增加1。在irq_exit函数中，会调用preempt_count_sub(HARDIRQ_OFFSET)，为hardirq count的bit field减去1。hardirq count占用了4个bit，说明硬件中断handler最大可以嵌套15层。在旧的内核中，hardirq count占用了12个bit，支持4096个嵌套。当然，在旧的kernel中还区分fast interrupt handler和slow interrupt handler，中断handler最大可以嵌套的次数理论上等于系统IRQ的个数。在实际中，这个数目不可能那么大（内核栈就受不了），因此，即使系统支持了非常大的中断个数，也不可能各个中断依次嵌套，达到理论的上限。基于这样的考虑，后来内核减少了hardirq count占用bit数目，改成了10个bit（在general arch的代码中修改为10，实际上，各个arch可以redefine自己的hardirq count的bit数）。但是，当内核大佬们决定废弃slow interrupt handler的时候，实际上，中断的嵌套已经不会发生了。因此，理论上，hardirq count要么是0，要么是1。不过呢，不能总拿理论说事，实际上，万一有写奇葩或者老古董driver在handler中打开中断，那么这时候中断嵌套还是会发生的，但是，应该不会太多（一个系统中怎么可能有那么多奇葩呢？呵呵），因此，目前hardirq count占用了4个bit，应付15个奇葩driver是妥妥的。
对softirq count进行操作有两个场景：
（1）也是在进入soft irq handler之前给 softirq count加一，退出soft irq handler之后给 softirq count减去一。由于soft irq handler在一个CPU上是不会并发的，总是串行执行，因此，这个场景下只需要一个bit就够了，也就是上图中的bit 8。通过该bit可以知道当前task是否在sofirq context。
（2）由于内核同步的需求，进程上下文需要禁止softirq。这时候，kernel提供了local_bf_enable和local_bf_disable这样的接口函数。这部分的概念是和preempt disable/enable类似的，占用了bit9～15，最大可以支持127次嵌套。 
 2、一个task的各种上下文
看完了preempt_count之后，我们来介绍各种context：
    #define in_irq()        (hardirq_count())
    #define in_softirq()        (softirq_count())
    #define in_interrupt()        (irq_count())
    #define in_serving_softirq()    (softirq_count() & SOFTIRQ_OFFSET)
这里首先要介绍的是一个叫做IRQ context的术语。这里的IRQ context其实就是hard irq context，也就是说明当前正在执行中断handler（top half），只要preempt_count中的hardirq count大于0（＝1是没有中断嵌套，如果大于1，说明有中断嵌套），那么就是IRQ context。
softirq context并没有那么的直接，一般人会认为当sofirq handler正在执行的时候就是softirq context。这样说当然没有错，sofirq handler正在执行的时候，会增加softirq count，当然是softirq context。不过，在其他context的情况下，例如进程上下文中，有有可能因为同步的要求而调用local_bh_disable，这时候，通过local_bh_disable/enable保护起来的代码也是执行在softirq context中。当然，这时候其实并没有正在执行softirq handler。如果你确实想知道当前是否正在执行softirq handler，in_serving_softirq可以完成这个使命，这是通过操作preempt_count的bit 8来完成的。
所谓中断上下文，就是IRQ context ＋ softirq context＋NMI context。 
关于开发中断的kernel-API 架构 workqueue softirq tasklet waitlist!!



















http://www.wowotech.net/device_model/bus.html
bus设备:
 subsys、devices_kset、drivers_kset是三个kset，由"Linux设备模型(2)_Kobject”中对kset的描述可知，kset是一个特殊的kobject，用来集合相似的kobject，它在sysfs中也会以目录的形式体现。其中subsys，代表了本bus（如/sys/bus/spi），它下面可以包含其它的kset或者其它的kobject；devices_kset和drivers_kset则是bus下面的两个kset（如/sys/bus/spi/devices和/sys/bus/spi/drivers），分别包括本bus下所有的device和device_driver。

interface是一个list head，用于保存该bus下所有的interface。有关interface的概念后面会详细介绍。 
 bus和class指针，分别保存上层的bus或者class指针。 

 bus_add_device的处理逻辑：

    调用内部的device_add_attrs接口，将由bus->dev_attrs指针定义的默认attribute添加到内核中，它们会体现在/sys/devices/xxx/xxx_device/目录中
    调用sysfs_create_link接口，将该device在sysfs中的目录，链接到该bus的devices目录下，例如：

    xxx# ls /sys/bus/spi/devices/spi1.0 -l                                                        
    lrwxrwxrwx root     root              2014-04-11 10:46 spi1.0 -> ../../../devices/platform/s3c64xx-spi.1/spi_master/spi1/spi1.0
    其中/sys/devices/…/spi1.0，为该device在sysfs中真正的位置，而为了方便管理，内核在该设备所在的bus的xxx_bus/devices目录中，创建了一个符号链接
    调用sysfs_create_link接口，在该设备的sysfs目录中（如/sys/devices/platform/alarm/）中，创建一个指向该设备所在bus目录的链接，取名为subsystem，例如：

    xxx # ls /sys/devices/platform/alarm/subsystem -l                                                
    lrwxrwxrwx root     root              2014-04-11 10:28 subsystem -> ../../../bus/platform
    最后，毫无疑问，要把该设备指针保存在bus->priv->klist_devices中

 bus_add_driver的处理逻辑：

    为该driver的struct driver_private指针（priv）分配空间，并初始化其中的priv->klist_devices、priv->driver、priv->kobj.kset等变量，同时将该指针保存在device_driver的p处
    将driver的kset（priv->kobj.kset）设置为bus的drivers kset（bus->p->drivers_kset），这就意味着所有driver的kobject都位于bus->p->drivers_kset之下（寄/sys/bus/xxx/drivers目录下）
    以driver的名字为参数，调用kobject_init_and_add接口，在sysfs中注册driver的kobject，体现在/sys/bus/xxx/drivers/目录下，如/sys/bus/spi/drivers/spidev
    将该driver保存在bus的klist_drivers链表中，并根据drivers_autoprobe的值，选择是否调用driver_attach进行probe
    调用driver_create_file接口，在sysfs的该driver的目录下，创建uevent attribute
    调用driver_add_attrs接口，在sysfs的该driver的目录下，创建由bus->drv_attrs指针定义的默认attribute
    同时根据suppress_bind_attrs标志，决定是否在sysfs的该driver的目录下，创建bind和unbind attribute（具体可参考"Linux设备模型(5)_device和device driver”中的介绍） 






trace处理	有一个debug linux用户程序的手段
Linux的内核提供了ptrace这样的系统调用，通过它，一个进程（我们称之 tracer，例如strace、gdb）可以观测和控制另外一个进程（被trace的进程，我们称之tracee）的执行。一旦Tracer和 tracee建立了跟踪关系，那么所有发送给tracee的信号(除SIGKILL)都会汇报给Tracer，以便Tracer可以控制或者观测 tracee的执行。例如断点的操作。Tracer程序一般会提供界面，以便用户可以设定一个断点（当tracee运行到断点时，会停下来）。当用户设定 了断点后，tracer就会保存该位置的指令，然后向该位置写入SWI __ARM_NR_breakpoint（这种断点是soft break point，可以设定无限多个，对于hard break point是和CPU体系结构相关，一般支持2个）。当执行到断点位置的时候，发生软中断，内核会给tracee进程发出SIGTRAP信号，当然这个信号也会被tracer捕获。对于tracee，当收到信号的时候，无论是什么信号，甚至是ignor的信号，tracee进程都会停止运行。Tracer进程可以对tracee进行各种操作，例如观察tracer的寄存器，观察变量等等。 










struct class是class的抽象，它的定义如下：
   1: /* include/linux/device.h, line 332 */
   2: struct class {
   3:         const char              *name;
   4:         struct module           *owner;
   5:  
   6:         struct class_attribute          *class_attrs;
   7:         struct device_attribute         *dev_attrs;
   8:         struct bin_attribute            *dev_bin_attrs;
   9:         struct kobject                  *dev_kobj;
  10:  
  11:         int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
  12:         char *(*devnode)(struct device *dev, umode_t *mode);
  13:  
  14:         void (*class_release)(struct class *class);
  15:         void (*dev_release)(struct device *dev);
  16:  
  17:         int (*suspend)(struct device *dev, pm_message_t state);
  18:         int (*resume)(struct device *dev);
  19:  
  20:         const struct kobj_ns_type_operations *ns_type;
  21:         const void *(*namespace)(struct device *dev);
  22:  
  23:         const struct dev_pm_ops *pm;
  24:  
  25:         struct subsys_private *p;
  26: };
    其实struct class和struct bus很类似，解释如下：
    name，class的名称，会在“/sys/class/”目录下体现。
    class_atrrs，该class的默认attribute，会在class注册到内核时，自动在“/sys/class/xxx_class”下创建对应的attribute文件。
    dev_attrs，该class下每个设备的attribute，会在设备注册到内核时，自动在该设备的sysfs目录下创建对应的attribute文件。
    dev_bin_attrs，类似dev_attrs，只不过是二进制类型attribute。
    dev_kobj，表示该class下的设备在/sys/dev/下的目录，现在一般有char和block两个，如果dev_kobj为NULL，则默认选择char。
    dev_uevent，当该class下有设备发生变化时，会调用class的uevent回调函数。
    class_release，用于release自身的回调函数。
    dev_release，用于release class内设备的回调函数。在device_release接口中，会依次检查Device、Device Type以及Device所在的class，是否注册release接口，如果有则调用相应的release接口release设备指针。
    p，和“Linux设备模型(6)_Bus”中struct bus结构一样，不再说明。

    device的注册最终是由device_add接口（drivers/base/core.c）实现了，该接口中和class有关的动作包括：

        调用device_add_class_symlinks接口，创建3.1小节描述的各种符号链接，即：在对应class的目录下，创建指向device的符号链接；在device的目录下，创建名称为subsystem、指向对应class目录的符号链接
        调用device_add_attrs，添加由class指定的attributes（class->dev_attrs）
        如果存在对应该class的add_dev回调函数，调用该回调函数
依旧没有弄清楚class在内核到底是怎么使用的









电源管理有关的Source code分别位于：

    kernel/power/ *
    drivers/power/
    drivers/base/power/*
    drivers/cpuidle/*
    drivers/cpufreq/*
    drivers/devfreq/*
    include/linux/power_supply.h
    include/linux/cpuidle.h
    include/linux/cpufreq.h
    include/linux/cpu_pm.h
    include/linux/device.h
    include/linux/pm.h
    include/linux/pm domain.h
    include/linux/pm runtime.h
    include/linux/pm wakeup.h
    include/linux/suspend.h
    Documentation/power/*.txt



































































































































(USB IN Endpoint 1,video streaming interface 1)
