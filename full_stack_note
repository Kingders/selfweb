全栈:
高并发:
负载均衡:  LVS Nginx 应用服务器集群
LAMP  


decops
可用工具有很多，但其中一些环节是组织内部应用DevOps工具链不可或缺的。
诸如Docker（容器化）、Jenkins（持续集成）、Puppet（基础架构构建）、Vagrant（虚拟化平台）等常用、广泛使用的工具都是2016年的DevOps热门工具。




tomcat 


SpringBoot: https://www.cnblogs.com/java1024/p/8570401.html
    JDK8
    Maven3.0+
    Intellij IDEA

前端程序员
    基础
        HTML / CSS
        JavaScript
        DOM
    中级篇
        数据格式（如JSON、XML）
        RESTful API交互（如jQuery Ajax，Fetch API，ReactiveX）
        正则表达式
        HTML语义化
        命令行
        Node.js
        DIV / CSS
        SCSS / SASS
        矢量图形 / 矢量图形动画（如SVG）
        单页面应用
    高级篇
        ES6 / TypeScript
        CSS3
        面向对象编程
        函数式编程
        MVC / MVVM / MV*
        安全性（如跨域）
        授权（如HTTP Basic、JWT等等）
    工程化
        代码质量（如JSLint / ESLint / TSLint / CSLint）
        代码分析（如Code Climate）
        测试覆盖率
        构建系统（gulp、grunt、webpack等等）
        自动构建（脚本）
    兼容性
        跨浏览器测试 （Chrome，IE，Firefox，Safari等等）
        跨平台测试（Windows、GNU/Linux，Mac OS等等）
        跨设备测试（Desktop，Android，iOS，Windows Phone）
        跨版本测试（同一个浏览器的不同版本）
    前端特定
        CSS / CSS3 动画
        JavaScript 动画
        Web字体嵌入
        Icon 字体
        图形和图表
        CSS Sprite（如glue）
        DOM操作（如jQuery、React等等）
        模板引擎（如JSX、Handlebars、JSP、Mustache等等）
    软件工程
        版本管理（如git、svn）
        包管理（如npm、bower）
        依赖管理
        模块化（如CommonJS、WebPack）
    调试
        浏览器调试
        Debug工具
        Wireshark / Charles抓包
        远程设备调试（如Chrome Inspect Devices）
    测试
        单元测试
        服务测试
        UI测试
        集成测试
    性能与优化
        PageSpeed / Yslow 优化
        加载优化（如gzip压缩、缓存等等）
        性能测试（特别是移动Web）
        可用性
        压缩（如Minify、Uglify、CleanCSS等等）
    设计
        切页面
        线框图（Wireframe）
        响应式设计
        网格布局（Grid Layout）
        Flexbox布局
    SEO
        Sitemap（站点地图）
        内部链接建设
        MicroData / MicroFormat
        页面静态内容生成
        H1、H2、H3和strong使用
        Title、Description优化
        页面静态内容生成
后端程序员
    入门
        HTML / CSS
        编程语言：Java / Python / PHP / Ruby等等
        Web框架，如Spring MVC、Flask、Laravel等等
        HTTP协议基础
        CGI基础
    中级篇
        XML和JSON处理
        数据结构与算法
        面向对象编程
        CMS
        API设计
        网络通信协议，如TCP / Socket
    高级篇
        函数式编程
        领域驱动设计
        MVC架构
        运行环境优化，如JVM
        远程调试
    工程化
        版本管理
        单元测试
        依赖管理
        包管理
    基础设施
        虚拟化，如Docker
        自动化部署
        应用包创建、管理、发布
        发布脚本编写
        Web容器，如Jboss
    缓存篇
        应用层缓存
        平台缓存
        数据库端缓存
        分布式缓存
    数据持久化
        SQL
        NoSQL
        ORM
        DBMS
        搜索引擎
    数据库
        查询性能优化
        结构优化
        主从复制、主主复制等等
        伸缩性与高可用性
        备份恢复与容灾
    安全和加密
        认证与会话管理
        加密解密
        数字签名、数字证书
        加密算法
        XSS/CSRF/SQL注入
    监控
        应用性能监控
        异常监控
        日志
        流量监控
    服务
        RESTful
        SOA
        RPC
        MicroServices
    消息
        JMS
        IPC
        MQ
运维开发者
    入门篇
        编写脚本，如Shell、Perl、Rython等等
        编程语言
        Web应用运行基本原理
        HTTP服务器
        应用容器
        命令行，如awk
        CGI
        修复漏洞
    中级篇
        自动化运维
        GNU/Linux操作系统
        编译
        数据库
    高级篇
        分布式文件系统
        分布式存储系统
    云服务
        存储服务，如AWS S3
        计算服务，如AWS Lambda
        托管服务，如AWS EC2
    安全性
    网络
        CCNP / CCNA
    持续集成
        持续集成工具
        自动构建工具
        依赖管理工具
        版本管理工具
    虚拟化
        应用容器虚拟化，如Docker
        环境虚拟化
        操作系统虚拟化
    自动化 (puppet,chef)
        自动化配置
        自动化部署
        进程管理工具，如Supervisor
    监控
        基础设施监控
        日志管理
        监控服务
    负载均衡
        边缘缓存，如（Varnish）
        DNS负载均衡
        CDN










20180726
主要练习部署 和 负载均衡 知识
web 服务器端下游: tomcat、apache httpd、nginx, uwsgi,
	uwsgi，它类似于nginx，通过一个守护进程把不同的http请求转交给子进程并发处理，并且支持多线程的方式，性能较高，
	与其让一个uwsgi服务跑10个进程，不如开10个uwsgi服务，然后用nginx做负载均衡！
	uwsgi本身的负载均衡没有nginx牛逼。所以阉割掉不用。因此uwsgi退化成了wsgi服务器
	nginx 可以一个ip 地址 配置不同端口来实现在 同一台机子上 访问多个不同的网站!!
	nginx 可以集群部署, 同一个网站,但分布多个主机,多个ip,
		https://www.cnblogs.com/lilongsheng1125/p/4978485.html  (nginx 科普)
		https://www.linuxidc.com/Linux/2017-05/143739.htm 	( Keepalived 和 nginx 配合使用 典型集群部署手把手例子)
		https://www.linuxidc.com/Linux/2017-03/141866.htm	( Keepalived 模式方案 )
			Keepalived 管理多个 nginx 节点,分主备节点,主节点死了,备节点顶上!!
			nginx 节点 实现 web服务的负载管理
Keepalived:是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，
	类似的工具还有heartbeat、corosync、pacemaker。
	但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用












20180727
使用 python3 重新开发 django selfweb项目!!
建立独立环境:
	mkvirtualenv django -p python3
	workon django
	pip install django
	pip install uwsgi
	mkdir selfweb_pyth3 && cd selfweb_pyth3
建立项目
	django-admin startproject selfweb_pyth3 /home/william/full_stack/selfweb_pyth3
建立网站
	django-admin startapp web	
尝试运行: 然后刻登录指定链接测试
	python manage.py runserver
	错误:You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): 
		admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them
	先不处理
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    path('admin/', admin.site.urls),
		    # by william
		    path('',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
如果要局域网的机子能访问自己
	在settings.py文件中，找到ALLOWED_HOSTS=[ ]，在中括号中加入你在局域网中的IP。如我在局域网中的IP为192.168.10.133
	所以设置ALLOWED_HOSTS = [ '192.168.10.133'] 
	python manage.py runserver 0.0.0.0:8000	//执行网站服务,添加向外开放段端口
设置简单高并发网站:(使用 uwsgi 多进程)
	在settings.py文件中，设置 ALLOWED_HOSTS=[ ]
	建立selfweb_pyth3/uwsgi.ini:
		[uwsgi]
		chdir = /home/william/full_stack/selfweb_pyth3
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb_pyth3.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb_pyth3/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
如果要局域网的机子能访问自己
	在settings.py文件中，设置 ALLOWED_HOSTS = [ 'xxx.xxx.xxx.xxx']
	selfweb_pyth3/uwsgi.ini: http = 0.0.0.0:8000 
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//启动服务!!
安装数据库:
	sudo apt-get install mysql-server
	sudo apt-get install mysql-client
	mysql 操作教程看 开发_in_linux_log
	还有django用到的python mysqllib 只支持 2.7
	所以需要:
	pip install PyMySQL
	gedit selfweb_pyth3/__init__.py 
	添加:
	import pymysql
	pymysql.install_as_MySQLdb()
添加数据库 mysql:
	数据库,是django网站各种扩展模块的基础,所以,建站之前先要初始化一个数据库
	当migrate过程时,django会给 selfweb/settings.py->INSTALLED_APPS 里提到的模块都建立相应的表单,
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:3***************7
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	配置工程连接这个数据库: 修改 selfweb_pyth3/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb_pyth3',
		        'USER': 'root',
		        'PASSWORD': '3***************7',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错:
	python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
	补充: 
		db_selfweb_pyth3 并不存在与 selweb网站目录里!!,拷贝移植selfweb网站到新机子时,并不带 db_selfweb_pyth3
		关于如何把 db_selfweb也拷贝过去,日后在探究
创建web模块,及建立自定义model模型
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',	//表示 添加 django管理模块 admin
		    'django.contrib.auth',	//表示 添加 django管理模块 admin
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的model 对应的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True,on_delete=models.CASCADE)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		除了web_blogpost 还有一个web_subject,
		web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项 (一对多原理)
		还多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系(多对多原理)
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	要使用admin管理模块: 需要: selfweb/settings.py -> INSTALLED_APPS 含有:
		'django.contrib.admin',	//表示 添加 django管理模块 admin
		'django.contrib.auth',	//表示 添加 django管理模块 admin
	还需要:selfweb/urls.py -> urlpatterns 含有 url(r'^admin/', admin.site.urls)
	python manage.py createsuperuser	//创建管理者:william:3**7q
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
			Django admin后台管理是不支持显示这种many_to_many关系的,因为 'tags' many_to_many关系
			改成 list_display = ('title', 'create_time', 'subject')
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.		
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
			显然 list_display = ('name') 只有name,一项, 不是一个列表,必须加 , 号
			改成 list_display = ('name',)
		System check identified 3 issues (0 silenced).
		错误,不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	关于 admin 进一步定制:https://www.cnblogs.com/zhming26/p/5767158.html
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功










20180731
目前使用 django2.0
	路径分配要使用通配符的话, 需要 import re_path 使用有正则表达式的路径
	view.py 每个def 一般都是定义一个页面的实现方式,如果要像使用print那样调试,可以使用 assert False 主动触发出错页来代替
	例如:
	def hours_ahead(request, offset):
	    try:
	        offset = int(offset)
	    except ValueError:
	        raise Http404()
	    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
	    assert False
	    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
	    return HttpResponse(html)
	django 使用的网页模板 一般使用 .html后缀名, 这个不是一个严格的 html页面文件,里面夹杂着django的一些自家语法.
	利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射
html常用小知识:
	注释符号
	Html
		单行:<!-- -->
		多行:<!-- -->

	javascript
		单行://
		多行:/*  */
		
	Vbscript
		单行:'
		多行:'
		
	ASP <% %>中： 
		单行：' 
		多行：'
	还有跨浏览器管理


















second_brain
初步架构是 
以行号为基础
每行 一条数据指针,每条指针,指向同一条数据 (针对,上十万行后,出现行位转移问题,)
一般来说,一行一段文字
两张数据表, 一个行号表,一个内容表
每一行都有一个属性字节 0位, 换了行位置, 1位, 改变了内容,
由于 行数据指针制度,所以可以一行放置超文本内容(公式,图片,视频链接!!)
按用户分配负载,和database位置空间,而不是按流量
初步发现,使用django应该并不合适.第一版还是用django 吧

任务一:全页文本框
通过建立 html页模板:
	<input> 单行文本框,好像并不合适 
	<br /> 另起一行
	多行文本框 五行、一行50字的文本框，<textarea name="txt" clos=",50" rows="5" warp="virtual"></textarea>
	但是这种多行文本似乎也不理想
	
	参考CKEditor 5 https://ckeditor.com/ckeditor-5/ 的 在线文本编辑框, 这样就建立了一个简单的在线文本编辑.
	<div class="cc" role="textbox" aria-label="Rich Text Editor, main" contenteditable="true">
		<h2>The three greatest thiou learn from traveling</h2>
	这种文本框比较理想
	role 只是识别标记, aria-label只是注释,暂时都未知如何使用
	contenteditable="true" 才表示 当前的这个 div 块,允许编辑!!

回车键监听
	注意js里 跨浏览器的处理方式:
		<div ...onKeyDown="ifenter(event)" >
		function ifenter(e)
		{
			var x
			if(window.event) // IE8 以及更早版本	
			{
				x=e.keyCode;
			}
			else if(e.which) // IE9/Firefox/Chrome/Opera/Safari
			{
				x=e.which;
			}
			......
		}
	通过js 插入html段落: 网上一个 js 片段:
		window.onload = function(){
		var testingText = '<p>hello</p>'
		var rootElement = document.body;
		var newElement = document.createElement("div");
		var newElementHtmlContent = document.createTextNode(testingText);
		rootElement.appendChild(newElement);
		newElement.appendChild(newElementHtmlContent);
		} 
		这段js 是假设放在 <head>段的
		window.onload 表示当<body>加载显示完毕,即html完全显示后 就执行这个function,
		通过 DOM 动态加载一个新段落 <p>hello</p>
		但是 这只能加载 一段 "<p>hello</p>" 字符窜 而不能真的加载一段<p>段落!!
		以下这段才能成功添加一段段落:
			var testingText = "<p>hello william</p>"
			var ccElement = document.body.getElementsByClassName('cc')
			ccElement[0].insertAdjacentHTML("beforeEnd",testingText);	
		原型：insertAdjacentHTML(swhere,stext) 在指定的地方插入html标签语句
		参数：
			swhere:指定插入html标签语句的地方，有四种值可以用：
			1.beforeBegin:插入到标签开始前
			2.afterBegin:插入到标签开始标记后
			3.beforeEnd:插入到标签结束标记前
			4.afterEnd:插入到标签结束标记后
	按键事件  onkeydown、 onkeypress 和 onkeyup这三个事件句柄:
		按键监听句柄书写 可以 onkeydown 也可以 onKeyDown
		onkeydowm 是比较底层的句柄, 不能识别 组合按键和 按键的复用内容,
			比如, g按键 只能传递按键原码,即大写G字符的字符码,不能传递小写g字符码
			shift+1 并不能传递出 感叹号 ! 的字符码
		onkeypress 高级句柄 能识别 组合按键和 按键的复用内容, g按键 可以识别传递 大写字符码或者小写字符码,
			shift+1 能传递出 感叹号 ! 的字符码
		onkeyup 也是底层句柄	
		就是说 onkeydowm / onkeyup 传递的是按键码, 而 onkeypress 传递的是具体的字符码
		当按键一直按住,相当于 连续触发多次 onkeydowm / onkeypress 事件
		暂时只从 firefox 讨论 !!
			按键事件都会传递一个隐含变量 e , 而 e.which 就是传递过来的字符码数字,
			根据事件句柄类型, e.which要么是按键码, 要么是具体的字符码
			还有两个擦差不多的属性变量 e.keycode  e.charcode ,不过都是在跨浏览器上使用的
		通过 fromCharCode 可以把按键码,字符码转换成实际 字符 变量.
		例如: var keychar = String.fromCharCode(e.which)	
	光标控制!!
		'\r'是回车，使光标到行首，return（carriage return）
		'\n'是换行，使光标下移一格，newline（line feed）
		根据 id 跳到 焦点指定的 段落里文本框,光标直接跳到指定段落里的文本框:
			var fui = document.getElementById('dfg')
			fui.focus(); 
			注意,虽然是再<head>写的代码,但不用document.body.getElementById('dfg') 从<body>段寻找
			直接从全页寻找, 而且不像 class标签 得到的不是数组变量,不用使用 fui[xx]指代
		光标 是选区知识的一个部分,必须系统学习 selection 选区内容
		var sel = getSelection()	//选区
		var node = sel.anchorNode	//开始节点, 节点就是<xx>段落
			//鼠标落到的地方所处的段落就是 选区开始作用的段落 (开始节点)
			<div contenteditable="true"...>
			 	<h2>The three greatest</h2>
				<p>hello</p>
				klkkl
				opp
			</div>
			//当鼠标落到 three 这个地方, 那么此刻选取的开始节点是 <h2>段落 中的 #text 文本段落
			//当鼠标落到 hello 这个地方, 那么此刻选取的开始节点是 <p>段落 中的 #text 文本段落
			//当鼠标落到 kikkl或者 opp 这个地方, 那么此刻选取的开始节点是 <div> 段落中的 #text 文本段落
			//一般用户点击时 selection的 anchorNode 只会落在 各个标签段落中的 #text 文本段落
			//所以 node 值一般是 #text
			//如果要 真正落到指定的 tag段落 例如<div> node:div#dfg.cc,一般是 DOM函数获取
			//真正的 tag段落: 每个tag子段落为占一个偏移位置, 每段文本占一个偏移位置
			//tag段落中的#text 文本段落: 每个字符占一个偏移, 注意回车,缩进什么的也算一个字符
		var number = sel.anchorOffset	//开始节点的偏d移
			//当鼠标落到 The 的 h 之后的地方, 此刻开始节点偏移是从<h2>段落里#text 文本段落的第 2 个位置
			//当鼠标落到 hello 的 o 之前的地方, 此刻开始节点偏移是从<p>段落里#text 文本段落的第 4 个位置
			//当鼠标落到 kikkl 的第一个 k 之前的地方, 此刻开始节点偏移是从<div>段落里#text 文本段落第 2 个位置
			//因为 在 <div>段落里<div>段落里#text 文本段落中</P>之后有一个回车和缩进字符才到达位置 kikkl之前
		var fnode = sel.focusNode 	//结束节点  选区最后的段落,
			//一般情况下,开始节点和结束节点是同一个,所以不知道可以怎么用
		var offset = sel.focusOffset	//结束节点偏移, 也是从结束节点的段落里的第 xx 个位置的意思
		var bool = sel.isCollapsed	//选区的开始和结束位置是否重合
			//当开始节点 == 结束节点, 开始节点偏移==结束节点位置, 选区的开始和结束位置就重合, bool==true
			//这个位置点也是光标闪烁的位置点
			//如果是高亮选择的一块区域, 这一次操作选取的区域为 一个 range
			//当 选择高亮 three,时从左到右选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 4, 结束偏移 9
				isCollapsed :false
			//当 选择高亮 three,时从右到左选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 9, 结束偏移 4
				isCollapsed :false			
			//当 选择高亮从 greatest 的第一个 t 到 hello 的第一个l, 即 test hel :
				开始节点 <h2>  结束节点 <p>
				开始节点偏移 14, 结束偏移 3
				isCollapsed :false
				类似这样的跨节点 选择一块分选区能成,是因为 <div contenteditable="true"...>
		var value = sel.rangeCount	//选区的 分选区 个数
			//通过按住 ctrl 我们 多次操作 间断 高亮选择多块区域
			//每一块都作为一个分选区,统计的数字就是 rangcount
			//然而, 开始节点 结束节点 开始节点偏移 结束偏移  都是最新一个分选区区域的对应的内容
			//而之前分选区的这些参数却未知在哪里
		var typ = sel.type	//当前的选区,当前的分选区的类型
			//一个selection 里 可能有很多分选区成员 包括 多个高亮区域,和一般只有一个光标
			//高亮区域的 type是 range 类型
			//光标的 type 是 Caret 类型, 即 collapsed
			//不论是 光标还是 高亮区域 都算入一个 rangeCount 计数
			//但是 高亮区域 和 光标 不能同时存在,
			//某刻,如果有n个 高亮区域 ,那么 selection.rangeCount:n  selection.type= range
			//某刻有光标,那也只能有一个光标, selection.rangeCount:1  selection.type= Caret
		以上光标内容都是 只读 内容,即只能用特定 api 修改, 不能手动修改
		给选区添加一个range
			var ccElement = document.body.getElementsByClassName('cc') //寻找class="cc"的节点 
			var sel = getSelection()  //获取 此刻的 selection 对象 (选区对象)
			if(sel.rangeCount > 0) sel.removeAllRanges(); 
				//如果此刻你见到有光标/高亮区域,说明selection里有分选区成员,这里是都清除他们
			var range = document.createRange();	//新建一个range
  			range.selectNode(ccElement[0]);	//把节点里的所有内容,都放入这个range
			sel.addRange(range);	
				//把这个range 添加到 selection里, 这时,selection 只有一个包含节点内所有内容的高亮区域
				//这时 selection.rangeCount:1  selection.type= range
		光标跳到指定位置:	
			sel.collapse(ccElement[0],1)
				//ccElement[0] 指是 光标要停在的节点, 是tag节点,而不是tag节点里的#text段落
				//1 是 在这节点上对应的偏移地方
				//所以 一个子段落是算 1 个偏移
				//一段字符串算 1 个偏移
				//注意 html 书写为了美观,使用大量缩进键,但是缩进键也算字符串里的字符
				//所以使用这个要非常谨慎
		        sel.collapseToEnd()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最后的那个点.
				//让光标跳到最后的那个逻辑位置
		        sel.collapseToStart()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最前的那个点.
				//让光标跳到最前的那个逻辑位置
		判断指定节点内容是否选上,光标是否在指定节点
			console.log(sel.containsNode(ccElement[0], true))
				//判断 selection对象 比如 光标 落到指定的 节点上,  
				//判断 selection的高亮选区 有没有在 指定节点 选取了部分内容
  			console.log(sel.containsNode(ccElement[0], false))
				//判断 selection的高亮选区 有没有在 指定节点 选取了全部内容
 		删除指定高亮的 文本内容!!
			sel.deleteFromDocument()
		选取扩充至:	
			sel.extend(nodeA, offsetA)	
				//高亮选取一片区域range, 
				//以当前节点,当前偏移位置 (或者某自定义节点,节点偏移)为 开始节点,开始节点偏移, 
				//以 nodeA 为结束节点, offsetA为结束节点偏移
		获选区中其中的一个range
			首先,我们知道,打开的 html 页面,只有一个 selection 对象,而且一直存在, 只不过他的内容不断变换
			selection 里内容,要么是光标,要么是高亮选区range
			如果是光标, 开始节点==结束节点,开始节点偏移==结束节点偏移, rangeCount:1
			Selection { anchorNode: #text, anchorOffset: 17, 
				    focusNode: #text, focusOffset: 17, 
				    isCollapsed: true, rangeCount: 1, 
				    type: "Caret", caretBidiLevel: 0 }
			如果是高亮选区, selection  选中了 多少个高亮选区,就有多少个rangeCount,
			而开始节点,结束节点,开始节点偏移,结束节点偏移 都是最后加入那一个 高亮选区 的参数,
			Selection { anchorNode: #text, anchorOffset: 28, 
				    focusNode: #text, focusOffset: 34, 
				    isCollapsed: false, rangeCount: 4, 
				    type: "Range", caretBidiLevel: 0 }
			然而,如何获得 selection 存着的,靠前的高亮选区 range 呢? 
			range = sel.getRangeAt(index)
				//获得 selection 里 指定序号的 range ,序号0开始 
				//例如 rangeCount:7 表示有7个range ,序号6表示第7个range
		量化移动光标,量化选range
			sel.modify(alter, direction, granularity)
			alter: move 移动光标
			       extend 选range区域
			directtion: forward / right 向前移动/选 (向右)
				    backward / left 向后移动/选 (向左)
			granularity: (量化值)
				"character",按字符
				"word", 按单词
				"sentence", 
				"line", 
				"paragraph", 
				"lineboundary", 
				"sentenceboundary", 
				"paragraphboundary", 
				"documentboundary".
			例如 The three greatest thiou learn from traveling
				sel.modify("move", "forward", "word")
				//点击 greatest 的 a前面时, 光标会出现在最后的t后面
				sel.modify("extend", "backward", "word")
				//点击 thiou 的 o 前面时, thi 被高量选择!			 
		删除 selection 里的 所有 range:  sel.removeAllRanges();
		删除 selection 里的 指定 range:  sel.removeRange(sel.getRangeAt(index))	
		选择节点里的所有内容,包括各种嵌入子节点: sel.selectAllChildren(parentNode)
		通过代码指定一个 selection.
			sel.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)
			例子:
				var one = document.querySelector('.one');
				var two = document.querySelector('.two');
				var aOffset = document.getElementById('aOffset');
				var fOffset = document.getElementById('fOffset');
			    	selection.setBaseAndExtent(one, aOffset.value, two, fOffset.value);
			然后你就看到一段 指定的内容 高亮选中了,此刻 sslection 里也仅有这个range
		sel.toString();
			把 selection 中的文本内容全部转化策成 字符串!!	
	
文本边框消失 CSS !! 
	通过 css实现,例如 <style>#edit{height:500px;width:500px;border:50px none transparent;outline:none}</style>
	首先 boarder:none,表示不显示边框,
	outline:none,也表示 当文本框被点击focus时,边框的显示, 也为none
文本框字体 CSS !!
	大小:	h1 {font-size:3.75em;} /* 60px/16=3.75em */
		h2 {font-size:2.5em;}  /* 40px/16=2.5em */
		p {font-size:0.875em;} /* 14px/16=0.875em */ 	
	颜色:
		直接用 color:#F00;  三原色组合 F00 
背景
	body{background:#001122}
django 外部css 外部script:
	注意没有和nginx一起部署时，DEBUG = True 才能访问django静态资源。
	django 使用 外部css设置简单,但要先理解每一个参数,所以比较耗时间,要引入外部 css 就是相当于引入外部静态资源
	先看 settings.py
	STATIC_URL = '/static/'		//必要,这个是告诉 html可以直接以这个/static为url头,直接获取各静态资源 
					//比如远程客户机浏览器访问
					// http://127.0.0.1:8000/home/william/full_stack/selfweb_pyth3/static/css/base.css
					//可以改为: http://127.0.0.1:8000/tatic/css/base.css 就能访问
					//但似乎 没有也可以实现, 只要有 STATICFILES_DIRS,所以感觉可有可无,可能在真实部署时才有用吧
	STATIC_ROOT = os.path.join(BASE_DIR, 'static')	  //只是声明了一个路径, 没有特殊意义 ,所以非必要 
					//具体线路是:/home/william/full_stack/selfweb_pyth3/static
					//一般也可以这样声明
					//STATIC_ROOT = os.path.join(BASE_DIR, 'static').replace('\\', '/')
	STATICFILES_DIRS = (...)				//必要,这里才是真正定义外部可访问的静态资源链接
	例子一: STATICFILES_DIRS = ( 
			os.path.join(BASE_DIR, 'static'),  //假如 BASE_DIR: /home/william/full_stack/selfweb_pyth3
			)				   //那么 把 BASE_DIR 接上 static 得到一条具体路径:
							   // /home/william/full_stack/selfweb_pyth3/static
							   //这条路径就是 被添加上的一条静态资源路径,假如路径里有文件 body.css yilaao.jpg
							   //浏览器直接访问 http://127.0.0.1:8000/static/yiliao.jpg 就可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/body.css">
							   //就可以加载 对应的 css文件
	例子二:STATICFILES_DIRS = ( 
		     ('css', os.path.join(BASE_DIR, 'static')), //具体线路是:/home/william/full_stack/selfweb_pyth3/static
			)				   //浏览器直接访问 http://127.0.0.1:8000/static/css/yiliao.jpg 可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/css/body.css">
							   //就可以加载 对应的 css文件
	例子三:STATICFILES_DIRS = (
	    ('css', os.path.join(STATIC_ROOT, 'css').replace('\\', '/')),  
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/css
							//访问线路 http://127.0.0.1:8000/static/css/
	    ('img', os.path.join(STATIC_ROOT, 'images').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/images
							//访问线路 http://127.0.0.1:8000/static/img/
	    ('fonts', os.path.join(STATIC_ROOT, 'fonts').replace('\\', '/')), 
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/fonts
							//访问线路 http://127.0.0.1:8000/static/fonts/
	    ('js', os.path.join(STATIC_ROOT, 'js').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/js
							//访问线路 http://127.0.0.1:8000/static/js/
	)
	settings.py设定后,(重点设置是STATICFILES_DIRS) 把要用到的文件放到指定 具体地址后,
	编译 django python manage.py migrate. 

	然后就可以再 .html 上使用外部 css 文件
	有两种使用方式: 
	第一种: 使用 django 的 html 语法.
	{% load static %}	// 在 <!DOCTYPE html> 之前加入
	<link rel="stylesheet" href="{% static '/css/index.css' %}">	
	第二种: 使用标准的 html语法
	<link rel="stylesheet" href="/static/css/body.css">	

	在 .html 上使用外部 js 文件
	<script type="text/javascript" src="/static/js/login.js"></script>


<link>标签的一些补充: 1. 定义文档与外部资源的关系；2. 是链接样式表。
	rel各个属性值配置的意思：
              Alternate -- 定义交替出现的链接 
              Stylesheet -- 定义一个外部加载的样式表 
              Start -- 通知搜索引擎,文档的开始 
              Next -- 记录文档的下一页.(浏览器可以提前加载此页) 
              Prev -- 记录文档的上一页.(定义浏览器的后退键) 
              Contents 
              Index -- 当前文档的索引 
              Glossary -- 词汇 
              Copyright -- 当前文档的版权 
              Chapter -- 当前文档的章节 
              Section -- 作为文档的一部分 
              Subsection -- 作为文档的一小部分 
              Appendix -- 定义文档的附加信息 
              Help -- 链接帮助信息 
              Bookmark -- 书签 	
	例如, <link rel="stylesheet" href="css/bootstrap.css">，引入外部的css文件时，一定不能忘记rel属性的配置。

要着重掌握对 contenteditable 里 innertext 的 光标定位问题!! 还有获取光标所在节点
	<div id="dw" contenteditable="true"></div>
	$('#dw')[0].innerHTML
	console.log($('#dw')[0].innerHTML );就是div中的内容 

	数字转换:https://www.jb51.net/article/45331.htm
	javascript自带parseInt(str)函数
	参数：str，为一个包含数字的字符串
	返回值：
	如果str中最前面几个字符是数字，则返回该数字； 如果str第一个字符不是数字，返回NaN。
	例如：
	parseInt("1234"); //返回1234
	parseInt("1234A"); //返回1234
	parseInt("1234A5"); //返回1234
	parseInt("A1234"); //返回NaN 

	字符窜的处理:https://www.cnblogs.com/l1pe1/p/6197371.html
	



代码片段:
回车后插入字符窜再定位事件方法1:
	e.preventDefault();	//阻止回车原来事件 原来回车事件会插入一个 <div><br/></div> 段
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点		
	var range = document.createRange()	//创建一个range
	range.selectNodeContents(o) 		//把节点里的所有内容都选上,即整个文本段选上
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range
	sel.collapseToEnd()			//光标跑到 selection 逻辑最后的那个 range 里的最后一个位置,
						//就是 刚刚添加的 div文本节点的文本段的最后一个位置
回车后插入字符窜再定位事件方法2:
	e.preventDefault();	//阻止回车原来事件
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点	
	var endOffset = o.childNodes.length;	//获取 o 节点 的子节点个数,由于只有一段文本,一段文本作为一个子节点,所以是1 
	var range = document.createRange()	//创建一个range
	range.setEnd(o,endOffset)		// range 开始地方 在o节点里的endOffset位置
	range.setStart(o,endOffset)		// range 结束地方 在o节点里的endOffset位置
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range,由于setEnd,setStart 设置同一个地方
						//所以光标处于这个位置中,即 div文本节点的文本段的最后一个位置
中段插入方法1:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode.parentElement  	//得到当前 节点的父节点, 
	//注意 #text的父节点是<div>文本节点, 但是 <div>文本节点 的父节点是 id=editor节点
	//注意 光标在#text时,在 <div></div>中任意字符旁边的位置,
	//注意 光标在<div>文本节点时,在 <div></div>中字符串之前或之后的位置,
	//所以需要做if判断!! 							
	if (El == document.getElementById('editor'))
	{	El.insertAdjacentHTML("beforeEnd",htmlcontent) }
	else
	{	El.insertAdjacentHTML("afterEnd",htmlcontent); 	}
中段插入方法2并定位下一行:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode
	if (El.parentElement != document.getElementById('editor'))
	{	El = El.parentElement }
	El.insertAdjacentHTML("afterEnd",htmlcontent)	//确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
	var endOffset = o.childNodes.length;
	var range = document.createRange()	
	range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
	range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
	sel.removeAllRanges()
	sel.addRange(range)
中段插入自调整行号定位下一行
	e.preventDefault();	//阻止回车原来事件
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		linenum = linenum + 1	
		var htmlcontent = "<div>" + linenum + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent) //确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var El1 = El.nextSibling
	El1 = El1.nextSibling
	for (;El1 != null;)		//自调整行号
	{
	var index = El1.innerText.indexOf(":")	//获取第一个":"字符的位置
	var str = El1.innerText.substring(index)
	linenum = linenum + 1
	El1.innerText = linenum + str	
	El1 = El1.nextSibling
	}
		var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
		var endOffset = o.childNodes.length;
		var range = document.createRange()	
		range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
		range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
		sel.removeAllRanges()
		sel.addRange(range)	//定位下一行
加上行号对齐,字符串调整!!(基本完成回车按键, 有bug)
	//阻止回车原来事件
		e.preventDefault();	
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length	
	//前方行号对齐	
		var Ell = document.getElementById('editor').lastChild	
		var lastline = parseInt(Ell.innerText)+1	//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 	
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		var cnt3 = El.innerText.indexOf(":")
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'	
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}

		str0 = str0 + linenum

		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling  	//擦入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )	//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					console.log("templine:"+ templine +"cnt5:"+ cnt5 + "cnt6:" + cnt6)			
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段的 cnt4 == 0 导致,
					//不是最后一阶段 cnt4 绝不等于 0 ,所以 cnt5 绝对不会出现 -1.	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转 以及 附加的字符串处理: 回车时,把光标后的字符串放到插入行)
		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,会添加上述字符串处理
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		sel.removeAllRanges()
		sel.addRange(range)	//简单光标跳转
		if( (range2 == "nothing to do") || (range2.startContainer == El) ) //range2.startContainer也是一个节点
		{	//console.log("nothing to do")	}
		else
		{
			var chofst = range2.startOffset		//光标未跳转所在的文本段位置偏移	
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	console.log("nothing to do 2")	}
			else
			{
				//console.log(chofst)
				//console.log(range2.startContainer.length)			
				var fenhao = o.innerText.indexOf(":")		//插入行的第一个分号的位置
				var str1 = El.innerText.substring(chofst)	//未跳转前光标位置后的字符串
				//console.log(range2)
				//console.log(str1)
				o.innerText = o.innerText + str1		//未跳转前光标位置后的字符串添加到擦插入行
				El.innerText = El.innerText.substr(0,chofst)	//原来位置上的删掉
			
			//以下表演如何把光标重新定位到 #text 文本指定位值
				var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
										//o节点的 子节点是我们寻寻觅觅的 #text 节点
				var range1 = document.createRange()
				range1.selectNodeContents(oo) //把 oo 节点里的所有内容都选上
				range1.setEnd(oo,fenhao+1)	// range1 开始地方 #text 分号后的位置
				range1.setStart(oo,fenhao+1)	// range1 结束地方 #text 分号后的位置
				sel.removeAllRanges()
				sel.addRange(range1)		//光标跳转到插入行的分号后位置
								//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
								//所以浏览器知道我们所指向的是哪个 #text节点
			}
		
		}
回车跳转行号对齐字符窜调整,(解除上述bug)
	//阻止回车原来事件
		e.preventDefault();	//阻止回车原来事件
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length
	//获取光标后字符串
		var str1 = null
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,获取光标后字符串
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		if( (range2 == "nothing to do") || (range2.startContainer == El) )  //判断range在#text节点里,还是<div>节点,
		{	//console.log("nothing to do")	
		}
		else						//range在#text节点里的时候,才继续
		{
			var chofst = range2.startOffset
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	//console.log("nothing to do 2")	
			}
			else
			{
				str1 = El.innerText.substring(chofst)
			}
		
		}	

	//前方行号对齐
		var Ell = document.getElementById('editor').lastChild
		var lastline = parseInt(Ell.innerText)+1		//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 
		var cnt3 = El.innerText.indexOf(":")
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}
		str0 = str0 + linenum
		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling		//插入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转	

		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方 
		//光标简单跳转
		sel.removeAllRanges()	
		sel.addRange(range)	
		//如果 回车后有字符串, 则重新光标跳转
		if( str1 != null )
		{
			
			var fenhao = o.innerText.indexOf(":")
			o.innerText = o.innerText + str1		//str1 放到插入行
			El.innerText = El.innerText.substr(0,chofst)  	//原来位置上的删掉
				
			var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
									//o节点的 子节点是我们寻寻觅觅的 #text 节点
			var range1 = document.createRange()
			range1.selectNodeContents(oo) //把节点里的所有内容都选上
			range1.setEnd(oo,fenhao+1)	// range 开始地方 #text 分号后的位置
			range1.setStart(oo,fenhao+1)	// range 结束地方 #text 分号后的位置
			sel.removeAllRanges()
			sel.addRange(range1)		//光标跳转到插入行的分号后位置
							//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
							//所以浏览器知道我们所指向的是哪个 #text节点
		}
TAB基本实现缩进	(但是 未处理缩进显示问题)
	//阻止tab原来事件
		e.preventDefault()
	//实现
		var sel = getSelection()
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))	//在selection在 #text 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer.parentNode
         		console.log(range)
			var str = patN.innerText.substr(0,range.startOffset)
			var str1 = patN.innerText.substring(range.startOffset)
			var offset = str.length +1
			patN.innerText = str + "\t" + str1
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])	//patN.childNodes[0] 指修改后的 #text
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)		
		}
		else if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))	//在selection在 <div> 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer	
			var str = patN.innerText
			var offset = str.length +1
			patN.innerText = str + "\t"
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)
		}	
退格按键 有bug 未实现 缩行操作
	var sel = getSelection()
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer.parentNode
		if( (patN.innerText.indexOf(":"))+1 ==  range.startOffset )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)			
		}
	}
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer
		if( (patN.innerText.indexOf(":"))+1 ==  patN.innerText.length )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)
			
		}
	}
退格键,基本完成
	//初始化
		var sel = getSelection()
		var range
		var Nod
		var preN = null
		var range1
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer.parentNode
			if( (Nod.innerText.indexOf(":"))+1 ==  range.startOffset )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer
			if( (Nod.innerText.indexOf(":"))+1 ==  Nod.innerText.length )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if(!preN)	//如果 检测到退到第 1 行,则退无可退
		{	return 1		}
		else
		{	var creN = preN 	}
		var LaN = document.getElementById('editor').lastChild
		var lastline_bf = parseInt(LaN.innerText)
		var lastline_af = parseInt(LaN.innerText) - 1
	//前行号对齐
		if (lastline_bf.toString().length - lastline_af.toString().length ) //行号位数少1
		{
			var cnt = parseInt(Nod.innerText) - 1 
			for(;cnt;)
			{
				preN.innerText = preN.innerText.substr(1,preN.innerText.length)
				preN = preN.previousSibling
				cnt--
			}
		}
	//后行号对齐 不管 行号位数是否少1		
		var NexN = Nod.nextSibling
		if (NexN != null)
		{	var linenum = parseInt(NexN.innerText) - 2 }	//复用 回车片段对应修改
		var lastline = parseInt(LaN.innerText) - 1
		var cnt5 = 0
		var index
		var str
		var num0 = null
		var num = null
		for (;NexN != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = NexN.innerText.indexOf(":")
			str = NexN.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			NexN.innerText = num + str
			NexN = NexN.nextSibling
		}	
	//缩行
		Nod.remove()
	//跳转
		range1 = document.createRange() 
		range1.selectNodeContents(creN)
		range1.collapse(false)
		sel.removeAllRanges()
		sel.addRange(range1)
方向左键
if (x == 37 ) //方向左键
	{
		var sel = getSelection()
         		console.log(sel)
		if ( (sel.anchorNode.nodeType == 3) && (sel.anchorNode.parentNode.innerText.indexOf(':') + 1 == sel.anchorOffset ) )
		{	e.preventDefault()	}
		if ( (sel.anchorNode.nodeType == 1) && (sel.anchorNode.innerText.indexOf(':') + 1 == sel.anchorNode.innerText.length ))
		{	e.preventDefault()	}
	}
以上代码片段 仅仅基于 纯文本记录下的操作



html 转义字符: ISO Latin-1字符集: 
&#09; — 制表符Horizontal tab 			&#10; — 换行Line feed 			&#13; — 回车Carriage Return 
&#32; / &nbsp; — Space 				! &#33; — 惊叹号Exclamation mark 	” &#34; &quot; 双引号Quotation mark 
# &#35; — 数字标志Number sign 			$ &#36; — 美元标志Dollar sign 		% &#37; — 百分号Percent sign 
& &#38; &amp; Ampersand 			‘ &#39; — 单引号Apostrophe 		( &#40; — 小括号左边部分Left parenthesis 
) &#41; — 小括号右边部分Right parenthesis 	* &#42; — 星号Asterisk 			+ &#43; — 加号Plus sign 
, &#44; — 逗号Comma 				- &#45; — 连字号Hyphen 			. &#46; — 句号Period (fullstop) 
/ &#47; — 斜杠Solidus (slash) 			0 &#48; — 数字0 Digit 0 		1 &#49; — 数字1 Digit 1
2 &#50; — 数字2 Digit 2 			3 &#51; — 数字3 Digit 3 		4 &#52; — 数字4 Digit 4 
5 &#53; — 数字5 Digit 5 			6 &#54; — 数字6 Digit 6 		7 &#55; — 数字7 Digit 7 
8 &#56; — 数字8 Digit 8 			9 &#57; — 数字9 Digit 9 		: &#58; — 冒号Colon 
; &#59; — 分号Semicolon 			< &#60; &lt; 小于号Less than 		= &#61; — 等于符号Equals sign 
> &#62; &gt; 大于号Greater than 		? &#63; — 问号Question mark 		@ &#64; — Commercial at 
A &#65; — 大写A Capital A 			B &#66; — 大写B Capital B 		C &#67; — 大写C Capital C 
D &#68; — 大写D Capital D 			E &#69; — 大写E Capital E 		F &#70; — 大写F Capital F 
G &#71; — 大写G Capital G 			H &#72; — 大写H Capital H 		I &#73; — 大写J Capital I 
J &#74; — 大写K Capital J 			K &#75; — 大写L Capital K 		L &#76; — 大写K Capital L 
M &#77; — 大写M Capital M 			N &#78; — 大写N Capital N 		O &#79; — 大写O Capital O 
P &#80; — 大写P Capital P 			Q &#81; — 大写Q Capital Q 		R &#82; — 大写R Capital R 
S &#83; — 大写S Capital S 			T &#84; — 大写T Capital T 		U &#85; — 大写U Capital U 
V &#86; — 大写V Capital V 			W &#87; — 大写W Capital W 		X &#88; — 大写X Capital X 
Y &#89; — 大写Y Capital Y 			Z &#90; — 大写Z Capital Z 
[ &#91; --- 中括号左边部分Left square bracket 	\ &#92; --- 反斜杠Reverse solidus (backslash) 
] &#93; — 中括号右边部分Right square bracket 	^ &#94; — Caret 			_ &#95; — 下划线Horizontal bar (underscore) 
` &#96; — 尖重音符Acute accent 			a &#97; — 小写a Small a 
b &#98; — 小写b Small b 			c &#99; — 小写c Small c 		d &#100; — 小写d Small d 
e &#101; — 小写e Small e 			f &#102; — 小写f Small f 		g &#103; — 小写g Small g 
h &#104; — 小写h Small h 			i &#105; — 小写i Small i 		j &#106; — 小写j Small j 
k &#107; — 小写k Small k 			l &#108; — 小写l Small l 		m &#109; — 小写m Small m 
n &#110; — 小写n Small n 			o &#111; — 小写o Small o 		p &#112; — 小写p Small p 
q &#113; — 小写q Small q 			r &#114; — 小写r Small r 		s &#115; — 小写s Small s 
t &#116; — 小写t Small t 			u &#117; — 小写u Small u 		v &#118; — 小写v Small v 
w &#119; — 小写w Small w 			x &#120; — 小写x Small x 		y &#121; — 小写y Small y 
z &#122; — 小写z Small z 			{ &#123; — 大括号左边部分Left curly brace 
| &#124; — 竖线Vertical bar 			} &#125; — 大括号右边部分Right curly brace 
~ &#126; — Tilde 				— &#127; — 未使用Unused 		&#160; &nbsp; 空格Nonbreaking space 
? &#161; &iexcl; Inverted exclamation 		￠ &#162; &cent; 货币分标志Cent sign 	￡ &#163; &pound; 英镑标志Pound sterling 
¤ &#164; &curren; 通用货币标志General currency sign 
￥ &#165; &yen; 日元标志Yen sign 		| &#166; &brvbar; or &brkbar; 断竖线Broken vertical bar 
§ &#167; &sect; 分节号Section sign 		¨ &#168; &uml; or &die; 变音符号Umlaut 
? &#169; &copy; 版权标志Copyright 		a &#170; &ordf; Feminine ordinal 
? &#171; &laquo; Left angle quote, guillemet left 
? &#172; &not Not sign 				? &#173; &shy; Soft hyphen 		? &#174; &reg; 注册商标标志Registered trademark 
ˉ &#175; &macr; or &hibar; 长音符号Macron accent ° &#176; &deg; 度数标志Degree sign 
± &#177; &plusmn; 加或减Plus or minus 		2 &#178; &sup2; 上标2 Superscrīpt two 	3 &#179; &sup3; 上标3 Superscrīpt three 
′ &#180; &acute; 尖重音符Acute accent 		μ &#181; &micro; Micro sign 		? &#182; &para; Paragraph sign 
? &#183; &middot; Middle dot 			? &#184; &cedil; Cedilla 		1 &#185; &sup1; 上标1 Superscrīpt one 
o &#186; &ordm; Masculine ordinal 		? &#187; &raquo; Right angle quote, guillemet right 
? &#188; &frac14; 四分之一Fraction one-fourth 	? &#189; &frac12; 二分之一Fraction one-half 
? &#190; &frac34; 四分之三Fraction three-fourths ? &#191; &iquest; Inverted question mark 
à &#192; &Agrave; Capital A, grave accent 	á &#193; &Aacute; Capital A, acute accent 
? &#194; &Acirc; Capital A, circumflex 		? &#195; &Atilde; Capital A, tilde 	? &#196; &Auml; Capital A, di?esis / umlaut 
? &#197; &Aring; Capital A, ring 		? &#198; &AElig; Capital AE ligature 	? &#199; &Ccedil; Capital C, cedilla 
è &#200; &Egrave; Capital E, grave accent 	é &#201; &Eacute; Capital E, acute accent 
ê &#202; &Ecirc; Capital E, circumflex 		? &#203; &Euml; Capital E, di?esis / umlaut 
ì &#204; &Igrave; Capital I, grave accent 	í &#205; &Iacute; Capital I, acute accent 
? &#206; &Icirc; Capital I, circumflex 		? &#207; &Iuml; Capital I, di?esis / umlaut 
D &#208; &ETH; Capital Eth, Icelandic 		? &#209; &Ntilde; Capital N, tilde 	ò &#210; &Ograve; Capital O, grave accent 
ó &#211; &Oacute; Capital O, acute accent 	? &#212; &Ocirc; Capital O, circumflex 	? &#213; &Otilde; Capital O, tilde 
? &#214; &Ouml; Capital O, di?esis / umlaut 	× &#215; &times; 乘号Multiply sign 	? &#216; &Oslash; Capital O, slash 
ù &#217; &Ugrave; Capital U, grave accent 	ú &#218; &Uacute; Capital U, acute accent 
? &#219; &Ucirc; Capital U, circumflex 		ü &#220; &Uuml; Capital U, di?esis / umlaut 
Y &#221; &Yacute; Capital Y, acute accent 	T &#222; &THORN; Capital Thorn, Icelandic 
? &#223; &szlig; Small sharp s, German sz 	à &#224; &agrave; Small a, grave accent 
á &#225; &aacute; Small a, acute accent 	a &#226; &acirc; Small a, circumflex 
? &#227; &atilde; Small a, tilde 		? &#228; &auml; Small a, di?esis / umlaut 
? &#229; &aring; Small a, ring 			? &#230; &aelig; Small ae ligature 
? &#231; &ccedil; Small c, cedilla 		è &#232; &egrave; Small e, grave accent 
é &#233; &eacute; Small e, acute accent 	ê &#234; &ecirc; Small e, circumflex 
? &#235; &euml; Small e, di?esis / umlaut 	ì &#236; &igrave; Small i, grave accent 
í &#237; &iacute; Small i, acute accent 	? &#238; &icirc; Small i, circumflex 
? &#239; &iuml; Small i, di?esis / umlaut 	e &#240; &eth; Small eth, Icelandic 
? &#241; &ntilde; Small n, tilde 		ò &#242; &ograve; Small o, grave accent 
ó &#243; &oacute; Small o, acute accent 	? &#244; &ocirc; Small o, circumflex 
? &#245; &otilde; Small o, tilde 		? &#246; &ouml; Small o, di?esis / umlaut 
÷ &#247; &divide; 除号Division sign 		? &#248; &oslash; Small o, slash 
ù &#249; &ugrave; Small u, grave accent 	ú &#250; &uacute; Small u, acute accent 
? &#251; &ucirc; Small u, circumflex 		ü &#252; &uuml; Small u, di?esis / umlaut 
y &#253; &yacute; Small y, acute accent 	t &#254; &thorn; Small thorn, Icelandic 
? &#255; &yuml; Small y, umlaut 		symbols, mathematical symbols, and Greek letters 
? &fnof; 	Α &Alpha; 	Β &Beta; 	Γ &Gamma; 	Δ &Delta; 	Ε &Epsilon; 	Ζ &Zeta; 	Η &Eta; 
Θ &Theta; 	Ι &Iota; 	Κ &Kappa; 	Λ &Lambda; 	Μ &Mu; 		Ν &Nu; 		Ξ &Xi; 		Ο &Omicron; 
Π &Pi; 		Ρ &Rho; 	Σ &Sigma; 	Τ &Tau; 	Υ &Upsilon; 	Φ &Phi; 	Χ &Chi; 	Ψ &Psi; 
Ω &Omega; 	α &alpha; 	β &beta; 	γ &gamma; 	δ &delta; 	ε &epsilon; 	ζ &zeta; 	η &eta; 
θ &theta; 	ι &iota; 	κ &kappa; 	λ &lambda; 	μ &mu; 		ν &nu; 		ξ &xi; 		ο &omicron; 
π &pi; 		ρ &rho; 	? &sigmaf; 	σ &sigma; 	τ &tau; 	υ &upsilon; 	φ &phi; 	χ &chi; 
ψ &psi; 	ω &omega; 	? &thetasym; 	? &upsih; 	? &piv; 	? &bull; 	… &hellip; 	′ &prime; 
″ &Prime; 	￣ &oline; 	? &frasl; 	? &weierp; 	? &image; 	? &real; 	? &trade; 	? &alefsym; 	
← &larr; 	↑ &uarr; 	→ &rarr; 	↓ &darr; 	? &harr; 	? &crarr; 	? &lArr; 	? &uArr; 
? &rArr; 	? &dArr; 	? &hArr; 	? &forall; 	? &part; 	?&exist; 	?&empty; 	? &nabla; 
∈ &isin; 	? &notin; 	? &ni; 		∏ &prod; 	∑ &sum; 	? &minus; 	?&lowast; 	√ &radic; 
∝ &prop; 	∞ &infin; 	∠ &ang; 	∧ &and; 	∨ &or; 	∩ &cap; 	∪ &cup; 	∫ &int; 
∴ &there4; 	～ &sim; 	? &cong; 	≈ &asymp; 	≠ &ne; 		≡ &equiv; 	≤ &le; 		≥ &ge; 
? &sub; 	? &sup; 	? &nsub; 	?&sube; 	? &supe; 	⊕ &oplus; 	? &otimes; 	⊥ &perp; 
? &sdot; 	?&lceil; 	? &rceil; 	? &lfloor; 	?&rfloor; 	? &lang; 	? &rang; 	? &loz; 
? &spades; 	? &clubs; 	? &hearts; 	? &diams; 
markup-significant and internationalization characters: 
“ &quot; 	& &amp; 	< &lt; 		> &gt; 		? &OElig; 	? &oelig; 	? &Scaron; 	? &scaron; 
? &Yuml; 	? &circ; 	? &tilde; 	&ensp; 		&emsp; 		&thinsp; 	? &zwnj; 	? &zwj; 	
? &lrm; 	?&rlm; 		– &ndash; 	— &mdash; 	‘ &lsquo; 	’ &rsquo; 	? &sbquo; 	“ &ldquo; 
” &rdquo; 	? &bdquo; 	?&dagger; 	? &Dagger; 	‰ &permil; 	? &lsaquo; 	? &rsaquo; 	€ &euro; 



浮窗代码片段:
新闻弹窗: https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  //新闻弹窗
	<head>
	<meta charset="utf-8">
	<title>jquery漂浮广告代码</title>
	<script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	<style>
	</style>
	</head>
	<body>
	<div id="imgDiv" style="position:absolute;left:50px;top:60px;">
	    <div id="a" style="width:20px;height:20px;position:absolute;left:160px;background:salmon;text-align: center;">×</div>
	    <!-- <img src="01.jpg" border="0" /> -->
	    <div style="width:180px;height:180px;background:red;"></div>
	</div>
	 
	<script>
	var xin = true,
	    yin = true;
	var step = 1;
	var delay = 10;
	var $obj;
	$(function() {
	    $obj = $("#imgDiv");
	    var time = window.setInterval("move()", delay);
	    $obj.mouseover(function() {
	        clearInterval(time)
	    });
	    $obj.mouseout(function() {
	        time = window.setInterval("move()", delay)
	    });
	});
	 
	function move() {
	    var left = $obj.offset().left;
	    var top = $obj.offset().top;
	    var L = T = 0; //左边界和顶部边界
	    var R = $(window).width() - $obj.width(); // 右边界
	    var B = $(window).height() - $obj.height(); //下边界
	 
	    //难点:怎样判断广告的4个边框有没有超出可视化范围!
	    if (left < L) {
	        xin = true; // 水平向右移动
	    }
	    if (left > R) {
	        xin = false;
	    }
	    if (top < T) {
	        yin = true;
	    }
	    if (top > B) {
	        yin = false;
	    }
	    //根据有没有超出范围来确定广告的移动方向
	    left += step * (xin == true ? 1 : -1);
	    top  += step * (yin == true ? 1 : -1);
	    // 给div 元素重新定位
	    $obj.offset({
	        top: top,
	        left: left
	    })
	}
	    //关闭
	$(function() {
	    $("#a").click(function() {
	        var b = $("#a").parent();
	        $(b).remove();
	    })
	})
	</script>
	</body>
浮窗广告: https://blog.csdn.net/Jensen_Yao/article/details/64926666
	<style type=text/css>
	  div#roll {
		width: 100px; color: #fff; position: absolute; height: 100px; background-color: #000
	}
	</style>
	<body>
	<H2>JS全屏漂浮广告，移入光标停止移动</H2>
	<div id="roll">我是广告</div>
	<script type=text/javascript>
	  var ggRoll = {
	    roll: document.getElementById("roll"),
	    speed: 20,
	    statusX: 1,
	    statusY: 1,
	    x: 100,
	    y: 300,
	    winW: document.documentElement.clientWidth - document.getElementById("roll").offsetWidth,
	    winH: document.documentElement.clientHeight - document.getElementById("roll").offsetHeight,
	    Go: function () {
	       this.roll.style.left = this.x + 'px';
	       this.roll.style.top = this.y + 'px';
	 
	       this.x = this.x + (this.statusX ? -1 : 1)
	       if (this.x < 0) { this.statusX = 0 }
	       if (this.x > this.winW) { this.statusX = 1 }
	 
	       this.y = this.y + (this.statusY ? -1 : 1)
	       if (this.y < 0) { this.statusY = 0 }
	       if (this.y > this.winH) { this.statusY = 1 }
	 
	     }
	  };
	    var interval = setInterval("ggRoll.Go()", ggRoll.speed);
	    ggRoll.roll.onmouseover = function () { clearInterval(interval) };
	    ggRoll.roll.onmouseout = function () { interval = setInterval("ggRoll.Go()", ggRoll.speed) };
	</script>
	</body>	
固定浮窗: https://www.jb51.net/article/65211.htm
	<style>
	* { font-size:12px; font-family:Verdana,宋体; }
	html, body { margin:0px; padding:0px; overflow:hidden; }
	.b { margin:0px; padding:0px; overflow:auto; }
	.line0 { line-height:20px; background-color:lightyellow;
	padding:0px 15px; }
	.line1 { line-height:18px; background-color:lightblue;
	padding:0px 10px; }
	.w { position:absolute; right:10px; bottom:10px; width:160px; 
	height:240px; overflow:hidden; border:2px groove #281;
	cursor:default; -moz-user-select:none; }
	.t { line-height:20px; height:20px; width:160px;
	overflow:hidden; background-color:#27C; color:white;
	font-weight:bold; border-bottom:1px outset blue;
	text-align:center; }
	.winBody { height:218px; width:160px; overflow-x:hidden;
	overflow-y:auto; border-top:1px inset blue;
	padding:10px; text-indent:10px; background-color:white;
	}
	</style>
	</head>
	<body>
	<div class="w">
	<div class="t">Demo Win - Fixed</div>
	<div class="winBody">Hello world</div>
	<div>//www.jb51.net/</div>
	</div>
	</body>
	<script>
	//测试用，随机产生一定的内容
	for(var i=0; i<400; i++)document.write("<div class=\"line"+(i%2)+"\">"+(new Array(20)).join((Math.random()*1000000).toString(36)+" ")+"<\/div>");
	//代码如下：
	new function(w,b,c,d,o){
	d=document;b=d.body;o=b.childNodes;c="className";
	b.appendChild(w=d.createElement("div"))[c]= "b";
	for(var i=0; i<o.length-1; i++)if(o[i][c]!="w")w.appendChild(o[i]),i--;
	(window.onresize = function(){
	w.style.width = d.documentElement.clientWidth + "px";
	w.style.height = d.documentElement.clientHeight + "px";
	})();
	}
	</script>		
			
固定<div>: https://blog.csdn.net/qq_26817251/article/details/53648685		
	div id="dg" style="z-index: 9999; position: fixed ! important; right: 0px; top: 0px;">
	<table width=""100% style="position: absolute; width:260px; right: 0px; top: 0px;">
	//table 内部控件代码
	</table>
	</div>	
	div position参数设置为fixed 其相对于浏览器为绝对位置，通过设置right和top将div固定在右上角。
	table position参数设置为absolute,其相对于第一层div绝对定位，通过设置right和top将table固定在div容器的右上角。
		
弹出表单表框层: https://blog.csdn.net/Seety_ST/article/details/49020047
	<style>
	/*灰色遮罩层*/
	.fade{
	    width:100%;
	    height:100%;
	    background:rgba(0, 0, 0, 0.5);
	    position: fixed;
	    left: 0;
	    top: 0;
	    z-index: 99;
	}
	/*弹出层*/ 
	.succ-pop{
	    width: 400px;
	    height: 300px;
	    background: #fff;
	    position: fixed;
	    left: 50%;
	    top: 50%;
	    margin-left: -200px;
	    margin-top: -150px;
	    z-index: 999;
	    border-radius: 5px;
	}   
	.succ-pop h3.title{
	    text-align: center;
	    font-size: 22px;
	    color: #ce002c;
	}
	</style>
	<div class="succ-pop">
	    <h3 class="title">
	        中间填写内容
	    </h3>
		<textarea>options space=20 player=true  tempo=80
		</textarea>
	</div>
	<div class="fade"></div>
通用思路上传文件:
	前端:
		<form enctype="multipart/form-data" action="/uploadFile/" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
	后端:
	views.py
		def upload_file(request):
		    if request.method == "POST":    # 请求方法为POST时，进行处理
		        myFile =request.FILES.get("myfile", None)    # 获取上传的文件，如果没有文件，则默认为None
		        if not myFile:
		            returnHttpResponse("no files for upload!")
		        destination = open(os.path.join("./",myFile.name),'wb+')    # 打开特定的文件进行二进制的写操作
		        for chunk in myFile.chunks():      # 分块写入文件
		            destination.write(chunk)
		        destination.close()
		        return HttpResponse("upload over!")			
	urls.py
		urlpatterns = [
			...
			    re_path('uploadFile',views.upload_file),
			...
		]
	通过通用的 html 标准 <form> <input> 组成的 上传模组实现上传文件
		enctype="multipart/form-data" 表示上传非文本而是文件	
		action="/uploadFile/" 表示要访问的新网址是 http://127.0.0.1:8000/uploadFile
		method="post" 访问新网址时 申请的操作, 这里上传一段数据
		type="file" 表示这个input 是给这个 <form> 载入一个文件,具体选择文件路径
		name="myfile" 很重要 后端通过这个项 来寻找正确的文件位置 
		type="submit"  表示这个input, 把这个form 打包 并并向服务器提交内容 
			先建立握手访问,然后提交post申请,获许后才开始上传数据流, 
			最后获得反馈页面,浏览器新建http://127.0.0.1:8000/uploadFile页面显示反馈页面
	远程服务器网址:http://127.0.0.1:8000/uploadFile 接受链接后,移交 def upload_file(request): 处理 
		if request.method == "POST":    # 查看请求方法是否为POST时
		myFile =request.FILES.get("myfile", None) # 允许上传内容,并开始上传内容
			"myfile" 对应前端的 name="myfile"
			内容上传完,会存在 myFile,然后才开始后续处理工作
		return HttpResponse("upload over!")	#处理工作完了,最后返回一个反馈页面			
	整个过程使用标准 html 方案,所以前端不需要另外使用 js 辅助或实现
通用思路上传文件, 但是浏览器不跳转新页面
	只需要修改前端代码为:
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
		<iframe name="frame1" frameborder="0" height="40"></iframe>
	思路是 在原网页 添加一个内嵌页面框, 这样访问 http://127.0.0.1:8000/uploadFile 获得的反馈页内容
	会放入这个内嵌页面框里显示,这样做的好处是 原网页可以直接得到反馈页内容执行交互和信息处理工作
	<form> 添加了 target="frame1",	表示得到的反馈页或内容,不另开新页面显示,而是放到 frame1 里去
	<iframe name="frame1" frameborder="0" height="40"></iframe>	
		<iframe>是标记一个内嵌页面框, 反馈页或者内容会放到这里去
通过 ajax 实现 上传文件
	前端:
		<div>
		        <input type="file" name="file" id="file_upload">
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>
		function FileUpload() {
			var form_data = new FormData();
			var file_info =$( '#file_upload')[0].files[0];
			form_data.append('file',file_info);
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        file_obj = request.FILES.get('file')
	        import os
	        f = open(os.path.join("./",file_obj.name), 'wb+')
	        print(file_obj,type(file_obj))
	        for chunk in file_obj.chunks():
	            f.write(chunk)
	        f.close()
	        print('11111')
	        return HttpResponse('OK')
	urlpatterns = [
	...
	    re_path('upload_ajax',views.upload_ajax),
	...
	]	
	这里通过 jquery 的 ajax 的 实现上传文件,上传工作都通过 js 函数实现
	首先新建填充 一个form数据, 把上传的内容都放入
	然后执行 ajax()函数,实现上传工作 其中填入的数据有
		url:'/upload_ajax/',	要访问的网址链接: http://127.0.0.1:8000/upload_ajax
		type:'POST',		请求类型 post	
		data: form_data,	上传数据
		success: function(callback) {	//成功的回调函数
			console.log(callback)
		}
	执行ajax()时, 浏览器通过子进程访问服务器 并提出 post 上传操作
	服务器后端  def upload_ajax(request): 处理访问, request.FILES.get('file') 允许并开始数据上传
	上传结束,数据存在 file_obj 供 def upload_ajax(request): 继续处理,
	最后返回 反馈页内容, 
	反馈内容被还在执行的 ajax()捕捉,然后返回到当前页面处理, 而不是 浏览器另外开一页面显示!!
通过 ajax 实现 上传 多个文件
	前端:
		<div style="display:block;" >
			<!-- 注意多了multiple,这样可以同时选多个文件, name="file" 为每个选择的文件挂上标签file  -->
		        <input type="file" name="file" id="file_upload" multiple >  
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>	
		function FileUpload() {
			var form_data = new FormData();
			//多文件 依次插入 form_data 队列数据     
			for ( var i=0 ;i < $( '#file_upload')[0].files.length; i++)
			{
				var file_info = $( '#file_upload')[0].files[i];
				form_data.append('file',file_info);
			}
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	# 多文件接收
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        files = request.FILES.getlist('file')	# 使用 getlist, 挖出标签 file 的 form_data 成员
	        print(files,type(files))
	        for f in files:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            dest = open(os.path.join("./",f.name),'wb+')
	            for chunk in f.chunks():
	                dest.write(chunk)
	            dest.close()
	        print('11111')
	        return HttpResponse("ok")	
通用思路上传 多个文件
	前端
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
			<!-- 注意多了multiple,这样可以同时选多个文件, name="myfile" 为每个选择的文件挂上标签myfile  -->		
			<input type="file" name="myfile" multiple />
			<input type="submit" value="upload"/>
		</form>
	后端
	views.py
	# 多文件
	def upload_file(request):
	    if request.method == "POST":    # 请求方法为POST时，进行处理
	        myFiles =request.FILES.getlist("myfile", None)    # 使用 getlist, 挖出标签 myfile 的 form_data 成员
	        if not myFiles:
	            return HttpResponse("no files for upload!")
	        for f in myFiles:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            destination = open(os.path.join("./",f.name),'wb+')    # 打开特定的文件进行二进制的写操作
	            for chunk in f.chunks():
	                destination.write(chunk)
	            destination.close()
	        return HttpResponse("upload over!")






	
	
20180824
坑:
	发现,如果 selection, range 所指的 #text文本 被修改了,机制是原来的#text段落会被新的替换,
	所对应的 selection range 指向了 null ,指向#text文本 的节点指针也会指向null
	null + '0' 不等于字符串"0"
	多个空格只显示一个空格,多个tab只显示一个空格的问题!! css 添加 white-space:pre; 处理
	text-indent:2em  css的首行缩进
 	letter-spacing:2px;	css 字符之间间距
	nodeType == 1 //<div>
	nodeType == 3 //<#text>
	图片要居中, 同一div 使用 text-align: center;css属性 然后<img>里  margin: 0 auto; css属性
	可以令 子 div 并排显示 justify-content: center; display:flex;
	<p>和<div>的间距有区别,p 和 div 都是块元素, p和div作为同级元素的情况下会换行显示,但是行距有区别!!
	<img>间距 用 hspace="50"
	<div> 的间距用{margin:top right bottom left }
		如：{margin:10px 20px 30px 40px}表示该元素与上面的元素相距10px，
		与右边的元素相距20px，与下面的元素相距30px，与左边的元素相距40px;
		使用该属性的时候要注意当上面元素的margin-bottom:10px;下面元素margin-top:10px;那么他们的间距将会合并，
			即他们之间的间距变为10px;	
		如果这两个值不一样，那么浏览器将会取较大值。
		但是如果其中有一个元素设置position为absolute时，间距将不会合并。
		使用该属性时一定要注意与它相关的元素的属性，注意观察他们的position和float属性。
		注意使用的时候 是在 子div里使用,不可在父div里使用让子div继承!!
	<audio>起码要这样子标记: <audio src="/static/music/yuxuanji.mp3" controls autoplay="true"></audio>
		不然无法显示
	网页获取 例如:wget -p -np -k -r https://www.52cmajor.com/tab/editor
		wget https://static.52cmajor.com/static/vextab/ -r -c -np -nH --cut-dirs 2 --restrict-file-names=nocontrol
wget -c -r -np -k -L -p -A '*.js*' https://static.52cmajor.com/static/vextab/
	html显示空格:
		连续的空格一般只显示一个
		white-space:pre; 后才显示多个
	现在是制表符号的显示!!!


五线谱: https://www.52cmajor.com/tab/editor 
	https://my.oschina.net/daxia/blog/1590124
	直接下载整个网页分析 wget -p -np -k -r https://www.52cmajor.com/tab/editor 然后点击网页,
	居然发现功能完好!! 而且还有回播功能,可以移植使用
	这三个直接添加了监听处理,而不需要自己主动在<div>标签上设置监听
        	vexTabEditor.keyup(_.throttle(parseAndRender, 250));
   		vexTabEditor.resize(_.throttle(parseAndRender, 250));
   		$(window).resize(_.throttle(parseAndRender, 250));
	使用 vextab相当奇葩, 最稳妥复用几个 div 把 canvas 包涵进去,不然 background 错亂
	还有,使用 vextab 自带 player 时其实是两个canvas重合的,所以 css.position 应当 relative
	值得wget下来参考的网址: 
		https://www.52cmajor.com/doc?doc=vextab
		http://www.vexflow.com/vextab/tutorial.html

数学公式: http://www.html580.com/11952/demo   JMeditor
	显示使用了 	<link rel="stylesheet" href="/static/css/mathquill.css">

js 数组的大坑
	例如:  var vexTabEditor = $('.vex-tab-editor');
	使用了 jquery 的语法 吧 class="vex-tab-editor" 成员都给 vexTabEditor 变量
	vexTabEditor 应该是 一个数组, vexTabEditor[i] 是每一个数组成员的表述
	但是 这里得到的数组成员没有函数, 只有数组有函数方法:
	vexTabEditor.val() 是可执行的,  vexTabEditor[i].val(),却并不存在
	数组有函数方法 一般只是围绕第一个成员.
	比如 vexTabEditor.val() 得到的是 vexTabEditor[i].value 的值
	但是 数组成员是可以有函数方法的!!
	例如 	var artist = new Array()  创建一个新数组
	artist[i] = new Artist(10, 10, 1000, {scale: 0.8});   数组成员被赋予内容
        artist[j].render(renderer[j]); 	数组成员是可以有函数方法的				
浮窗
	https://blog.csdn.net/yongbosong/article/details/4210693	//移动浮窗
	https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  	//新闻弹窗
	重点参数说明 <div style="z-index:100; position:fixed; width:320px; height:320px; background:#aaa; right: 0px; top: 0px">
	z-index 所在显示的层数,高层数遮盖低层数
	position:fixed; 位置方式, 以当前屏幕窗口为准		
	width:320px; height:320px; <div>等控件大小
	right: 0px; top: 0px 具体位置!!
	弹出表单表框层 学会了如何 遮罩的问题!!
	如果在窗口上摆按钮 那么按钮的 位置方式是position:relative: 是相对窗口的摆放 !!
		<div style="float:left; width:160px; height:auto;"></div>
		<div style="float:left; position:relative; width:30px; height:30px; margin-left:-30px"></div>
		设置position:relative;下方的div是相对于上方的div摆放的,float:left 表示 div是 从左到右放
		position:relative; 配对的位置方法是 margin-left
		margin-left:-30px 是根据 relative得到的位置后,往左退30px 

基本DOM 操作:
	更改CSS ,http://www.w3school.com.cn/js/js_htmldom_css.asp
		document.getElementById("p2").style.color="blue";
		注意,一定要字符串,即使是数字 例如
		document.getElementById("p2").style.xxx="233";
		var Y = (233).toString() + "px"
		document.getElementById("p2").style.xxx= Y  ;		
	更改Id
		 $('你的元素').arrt（‘id’,你要的新id）； 
		var obj = document.getElementById("aa");//获取原来的id = aa的div 
		obj.setAttribute("id","bb"); 
	js 的 event 操作:
		onmousedown="contentbar(event)"	这里一定要填写 event 才能传递 event 内容
		function contentbar(e){...}	这里 可以简单用 e 来获得传递过来的event内容
		e.currentTarget.	//重要 因为	getSelection().anchorNode 里都不能很好得到触发事件的 元素!!
	js鼠标样式: 
		<span style="cursor:auto">Auto</span><br />
		<span style="cursor:crosshair">Crosshair</span><br />
		<span style="cursor:default">Default</span><br />
		<span style="cursor:pointer">Pointer</span><br />
		<span style="cursor:move">Move</span><br />
		<span style="cursor:e-resize">e-resize</span><br />
		<span style="cursor:ne-resize">ne-resize</span><br />
		<span style="cursor:nw-resize">nw-resize</span><br />
		<span style="cursor:n-resize">n-resize</span><br />
		<span style="cursor:se-resize">se-resize</span><br />
		<span style="cursor:sw-resize">sw-resize</span><br />
		<span style="cursor:s-resize">s-resize</span><br />
		<span style="cursor:w-resize">w-resize</span><br />
		<span style="cursor:text">text</span><br />
		<span style="cursor:wait">wait</span><br />
		<span style="cursor:help">help</span>
上传预览:
	https://blog.csdn.net/x550392236/article/details/76690927
django 上传到服务器:	
	https://blog.csdn.net/jiangpf1992/article/details/49406879
django 上传到服务器又不跳转页面: 使用 <iframe>
	https://blog.csdn.net/ling926/article/details/72888831
django + jquery(重写的ajax) + 上传文件服务器 重点
	https://www.cnblogs.com/liaojiafa/p/6231382.html
	https://www.cnblogs.com/jishuweiwang/p/6140132.html
	https://www.cnblogs.com/liyqiang/articles/7858523.html  //成功实现,所以从这参考
	上传文件的主要思路 主要是 直接 打包好一段数据 ,然后给某个网址(例如http://127.0.0.1:8000/upload_file 传过去
		相当于访问网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		如果 服务器后端接受 post 请求 , 远程机就可以 把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个页面 表示上传成功, 远程机另开一个页面 显示 访问 网址 http://127.0.0.1:8000/upload_file 得到的页面
	使用 ajax 上传文件的意义在于 此刻 远程机浏览器显示的页面是 http://127.0.0.1:8000/test1 
		浏览器辟出一个子进程访问 网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		服务器后端接受 post 请求 , 远程机把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个成功页面 表示上传成功, 
		但是 远程机并不会显示这个页面,远程机仍然显示着 http://127.0.0.1:8000/test1 的页面
		返回的成功页面会 转为附加内容 会添加到现在显示的 http://127.0.0.1:8000/test1 的页面中去
以上都是一次上传单个文件的
一次上传多个文件:
	首先 前端: <input type="file" name="file" id="file_upload" multiple >	添加  multiple 可以选多个
	 js 和 后端 都有对应修改,详细看片段
	不论是通用的 还是 ajax 都是建立一个 form 数据队列,然后把独立数据(独立文件),作为一个个成员放入,最后上传
	就是这样完成 文件,数据,多文件,多数据 上传的
	
(django1.10)访问url报错Forbidden (CSRF cookie not set.): xxx
	修改settings.py文件，注释掉
	django.middleware.csrf.CsrfViewMiddleware',

CSS优先级:
	行间>id>class>标签>通配符
		即 stytle="" > #AAA > .BBB >  CCC > * 
	优先级相同,谁后谁优先；优先级不同，优先级高的优先  
	优先级是一种累加的关系，加起来的值越大优先级就越高
		例如  #div3 .dd{...}  这个的优先级是 #div3 和 .dd 累加的优先级
	群组选择器的优先级取决于位置，谁靠后谁的优先级就高，会把前面的样式给覆盖了
		例如以下 必然是 green 
	            div,p,h1{
	                background: red;
	                margin-top: 50px;
	            }
	            div{
	                background: green;
	            }
css推荐模块化,集中化写法:例如
	<div class="uppic">
		<div class="Win" style="">
			<h3 class="title" style="">上传图片</h3>
			<div class="image" style="">
				<img src="/static/img/eye_expression.gif" alt="pleace select a picture " ></img>
			</div>
			<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
				<input type="file" name="myfile" multiple />
				<input type="submit" value="upload"/>
			</form>
			<!-- not use -->
			<iframe name="frame1" frameborder="0" height="40" style="display:none;"></iframe>
	
			<div style="display:block;" >
			        <input type="file" name="file" id="file_upload" multiple >
			        <input type="button" value="上传" onclick="FileUpload()">
			</div>
	
		</div>
		<div class="closeW" onmousedown="closeWin(event)"  style=" "></div>
	</div>
	xx.css:
	.uppic{ display:block; width:80%; height:80%; background:#fff; position: fixed; left: 10%; top: 10%;
		margin-left: 0px; margin-top: 0px; z-index: 999; border-radius: 5px; }   
	.uppic div.Win{ float:left; width:100%; height:100%; background:#dddddd; text-align: center;}
	.uppic div.Win div.image{ width:80%;height:70%;overflow:scroll; margin:0 auto; background:#ddddee; text-align: center; }
	.uppic div.Win h3.title{ text-align: center; font-size: 22px; color: #ce002c; }
	.uppic div.closeW{ float:left; position:relative; background:#cc00cc; width:30px; height:30px; margin-left:-30px;  }
CSS class 与 ID 区别:
	id 是 一对一的 ,  class是 一对多的 
	目前的浏览器还都允许用多个相同ID，一般情况下也能正常显示，不过当你需要用JavaScript通过id来控制div时就会出现错误。	


<ing>自身有 width 和 height , 不一定用到 css上的, 当然css上的也起作用
	但是src 没有内容的情况下, 只显示 alt 的文字内容
	css 的background 没有起作用
	width 和 height 不设置,原尺寸显示
要使图片原尺寸显示,显示不到的又可以滚动显示,用div包裹,加 overflow:scroll;
	<div style="width:80%;height:70%;overflow:scroll;text-align:center; background:#ddddee;">
		<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
	</div>
	如果想单滚动条: 例如 overflow-x: hidden; overflow-y: scroll;
	但是滚动条会看到,很讨厌!!
	使滚动条消失,方法一,再包裹一个尺寸小一点div把里面div的滚动条隐藏掉
	<div style="width:800px; height:700px; overflow:hidden; ">
		<div style="width:820px; height:720px;overflow:scroll;text-align:center; background:#ddddee;">
			<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
		</div>
	</div>
	注意: 第一个div width:800px; height:700px; overflow:hidden;
	      第二个div width:820px; height:720px;overflow:scroll;
	方法二:
	改css:
		scrollbar-3dlight-color:#fff; // 3d亮色阴影边框(threedlightshadow)的外观颜色
		scrollbar-highlight-color:#fff; // 滚动条3d高亮边框(threedhighlight)的外观颜色
		scrollbar-arrow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-shadow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-darkshadow-color:#fff; // 滚动条3d暗色阴影边框(threeddarkshadow)的外观颜色
		scrollbar-base-color:#fff; // 滚动条基准颜色
		scrollbar-track-color:#fff; // 滚动条拖动区域的外观颜色
	滚动条隐藏后操作: 滑轮 y轴；shift+滑轮 x轴;
div 居中与div内容居中: 更多扩展: https://www.thinkcss.com/jiqiao/1460.shtml
	div自身居中：
		使用margin:0 auto
		上下为0，左右自适应的css样式。
	div内容居中:
		1、div内容水平居中CSS： text-align:center
			无论是p还是div都可以对其设置此CSS实现对应对象内的内容水平居中。
		2、div内容垂直居中 行高属性：line-height
			要让div内只有一行的内容垂直居中，通常对div设置的height(高)与line-height(行高)相同，即可实现div内容垂直居中。








20180903
继续填坑:
节点学习:
	<div> XXXXX <span>cccc</span> llll <p>fff</p> kkk </div> oo <div>uu<div>
	对于第一个div来说:
	childNodes: 有 #test( XXXXX ), <span>, #text( llll ), <p>, #test( kkk ), 共 5 个子节点	(算上#text节点)
	children: 有 <span>, <p> 共 2 个子节点		(不算#text节点)
	firstChild 指向 #test( XXXXX ) 子节点		(算上#text节点)
	firstElementChild 指向 <span> 子节点		(不算#text节点)
	innertext 并不好分析,不可信
	lastChild 指向 #test( kkk ) 子节点		(算上#text节点)
	lastElementChild 指向 <p> 子节点		(不算#text节点)
	nextElementSibling 指向 <div>uu<div> 同级节点	(不算#text节点)
	nextSibling 指向 #test( oo ) 同级文本节点	(算上#text节点)
	previousElementSibling,  previousSibling 指向之前的,同理分析可知道具体指向
	parentNode 和 parentElement 一般都直接 指向相同的上级节点,没有据别
插入 html段落内容: insertAdjacentHTML(位置,字符串)
	段落内容写成字符窜 然后使用 insertAdjacentHTML 即可以插入解析
	但是注意 转义字符 的使用
	"&#09;&#09;&#09;<div class=\"spac\">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</div>&#10;&#09;&#09;&#09;<div class=\"igdd\">&#10;&#09;&#09;&#09;&#09;<img class=\"imgs\" src=\"" + src[f] + "\"&#32;alt=\"pic error\" ></img>&#10;&#09;&#09;&#09;&#09;<div class=\"imgi\">" + info[f] + "</div>&#10;&#09;&#09;&#09;</div>&#10;"
	例如这样的 使用了 &#09; 一类转义字符串,但是 html解析时会认可并转成相关字符 会构成#text 文本节点
还有注意常常用到的在节点里挖掘 class 子节点的做法:
	var ff = curNode.getElementsByClassName('tabPreviewer'),
	会得到 curNode 里 所有 class= "tabPreviewer" 的子节点
结合现阶段工作小结:
	接下来打算做的事:构思时间保存链,或者 写功能键内容.
	选择构思时间保存链, 学习体验使用参考区块链
另外建立了blockchain 实验:  lsgo技术团队
	git clone https://github.com/bitcoin/bitcoin.git
	cd bitcoin
	git tag		//查看版本
	git checkout v0.16.1	//选择没有 rc 的一个稳定版本
	git status	//查看版本
	//编译安装..... 后,有 bitcoind,bitcoin-cli两个主要命令, 还有自动建立~/..bitcoin 文件夹
	运行Bitcoin Core 客户端, 注意容易与curl冲突导致意外关闭!!
		bitcoind -printtoconsole	//前台执行 bitcoind初步会同步世界数据!!几乎有 130G!!! 草!!
		bitcoind -daemon		//后台执行
		bitcoin-cli stop		//关闭,切勿 ctrl+c  !! bitcoin-cli是辅助工具
	配置bitcoind
	gedit ~/.bitcoin/bitcoin.conf
	//一个完整索引节点的配置
		txindex=1
		rpcuser=bitcoinrpc
		rpcpassward=CHANGE_THIS
	//或者 这样 当设备资源有限时的配置
		maxconnections=15
		prune=5000
		minrelaytxfee=0.0001
		maxmempool=200
		maxreceivebuffer=2500
		maxsendbuffer=500
		rpcuser=bitcoinrpc
		rpcpassword=CHANGE_THIS
	重新运行 bitcoind 客户端 (Bitcoin Core 客户端), 并重建索引
		bitcoind -printtoconsole -reindex
	比特币核心客户端实现了 JSON-RPC 接口，这个接口可以通过命令行帮助程序 bitcoin-cli 访问，也可以通过编程的形式在程序中访问。
btcoin:使用到的密码学:
	hash:
		ripemd160:
		SHA-256: 几乎每个文件都有一个独一无二的 sha256编码,哪怕 文件之间只差几个字符!!都没有可能相同
			 其实说的是,两个完全不同的文件有极低概率sha256相同,但是两个相近的文件的 sha256 绝对不同!!
	密钥对包含了一个私钥和一个（由私钥导出的唯一）公钥。公钥被用来接收款项，私钥被用来签署一笔交易来花费比特币
	btcoin 构成交易的 要素, 私钥,公钥,钱包地址,
	生成一对公私钥的方法: 椭圆曲线乘法, RSA算法
	比特币的公钥是由私钥通过 椭圆曲线乘法 导出的	
	非对称加密: 公钥加密, 私钥解密 ； 私钥加密,公钥解密 ; 公钥无法推导出私钥
		数字签名:应用:
			1.Alice需要使用具体约定的算法（例如RSA）生成私钥和公钥，私钥自己保留，公钥对外公布。
			2.Alice想要发送消息 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。",
			  Alice使用自己的私钥对消息进行加密，例如加密后的密文是 SHG356g3T4+dh4fh，这个密文就是Alice的数字签名。
			3.Alice将消息明文和数字签名打包一起,并发送到网络中:
			 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			4.网络中的所有人接收到消息后，都可以进行如下操作完成验证：
			  收到消息 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			  使用提供的公钥 gh3giPGFN2jgh3sF 对数字签名 “SHG356g3T4+dh4fh” 进行解密
			  将解密结果与消息明文 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。" 进行对比
			  如果一致，说明消息是Alice亲自发送的，因为只有Alice本人拥有Alice的密钥
			  如果不一致，则说明消息不是Alice发送的，或者虽然消息是Alice发送的但已遭到他人篡改
			问题: 如果黑客占线 发布同样的内容,但是发送黑客自己的公钥和自己生成的签名,
			那么网络人是分不清消息的来源的,可以把黑客误以为 Alice
		数字证书:
			自己生成的公私钥, 公钥向相关权威机构登记并公开,客户可以公开查询的,公私钥不再是随便生成的
python 的hash 计算:crypt hashlib
时间保存链构思:
	一张 conteid hsah表	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	一个用户, 有 一个行表数据表, 一个cnteid数据表, 一个流媒体文件目录
	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	不合理,黑客可以自己随时得到其他人的hash 然后更改自己的时间,然后生成自己的保存块,来欺骗
	构建这个算法要用演绎思维去想,从攻击者手段想如何修改得到合法的时间事件保存块!!!
	算法的核心是保证,保存时间的权威性!

骚操作: 
	ls -lc -t	//查询当前目录下的文件及最后修改时间
	df -hl命令查看磁盘占用情况
	sudo du -sh * 命令查看当前目录下文件的大小
	du -sh .[!.]* 命令查看所有隐藏文件的大小
	频繁利以上两个命令，可追溯想要的文件








20180906
学习了相关 加密算法,发现现阶段构建时间保存链 实在太浪费时间, 还是先优先完成前端基本功能:
	接下来 ,功能按键, 完成媒体文件的修改,提交!!
	还有 批量行处理, 滑轮显示总行数!!
关于 event 的深入
	例如: onmousedown 事件
	e.currentTarget 指的是 设置了 被设置响应事件的 节点 往往一个节点设置了事件, 事件发生时就会显示这个节点
		例如, <span class="newl" onmousedown="cntebar(event)">事件响应时, e.currentTarget一定是 这个设置了事件的span
	e.explicitOriginalTarget 得到的是 具体点击落在的的节点
	e.originalTarget 得到的是 具体点击落在的节点 的 父节点!!
		例如:
<div Id="main" contenteditable="true" onmousedown="point(event)" >
	<div class="vido" cnteid=600 cntety=5 ><span class="svdl" onmousedown="cntebar(event)">&nbsp;</span>15:
		<div class="vidd">
			<video width="320" height="240" controls>
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi">amimal</div>		
		</div>
	</div>
</div>
	设置事件的是 main, 但当鼠标点击落在 animal的 字符串里时, 	explicitOriginalTarget 指的是#text节点, originalTarget指的是 vidi节点
	当鼠标落在 非视频,非animal的字符串时, 即 15 行的空白处时! explicitOriginalTarget 指的是vidd节点, originalTarget也指向 vidd节点
	刚处理完所有按键问题,和 点击问题,发现 还缺一类行数据, 就是 标题行数据
	所以需要规划添加这类行媒体数据格式!! 然后重新调整所有按键操作
	然后就是 媒体行数据的生成页功能,然后ctrl+cv 然后是批量插入,删掉行数据, 
	还有一个就是 方向键操作后的屏幕跟随, 和 滑动显示的 加载行数 !!
	最后是保存上存!!然后就开始做服务器了!!保存到服务器,需要数据回滚操作, 以防保存失败!!!
event 和 this 
	onclick等事件,不仅仅传递event 还可以传递 this, this就是 设置 onlick 的节点!!
	例如 onclick="kkk(this,event)"  function kkk(t,e){}, t和e是自己取的名字,位置对应this,event参数


现在发现 css 关于位置关系的描述非常重要!!需要学习掌握!!










20180913
css位置学习:
CSS 框模型
	---------------------------------------------------------
	|                  外边距 margin (空白透明)              |
	|      ------ 边框 border (线,点,透明)--------------     |
	|      |           内边距 padding (空白透明)       |     |
	|      |      ----------宽 width -----------      |     |
	|      |      |                            |      |     |
	|      |      |                            高     |     |
	|      |      |         element          height   |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      ------------------------------      |     |
	|      |                                          |     |
	|      |                                          |     |
	|      --------------------------------------------     |
	|                                                       |
	|                                                       |
        ---------------------------------------------------------
padding 与 margin 的设置方式
	margin: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	margin: 20px			// 统一 20px 的边距
	margin-top: 10px;
	margin-right: 0.25em;
	margin-bottom: 2ex;
	margin-left: 20%;
	padding: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	padding: 20px			// 统一 20px 的边距
	padding-top: 10px;
	padding-right: 0.25em;
	padding-bottom: 2ex;
	padding-left: 20%;
	
border设置:
  	border:5px solid red;		//边粗, 边样式, 边颜色
	独立设置:
	border 	简写属性，用于把针对四个边的属性设置在一个声明。
	border-style 	用于设置元素所有边框的样式，或者单独地为各边设置边框样式。
	border-width 	简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。
	border-color 	简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。
	border-bottom 	简写属性，用于把下边框的所有属性设置到一个声明中。
	border-bottom-color 	设置元素的下边框的颜色。
	border-bottom-style 	设置元素的下边框的样式。
	border-bottom-width 	设置元素的下边框的宽度。
	border-left 	简写属性，用于把左边框的所有属性设置到一个声明中。
	border-left-color 	设置元素的左边框的颜色。
	border-left-style 	设置元素的左边框的样式。
	border-left-width 	设置元素的左边框的宽度。
	border-right 	简写属性，用于把右边框的所有属性设置到一个声明中。
	border-right-color 	设置元素的右边框的颜色。
	border-right-style 	设置元素的右边框的样式。
	border-right-width 	设置元素的右边框的宽度。
	border-top 	简写属性，用于把上边框的所有属性设置到一个声明中。
	border-top-color 	设置元素的上边框的颜色。
	border-top-style 	设置元素的上边框的样式。
	border-top-width 	设置元素的上边框的宽度。	
margin 外边框合并!!!
	位置相邻的两个元素,不管是 同阶级关系,还是父子关系, 只要他们都设置了margin 而且是两者的margin相贴合,那么就会发生合并
	保留参数值大的margin,消灭调参数值小的margin 	
块元素,行元素
	div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。
	与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”
	display 设置为 block，可以让行内元素（比如 <a> 元素）表现得像块级元素一样
	display 设置为 none，让生成的元素根本没有框,即该框及其所有内容就不再显示，不占用文档中的空间。
CSS 有三种基本的定位机制：普通流、浮动和绝对定位	
	除非专门指定，否则所有框都在普通流中定位。
	块级框 从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。
	行内框 在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。
		垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），
		行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。
position : relative 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。
	relative 配合 top,left,right,bottom 方位属性 使用
	position:relative;left:20px;	//表示 元素在原始位置的基础上,从元素的原始左侧位置加上 20px ,相当于向右移动 20px
					//但是原始位置保留, 即下一个元素的原始位置,根据这个元素的原始位置决定
	relative 是 普通流机制的一部分, 原始位置也是 普通流机制的内容`
position : absolute 按绝对坐标定位 它原本所占的空间不保留。	
	absolute 配合 top,left,right,bottom 方位属性 使用
	position:absolute;left:100px;top:150px;		//以页面 左 上 角为原点,水平加100px,垂直加150px
					//即以左上角为原点,向右移动100px,向下移动150px的位置
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
	position:absolute;left:100px;	//以页面 左 上 角为原点,水平加100px,即以左上角为原点,向右移动100px
					//这里只定义了 水平位置的绝对坐标, 垂直位置绝对坐标没有定义.
					//所以垂直位置 按 原始位置的垂直位置排位, 把这个垂直位置作为绝对坐标
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
position : fixed 固定定位,这是根据浏览器窗口来定位的, 同样, 与absolute 一样是固定定位,
	不保留原始位置!!, 不对往后的元素的位置有影响. 永远保持显示在最前位置!!
position : static（静态定位）：就是普通流的获得的 原始位置,而且忽略 top, bottom, left, right 或者 z-index 声明的参数!	

overflow: 块元素内容 溢出的显示对策
	visible 默认值。内容不会被修剪，会呈现在元素框之外。
	hidden 	内容会被修剪，并且其余内容是不可见的。
	scroll 	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
	auto 	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
	inherit 规定应该从父元素继承 overflow 属性的值。
clip: 只有 position:absolute 绝对定位的元素, 才可以被clip 裁剪显示元素的展示空间即配合 absolute 使用
	position:absolute;left:100px;clip:rect(0px 50px 200px 0px)	//显示局对定位的元素 50*200 空间 内容
	值:
	shape 	设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left)
	auto 	默认值。不应用任何剪裁。
	inherit 	规定应该从父元素继承 clip 属性的值。	
vertical-align 属性设置 同阶级 元素间 的垂直对齐方式 ,不是设置在父元素上,而是设置在有需要的子元素上
	baseline 默认。元素放置在父元素的基线上。
	sub 	垂直对齐文本的下标。
	super 	垂直对齐文本的上标
	top 	把元素的顶端与行中最高元素的顶端对齐
	text-top 把元素的顶端与父元素的 #text 的顶端对齐
	middle 	把此元素放置在父元素的中部。
	bottom 	把元素的顶端与行中最低的元素的顶端对齐。
	text-bottom 	把元素的底端与父元素的 #text的底端对齐。
	length 	 例如 20px -10px
	% 	使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。
	inherit 规定应该从父元素继承 vertical-align 属性的值。
text-align: center;对子元素的对齐要求,设置在父元素上
z-index 元素所在的 显示层数, 层数越高元素遮挡层数低的元素
	如果元素不是绝对定位! 层数不管怎样变化,元素的原始位置依然没有改变!!
	所以 z-index 一般是配合 position:absolute 使用的!!

css 浮动:
	html 排布 有 3个次元 普通流 浮动 绝对定位
	普通流
		默认的元素是按照 html 文本流 一个一个相互影响地排列着 ,这是这时普通流的 元素排列
		普通流的方式下, 每个元素都有自己一个对应的原始位置!!
		即使使用了 relative 每个元素的实际所在位置有了偏移, 但是其原始位置是保留下来,对其他元素的位置有影响的!! 
		默认下普通流的 所有元素都 位于 z-index:0 这一层, 但是文本流 往后元素 可以遮盖 往前元素
		除非 往前元素主动设置z-index > 0 或者 > 往后元素的z-index , 往前元素 才有机会遮盖 往后元素 !
	绝对定位	
		如果只是 absolute 但没有水平/垂直坐标, 会先从文本流得到原来应该的原始坐标作为绝对坐标,
		但是并不保留自己的原始坐标,所以下个元素的原始坐标 与这个定义了absolute的元素没有关系!
		拓展例子: 
			<div>普通1</div>
			<div>绝对2</div>
			<div>普通3</div>
			<div>绝对4</div>
			绝对定位的例子只是position:absolute; 并没有设置水平垂直位置. 这时:
			绝对2 的 原始位置 根据 普通1, 普通3 原始位置 也是根据 普通1 而不是绝对2,所以
			<div>绝对2</div>,<div>普通3</div> 的原始位置都是同一个位置上,普通3 遮盖 绝对2,因为普通3元素比绝对2靠后
			绝对4 的位置是 根据 普通3,普通1,的原始位置得到的,与 绝对2 没有任何关系 
		虽然只是坐标关系变化了, 但是显示的先后顺序还是按着文本流 元素出现的先后顺序来,
		默认下绝对定位 的元素 也都 位于 z-index:0 这一层 文本流 往后元素 可以遮盖 往前元素,也是改z-index改变遮盖关系 
	浮动:
		经过实验,发现浮动,是普通流的升级板,例子说明:
		不使用float,普通流: div元素的排布:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------
 			|        |
			|    2   |
			|        |	
			----------
			--------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1使用 float:left 时:
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |
			|          |  |        |
			|          |  ----------
			------------  --------
			              |   3  |
			              |      |
			              --------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素2使用 float:left 时:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------   --------
 			|        |   |   3  |
			|    2   |   |      |
			|        |   --------
			----------   ----------
 			             |        |
			             |    4   |
			             |        |	
			             ----------
		元素1,2使用 float:left 时:
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4)
 		元素 1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4)
			------------  ----------  --------
			|          |  |        |  |   3  |
			|     1    |  |    2   |  |      |
			|          |  |        |  --------
			|          |  ----------  ----------
			------------              |        |
			                          |    4   |
			                          |        |				
			                          ----------
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4, 元素3高度变得与元素2一样高 )
		元素1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4,元素3高度变得与元素2一样高 )
			------------  ----------  --------
			|          |  |        |  |      |
			|     1    |  |    2   |  |   3  |
			|          |  |        |  |      |
			|          |  ----------  --------
			------------  ----------
			              |        |
			              |    4   |
			              |        |				
			              ----------
		元素1,2,3使用 float:left 时, (假设页面无限宽)
		元素1,2,3,4使用left时: (假设页面无限宽)
			------------  ----------  --------  ----------
			|          |  |        |  |   3  |  |        |
			|     1    |  |    2   |  |      |  |    4   |
			|          |  |        |  --------  |        |
			|          |  ----------            ----------
			------------          
		元素1 使用 float:right 时,	
			----------             ------------
 			|        |             |          |
			|    2   |             |     1    |
			|        |             |          |
			----------             |          |
			--------               ------------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2 使用 float:right 时,
			--------     ----------  ------------
 			|   3  |     |        |  |          |
			|      |     |    2   |  |     1    |
			--------     |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------	
		元素2 使用 float:right 时,
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			--------                   ----------
 			|   3  |                   |        |
			|      |                   |   2    |
			--------                   |        |
			----------                 ----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2,3 使用 float:right 时, (假设页面宽差一点而不能容纳元素4,)
			   --------  ----------  ------------
 			   |   3  |  |        |  |          |
			   |      |  |    2   |  |     1    |
			   --------  |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------
		也就是说 float 也是 普通流的一种扩展形式, 设置了float的元素, 原始位置也是根据float发生了变化
		影响到 普通流 的其他元素的 原始位置!!
		float还可以配合 clear使用:
		元素1,2,3,4使用left时, 元素3使用了clear:left: (假设页面无限宽)
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |	//其实就是说 3 左边不能紧接着 float:left 的元素  
			|          |  |        |
			|          |  ----------
			------------ 		
			--------  ----------
			|   3  |  |        |
			|      |  |    4   |
			--------  |        |
			          ---------- 		
		同理,  clear:right;  其实就是说 元素 右边不能紧接着 float:right 的元素
		clear:both; 就是 左边不能紧接着 float:left 的元素, 右边不能紧接着 float:right 的元素!!
		clear:both; 就是 左边可以紧接着 float:left 的元素, 右边可以紧接着 float:right 的元素!!
		文字段 #text 与 float元素的的位置关系也是值得 讨论 例如:
			<div id=1>...</div>
			<div id=2>~~~~~~~~~~~~~~~~~~~~..... <img>3</img><div>
			其中 div1 float:right,
			其中 div2 text-align:center; 假装---是文本,最后还有一张图片3,
			就会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
		这样子的话也一样`:
			<div id=2>
			<div id=1>...</div>
			~~~~~~~~~~~~~~~~~~~~..... <img>3</img>
			</div>
			其中 div1 float:right,
			其中 div2 text-align:center;
			div1, 文字段 ~~~~~, 图片3 都是 div1 的子元素
			也会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
			注意	text-align:center; 都是对于一行内容来说的,
				对于有 float占据空间的 的 行 文字居中不算 float占据空间 例如 第2,4行明显
				如果文字与某些非float元素 同阶级, 元素排版时算作文字中的一员,共同实现居中
				图片3 与 文字共存的一行, 图片决定行高,文字和图片一起居中	
				图片3 是内联元素，如果是<div>,就不会出现最后的居中显示 ！！！而是div另外一行！！
display:
	inline: 相当于 <p>AA</p> <p>BBB</p> 能以 <p>AABBB</p> 显示
		------
		| AA |              ---------
		------       --->   | AABBB |
		-------             ---------
		| BBB |
		-------
		一般 <span> <a> 称为内联元素, 因为他们 即使默认情况下,不用设置 dispaly:inline时,
		 <span>AA</span> <span>BBB</span> 也会以 <span>AABBB</span> 显示 !!
	block: 对于 内联元素<span> <a> 等设置 dispaly:block时,内联元素的排版如 <div> <p> 这些快元素一样 一个元素占一行,
		                      ------
		                      | AA |
		---------             ------
		| AABBB |    --->     -------
		---------             | BBB |
		                      -------
	inline-block: 对于 每一个元素都看作 块元素, 然后把块元素放在 同一行上 !!
		即 <p>AA</p> <p>BBB</p> 不以 <p>AABBB</p> 显示, 而是 <p>AA</p> <p>BBB</p>
		   <span>AA</span> <span>BBB</span> 不以 <span>AABBB</span> 显示, 而是 <p>AA</p> <p>BBB</p>
		------
		| AA |              ------ -------
		------       --->   | AA | | BBB |
		-------             ------ -------
		| BBB |
		-------

		---------           ------ -------
		| AABBB |    --->   | AA | | BBB |
		---------           ------ -------
		注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
			如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
			所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

	none:	元素不会计入页面排版,不占用位置,所以也不就不能显示, 
		对应类似属性: visibility:hidden, 但是这个属性会把元素计入排版,即会占用位置只是不显示
dispay:flex  display新属性!!,弹性布局,是容器属性, 即设置在父元素上的.
	子元素的float、clear和vertical-align属性将失效。
	display:flex 需要配合以下属性,一起使用
		flex-direction　　容器内项目的排列方向(默认横向排列)　　
		flex-wrap　　容器内项目换行方式
		flex-flow　　以上两个属性的简写方式
		justify-content　　项目在主轴上的对齐方式
		align-items　　项目在交叉轴上如何对齐
		align-content　　定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
	详细: https://www.cnblogs.com/xuyuntao/articles/6391728.html
对子内联元素/(文本内容),强制不转行,父元素添加:
		style  white-space:nowrap;
		(默认一般自动转行)自动换行:word-wrap:break-word;  


		
综合使用: margin: auto;
	  width: 50%;
	  text-align: center;
	    display: block;
	    position: absolute;
	    right: 0px;
	    width: 300px;
	    padding: 10px;
	    float: right; 	
	    overflow: auto; 	
	    line-height: 200px;
	    height: 200px;
	    display: inline-block;
	    vertical-align: middle;
	    top: 50%;
	    left: 50%;
	可以实现各种对齐居中,,









20180914
前提
	额外js 保存全局变量
	以下框都允许点击并输入数据 称为合法文本框
		spac edtx hdda hdti imgi mati adoi vidi
	合法文本 imgi mati adoi vidi 复杂 \n\r处理,
		一般加\n 如果文本末加\n必须紧接加上\r
		一般退格 删 连续个\r与最前\r前的一个字符
		具体按键具体分析:
修正点击和按键操作 !!!
	base:mousu(event) , base:mousd(event) , base:mousm(event)配合使用,
	   √	mousd 先行任务: 合法文本 hdda hdti imgi mati adoi vidi 是否空,空则补上 <nothing>
	   √	实现基本鼠标点击动作,
	   √	能避免光标落入禁区,
	   √	点击标记色指定打开 contentbar
	   √	可做简单文本拖选, 
	  hold	一些地方的点击效果未理想{暂时不处理}
	keyboard.js : keypress(event) : 预处理
	   √	弹窗删除媒体行相关预处理
	   √	sel非空,才接下一步工作
	   √	sel是光标,才接下一步工作	
	keyboard.js : keypress(event) : spec优先处理:
	   √	spec只接受 空格和\b, 并优先处理, 方向键不在 keypress 处理, 
	   √	退格处理,永远不能让spac没有内容!!
	keyboard.js : keypress(event) : 简单的 fixl判断处理: 
	   √	keypress 前方讨论 提高输入速度  不谈论 \r \b 等 keypress部分按键, 后面会详细讨论
	   √	spac不处理,spac以外的合法文本框处理
	   √	不是undefine的按键都算字符输入, 需要改 fixl
	   √	onkeypress 似乎不识别 ctrl shift capslock, 而基本功能键为undefined,例如方向键
	keyboard.js : keypress(event) : \r(回车):
	   √	spac hdda hdti不处理
	   √	合法文本 imgi mati adoi vidi 生效:
	   √		复杂 \n\r处理: 文末加\n\r,不是文末加\r 	统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √	edtx 生效: 插入newl, 都不改变 cnteid 和 oid
	   √		\r作用行有机会变 fixl,插入行是newl,
	   √		其他行对齐:svdl,orgl变wrpl,wrpl有机会变回svdl,而newl,fixl不变
	 hold	屏幕跟随光标显示
	keyboard.js : keypress(event) : \b(退格):
	   √	spac不处理,多此一举
	   √	合法文本  hdda hdti imgi mati adoi vidi 同样的处理,
	   √		复杂\n\r处理,循环检查光标前有多少个连续\r,一次过删掉多个连续\r和\r前的一个字符
	   √			\r前是文本起点,则只退到文本起点文本起点
	   √			统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √			由于 hdda hdti 没有 \n 或 \r， 所以会自动绕过 \n\r处理
	   √		当回到尽头不操作,当空标记为空文本 
	   √	最后 edtx...
	   √		尽头时,删除当前行,把余下的文本接入上一行
	   √		遇到媒体行, 光标依然处在文本行,弹窗询问是否删除遇到的媒体行,抬起,再按一次\b实现删除,
	   √			实现这个功能现在不能笼统写成一个模快,各种边沿代码遍布各处,其他地方标明 弹窗删除媒体行相关
	   √			分布:keypress开头预处理, \b段贯穿全部, closeWin部分
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : tab键
	   √	实现 tab 缩进
	keyboard.js : keydowm(event) : 方向左
	   √	合法文本 spac hdda imgi mati adoi vidi: 左到尽头不作为 
	   √	hdti : 左到尽头到 hdda
	   √	edtx : 左到尽头, 跳到再上一个文本行的文本末位置, 最初文本行文本初位置不作为
	   √	合法文本 imgi mati adoi vidi  复杂\n\r处理,
	   √		循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点
	keyboard.js : keydowm(event) : 方向右
	   √	合法文本 spac hdti imgi mati adoi vidi: 右到尽头不作为 				
	   √	hdda: 右到头到 hdti
	   √	edtx : 左到尽头, 跳到再下一个文本行的文本初位置, 最后文本行文本末位置不作为
	   √	所有都有 复杂\n\r处理,循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点		
	keyboard.js : keydowm(event) : 方向上
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再上一个文本行同样的文本偏移位置, 溢出跳到文本末, 最初文本行不作为
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : 方向下
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再下一个文本行同样的文本偏移位置, 溢出跳到文本末, 最后文本行不作为
	 hold	屏幕跟随光标显示
修组合键操作操作 !!!	（hold）
	ctrl + cv
特殊操作:	（hold）
	媒体元素上滑鼠,放大显示尺寸
	页面上滑鼠, 显示已加载的起始行~结束行







20180918
完整修正媒体生成
前提：
	base:mousu(event) 已经讨论，
	   √	点击标记色指定打开 contentbar
	base.js : closeWin(e)	弹窗关闭 处理
	   √	检查并关闭 媒体删除弹窗 
	   √	检查并关闭 各类媒体生成弹窗
	base.js : upmed(e) 
	   √	打开指定媒体生成弹窗
	base.js : mmedial(event) :
	 doing	媒体生成弹窗 加载好的内容插入行
	...
继续学习css h3 
	注意 width height 关于% 的层次关系, %是相对父元素的!!
	默认margin-top/bottom > 0 ！
	font-size:6vh;  //vh vw 是字体大小等于浏览器screen的 width height 的%比例例如 6%height
	text-align: center; 只对父元素内的 内联元素和#text起作用，对于块元素不起作用
		例如 文本 + <audio> <img> 会显示在一行并居中
		     文本 + <div> + <p>  <div> 和 <p> 都会另一行显示
		     所以 对于子块元素的居中使用 margin: 0 auto; //上下没有间距，左右间距一样
	关于 form 和 input 的关系:
		input是内联元素,是放入line上的内容. 而 font-size:6vh; line-height:6vh; 是描述 line 和文字的高度的
		内联元素都可以被看成特殊的行文本文字,内联元素的位置 与 父元素的 font-size line-height 设置有紧密关系!!
	就是说 font-size, line-height 可以控制内联元素的位置
	注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
		如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
		所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

继续学习js
	iframe relaod:
		window.location.reload(true); 
			//如需刷新iframe，则只需把window替换为响应的iframe的name属性值或ID属性值
			//  https://www.jb51.net/article/65013.htm  
继续学习python:
	python中是没有NULL的，取而代之的是None
	python是把0，空字符串‘’和None都看作False，把其他数值和非空字符串都看作True
		给一个文字串变量里不停加东西!!可以这样子:
		str1 = ""
		for f in files
			str1 += ("helloworld" + str2 + f.name)
这里修正的内容要一个个流程来记录：
	上传插入音频
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入视频:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!	
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入图片:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 pic数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传公式:
	   (jmeditor要点:jme.js onok 告诉如何获得和处理公式,不过是通过jqurey 方式!!)
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed		funcedit 写公式
	 writed		funcview 预览公式
	 writed		- + 添加/减少写好的公式, 可以点击高亮要加删的位置
	 writed		ok 添加到行数据 !!  恢复默认页面(iframe使用reload)
	上传主题:
	 writed	修正主题行:
	 writed		主题行 标题过长隐藏, 使用的 overflow:hidden; 还有 margin-bottom:-0.4em 微调位置
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed		ok 添加到行数据 !!  恢复默认页面 (iframe可以使用reload)
	 writed		主题优先处理 空白内容 按 ok 的 问题!! nullmed 处理
	上传五线谱:
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示, 并排显示效果不理想,还是竖排比较好
	 writed		有教程链接,
	 writed		textarea 按键触发,自动更新乐谱
	 writed		ok 添加到行数据 !!  恢复默认页面  textarea 的 value 值放文本
	添加/缩减行:(当紧邻的行是媒体行时特别有用)
	 writed	+ 后插入一行
	 writed	- 删除当前一行,
	 writed		删除文本行
	 writed		删除媒体行 (借助 \b按键)
			发现了一个大坑:
`				//   sel一直存在的, 但sel的内容可以是null 
				//   当js函数 中 sel.removeAllRanges() 只是把sel的内容设置null
				//   当js函数完毕后 不会默认处理 sel
				//   但是 js 不管是否执行了 e.preventDefault(), js完毕后, sel的内容都不会被另外处理
				//   event 与 sel 是有区别的
				//   特别注意 js 执行了 e.preventDefault(), js完毕后, 之前的获得的 event 没有释放
				//   所以 可以简单重新 触发 同样的 js !!
				//   比如 div id=klj 设置了一个keydown2,当在点击这个div时,sel指向当前div 并生成 event 
				//   按键时会触发keydowm2,例如打开了一个窗口, 而且例如 keydown2 会 把sel指向其他div
				//   如果 keydown2 执行了 e.preventDefault(), 则keydown2结束后, event斌没有自动消除,
				//   下一刻,按键时,即使 sel不指向当前div, 由于event还在,所以会继续触发这个div 的 keydown2
				//   再下一刻, 鼠标点击其他div 这时,keydown2 没有清除的event 会被 鼠标点击默认事件清除
				//   并获得新的 sel 和 event!!!
				//   页面上的逻辑解释 (糊涂做出来的逻辑,狗屎运)
				//	注意 页面上 按键是 main 元素设置的 , 而其他弹窗独立于 main 元素,
				//	点击 标记色时, 传递js 的是 main 的 event, 标记色打开了独立于 main 的 contentbar
				//	标记色js 执行e.preventDefault(), 标记色js结束后 没有清 event
				//	打开了 contentbar 后, 点击+ - 会传递  contentbar 的 event 到 lineadd-js
				//	这时 lineadd-js 也 执行e.preventDefault() 没有清 event
				//	lineadd-js结束后,     现在 event 存在 main-event 和 contentbar-event
				//	这时,我们可以任意继续 触发 注册在 main 的js ,或则	注册在 contentbar 的js	
				//	而不需要关注 sel 是否也指向同样的位置!!	
	closewin 时恢复素材添加页面
	 writed	所有媒体行窗口关闭时都处理
	ok按键 nullmed 处理!!  (主要在 mmedial 添加处理)
	 writed	pic aud pic 未选择,没有名字,未上传 nullmed	(与服务器设计相关,移植别的服务器请修改mmedial)
	 writed	func 没有函数,函数没有名字,nullmed	//已解决 有bug  第二次无法upfuc 其实是 fucitem 问题, mmedial结束前 fucitem = null
 	 writed	tit  有空白框没填 nullmed		//已解决 有bug <nothing> 问题, 
							//已解决 所有非edtx合法文本都有<nothing>问题, 修改 legalTEmpty 赋值解决
							//已解决 tit独有的 bug ,date title 与 方向左右 与 <nothing>
							//已解决 tit 去 \n\r
	 writed	stv 文本没有内容 nullmed
	媒体行 打开 同样的添加页面, 加载已有内容 修改 upmed
	 writed	tit	
	 writed	fuc
	 writed	stv
	skipped 做着做着才发现, 加载已有的 pic aud vid 没有意义!!因为,使用input type=file type=submit 的关系
至此,实现所有基本编辑功能!!! (仅 firefox)
后续发现bug
	非edtx的合法文本去掉所有字符后再加上新字符也会变nothing,只有不清除所有字符的情况下才不会变















20180929
检修,并开始写 后端
	已解决 tab bug: <div><br></div> 无法添加tab  已解决
安装 pycharm
	https://blog.csdn.net/qq_38683692/article/details/79868391
由于是社区板,没有django套件,不过没关系,我就要它的编辑界面,其他都终端编译,
在所在目录新建一个pycharm工程就可以链接整个文件夹,使用 pc 的文本编辑器方便编译,至于其他功能还是 终端实现
取消自动保存,加星号标记 修改未保存

设计一个`独立的页面使用
	loadlast.html
	base1.js	//拷贝复制base的内容,抽出window.onload
	ready.js 	//专门处理 window.onload()
		使用 $.get( "loadfile", fuction(data.status,xhr){readyloadfile(data.status,xhr)} )
		成功回调函数需要 完全定义在 get 里, 然后调用外部函数 readyloadfile() 执行其他操作
	urls.py  views.py 	//添加	loadlast.html , loadfile 请求处理!

每个用户都有自己的数据表,所以,需要动态建表的能力!!
https://blog.csdn.net/siete/article/details/6170755
https://www.cnblogs.com/kimyeee/p/7241754.html
https://blog.csdn.net/weixin_42134789/article/details/80194488

django 添加 .py 文件,跟普通python添加文件一样不需要另外特别注册
	for 文件夹 import py文件
		py文件.函数()
	for 文件夹.py文件 import 函数
		函数()
	for . import XXX    //从 当前文件位置 加入 XXX
	
	sql命令笔记:
		删除table sql语句:
			drop table web_kate_line;
		查看表内容:
			select * from web_kate_line

关于django 动态建立数据表的 问题,非 通过manager migrate 这样静态指令初始化
	经过痛苦的分析过程,高度怀疑是 BaseDatabaseSchemaEditor.create_model(model) 实现动态建表
	但未知 model具体指什么,
	从源码 发现 model 类似构造
    class Migration(models.Model):
        app = models.CharField(max_length=255)
        name = models.CharField(max_length=255)
        applied = models.DateTimeField(default=now)

        class Meta:
            apps = Apps()
            app_label = "migrations"
            db_table = "django_migrations"

        def __str__(self):
            return "Migration %s for %s" % (self.name, self.app) 
	那么 在 models.py 构造的就是可以填入的 model
	那么一个可用的 动态建表的代码像这样:
		class kate_line(models.Model):
		    name = models.CharField(max_length=255,verbose_name='kname')
		    introduce = models.CharField(max_length=255,verbose_name='ksobject')
		from django.db import connection
		with connection.schema_editor() as editor:
		    editor.create_model(kate_line)
		// connection 与 BaseDatabaseSchemaEditor 的关联如上 connection.schema_editor()
		//一定要用 with 因为涉及 __enter__ 和缺参数的问题
		//python __enter__() 问题:https://www.cnblogs.com/DragonFire/p/6764066.html
		//不能直接 connection.schema_editor().create_model(custom_model)
	创建了数据表,添加数据内容:
		base = kate_line(name = 'bilibiliai',
		                 introduce = 'i still love u'
		                 )
		base.save()
		// django 使用 ORM 的方式 访问 数据库
		// 所以 可以这种方式 给 数据表 web_kate_line 写入数据 bilibiliai i still love u
	另外脱离 models.py那种固定方式,可以使用参考dy_model_creat.py 的 create_model 这种自己建立一个class出来!! 
建立一个保存按钮:页面右下角,鼠标移到显示,移开隐藏:
	onmouseover="this.style.opacity=1;" onmouseout="this.style.opacity=0;"
	点击,收集,并上存.json文件!!
新的技术点,自建文件,并上传!!
参考:
	上传显示进度: https://newsn.net/say/jquery_ajax_upload.html
	生成文件: https://www.jianshu.com/p/e7c7a8e4e9dc
	参考:	https://blog.csdn.net/xcymorningsun/article/details/52949848
		https://coderanch.com/t/549940/languages/generate-xml-file-submit-action
		https://stackoverflow.com/questions/6066837/how-to-write-data-from-form-in-html-to-xml-with-javascript
		https://blog.csdn.net/commandboy/article/details/55680654
	frommdata: 重点有即时处理: https://www.javascripture.com/FormData
	blob才是我需要的??:		https://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/
	用blob发即时图片,django后端获得:	https://stackoverflow.com/questions/48097297/upload-an-image-blob-from-ajax-to-django
	js blob 大文件分片传输:		https://www.jianshu.com/p/4d014a45aaf7
	filereader 读取file但是读取的 都是从input choose 获得的文件:	 https://www.cnblogs.com/tianma3798/p/5836484.html
	
	非常直观填了新坑 !! https://blog.csdn.net/hsany330/article/details/52575459
	不过还有 new file 的问题 active...
新坑: File、FileReader、Blob、Fromdata 对象
	一般 file对象是来自用户在一个 <input> 元素上选择文件后返回的FileList对象，也可以是来自由拖放操作生成的 DataTransfer对象
		FileList {0: file, 1: file, length: 2 }
			length: 2
			0: file
				lastModified: 130989987997
				LastModifiedDate: Thu May 26 2011 23:59:00 GMT+0800
				name: "aa.jpg" 
				size: 902047
				type: "image/jpeg"
				webkitRelativePath: ""
				__proto__: File
			1: file
			__proto__: FileList
	FileReader 对 file 对象 blob 对象的 处理过程对象 例子
		var reader = new FileReader();
		reader.onload = function() {
		    console.log(this.result);
		}
		reader.readAsDataURL(file);	//这里是 通过FileReader 读出一个 file 对象的 DataURL
	dataurl: 一般用于把小文件 对应小的 file 对象 转换成 包含数据信息的 url 跟普通的url一样的使用方式:
		DataURI 一般是把 file对象 编译成 base64 斌码 的 一条长字符串
		格式为:		
		data:[<MIME type>][;charset=<charset>][;base64],<encoded data>	
		对应例子:
		<img class='obj' src="data:[<MIME type>][;charset=<charset>][;base64],<encoded data>"
	URL:一般是文件的位置,但如果文件读入到 file 对象里, 
		可以通过 URL.createObjectURL() 对 file对象里的文件建立一个临时的 url
		img.src = window.URL.createObjectURL(file);
  		<img class="obj" src="blob:null/34c9b3b5-9ca9-4b18-9798-xxxxxx">
	blob: blob 跟 file 对象是一样的, 不过 file对象一般是 通过 <input>选入的,但是 blob是凭空创建的
		var arr = ['<h1>hello world</h1>'];
		var blob = new Blob(arr, { "type" : "text/xml" }); // the blob
		slice方法生成blob对象
			var newBlob = Blob.slice(startingBytenum, endindBytenum);
		DataURI（base64）对象转blob对象（二进制）
			function dataURItoBlob(dataURI) { 
				var byteString = atob(dataURI.split(',')[1]); 
				var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; 
				var ab = new ArrayBuffer(byteString.length); 
				var ia = new Uint8Array(ab); 
				for (var i = 0; i < byteString.length; i++) { 
					ia[i] = byteString.charCodeAt(i); 
				} 
				return new Blob([ab], {type: mimeString}); 
			} 
			// atob() 将base64解码 , btoa() 将字符串转码为base64 
			var str = 'javascript'; 
			window.btoa(str) 		//转码结果 "amF2YXNjcmlwdA==" 
			window.atob("amF2YXNjcmlwdA==") //解码结果 "javascript"
	FormData 用于 ajax 或者 XMLHttpRequest 上传数据到服务器!!
		一般可以值直接把 <form> 内容在初始化时放入
			<form id="uploadForm" enctype="multipart/form-data"> 
				<input id="file" type="file" name="file"/> 
				<button id="upload" type="button">upload</button> 
			</form>
			var fdata = new FormData($('#uploadForm')[0]);
		也可以把数据一条一条放入, 通过 append()
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			append 可以加载 file blob 对象,还可以加载一般表单项
		一般 FormData  例子:
			<form id='test-form'>
			  Input1: <input name='input1'><br>
			  Input2: <input name='input2'><br>
			  <input type='submit'>
			</form>
			..
			  testForm.onsubmit = function(event) {
			    event.preventDefault();
			
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			
			    var formData = new FormData(document.getElementById('test-form')); //添加了 input1 input2 表项
 			
			    formData.append('appendedFile1', new Blob(['foo']));	// 添加了 blob 对象
			    formData.append('appendedFile2', new Blob(['bar']), 'bar.txt'); // 添加了 blob 对象
    			    formData.append('appended1', 'appended value');		// 添加了 一般表单项
			
			    request.send(formData);
			
			    console.log(request.response);
			  }
			formData 内容: 这个表内容格式并不正确 已经误导我了!!1
			{
			  "args": {}, 
			  "data": "", 
			  "files": {			// file blob 对象 会加载到 flies 数组
			    "appendedFile1": "foo",
			    "appendedFile2": "bar"
			  }, 
			  "form": {			// 普通表项会加载到 from 数组
			    "appended1": "appended value", 
			    "input1": "dd", 
			    "input2": "ddd"
			  }, 
			  "headers": {
			    "Accept": "*/*", 
			    "Accept-Encoding": "gzip, deflate, br", 
			    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", 
			    "Connection": "close", 
			    "Content-Length": "648", 
			    "Content-Type": "multipart/form-data; boundary=---------------------------56193008011516604521985403512", 
			    "Host": "httpbin.org", 
			    "Origin": "https://www.javascripture.com", 
			    "Referer": "https://www.javascripture.com/FormData", 
			    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0"
			  }, 
			  "json": null, 
			  "origin": "149.28.122.195", 
			  "url": "https://httpbin.org/post"
			}
	ajax 与 XMLHttpRequest , ajax 是 jqurey 的方式  XMLHttpRequest是 标准 DOM
		ajax: 例子1
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			$.ajax({ 
				type: 'POST', 
				url: '/upload', 
				data: fd, 
				processData: false, // 不会将 data 参数序列化字符串,必须false 
				contentType: false, // 根据表单 input 提交的数据使用其默认的 contentType，必须false 
				xhr: function() { 
					var xhr = new window.XMLHttpRequest(); 
					xhr.upload.addEventListener("progress", function(evt) { 
						if (evt.lengthComputable) { 
							var percentComplete = evt.loaded / evt.total; 
							console.log('进度', percentComplete); 
						} 
					}, false); 
					return xhr; 
				} 
			}).success(function (res) { 
				// 拿到提交的结果 
			}).error(function (err) { 
				console.error(err); 
			});
		ajax: 例子2
			$.ajax({ 
				url: '/upload', 
				type: 'POST', 
				cache: false, 
				data: new FormData($('#uploadForm')[0]), 
				processData: false, 
				contentType: false 
			}).done(function(res) { 
			}).fail(function(res) {
			});
		XMLHttpRequest 例子1
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			    var formData = new FormData(document.getElementById('test-form'));		
			    request.send(formData);
	file对象 还有一种创建,非 input 输入的方式:
		var objFile=new File(["First Line Text","Second Line Text"],FileName);
		第一个参数是一个字符串数组。数组中的每一个元素对应着文件中一行的内容。
		第二个参数就是文件名字符串。
		var objFile=new File(["First Line Text","Second Line Text"],FileName,{type: "text/plain", lastModified: date});
		如果是用三个参数的形式
		第三个参数可以设定一些文件的属性，比如文件的MIME，最后更新时间等。 
	js 的 file 对象相关 还有一个 ActiveXObject 不过是微软 activeX 内容,所以不考虑!!
		但是这个涉及到完整的浏览器操作本地文件的过程:
		参考:http://www.cnblogs.com/ayan/archive/2013/04/22/3036072.html
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据补充
	//前端js 查看 formdata 内容的 方式
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
FormData补充:
	FormData类型其实是在XMLHttpRequest 2级定义的，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利。
	构造函数
		创建一个空对象实例
			var formData = new FormData();
			此时可以调用append()方法来添加数据
		使用已有的表单来初始化一个对象实例
			假如现在页面已经有一个表单
			<form id="myForm" action="" method="post">
			    <input type="text" name="name">名字
			    <input type="password" name="psw">密码
			    <input type="submit" value="提交">
			</form>
			我们可以使用这个表单元素作为初始化参数，来实例化一个formData对象
			// 获取页面已有的一个form表单
			var form = document.getElementById("myForm");
			// 用表单来初始化
			var formData = new FormData(form);
			// 我们可以根据name来访问表单中的字段
			var name = formData.get("name"); // 获取名字
			var psw = formData.get("psw"); // 获取密码
			// 当然也可以在此基础上，添加其他数据
			formData.append("token","kshdfiwi3rh");
	操作方法   首先，我们要明确formData里面存储的数据形式，一对key/value组成一条数据，
		key是唯一的，一个key可能对应多个value。如果是使用表单初始化，每一个表单字段对应一条数据，
		它们的HTML name属性即为key值，它们value属性对应value值。
			key value
			k1 	[v1,v2,v3]
			k2 	v4
		获取值
			我们可以通过get(key)/getAll(key)来获取对应的value，
			formData.get("name"); // 获取key为name的第一个值
			formData.getall("name"); // 返回一个数组，获取key为name的所有值
		添加数据
			我们可以通过append(key, value)来添加数据，如果指定的key不存在则会新增一条数据，如果key存在，则添加到数据的末尾
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.get("k1"); // "v1"
			formData.getAll("k1"); // ["v1","v2","v1"]
		设置修改数据
			我们可以通过set(key, value)来设置修改数据，如果指定的key不存在则会新增一条，如果存在，则会修改对应的value值。
			formData.append("k1", "v1");
			formData.set("k1", "1");
			formData.getAll("k1"); // ["1"]
		判断是否该数据
			我们可以通过has(key)来判断是否对应的key值
			formData.append("k1", "v1");
			formData.append("k2",null);		
			formData.has("k1"); 		// true
			formData.has("k2"); 		// true
			formData.has("k3"); 		// false
		删除数据
			通过delete(key)，来删除数据
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.delete("k1");			
			formData.getAll("k1"); 		// []
		遍历
			我们可以通过entries()来获取一个迭代器，然后遍历所有的数据，
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");
			var i = formData.entries();
			i.next(); // {done:false, value:["k1", "v1"]}
			i.next(); // {done:false, value:["k1", "v2"]}
			i.next(); // {done:false, value:["k2", "v1"]}
			i.next(); // {done:true, value:undefined}
			每调用一次next()返回一条数据，数据的顺序由添加的顺序决定
			返回的是一个对象，当其done属性为true时，说明已经遍历完所有的数据，这个也可以作为判断的依据
			返回的对象的value属性以数组形式存储了一对key/value，数组下标0为key，下标1为value，
			如果一个key值对应多个value，会变成多对key/value返回
		我们也可以通过values()方法只获取value值
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");	
			var i = formData.entries();
			i.next(); // {done:false, value:"v1"}
			i.next(); // {done:fase, value:"v2"}
			i.next(); // {done:fase, value:"v1"}
			i.next(); // {done:true, value:undefined}
		发送数据
			我们可以通过xhr来发送数据
			var xhr = new XMLHttpRequest();
			xhr.open("post","login");
			xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			xhr.send(formData);
			这种方式可以来实现文件的异步上传。
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据formdata补充 知道: 
	也就是 file100 是key 但是一个key可以对应很多 value, 而value的类型可以是单纯字符串,可以是file对象 等等 !!
	//前端js 查看 formdata 内容的 方式1 
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
	//查看 formdata 内容的 方式2
	    var i = fd.entries()
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())


?????????????????????????????????????
工作小结:
	写出了html范本,基本构建富文本内容方式(未完善),(test1.html, base.js, body.css)
	第一版,纯文本 test1.js 搭配 test1.html 这句
<body>
	<div Id="editor" contenteditable="true" onKeypress="ifenter(event)" onKeydown="ifdown(event)" onKeyUp="ifup(event)"><div>1:</div></div>
</body>
	第二版,加入媒体行!!
	后来发现超过1000行,处理速度就开始卡了, 先尝试优化,不行的话,就使用框选编译方式,
	开始设计数据库和表单!!!
		发现还要添加的内容:
		spac 禁止中文输入问题!!
		关于上传文件的规范,要筛选处理,涉及安全,不能什么文件都能传
	第三版,(未开始)
	所谓框选:
			--------------
			.            .
			.            .
			|            |
			|            |
			|            |
		      ------------------
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      ------------------
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			.            .
			.            .
			--------------


设计:
1,每行都有行号,行号前有标记色 
	每一行前的标记色,新建, 修改, 换行! 无操作, 某行内容既换行,又修改时,设为修改色 
	行号标记色点击可以选择该行的编辑内容,即行内容变换填充!!
	前端显示: cnteid 和 oid 的分配就是不用在前端做了,放到后端 !!
	orgl : transparency cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	newl : yellow cnteid:0, oid:0
	svdl : green cnteid:0(空行)/cnteid:xx(非空行), oid:yy  (>=0)
	wrpl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	fixl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
2,回车, 退格键,方向键, 粘贴组合键, tab键, 方向左键, 还有鼠标点击  
	回车要自动添加新行号,转行,回车后字符串处理, 修改标记色和id,
		注意多媒体行无法使用回车, 相邻多媒体行中间插入行操作放入cntebar里
	tab按键:当在一个div里只有文字才能完美实现距离问题,和缩进!!
	退格键:不能退到行号处!!
	方向键, 上下左右都要处理!!(只能捕捉并跳到 edtx 区!!,禁止出现在其他区域!!)
3,公式编写,使用的一个开源库: JMEditor: http://www.html580.com/11952
4,五线谱
	使用 vextab 掌握 多段谱,而不是一段谱

??,显示尺寸问题!!缩放网页时,
	公式 直接设置 style="font-size:80px;"
	五线谱:  artist = new Artist(10, 10, 1000, {scale: 0.8});
		10 和 10 都是位置偏移
		1000是长度
		{scale: 0.8} 是 高度 0 ~ 无穷

?? 多媒体行的间隔问题处理, spec 除了只允许输入空格,允许左右方向键 和上下方向按键 但是中文输入法可以突破输入的问题(未解决)
	
??,定时 触发事件!!! 还有流文件上传事件!! 浮动按钮 ,	

??,输入日期格式 例如 20180819 ,自动成为标题数据.可以手动改回文本数据

??,批量 定位 增删内容
	保守加载的内容有10万行内容,浏览器压力会非常大,所以,应该提供批量功能
	另外,提供右下角统计数据 滑动鼠标时显示已经加载的 行数据数 起始行-结束行:一共行数
??,页面
	用户主页是编辑页面
	搜索主页可调,一般是详细博客或者关键字博客嵌套页面
	关注人页面是,详细博客嵌套页面
	其他页面!!(科研小说教育..)
	主题发展
3,行号数据表 与 数据实体数据表
	具体 数据条放在独立的数据表里, 每条数据条都有独立的序号 conteid
	行号 放在独立的数据表里, 行号数据保存 对应的conteid 指向具体数据
	流媒体数据 放在另外独立的数据表里. 提供url访问 当
		流媒体数据先上传到数据库,生成链接供行号指向,没有行号指向的流媒体文件,一个月后会被物理清除,不可修复!! 
	数据条类型:
		空数据(特殊的文本数据 cntety:1), cnteid 指定为0 (其他每行用户数据各占一个独立的cnteid)
		另外前 256 个 cnteid 保留 为各种衍生功能标记做预留,例如识别代码段实时调试
		文本数据, cntety:1 
		图片数据, cntety:2 可以多个 ( 图片url + 图片加密编码字符串 + 缩略图 + 间隔数) 多个之间可以添加空格手动控制间隔
		数学公式, cntety:3 可以多个 ( 文本数据 + 间隔数 )  多个之间可以添加空格手动控制间隔 
		音频数据, cntety:4 单个 (音频url + 音频加密编码字符串 + 音频片段/降码音频)
		视频数据, cntety:5 单个 (视频url + 视频加密编码字符串 + 视频裁剪缩略采样)
		五线谱,   cntety:6 其实是纯文本,就是 vextab 语言纯文本
	 	主题,     cntety:7 数据(推荐时间日期 + 简单标题 + 收藏数/注水数 间隔数 )
			前端显示 推荐时间日期 + 间隔 + 简单标题 + 收藏数/注水数星号(收藏数/注水数) + 扩展按钮
		(扩展文本数据,可以标记超链接和 v2.0再考虑如何改,)
	mmedl:生成数据行
		如果该行为 newl, 则 更改时  cnteid 不改
		如果 其他xxxl 行数据变其他类型数据时 cnteid 设新id
		这种修改机制会 很容易 浪费许多孤立cnteid 即么中间的一些cnteid没有内容,没有行号指向
		所以(后期要做一个回收表!!) 
??,时间信任保存
	所有流媒体内容 经过sha加密  行数据内容是 缩略图/音频片段 + 链接 + 256位加密码,
		其中   缩略图/音频片段 + 256位加密码, 计入保存时间加密, 链接不计入!!
	文本类内容(包括五线谱编码) 经过sha加密  行数据内容就是 文本内容!! 直接计入保存时间加密,
	每行内容都有最后的修改日期!! 不过这条信息只有作者可看,运营方可看.
	依照政策删除敏感内容后造成 保存链断裂 导致的 发布事件时间信任度问题
	五线谱内容可以显示每次更新的内容!!状态!!
	先不考虑完美的 保存链算法, 先简单实现产品,所以重点先在于确定哪些内容才是需要写进数据库的内容!!!!
??,收藏推广
	可以关注别人,不设立粉丝
	星号是 实名收藏为收藏数, 匿名收藏为注水数,注水数每季度清零一清,
	用户实名收藏记录永久, 匿名收藏记录 半年一清
??,举报 与 依照政策删除敏感内容
	初步通知 出版者 让其主动修改或删除或不作为
	若鉴别为真犯规,
		方案一,要求主动删除,替换内容,不然,强制注销账户
		方案二,运营方直接删除
		这些删除涉及真正的物理删除, 会造成其他用户的时间信任保存链断裂
		所以运营方应该设计并仅运营方拥有的一个特殊的亢余数据库来修补 其他用户的时间信任保存链断裂的 问题!
		当亢余数据库非常大,必须做修正工作,记录每一位涉及的用户!! 给出他们一个重新编排时间信任保存链的权利
??,首先做一个网页模板方案一:
	/////////////////////////////////////////文本
	<div class="edit" cnteid="0" cntety="1"><span class="newl">&nbsp;</span><span class="lid" oid="0">1087:</span><div class="edtx">	我有一只船<br></div></div>
	/////////////////////////////////////////标题
	<div class="hdty" cnteid="0" cntety="7"><span class="newl">&nbsp;</span><span class="lid" oid="0" style="font-size:0.84em; font-weight:normal;">1085:</span>
		<div class="hdda">20181001</div>
		<div class="spac">          </div>
		<div class="hdti">今天我背了一首诗</div>
		<div class="hdcr" contenteditable="false">
			<div class="rlik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>			
			</div>
			<div class="rlikn">0</div>
			<div class="flik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>
			</div>
			<div class="flikn">0</div>
			<div class="othrc">
				<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>		
			</div>
		</div>
	</div>
	/////////////////////////////////////////图片
	<div class="imgt" cnteid="432" cntety="2" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="16">1064:</span>
		<div class="imgd">
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/child.gif" alt="pic error">
				<div class="imgi" contenteditable="true">child</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////视频
	<div class="vido" cnteid="600" cntety="5" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="19">1070:</span>
		<div class="vidd">
			<video controls="" width="320" height="240">
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi" contenteditable="true">amimal</div>		
		</div>
	</div>
	/////////////////////////////////////////音频
	<div class="adio" cnteid="0" cntety="4" contenteditable="false"><span class="newl">&nbsp;</span><span class="lid" oid="0">1068:</span>
		<div class="adod">
			<audio src="/static/music/yuxuanji.mp3" controls=""></audio>
			<div class="adoi" contenteditable="true">Hanser-鱼玄机</div>		
		</div>
	</div>
	/////////////////////////////////////////乐谱
	<div class="stav" cnteid="694" cntety="6" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="23">1074:</span>
		<div class="stad">
			<div style="white-space:pre; display:none;">
<textarea class="vex-tab-editor">options space=20 player=true  tempo=80
tabstave
  notation=true
  key=A time=4/4

  notes :q =|: (5/2.5/3.7/4) :8 7-5h6/3 ^3^ 5h6-7/5 ^3^ :q 7V/4 |
  notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :h p5/4
  text :w, |#segno, ,|, :hd, , #tr

</textarea>
        			<p id="errorTip" class="text-danger"></p>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div>
				<div class="tab-preview-container" style="margin-left:50px;">
					<canvas class="tabPreviewer"></canvas>
				</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////公式
	<div class="math" cnteid="683" cntety="3" contenteditable="false"><span class="fixl">&nbsp;</span><span class="lid" oid="18">1066:</span>
		<div class="matd">
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><big mathquill-command-id="43">∫</big><sub class="non-leaf limit" mathquill-command-id="45" mathquill-block-id="46" style="left: -0.25em;"><var mathquill-command-id="51">x</var><span mathquill-command-id="52" class="binary-operator">+</span><var mathquill-command-id="53">y</var></sub><sup class="non-leaf limit" mathquill-command-id="48" mathquill-block-id="49" style="left: -1.8125em; margin-right: -0.775em;"><var mathquill-command-id="55">x</var><sup class="non-leaf" mathquill-command-id="57" mathquill-block-id="58"><span mathquill-command-id="60">2</span></sup></sup><span class="fraction non-leaf" mathquill-command-id="61"><span class="numerator" mathquill-block-id="62"><var mathquill-command-id="73">y</var><sup class="non-leaf" mathquill-command-id="68" mathquill-block-id="69"><span mathquill-command-id="74">4</span><span mathquill-command-id="75" class="binary-operator">+</span><var mathquill-command-id="76">x</var></sup></span><span class="denominator" mathquill-block-id="63"><var mathquill-command-id="83">x</var><sub class="non-leaf" mathquill-command-id="85" mathquill-block-id="86"><var mathquill-command-id="89">i</var></sub></span><span style="display:inline-block;width:0">&nbsp;</span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function A</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><sup class="nthroot non-leaf" mathquill-command-id="90" mathquill-block-id="91"><sup class="non-leaf" mathquill-command-id="127" mathquill-block-id="128"><var mathquill-command-id="135">x</var></sup><span mathquill-command-id="130">/</span><sub class="non-leaf" mathquill-command-id="132" mathquill-block-id="133"><var mathquill-command-id="136">y</var></sub></sup><span class="scaled" mathquill-command-id="90"><span class="sqrt-prefix scaled" style="transform: scale(1, 2.4);">√</span><span class="sqrt-stem non-leaf" mathquill-block-id="92"><span class="fraction non-leaf" mathquill-command-id="108"><span class="numerator" mathquill-block-id="109"><var mathquill-command-id="117">y</var><sup class="non-leaf" mathquill-command-id="114" mathquill-block-id="115"><var mathquill-command-id="118">x</var></sup></span><span class="denominator" mathquill-block-id="110"><var mathquill-command-id="125">z</var><sup class="non-leaf" mathquill-command-id="122" mathquill-block-id="123"><var mathquill-command-id="126">y</var></sup></span><span style="display:inline-block;width:0">&nbsp;</span></span></span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function B</div>		
			</div>
		</div>	
	</div>

??,有待加入的功能:
	代码高亮识别!!(以后再说!!)




<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
开发_web_log 重要内容,因为涉及多机上传问题!!,所以未充分测试前不贸然实施
full_stack_note 暂时 通过 hp机 备份到 selfweb 项目上去
20180726
尝试使用第二部电脑 git 备份同一个项目!!
	例如之前再二手thinkpad做的 selfweb,整个文件夹拷贝到现在的 hp 上!!
	这时相当于把整个 git 配置也拷贝过来了,
	所以直接在 selfweb 输入命令:
		git add xxxx
		git commit -m "xxxx"
		git push origin master
		直接成功上传
不过注意!!!!!!!!!!
	注意 由于并没有完全尝试用两部电脑交替上传文件,
	因为,Apc 上传后得到的新节点, Bpc并不知道, bpc又上传时,因为不知情Apc的修改的内容而导致冲突!!!
	所以,只能在 不重要的 selfweb 项目上做好充分的交替上传测试,才允许其他大型项目的实施























