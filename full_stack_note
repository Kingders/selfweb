全栈:
高并发:
负载均衡:  LVS Nginx 应用服务器集群
LAMP  


decops
可用工具有很多，但其中一些环节是组织内部应用DevOps工具链不可或缺的。
诸如Docker（容器化）、Jenkins（持续集成）、Puppet（基础架构构建）、Vagrant（虚拟化平台）等常用、广泛使用的工具都是2016年的DevOps热门工具。




tomcat 


SpringBoot: https://www.cnblogs.com/java1024/p/8570401.html
    JDK8
    Maven3.0+
    Intellij IDEA

前端程序员
    基础
        HTML / CSS
        JavaScript
        DOM
    中级篇
        数据格式（如JSON、XML）
        RESTful API交互（如jQuery Ajax，Fetch API，ReactiveX）
        正则表达式
        HTML语义化
        命令行
        Node.js
        DIV / CSS
        SCSS / SASS
        矢量图形 / 矢量图形动画（如SVG）
        单页面应用
    高级篇
        ES6 / TypeScript
        CSS3
        面向对象编程
        函数式编程
        MVC / MVVM / MV*
        安全性（如跨域）
        授权（如HTTP Basic、JWT等等）
    工程化
        代码质量（如JSLint / ESLint / TSLint / CSLint）
        代码分析（如Code Climate）
        测试覆盖率
        构建系统（gulp、grunt、webpack等等）
        自动构建（脚本）
    兼容性
        跨浏览器测试 （Chrome，IE，Firefox，Safari等等）
        跨平台测试（Windows、GNU/Linux，Mac OS等等）
        跨设备测试（Desktop，Android，iOS，Windows Phone）
        跨版本测试（同一个浏览器的不同版本）
    前端特定
        CSS / CSS3 动画
        JavaScript 动画
        Web字体嵌入
        Icon 字体
        图形和图表
        CSS Sprite（如glue）
        DOM操作（如jQuery、React等等）
        模板引擎（如JSX、Handlebars、JSP、Mustache等等）
    软件工程
        版本管理（如git、svn）
        包管理（如npm、bower）
        依赖管理
        模块化（如CommonJS、WebPack）
    调试
        浏览器调试
        Debug工具
        Wireshark / Charles抓包
        远程设备调试（如Chrome Inspect Devices）
    测试
        单元测试
        服务测试
        UI测试
        集成测试
    性能与优化
        PageSpeed / Yslow 优化
        加载优化（如gzip压缩、缓存等等）
        性能测试（特别是移动Web）
        可用性
        压缩（如Minify、Uglify、CleanCSS等等）
    设计
        切页面
        线框图（Wireframe）
        响应式设计
        网格布局（Grid Layout）
        Flexbox布局
    SEO
        Sitemap（站点地图）
        内部链接建设
        MicroData / MicroFormat
        页面静态内容生成
        H1、H2、H3和strong使用
        Title、Description优化
        页面静态内容生成
后端程序员
    入门
        HTML / CSS
        编程语言：Java / Python / PHP / Ruby等等
        Web框架，如Spring MVC、Flask、Laravel等等
        HTTP协议基础
        CGI基础
    中级篇
        XML和JSON处理
        数据结构与算法
        面向对象编程
        CMS
        API设计
        网络通信协议，如TCP / Socket
    高级篇
        函数式编程
        领域驱动设计
        MVC架构
        运行环境优化，如JVM
        远程调试
    工程化
        版本管理
        单元测试
        依赖管理
        包管理
    基础设施
        虚拟化，如Docker
        自动化部署
        应用包创建、管理、发布
        发布脚本编写
        Web容器，如Jboss
    缓存篇
        应用层缓存
        平台缓存
        数据库端缓存
        分布式缓存
    数据持久化
        SQL
        NoSQL
        ORM
        DBMS
        搜索引擎
    数据库
        查询性能优化
        结构优化
        主从复制、主主复制等等
        伸缩性与高可用性
        备份恢复与容灾
    安全和加密
        认证与会话管理
        加密解密
        数字签名、数字证书
        加密算法
        XSS/CSRF/SQL注入
    监控
        应用性能监控
        异常监控
        日志
        流量监控
    服务
        RESTful
        SOA
        RPC
        MicroServices
    消息
        JMS
        IPC
        MQ
运维开发者
    入门篇
        编写脚本，如Shell、Perl、Rython等等
        编程语言
        Web应用运行基本原理
        HTTP服务器
        应用容器
        命令行，如awk
        CGI
        修复漏洞
    中级篇
        自动化运维
        GNU/Linux操作系统
        编译
        数据库
    高级篇
        分布式文件系统
        分布式存储系统
    云服务
        存储服务，如AWS S3
        计算服务，如AWS Lambda
        托管服务，如AWS EC2
    安全性
    网络
        CCNP / CCNA
    持续集成
        持续集成工具
        自动构建工具
        依赖管理工具
        版本管理工具
    虚拟化
        应用容器虚拟化，如Docker
        环境虚拟化
        操作系统虚拟化
    自动化 (puppet,chef)
        自动化配置
        自动化部署
        进程管理工具，如Supervisor
    监控
        基础设施监控
        日志管理
        监控服务
    负载均衡
        边缘缓存，如（Varnish）
        DNS负载均衡
        CDN










20180726
主要练习部署 和 负载均衡 知识
web 服务器端下游: tomcat、apache httpd、nginx, uwsgi,
	uwsgi，它类似于nginx，通过一个守护进程把不同的http请求转交给子进程并发处理，并且支持多线程的方式，性能较高，
	与其让一个uwsgi服务跑10个进程，不如开10个uwsgi服务，然后用nginx做负载均衡！
	uwsgi本身的负载均衡没有nginx牛逼。所以阉割掉不用。因此uwsgi退化成了wsgi服务器
	nginx 可以一个ip 地址 配置不同端口来实现在 同一台机子上 访问多个不同的网站!!
	nginx 可以集群部署, 同一个网站,但分布多个主机,多个ip,
		https://www.cnblogs.com/lilongsheng1125/p/4978485.html  (nginx 科普)
		https://www.linuxidc.com/Linux/2017-05/143739.htm 	( Keepalived 和 nginx 配合使用 典型集群部署手把手例子)
		https://www.linuxidc.com/Linux/2017-03/141866.htm	( Keepalived 模式方案 )
			Keepalived 管理多个 nginx 节点,分主备节点,主节点死了,备节点顶上!!
			nginx 节点 实现 web服务的负载管理
Keepalived:是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，
	类似的工具还有heartbeat、corosync、pacemaker。
	但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用












20180727
使用 python3 重新开发 django selfweb项目!!
建立独立环境:
	mkvirtualenv django -p python3
	workon django
	pip install django
	pip install uwsgi
	mkdir selfweb_pyth3 && cd selfweb_pyth3
建立项目
	django-admin startproject selfweb_pyth3 /home/william/full_stack/selfweb_pyth3
建立网站
	django-admin startapp web	
尝试运行: 然后刻登录指定链接测试
	python manage.py runserver
	错误:You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): 
		admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them
	先不处理
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    path('admin/', admin.site.urls),
		    # by william
		    path('',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
如果要局域网的机子能访问自己
	在settings.py文件中，找到ALLOWED_HOSTS=[ ]，在中括号中加入你在局域网中的IP。如我在局域网中的IP为192.168.10.133
	所以设置ALLOWED_HOSTS = [ '192.168.10.133'] 
	python manage.py runserver 0.0.0.0:8000	//执行网站服务,添加向外开放段端口
设置简单高并发网站:(使用 uwsgi 多进程)
	在settings.py文件中，设置 ALLOWED_HOSTS=[ ]
	建立selfweb_pyth3/uwsgi.ini:
		[uwsgi]
		chdir = /home/william/full_stack/selfweb_pyth3
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb_pyth3.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb_pyth3/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
如果要局域网的机子能访问自己
	在settings.py文件中，设置 ALLOWED_HOSTS = [ 'xxx.xxx.xxx.xxx']
	selfweb_pyth3/uwsgi.ini: http = 0.0.0.0:8000 
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//启动服务!!
安装数据库:
	sudo apt-get install mysql-server
	sudo apt-get install mysql-client
	mysql 操作教程看 开发_in_linux_log
	还有django用到的python mysqllib 只支持 2.7
	所以需要:
	pip install PyMySQL
	gedit selfweb_pyth3/__init__.py 
	添加:
	import pymysql
	pymysql.install_as_MySQLdb()
添加数据库 mysql:
	数据库,是django网站各种扩展模块的基础,所以,建站之前先要初始化一个数据库
	当migrate过程时,django会给 selfweb/settings.py->INSTALLED_APPS 里提到的模块都建立相应的表单,
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:3***************7
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	配置工程连接这个数据库: 修改 selfweb_pyth3/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb_pyth3',
		        'USER': 'root',
		        'PASSWORD': '3***************7',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错:
	python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
	补充: 
		db_selfweb_pyth3 并不存在与 selweb网站目录里!!,拷贝移植selfweb网站到新机子时,并不带 db_selfweb_pyth3
		关于如何把 db_selfweb也拷贝过去,日后在探究
创建web模块,及建立自定义model模型
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',	//表示 添加 django管理模块 admin
		    'django.contrib.auth',	//表示 添加 django管理模块 admin
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的model 对应的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True,on_delete=models.CASCADE)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		除了web_blogpost 还有一个web_subject,
		web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项 (一对多原理)
		还多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系(多对多原理)
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	要使用admin管理模块: 需要: selfweb/settings.py -> INSTALLED_APPS 含有:
		'django.contrib.admin',	//表示 添加 django管理模块 admin
		'django.contrib.auth',	//表示 添加 django管理模块 admin
	还需要:selfweb/urls.py -> urlpatterns 含有 url(r'^admin/', admin.site.urls)
	python manage.py createsuperuser	//创建管理者:william:3**7q
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
			Django admin后台管理是不支持显示这种many_to_many关系的,因为 'tags' many_to_many关系
			改成 list_display = ('title', 'create_time', 'subject')
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.		
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
			显然 list_display = ('name') 只有name,一项, 不是一个列表,必须加 , 号
			改成 list_display = ('name',)
		System check identified 3 issues (0 silenced).
		错误,不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	关于 admin 进一步定制:https://www.cnblogs.com/zhming26/p/5767158.html
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功










20180731
目前使用 django2.0
	路径分配要使用通配符的话, 需要 import re_path 使用有正则表达式的路径
	view.py 每个def 一般都是定义一个页面的实现方式,如果要像使用print那样调试,可以使用 assert False 主动触发出错页来代替
	例如:
	def hours_ahead(request, offset):
	    try:
	        offset = int(offset)
	    except ValueError:
	        raise Http404()
	    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
	    assert False
	    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
	    return HttpResponse(html)
	django 使用的网页模板 一般使用 .html后缀名, 这个不是一个严格的 html页面文件,里面夹杂着django的一些自家语法.
	利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射
html常用小知识:
	注释符号
	Html
		单行:<!-- -->
		多行:<!-- -->

	javascript
		单行://
		多行:/*  */
		
	Vbscript
		单行:'
		多行:'
		
	ASP <% %>中： 
		单行：' 
		多行：'
	还有跨浏览器管理


















second_brain
初步架构是 
以行号为基础
每行 一条数据指针,每条指针,指向同一条数据 (针对,上十万行后,出现行位转移问题,)
一般来说,一行一段文字
两张数据表, 一个行号表,一个内容表
每一行都有一个属性字节 0位, 换了行位置, 1位, 改变了内容,
由于 行数据指针制度,所以可以一行放置超文本内容(公式,图片,视频链接!!)
按用户分配负载,和database位置空间,而不是按流量
初步发现,使用django应该并不合适.第一版还是用django 吧

任务一:全页文本框
通过建立 html页模板:
	<input> 单行文本框,好像并不合适 
	<br /> 另起一行
	多行文本框 五行、一行50字的文本框，<textarea name="txt" clos=",50" rows="5" warp="virtual"></textarea>
	但是这种多行文本似乎也不理想
	
	参考CKEditor 5 https://ckeditor.com/ckeditor-5/ 的 在线文本编辑框, 这样就建立了一个简单的在线文本编辑.
	<div class="cc" role="textbox" aria-label="Rich Text Editor, main" contenteditable="true">
		<h2>The three greatest thiou learn from traveling</h2>
	这种文本框比较理想
	role 只是识别标记, aria-label只是注释,暂时都未知如何使用
	contenteditable="true" 才表示 当前的这个 div 块,允许编辑!!

回车键监听
	注意js里 跨浏览器的处理方式:
		<div ...onKeyDown="ifenter(event)" >
		function ifenter(e)
		{
			var x
			if(window.event) // IE8 以及更早版本	
			{
				x=e.keyCode;
			}
			else if(e.which) // IE9/Firefox/Chrome/Opera/Safari
			{
				x=e.which;
			}
			......
		}
	通过js 插入html段落: 网上一个 js 片段:
		window.onload = function(){
		var testingText = '<p>hello</p>'
		var rootElement = document.body;
		var newElement = document.createElement("div");
		var newElementHtmlContent = document.createTextNode(testingText);
		rootElement.appendChild(newElement);
		newElement.appendChild(newElementHtmlContent);
		} 
		这段js 是假设放在 <head>段的
		window.onload 表示当<body>加载显示完毕,即html完全显示后 就执行这个function,
		通过 DOM 动态加载一个新段落 <p>hello</p>
		但是 这只能加载 一段 "<p>hello</p>" 字符窜 而不能真的加载一段<p>段落!!
		以下这段才能成功添加一段段落:
			var testingText = "<p>hello william</p>"
			var ccElement = document.body.getElementsByClassName('cc')
			ccElement[0].insertAdjacentHTML("beforeEnd",testingText);	
		原型：insertAdjacentHTML(swhere,stext) 在指定的地方插入html标签语句
		参数：
			swhere:指定插入html标签语句的地方，有四种值可以用：
			1.beforeBegin:插入到标签开始前
			2.afterBegin:插入到标签开始标记后
			3.beforeEnd:插入到标签结束标记前
			4.afterEnd:插入到标签结束标记后
	按键事件  onkeydown、 onkeypress 和 onkeyup这三个事件句柄:
		按键监听句柄书写 可以 onkeydown 也可以 onKeyDown
		onkeydowm 是比较底层的句柄, 不能识别 组合按键和 按键的复用内容,
			比如, g按键 只能传递按键原码,即大写G字符的字符码,不能传递小写g字符码
			shift+1 并不能传递出 感叹号 ! 的字符码
		onkeypress 高级句柄 能识别 组合按键和 按键的复用内容, g按键 可以识别传递 大写字符码或者小写字符码,
			shift+1 能传递出 感叹号 ! 的字符码
		onkeyup 也是底层句柄	
		就是说 onkeydowm / onkeyup 传递的是按键码, 而 onkeypress 传递的是具体的字符码
		当按键一直按住,相当于 连续触发多次 onkeydowm / onkeypress 事件
		暂时只从 firefox 讨论 !!
			按键事件都会传递一个隐含变量 e , 而 e.which 就是传递过来的字符码数字,
			根据事件句柄类型, e.which要么是按键码, 要么是具体的字符码
			还有两个擦差不多的属性变量 e.keycode  e.charcode ,不过都是在跨浏览器上使用的
		通过 fromCharCode 可以把按键码,字符码转换成实际 字符 变量.
		例如: var keychar = String.fromCharCode(e.which)	
	光标控制!!
		'\r'是回车，使光标到行首，return（carriage return）
		'\n'是换行，使光标下移一格，newline（line feed）
		根据 id 跳到 焦点指定的 段落里文本框,光标直接跳到指定段落里的文本框:
			var fui = document.getElementById('dfg')
			fui.focus(); 
			注意,虽然是再<head>写的代码,但不用document.body.getElementById('dfg') 从<body>段寻找
			直接从全页寻找, 而且不像 class标签 得到的不是数组变量,不用使用 fui[xx]指代
		光标 是选区知识的一个部分,必须系统学习 selection 选区内容
		var sel = getSelection()	//选区
		var node = sel.anchorNode	//开始节点, 节点就是<xx>段落
			//鼠标落到的地方所处的段落就是 选区开始作用的段落 (开始节点)
			<div contenteditable="true"...>
			 	<h2>The three greatest</h2>
				<p>hello</p>
				klkkl
				opp
			</div>
			//当鼠标落到 three 这个地方, 那么此刻选取的开始节点是 <h2>段落 中的 #text 文本段落
			//当鼠标落到 hello 这个地方, 那么此刻选取的开始节点是 <p>段落 中的 #text 文本段落
			//当鼠标落到 kikkl或者 opp 这个地方, 那么此刻选取的开始节点是 <div> 段落中的 #text 文本段落
			//一般用户点击时 selection的 anchorNode 只会落在 各个标签段落中的 #text 文本段落
			//所以 node 值一般是 #text
			//如果要 真正落到指定的 tag段落 例如<div> node:div#dfg.cc,一般是 DOM函数获取
			//真正的 tag段落: 每个tag子段落为占一个偏移位置, 每段文本占一个偏移位置
			//tag段落中的#text 文本段落: 每个字符占一个偏移, 注意回车,缩进什么的也算一个字符
		var number = sel.anchorOffset	//开始节点的偏d移
			//当鼠标落到 The 的 h 之后的地方, 此刻开始节点偏移是从<h2>段落里#text 文本段落的第 2 个位置
			//当鼠标落到 hello 的 o 之前的地方, 此刻开始节点偏移是从<p>段落里#text 文本段落的第 4 个位置
			//当鼠标落到 kikkl 的第一个 k 之前的地方, 此刻开始节点偏移是从<div>段落里#text 文本段落第 2 个位置
			//因为 在 <div>段落里<div>段落里#text 文本段落中</P>之后有一个回车和缩进字符才到达位置 kikkl之前
		var fnode = sel.focusNode 	//结束节点  选区最后的段落,
			//一般情况下,开始节点和结束节点是同一个,所以不知道可以怎么用
		var offset = sel.focusOffset	//结束节点偏移, 也是从结束节点的段落里的第 xx 个位置的意思
		var bool = sel.isCollapsed	//选区的开始和结束位置是否重合
			//当开始节点 == 结束节点, 开始节点偏移==结束节点位置, 选区的开始和结束位置就重合, bool==true
			//这个位置点也是光标闪烁的位置点
			//如果是高亮选择的一块区域, 这一次操作选取的区域为 一个 range
			//当 选择高亮 three,时从左到右选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 4, 结束偏移 9
				isCollapsed :false
			//当 选择高亮 three,时从右到左选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 9, 结束偏移 4
				isCollapsed :false			
			//当 选择高亮从 greatest 的第一个 t 到 hello 的第一个l, 即 test hel :
				开始节点 <h2>  结束节点 <p>
				开始节点偏移 14, 结束偏移 3
				isCollapsed :false
				类似这样的跨节点 选择一块分选区能成,是因为 <div contenteditable="true"...>
		var value = sel.rangeCount	//选区的 分选区 个数
			//通过按住 ctrl 我们 多次操作 间断 高亮选择多块区域
			//每一块都作为一个分选区,统计的数字就是 rangcount
			//然而, 开始节点 结束节点 开始节点偏移 结束偏移  都是最新一个分选区区域的对应的内容
			//而之前分选区的这些参数却未知在哪里
		var typ = sel.type	//当前的选区,当前的分选区的类型
			//一个selection 里 可能有很多分选区成员 包括 多个高亮区域,和一般只有一个光标
			//高亮区域的 type是 range 类型
			//光标的 type 是 Caret 类型, 即 collapsed
			//不论是 光标还是 高亮区域 都算入一个 rangeCount 计数
			//但是 高亮区域 和 光标 不能同时存在,
			//某刻,如果有n个 高亮区域 ,那么 selection.rangeCount:n  selection.type= range
			//某刻有光标,那也只能有一个光标, selection.rangeCount:1  selection.type= Caret
		以上光标内容都是 只读 内容,即只能用特定 api 修改, 不能手动修改
		给选区添加一个range
			var ccElement = document.body.getElementsByClassName('cc') //寻找class="cc"的节点 
			var sel = getSelection()  //获取 此刻的 selection 对象 (选区对象)
			if(sel.rangeCount > 0) sel.removeAllRanges(); 
				//如果此刻你见到有光标/高亮区域,说明selection里有分选区成员,这里是都清除他们
			var range = document.createRange();	//新建一个range
  			range.selectNode(ccElement[0]);	//把节点里的所有内容,都放入这个range
			sel.addRange(range);	
				//把这个range 添加到 selection里, 这时,selection 只有一个包含节点内所有内容的高亮区域
				//这时 selection.rangeCount:1  selection.type= range
		光标跳到指定位置:	
			sel.collapse(ccElement[0],1)
				//ccElement[0] 指是 光标要停在的节点, 是tag节点,而不是tag节点里的#text段落
				//1 是 在这节点上对应的偏移地方
				//所以 一个子段落是算 1 个偏移
				//一段字符串算 1 个偏移
				//注意 html 书写为了美观,使用大量缩进键,但是缩进键也算字符串里的字符
				//所以使用这个要非常谨慎
		        sel.collapseToEnd()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最后的那个点.
				//让光标跳到最后的那个逻辑位置
		        sel.collapseToStart()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最前的那个点.
				//让光标跳到最前的那个逻辑位置
		判断指定节点内容是否选上,光标是否在指定节点
			console.log(sel.containsNode(ccElement[0], true))
				//判断 selection对象 比如 光标 落到指定的 节点上,  
				//判断 selection的高亮选区 有没有在 指定节点 选取了部分内容
  			console.log(sel.containsNode(ccElement[0], false))
				//判断 selection的高亮选区 有没有在 指定节点 选取了全部内容
 		删除指定高亮的 文本内容!!
			sel.deleteFromDocument()
		选取扩充至:	
			sel.extend(nodeA, offsetA)	
				//高亮选取一片区域range, 
				//以当前节点,当前偏移位置 (或者某自定义节点,节点偏移)为 开始节点,开始节点偏移, 
				//以 nodeA 为结束节点, offsetA为结束节点偏移
		获选区中其中的一个range
			首先,我们知道,打开的 html 页面,只有一个 selection 对象,而且一直存在, 只不过他的内容不断变换
			selection 里内容,要么是光标,要么是高亮选区range
			如果是光标, 开始节点==结束节点,开始节点偏移==结束节点偏移, rangeCount:1
			Selection { anchorNode: #text, anchorOffset: 17, 
				    focusNode: #text, focusOffset: 17, 
				    isCollapsed: true, rangeCount: 1, 
				    type: "Caret", caretBidiLevel: 0 }
			如果是高亮选区, selection  选中了 多少个高亮选区,就有多少个rangeCount,
			而开始节点,结束节点,开始节点偏移,结束节点偏移 都是最后加入那一个 高亮选区 的参数,
			Selection { anchorNode: #text, anchorOffset: 28, 
				    focusNode: #text, focusOffset: 34, 
				    isCollapsed: false, rangeCount: 4, 
				    type: "Range", caretBidiLevel: 0 }
			然而,如何获得 selection 存着的,靠前的高亮选区 range 呢? 
			range = sel.getRangeAt(index)
				//获得 selection 里 指定序号的 range ,序号0开始 
				//例如 rangeCount:7 表示有7个range ,序号6表示第7个range
		量化移动光标,量化选range
			sel.modify(alter, direction, granularity)
			alter: move 移动光标
			       extend 选range区域
			directtion: forward / right 向前移动/选 (向右)
				    backward / left 向后移动/选 (向左)
			granularity: (量化值)
				"character",按字符
				"word", 按单词
				"sentence", 
				"line", 
				"paragraph", 
				"lineboundary", 
				"sentenceboundary", 
				"paragraphboundary", 
				"documentboundary".
			例如 The three greatest thiou learn from traveling
				sel.modify("move", "forward", "word")
				//点击 greatest 的 a前面时, 光标会出现在最后的t后面
				sel.modify("extend", "backward", "word")
				//点击 thiou 的 o 前面时, thi 被高量选择!			 
		删除 selection 里的 所有 range:  sel.removeAllRanges();
		删除 selection 里的 指定 range:  sel.removeRange(sel.getRangeAt(index))	
		选择节点里的所有内容,包括各种嵌入子节点: sel.selectAllChildren(parentNode)
		通过代码指定一个 selection.
			sel.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)
			例子:
				var one = document.querySelector('.one');
				var two = document.querySelector('.two');
				var aOffset = document.getElementById('aOffset');
				var fOffset = document.getElementById('fOffset');
			    	selection.setBaseAndExtent(one, aOffset.value, two, fOffset.value);
			然后你就看到一段 指定的内容 高亮选中了,此刻 sslection 里也仅有这个range
		sel.toString();
			把 selection 中的文本内容全部转化策成 字符串!!	
	
文本边框消失 CSS !! 
	通过 css实现,例如 <style>#edit{height:500px;width:500px;border:50px none transparent;outline:none}</style>
	首先 boarder:none,表示不显示边框,
	outline:none,也表示 当文本框被点击focus时,边框的显示, 也为none
文本框字体 CSS !!
	大小:	h1 {font-size:3.75em;} /* 60px/16=3.75em */
		h2 {font-size:2.5em;}  /* 40px/16=2.5em */
		p {font-size:0.875em;} /* 14px/16=0.875em */ 	
	颜色:
		直接用 color:#F00;  三原色组合 F00 
背景
	body{background:#001122}
django 外部css 外部script:
	注意没有和nginx一起部署时，DEBUG = True 才能访问django静态资源。
	django 使用 外部css设置简单,但要先理解每一个参数,所以比较耗时间,要引入外部 css 就是相当于引入外部静态资源
	先看 settings.py
	STATIC_URL = '/static/'		//必要,这个是告诉 html可以直接以这个/static为url头,直接获取各静态资源 
					//比如远程客户机浏览器访问
					// http://127.0.0.1:8000/home/william/full_stack/selfweb_pyth3/static/css/base.css
					//可以改为: http://127.0.0.1:8000/tatic/css/base.css 就能访问
					//但似乎 没有也可以实现, 只要有 STATICFILES_DIRS,所以感觉可有可无,可能在真实部署时才有用吧
	STATIC_ROOT = os.path.join(BASE_DIR, 'static')	  //只是声明了一个路径, 没有特殊意义 ,所以非必要 
					//具体线路是:/home/william/full_stack/selfweb_pyth3/static
					//一般也可以这样声明
					//STATIC_ROOT = os.path.join(BASE_DIR, 'static').replace('\\', '/')
	STATICFILES_DIRS = (...)				//必要,这里才是真正定义外部可访问的静态资源链接
	例子一: STATICFILES_DIRS = ( 
			os.path.join(BASE_DIR, 'static'),  //假如 BASE_DIR: /home/william/full_stack/selfweb_pyth3
			)				   //那么 把 BASE_DIR 接上 static 得到一条具体路径:
							   // /home/william/full_stack/selfweb_pyth3/static
							   //这条路径就是 被添加上的一条静态资源路径,假如路径里有文件 body.css yilaao.jpg
							   //浏览器直接访问 http://127.0.0.1:8000/static/yiliao.jpg 就可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/body.css">
							   //就可以加载 对应的 css文件
	例子二:STATICFILES_DIRS = ( 
		     ('css', os.path.join(BASE_DIR, 'static')), //具体线路是:/home/william/full_stack/selfweb_pyth3/static
			)				   //浏览器直接访问 http://127.0.0.1:8000/static/css/yiliao.jpg 可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/css/body.css">
							   //就可以加载 对应的 css文件
	例子三:STATICFILES_DIRS = (
	    ('css', os.path.join(STATIC_ROOT, 'css').replace('\\', '/')),  
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/css
							//访问线路 http://127.0.0.1:8000/static/css/
	    ('img', os.path.join(STATIC_ROOT, 'images').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/images
							//访问线路 http://127.0.0.1:8000/static/img/
	    ('fonts', os.path.join(STATIC_ROOT, 'fonts').replace('\\', '/')), 
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/fonts
							//访问线路 http://127.0.0.1:8000/static/fonts/
	    ('js', os.path.join(STATIC_ROOT, 'js').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/js
							//访问线路 http://127.0.0.1:8000/static/js/
	)
	settings.py设定后,(重点设置是STATICFILES_DIRS) 把要用到的文件放到指定 具体地址后,
	编译 django python manage.py migrate. 

	然后就可以再 .html 上使用外部 css 文件
	有两种使用方式: 
	第一种: 使用 django 的 html 语法.
	{% load static %}	// 在 <!DOCTYPE html> 之前加入
	<link rel="stylesheet" href="{% static '/css/index.css' %}">	
	第二种: 使用标准的 html语法
	<link rel="stylesheet" href="/static/css/body.css">	

	在 .html 上使用外部 js 文件
	<script type="text/javascript" src="/static/js/login.js"></script>


<link>标签的一些补充: 1. 定义文档与外部资源的关系；2. 是链接样式表。
	rel各个属性值配置的意思：
              Alternate -- 定义交替出现的链接 
              Stylesheet -- 定义一个外部加载的样式表 
              Start -- 通知搜索引擎,文档的开始 
              Next -- 记录文档的下一页.(浏览器可以提前加载此页) 
              Prev -- 记录文档的上一页.(定义浏览器的后退键) 
              Contents 
              Index -- 当前文档的索引 
              Glossary -- 词汇 
              Copyright -- 当前文档的版权 
              Chapter -- 当前文档的章节 
              Section -- 作为文档的一部分 
              Subsection -- 作为文档的一小部分 
              Appendix -- 定义文档的附加信息 
              Help -- 链接帮助信息 
              Bookmark -- 书签 	
	例如, <link rel="stylesheet" href="css/bootstrap.css">，引入外部的css文件时，一定不能忘记rel属性的配置。

要着重掌握对 contenteditable 里 innertext 的 光标定位问题!! 还有获取光标所在节点
	<div id="dw" contenteditable="true"></div>
	$('#dw')[0].innerHTML
	console.log($('#dw')[0].innerHTML );就是div中的内容 

	数字转换:https://www.jb51.net/article/45331.htm
	javascript自带parseInt(str)函数
	参数：str，为一个包含数字的字符串
	返回值：
	如果str中最前面几个字符是数字，则返回该数字； 如果str第一个字符不是数字，返回NaN。
	例如：
	parseInt("1234"); //返回1234
	parseInt("1234A"); //返回1234
	parseInt("1234A5"); //返回1234
	parseInt("A1234"); //返回NaN 

	字符窜的处理:https://www.cnblogs.com/l1pe1/p/6197371.html
	



代码片段:
回车后插入字符窜再定位事件方法1:
	e.preventDefault();	//阻止回车原来事件 原来回车事件会插入一个 <div><br/></div> 段
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点		
	var range = document.createRange()	//创建一个range
	range.selectNodeContents(o) 		//把节点里的所有内容都选上,即整个文本段选上
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range
	sel.collapseToEnd()			//光标跑到 selection 逻辑最后的那个 range 里的最后一个位置,
						//就是 刚刚添加的 div文本节点的文本段的最后一个位置
回车后插入字符窜再定位事件方法2:
	e.preventDefault();	//阻止回车原来事件
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点	
	var endOffset = o.childNodes.length;	//获取 o 节点 的子节点个数,由于只有一段文本,一段文本作为一个子节点,所以是1 
	var range = document.createRange()	//创建一个range
	range.setEnd(o,endOffset)		// range 开始地方 在o节点里的endOffset位置
	range.setStart(o,endOffset)		// range 结束地方 在o节点里的endOffset位置
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range,由于setEnd,setStart 设置同一个地方
						//所以光标处于这个位置中,即 div文本节点的文本段的最后一个位置
中段插入方法1:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode.parentElement  	//得到当前 节点的父节点, 
	//注意 #text的父节点是<div>文本节点, 但是 <div>文本节点 的父节点是 id=editor节点
	//注意 光标在#text时,在 <div></div>中任意字符旁边的位置,
	//注意 光标在<div>文本节点时,在 <div></div>中字符串之前或之后的位置,
	//所以需要做if判断!! 							
	if (El == document.getElementById('editor'))
	{	El.insertAdjacentHTML("beforeEnd",htmlcontent) }
	else
	{	El.insertAdjacentHTML("afterEnd",htmlcontent); 	}
中段插入方法2并定位下一行:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode
	if (El.parentElement != document.getElementById('editor'))
	{	El = El.parentElement }
	El.insertAdjacentHTML("afterEnd",htmlcontent)	//确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
	var endOffset = o.childNodes.length;
	var range = document.createRange()	
	range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
	range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
	sel.removeAllRanges()
	sel.addRange(range)
中段插入自调整行号定位下一行
	e.preventDefault();	//阻止回车原来事件
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		linenum = linenum + 1	
		var htmlcontent = "<div>" + linenum + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent) //确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var El1 = El.nextSibling
	El1 = El1.nextSibling
	for (;El1 != null;)		//自调整行号
	{
	var index = El1.innerText.indexOf(":")	//获取第一个":"字符的位置
	var str = El1.innerText.substring(index)
	linenum = linenum + 1
	El1.innerText = linenum + str	
	El1 = El1.nextSibling
	}
		var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
		var endOffset = o.childNodes.length;
		var range = document.createRange()	
		range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
		range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
		sel.removeAllRanges()
		sel.addRange(range)	//定位下一行
加上行号对齐,字符串调整!!(基本完成回车按键, 有bug)
	//阻止回车原来事件
		e.preventDefault();	
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length	
	//前方行号对齐	
		var Ell = document.getElementById('editor').lastChild	
		var lastline = parseInt(Ell.innerText)+1	//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 	
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		var cnt3 = El.innerText.indexOf(":")
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'	
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}

		str0 = str0 + linenum

		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling  	//擦入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )	//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					console.log("templine:"+ templine +"cnt5:"+ cnt5 + "cnt6:" + cnt6)			
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段的 cnt4 == 0 导致,
					//不是最后一阶段 cnt4 绝不等于 0 ,所以 cnt5 绝对不会出现 -1.	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转 以及 附加的字符串处理: 回车时,把光标后的字符串放到插入行)
		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,会添加上述字符串处理
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		sel.removeAllRanges()
		sel.addRange(range)	//简单光标跳转
		if( (range2 == "nothing to do") || (range2.startContainer == El) ) //range2.startContainer也是一个节点
		{	//console.log("nothing to do")	}
		else
		{
			var chofst = range2.startOffset		//光标未跳转所在的文本段位置偏移	
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	console.log("nothing to do 2")	}
			else
			{
				//console.log(chofst)
				//console.log(range2.startContainer.length)			
				var fenhao = o.innerText.indexOf(":")		//插入行的第一个分号的位置
				var str1 = El.innerText.substring(chofst)	//未跳转前光标位置后的字符串
				//console.log(range2)
				//console.log(str1)
				o.innerText = o.innerText + str1		//未跳转前光标位置后的字符串添加到擦插入行
				El.innerText = El.innerText.substr(0,chofst)	//原来位置上的删掉
			
			//以下表演如何把光标重新定位到 #text 文本指定位值
				var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
										//o节点的 子节点是我们寻寻觅觅的 #text 节点
				var range1 = document.createRange()
				range1.selectNodeContents(oo) //把 oo 节点里的所有内容都选上
				range1.setEnd(oo,fenhao+1)	// range1 开始地方 #text 分号后的位置
				range1.setStart(oo,fenhao+1)	// range1 结束地方 #text 分号后的位置
				sel.removeAllRanges()
				sel.addRange(range1)		//光标跳转到插入行的分号后位置
								//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
								//所以浏览器知道我们所指向的是哪个 #text节点
			}
		
		}
回车跳转行号对齐字符窜调整,(解除上述bug)
	//阻止回车原来事件
		e.preventDefault();	//阻止回车原来事件
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length
	//获取光标后字符串
		var str1 = null
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,获取光标后字符串
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		if( (range2 == "nothing to do") || (range2.startContainer == El) )  //判断range在#text节点里,还是<div>节点,
		{	//console.log("nothing to do")	
		}
		else						//range在#text节点里的时候,才继续
		{
			var chofst = range2.startOffset
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	//console.log("nothing to do 2")	
			}
			else
			{
				str1 = El.innerText.substring(chofst)
			}
		
		}	

	//前方行号对齐
		var Ell = document.getElementById('editor').lastChild
		var lastline = parseInt(Ell.innerText)+1		//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 
		var cnt3 = El.innerText.indexOf(":")
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}
		str0 = str0 + linenum
		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling		//插入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转	

		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方 
		//光标简单跳转
		sel.removeAllRanges()	
		sel.addRange(range)	
		//如果 回车后有字符串, 则重新光标跳转
		if( str1 != null )
		{
			
			var fenhao = o.innerText.indexOf(":")
			o.innerText = o.innerText + str1		//str1 放到插入行
			El.innerText = El.innerText.substr(0,chofst)  	//原来位置上的删掉
				
			var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
									//o节点的 子节点是我们寻寻觅觅的 #text 节点
			var range1 = document.createRange()
			range1.selectNodeContents(oo) //把节点里的所有内容都选上
			range1.setEnd(oo,fenhao+1)	// range 开始地方 #text 分号后的位置
			range1.setStart(oo,fenhao+1)	// range 结束地方 #text 分号后的位置
			sel.removeAllRanges()
			sel.addRange(range1)		//光标跳转到插入行的分号后位置
							//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
							//所以浏览器知道我们所指向的是哪个 #text节点
		}
TAB基本实现缩进	(但是 未处理缩进显示问题)
	//阻止tab原来事件
		e.preventDefault()
	//实现
		var sel = getSelection()
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))	//在selection在 #text 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer.parentNode
         		console.log(range)
			var str = patN.innerText.substr(0,range.startOffset)
			var str1 = patN.innerText.substring(range.startOffset)
			var offset = str.length +1
			patN.innerText = str + "\t" + str1
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])	//patN.childNodes[0] 指修改后的 #text
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)		
		}
		else if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))	//在selection在 <div> 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer	
			var str = patN.innerText
			var offset = str.length +1
			patN.innerText = str + "\t"
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)
		}	
退格按键 有bug 未实现 缩行操作
	var sel = getSelection()
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer.parentNode
		if( (patN.innerText.indexOf(":"))+1 ==  range.startOffset )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)			
		}
	}
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer
		if( (patN.innerText.indexOf(":"))+1 ==  patN.innerText.length )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)
			
		}
	}
退格键,基本完成
	//初始化
		var sel = getSelection()
		var range
		var Nod
		var preN = null
		var range1
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer.parentNode
			if( (Nod.innerText.indexOf(":"))+1 ==  range.startOffset )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer
			if( (Nod.innerText.indexOf(":"))+1 ==  Nod.innerText.length )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if(!preN)	//如果 检测到退到第 1 行,则退无可退
		{	return 1		}
		else
		{	var creN = preN 	}
		var LaN = document.getElementById('editor').lastChild
		var lastline_bf = parseInt(LaN.innerText)
		var lastline_af = parseInt(LaN.innerText) - 1
	//前行号对齐
		if (lastline_bf.toString().length - lastline_af.toString().length ) //行号位数少1
		{
			var cnt = parseInt(Nod.innerText) - 1 
			for(;cnt;)
			{
				preN.innerText = preN.innerText.substr(1,preN.innerText.length)
				preN = preN.previousSibling
				cnt--
			}
		}
	//后行号对齐 不管 行号位数是否少1		
		var NexN = Nod.nextSibling
		if (NexN != null)
		{	var linenum = parseInt(NexN.innerText) - 2 }	//复用 回车片段对应修改
		var lastline = parseInt(LaN.innerText) - 1
		var cnt5 = 0
		var index
		var str
		var num0 = null
		var num = null
		for (;NexN != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = NexN.innerText.indexOf(":")
			str = NexN.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			NexN.innerText = num + str
			NexN = NexN.nextSibling
		}	
	//缩行
		Nod.remove()
	//跳转
		range1 = document.createRange() 
		range1.selectNodeContents(creN)
		range1.collapse(false)
		sel.removeAllRanges()
		sel.addRange(range1)
方向左键
if (x == 37 ) //方向左键
	{
		var sel = getSelection()
         		console.log(sel)
		if ( (sel.anchorNode.nodeType == 3) && (sel.anchorNode.parentNode.innerText.indexOf(':') + 1 == sel.anchorOffset ) )
		{	e.preventDefault()	}
		if ( (sel.anchorNode.nodeType == 1) && (sel.anchorNode.innerText.indexOf(':') + 1 == sel.anchorNode.innerText.length ))
		{	e.preventDefault()	}
	}
以上代码片段 仅仅基于 纯文本记录下的操作



html 转移字符: ISO Latin-1字符集: 
&#09; — 制表符Horizontal tab 			&#10; — 换行Line feed 			&#13; — 回车Carriage Return 
&#32; — Space 					! &#33; — 惊叹号Exclamation mark 	” &#34; &quot; 双引号Quotation mark 
# &#35; — 数字标志Number sign 			$ &#36; — 美元标志Dollar sign 		% &#37; — 百分号Percent sign 
& &#38; &amp; Ampersand 			‘ &#39; — 单引号Apostrophe 		( &#40; — 小括号左边部分Left parenthesis 
) &#41; — 小括号右边部分Right parenthesis 	* &#42; — 星号Asterisk 			+ &#43; — 加号Plus sign 
, &#44; — 逗号Comma 				- &#45; — 连字号Hyphen 			. &#46; — 句号Period (fullstop) 
/ &#47; — 斜杠Solidus (slash) 			0 &#48; — 数字0 Digit 0 		1 &#49; — 数字1 Digit 1
2 &#50; — 数字2 Digit 2 			3 &#51; — 数字3 Digit 3 		4 &#52; — 数字4 Digit 4 
5 &#53; — 数字5 Digit 5 			6 &#54; — 数字6 Digit 6 		7 &#55; — 数字7 Digit 7 
8 &#56; — 数字8 Digit 8 			9 &#57; — 数字9 Digit 9 		: &#58; — 冒号Colon 
; &#59; — 分号Semicolon 			< &#60; &lt; 小于号Less than 		= &#61; — 等于符号Equals sign 
> &#62; &gt; 大于号Greater than 		? &#63; — 问号Question mark 		@ &#64; — Commercial at 
A &#65; — 大写A Capital A 			B &#66; — 大写B Capital B 		C &#67; — 大写C Capital C 
D &#68; — 大写D Capital D 			E &#69; — 大写E Capital E 		F &#70; — 大写F Capital F 
G &#71; — 大写G Capital G 			H &#72; — 大写H Capital H 		I &#73; — 大写J Capital I 
J &#74; — 大写K Capital J 			K &#75; — 大写L Capital K 		L &#76; — 大写K Capital L 
M &#77; — 大写M Capital M 			N &#78; — 大写N Capital N 		O &#79; — 大写O Capital O 
P &#80; — 大写P Capital P 			Q &#81; — 大写Q Capital Q 		R &#82; — 大写R Capital R 
S &#83; — 大写S Capital S 			T &#84; — 大写T Capital T 		U &#85; — 大写U Capital U 
V &#86; — 大写V Capital V 			W &#87; — 大写W Capital W 		X &#88; — 大写X Capital X 
Y &#89; — 大写Y Capital Y 			Z &#90; — 大写Z Capital Z 
[ &#91; --- 中括号左边部分Left square bracket 	\ &#92; --- 反斜杠Reverse solidus (backslash) 
] &#93; — 中括号右边部分Right square bracket 	^ &#94; — Caret 			_ &#95; — 下划线Horizontal bar (underscore) 
` &#96; — 尖重音符Acute accent 			a &#97; — 小写a Small a 
b &#98; — 小写b Small b 			c &#99; — 小写c Small c 		d &#100; — 小写d Small d 
e &#101; — 小写e Small e 			f &#102; — 小写f Small f 		g &#103; — 小写g Small g 
h &#104; — 小写h Small h 			i &#105; — 小写i Small i 		j &#106; — 小写j Small j 
k &#107; — 小写k Small k 			l &#108; — 小写l Small l 		m &#109; — 小写m Small m 
n &#110; — 小写n Small n 			o &#111; — 小写o Small o 		p &#112; — 小写p Small p 
q &#113; — 小写q Small q 			r &#114; — 小写r Small r 		s &#115; — 小写s Small s 
t &#116; — 小写t Small t 			u &#117; — 小写u Small u 		v &#118; — 小写v Small v 
w &#119; — 小写w Small w 			x &#120; — 小写x Small x 		y &#121; — 小写y Small y 
z &#122; — 小写z Small z 			{ &#123; — 大括号左边部分Left curly brace 
| &#124; — 竖线Vertical bar 			} &#125; — 大括号右边部分Right curly brace 
~ &#126; — Tilde 				— &#127; — 未使用Unused 		&#160; &nbsp; 空格Nonbreaking space 
? &#161; &iexcl; Inverted exclamation 		￠ &#162; &cent; 货币分标志Cent sign 	￡ &#163; &pound; 英镑标志Pound sterling 
¤ &#164; &curren; 通用货币标志General currency sign 
￥ &#165; &yen; 日元标志Yen sign 		| &#166; &brvbar; or &brkbar; 断竖线Broken vertical bar 
§ &#167; &sect; 分节号Section sign 		¨ &#168; &uml; or &die; 变音符号Umlaut 
? &#169; &copy; 版权标志Copyright 		a &#170; &ordf; Feminine ordinal 
? &#171; &laquo; Left angle quote, guillemet left 
? &#172; &not Not sign 				? &#173; &shy; Soft hyphen 		? &#174; &reg; 注册商标标志Registered trademark 
ˉ &#175; &macr; or &hibar; 长音符号Macron accent ° &#176; &deg; 度数标志Degree sign 
± &#177; &plusmn; 加或减Plus or minus 		2 &#178; &sup2; 上标2 Superscrīpt two 	3 &#179; &sup3; 上标3 Superscrīpt three 
′ &#180; &acute; 尖重音符Acute accent 		μ &#181; &micro; Micro sign 		? &#182; &para; Paragraph sign 
? &#183; &middot; Middle dot 			? &#184; &cedil; Cedilla 		1 &#185; &sup1; 上标1 Superscrīpt one 
o &#186; &ordm; Masculine ordinal 		? &#187; &raquo; Right angle quote, guillemet right 
? &#188; &frac14; 四分之一Fraction one-fourth 	? &#189; &frac12; 二分之一Fraction one-half 
? &#190; &frac34; 四分之三Fraction three-fourths ? &#191; &iquest; Inverted question mark 
à &#192; &Agrave; Capital A, grave accent 	á &#193; &Aacute; Capital A, acute accent 
? &#194; &Acirc; Capital A, circumflex 		? &#195; &Atilde; Capital A, tilde 	? &#196; &Auml; Capital A, di?esis / umlaut 
? &#197; &Aring; Capital A, ring 		? &#198; &AElig; Capital AE ligature 	? &#199; &Ccedil; Capital C, cedilla 
è &#200; &Egrave; Capital E, grave accent 	é &#201; &Eacute; Capital E, acute accent 
ê &#202; &Ecirc; Capital E, circumflex 		? &#203; &Euml; Capital E, di?esis / umlaut 
ì &#204; &Igrave; Capital I, grave accent 	í &#205; &Iacute; Capital I, acute accent 
? &#206; &Icirc; Capital I, circumflex 		? &#207; &Iuml; Capital I, di?esis / umlaut 
D &#208; &ETH; Capital Eth, Icelandic 		? &#209; &Ntilde; Capital N, tilde 	ò &#210; &Ograve; Capital O, grave accent 
ó &#211; &Oacute; Capital O, acute accent 	? &#212; &Ocirc; Capital O, circumflex 	? &#213; &Otilde; Capital O, tilde 
? &#214; &Ouml; Capital O, di?esis / umlaut 	× &#215; &times; 乘号Multiply sign 	? &#216; &Oslash; Capital O, slash 
ù &#217; &Ugrave; Capital U, grave accent 	ú &#218; &Uacute; Capital U, acute accent 
? &#219; &Ucirc; Capital U, circumflex 		ü &#220; &Uuml; Capital U, di?esis / umlaut 
Y &#221; &Yacute; Capital Y, acute accent 	T &#222; &THORN; Capital Thorn, Icelandic 
? &#223; &szlig; Small sharp s, German sz 	à &#224; &agrave; Small a, grave accent 
á &#225; &aacute; Small a, acute accent 	a &#226; &acirc; Small a, circumflex 
? &#227; &atilde; Small a, tilde 		? &#228; &auml; Small a, di?esis / umlaut 
? &#229; &aring; Small a, ring 			? &#230; &aelig; Small ae ligature 
? &#231; &ccedil; Small c, cedilla 		è &#232; &egrave; Small e, grave accent 
é &#233; &eacute; Small e, acute accent 	ê &#234; &ecirc; Small e, circumflex 
? &#235; &euml; Small e, di?esis / umlaut 	ì &#236; &igrave; Small i, grave accent 
í &#237; &iacute; Small i, acute accent 	? &#238; &icirc; Small i, circumflex 
? &#239; &iuml; Small i, di?esis / umlaut 	e &#240; &eth; Small eth, Icelandic 
? &#241; &ntilde; Small n, tilde 		ò &#242; &ograve; Small o, grave accent 
ó &#243; &oacute; Small o, acute accent 	? &#244; &ocirc; Small o, circumflex 
? &#245; &otilde; Small o, tilde 		? &#246; &ouml; Small o, di?esis / umlaut 
÷ &#247; &divide; 除号Division sign 		? &#248; &oslash; Small o, slash 
ù &#249; &ugrave; Small u, grave accent 	ú &#250; &uacute; Small u, acute accent 
? &#251; &ucirc; Small u, circumflex 		ü &#252; &uuml; Small u, di?esis / umlaut 
y &#253; &yacute; Small y, acute accent 	t &#254; &thorn; Small thorn, Icelandic 
? &#255; &yuml; Small y, umlaut 		symbols, mathematical symbols, and Greek letters 
? &fnof; 	Α &Alpha; 	Β &Beta; 	Γ &Gamma; 	Δ &Delta; 	Ε &Epsilon; 	Ζ &Zeta; 	Η &Eta; 
Θ &Theta; 	Ι &Iota; 	Κ &Kappa; 	Λ &Lambda; 	Μ &Mu; 		Ν &Nu; 		Ξ &Xi; 		Ο &Omicron; 
Π &Pi; 		Ρ &Rho; 	Σ &Sigma; 	Τ &Tau; 	Υ &Upsilon; 	Φ &Phi; 	Χ &Chi; 	Ψ &Psi; 
Ω &Omega; 	α &alpha; 	β &beta; 	γ &gamma; 	δ &delta; 	ε &epsilon; 	ζ &zeta; 	η &eta; 
θ &theta; 	ι &iota; 	κ &kappa; 	λ &lambda; 	μ &mu; 		ν &nu; 		ξ &xi; 		ο &omicron; 
π &pi; 		ρ &rho; 	? &sigmaf; 	σ &sigma; 	τ &tau; 	υ &upsilon; 	φ &phi; 	χ &chi; 
ψ &psi; 	ω &omega; 	? &thetasym; 	? &upsih; 	? &piv; 	? &bull; 	… &hellip; 	′ &prime; 
″ &Prime; 	￣ &oline; 	? &frasl; 	? &weierp; 	? &image; 	? &real; 	? &trade; 	? &alefsym; 	
← &larr; 	↑ &uarr; 	→ &rarr; 	↓ &darr; 	? &harr; 	? &crarr; 	? &lArr; 	? &uArr; 
? &rArr; 	? &dArr; 	? &hArr; 	? &forall; 	? &part; 	?&exist; 	?&empty; 	? &nabla; 
∈ &isin; 	? &notin; 	? &ni; 		∏ &prod; 	∑ &sum; 	? &minus; 	?&lowast; 	√ &radic; 
∝ &prop; 	∞ &infin; 	∠ &ang; 	∧ &and; 	∨ &or; 	∩ &cap; 	∪ &cup; 	∫ &int; 
∴ &there4; 	～ &sim; 	? &cong; 	≈ &asymp; 	≠ &ne; 		≡ &equiv; 	≤ &le; 		≥ &ge; 
? &sub; 	? &sup; 	? &nsub; 	?&sube; 	? &supe; 	⊕ &oplus; 	? &otimes; 	⊥ &perp; 
? &sdot; 	?&lceil; 	? &rceil; 	? &lfloor; 	?&rfloor; 	? &lang; 	? &rang; 	? &loz; 
? &spades; 	? &clubs; 	? &hearts; 	? &diams; 
markup-significant and internationalization characters: 
“ &quot; 	& &amp; 	< &lt; 		> &gt; 		? &OElig; 	? &oelig; 	? &Scaron; 	? &scaron; 
? &Yuml; 	? &circ; 	? &tilde; 	&ensp; 		&emsp; 		&thinsp; 	? &zwnj; 	? &zwj; 	
? &lrm; 	?&rlm; 		– &ndash; 	— &mdash; 	‘ &lsquo; 	’ &rsquo; 	? &sbquo; 	“ &ldquo; 
” &rdquo; 	? &bdquo; 	?&dagger; 	? &Dagger; 	‰ &permil; 	? &lsaquo; 	? &rsaquo; 	€ &euro; 



浮窗代码片段:
新闻弹窗: https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  //新闻弹窗
	<head>
	<meta charset="utf-8">
	<title>jquery漂浮广告代码</title>
	<script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	<style>
	</style>
	</head>
	<body>
	<div id="imgDiv" style="position:absolute;left:50px;top:60px;">
	    <div id="a" style="width:20px;height:20px;position:absolute;left:160px;background:salmon;text-align: center;">×</div>
	    <!-- <img src="01.jpg" border="0" /> -->
	    <div style="width:180px;height:180px;background:red;"></div>
	</div>
	 
	<script>
	var xin = true,
	    yin = true;
	var step = 1;
	var delay = 10;
	var $obj;
	$(function() {
	    $obj = $("#imgDiv");
	    var time = window.setInterval("move()", delay);
	    $obj.mouseover(function() {
	        clearInterval(time)
	    });
	    $obj.mouseout(function() {
	        time = window.setInterval("move()", delay)
	    });
	});
	 
	function move() {
	    var left = $obj.offset().left;
	    var top = $obj.offset().top;
	    var L = T = 0; //左边界和顶部边界
	    var R = $(window).width() - $obj.width(); // 右边界
	    var B = $(window).height() - $obj.height(); //下边界
	 
	    //难点:怎样判断广告的4个边框有没有超出可视化范围!
	    if (left < L) {
	        xin = true; // 水平向右移动
	    }
	    if (left > R) {
	        xin = false;
	    }
	    if (top < T) {
	        yin = true;
	    }
	    if (top > B) {
	        yin = false;
	    }
	    //根据有没有超出范围来确定广告的移动方向
	    left += step * (xin == true ? 1 : -1);
	    top  += step * (yin == true ? 1 : -1);
	    // 给div 元素重新定位
	    $obj.offset({
	        top: top,
	        left: left
	    })
	}
	    //关闭
	$(function() {
	    $("#a").click(function() {
	        var b = $("#a").parent();
	        $(b).remove();
	    })
	})
	</script>
	</body>
浮窗广告: https://blog.csdn.net/Jensen_Yao/article/details/64926666
	<style type=text/css>
	  div#roll {
		width: 100px; color: #fff; position: absolute; height: 100px; background-color: #000
	}
	</style>
	<body>
	<H2>JS全屏漂浮广告，移入光标停止移动</H2>
	<div id="roll">我是广告</div>
	<script type=text/javascript>
	  var ggRoll = {
	    roll: document.getElementById("roll"),
	    speed: 20,
	    statusX: 1,
	    statusY: 1,
	    x: 100,
	    y: 300,
	    winW: document.documentElement.clientWidth - document.getElementById("roll").offsetWidth,
	    winH: document.documentElement.clientHeight - document.getElementById("roll").offsetHeight,
	    Go: function () {
	       this.roll.style.left = this.x + 'px';
	       this.roll.style.top = this.y + 'px';
	 
	       this.x = this.x + (this.statusX ? -1 : 1)
	       if (this.x < 0) { this.statusX = 0 }
	       if (this.x > this.winW) { this.statusX = 1 }
	 
	       this.y = this.y + (this.statusY ? -1 : 1)
	       if (this.y < 0) { this.statusY = 0 }
	       if (this.y > this.winH) { this.statusY = 1 }
	 
	     }
	  };
	    var interval = setInterval("ggRoll.Go()", ggRoll.speed);
	    ggRoll.roll.onmouseover = function () { clearInterval(interval) };
	    ggRoll.roll.onmouseout = function () { interval = setInterval("ggRoll.Go()", ggRoll.speed) };
	</script>
	</body>	
固定浮窗: https://www.jb51.net/article/65211.htm
	<style>
	* { font-size:12px; font-family:Verdana,宋体; }
	html, body { margin:0px; padding:0px; overflow:hidden; }
	.b { margin:0px; padding:0px; overflow:auto; }
	.line0 { line-height:20px; background-color:lightyellow;
	padding:0px 15px; }
	.line1 { line-height:18px; background-color:lightblue;
	padding:0px 10px; }
	.w { position:absolute; right:10px; bottom:10px; width:160px; 
	height:240px; overflow:hidden; border:2px groove #281;
	cursor:default; -moz-user-select:none; }
	.t { line-height:20px; height:20px; width:160px;
	overflow:hidden; background-color:#27C; color:white;
	font-weight:bold; border-bottom:1px outset blue;
	text-align:center; }
	.winBody { height:218px; width:160px; overflow-x:hidden;
	overflow-y:auto; border-top:1px inset blue;
	padding:10px; text-indent:10px; background-color:white;
	}
	</style>
	</head>
	<body>
	<div class="w">
	<div class="t">Demo Win - Fixed</div>
	<div class="winBody">Hello world</div>
	<div>//www.jb51.net/</div>
	</div>
	</body>
	<script>
	//测试用，随机产生一定的内容
	for(var i=0; i<400; i++)document.write("<div class=\"line"+(i%2)+"\">"+(new Array(20)).join((Math.random()*1000000).toString(36)+" ")+"<\/div>");
	//代码如下：
	new function(w,b,c,d,o){
	d=document;b=d.body;o=b.childNodes;c="className";
	b.appendChild(w=d.createElement("div"))[c]= "b";
	for(var i=0; i<o.length-1; i++)if(o[i][c]!="w")w.appendChild(o[i]),i--;
	(window.onresize = function(){
	w.style.width = d.documentElement.clientWidth + "px";
	w.style.height = d.documentElement.clientHeight + "px";
	})();
	}
	</script>		
			
			
		
		
		


20180824
坑:
	发现,如果 selection, range 所指的 #text文本 被修改了,机制是原来的#text段落会被新的替换,
	所对应的 selection range 指向了 null ,指向#text文本 的节点指针也会指向null
	null + '0' 不等于字符串"0"
	多个空格只显示一个空格,多个tab只显示一个空格的问题!! css 添加 white-space:pre; 处理
	text-indent:2em  css的首行缩进
 	letter-spacing:2px;	css 字符之间间距
	nodeType == 1 //<div>
	nodeType == 3 //<#text>
	图片要居中, 同一div 使用 text-align: center;css属性 然后<img>里  margin: 0 auto; css属性
	可以令 子 div 并排显示 justify-content: center; display:flex;
	<p>和<div>的间距有区别,p 和 div 都是块元素, p和div作为同级元素的情况下会换行显示,但是行距有区别!!
	<img>间距 用 hspace="50"
	<div> 的间距用{margin:top right bottom left }
		如：{margin:10px 20px 30px 40px}表示该元素与上面的元素相距10px，
		与右边的元素相距20px，与下面的元素相距30px，与左边的元素相距40px;
		使用该属性的时候要注意当上面元素的margin-bottom:10px;下面元素margin-top:10px;那么他们的间距将会合并，
			即他们之间的间距变为10px;	
		如果这两个值不一样，那么浏览器将会取较大值。
		但是如果其中有一个元素设置position为absolute时，间距将不会合并。
		使用该属性时一定要注意与它相关的元素的属性，注意观察他们的position和float属性。
		注意使用的时候 是在 子div里使用,不可在父div里使用让子div继承!!
	<audio>起码要这样子标记: <audio src="/static/music/yuxuanji.mp3" controls autoplay="true"></audio>
		不然无法显示
	网页获取 例如:wget -p -np -k -r https://www.52cmajor.com/tab/editor
		wget https://static.52cmajor.com/static/vextab/ -r -c -np -nH --cut-dirs 2 --restrict-file-names=nocontrol
wget -c -r -np -k -L -p -A '*.js*' https://static.52cmajor.com/static/vextab/


五线谱: https://www.52cmajor.com/tab/editor 
	https://my.oschina.net/daxia/blog/1590124
	直接下载整个网页分析 wget -p -np -k -r https://www.52cmajor.com/tab/editor 然后点击网页,
	居然发现功能完好!! 而且还有回播功能,可以移植使用
	这三个直接添加了监听处理,而不需要自己主动在<div>标签上设置监听
        	vexTabEditor.keyup(_.throttle(parseAndRender, 250));
   		vexTabEditor.resize(_.throttle(parseAndRender, 250));
   		$(window).resize(_.throttle(parseAndRender, 250));
	使用 vextab相当奇葩, 最稳妥复用几个 div 把 canvas 包涵进去,不然 background 错亂
	还有,使用 vextab 自带 player 时其实是两个canvas重合的,所以 css.position 应当 relative
	值得wget下来参考的网址: 
		https://www.52cmajor.com/doc?doc=vextab
		http://www.vexflow.com/vextab/tutorial.html

数学公式: http://www.html580.com/11952/demo   JMeditor
	显示使用了 	<link rel="stylesheet" href="/static/css/mathquill.css">

js 数组的大坑
	例如:  var vexTabEditor = $('.vex-tab-editor');
	使用了 jquery 的语法 吧 class="vex-tab-editor" 成员都给 vexTabEditor 变量
	vexTabEditor 应该是 一个数组, vexTabEditor[i] 是每一个数组成员的表述
	但是 这里得到的数组成员没有函数, 只有数组有函数方法:
	vexTabEditor.val() 是可执行的,  vexTabEditor[i].val(),却并不存在
	数组有函数方法 一般只是围绕第一个成员.
	比如 vexTabEditor.val() 得到的是 vexTabEditor[i].value 的值
	但是 数组成员是可以有函数方法的!!
	例如 	var artist = new Array()  创建一个新数组
	artist[i] = new Artist(10, 10, 1000, {scale: 0.8});   数组成员被赋予内容
        artist[j].render(renderer[j]); 	数组成员是可以有函数方法的
	
				
浮窗
	https://blog.csdn.net/yongbosong/article/details/4210693	//移动浮窗
	https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  	//新闻弹窗
		
	
	


















?????????????????????????????????????
1,每行都有行号,行号前有标记色   
	未实现标记色
2,回车, 退格键,方向键, 粘贴组合键, tab键, 方向左键 
	基本实现了回车,tab按键,退格键,方向左键,
	但是tab的显示距离问题现在还无法很好实现字符制表
	回车要自动添加新行号,转行,回车后字符串的处理
	现有行,要插入数据并回车,后面的数据全部 换行
	移动和退格都不能退到行号处!!
3,行号与数据条号
	div 建立一个 conteid 实现,
4,每一行前都有标记色!! 新建, 修改, 换行! 无操作, 某行内容既换行,又修改时,设为修改色 
5,输入日期格式,自动成为标题头.
6,设置星号内容!!	
7,公式编写,使用的一个开源库: JMEditor: http://www.html580.com/11952
8,首先显示做一个网页模板看看再说 
	<div conteid=666 contety=1 ><span style=background:#44ffff;> </span>00045:hello world<div>
	conteid 内容id contety 行内容类型 <span>是开头的标记色
??,代码高亮识别!!(以后再说!!)
??,时间保存
	所有流媒体内容 经过sha加密  行数据内容是 缩略图/音频片段 + 链接 + 256位加密码,
		其中   缩略图/音频片段 + 256位加密码, 计入保存时间加密, 链接不计入!!
	文本类内容(包括五线谱编码) 经过sha加密  行数据内容就是 文本内容!! 直接计入保存时间加密,
??,五线谱
	使用 vextab 掌握 多段谱,而不是一段谱






开发_web_log 重要内容,因为涉及多机上传问题!!,所以未充分测试前不贸然实施
full_stack_note 暂时 通过 hp机 备份到 selfweb 项目上去
20180726
尝试使用第二部电脑 git 备份同一个项目!!
	例如之前再二手thinkpad做的 selfweb,整个文件夹拷贝到现在的 hp 上!!
	这时相当于把整个 git 配置也拷贝过来了,
	所以直接在 selfweb 输入命令:
		git add xxxx
		git commit -m "xxxx"
		git push origin master
		直接成功上传
不过注意!!!!!!!!!!
	注意 由于并没有完全尝试用两部电脑交替上传文件,
	因为,Apc 上传后得到的新节点, Bpc并不知道, bpc又上传时,因为不知情Apc的修改的内容而导致冲突!!!
	所以,只能在 不重要的 selfweb 项目上做好充分的交替上传测试,财允许其他大型项目的实施
























