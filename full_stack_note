全栈:
高并发:
负载均衡:  LVS Nginx 应用服务器集群
LAMP  


decops
可用工具有很多，但其中一些环节是组织内部应用DevOps工具链不可或缺的。
诸如Docker（容器化）、Jenkins（持续集成）、Puppet（基础架构构建）、Vagrant（虚拟化平台）等常用、广泛使用的工具都是2016年的DevOps热门工具。




tomcat 


SpringBoot: https://www.cnblogs.com/java1024/p/8570401.html
    JDK8
    Maven3.0+
    Intellij IDEA

前端程序员
    基础
        HTML / CSS
        JavaScript
        DOM
    中级篇
        数据格式（如JSON、XML）
        RESTful API交互（如jQuery Ajax，Fetch API，ReactiveX）
        正则表达式
        HTML语义化
        命令行
        Node.js
        DIV / CSS
        SCSS / SASS
        矢量图形 / 矢量图形动画（如SVG）
        单页面应用
    高级篇
        ES6 / TypeScript
        CSS3
        面向对象编程
        函数式编程
        MVC / MVVM / MV*
        安全性（如跨域）
        授权（如HTTP Basic、JWT等等）
    工程化
        代码质量（如JSLint / ESLint / TSLint / CSLint）
        代码分析（如Code Climate）
        测试覆盖率
        构建系统（gulp、grunt、webpack等等）
        自动构建（脚本）
    兼容性
        跨浏览器测试 （Chrome，IE，Firefox，Safari等等）
        跨平台测试（Windows、GNU/Linux，Mac OS等等）
        跨设备测试（Desktop，Android，iOS，Windows Phone）
        跨版本测试（同一个浏览器的不同版本）
    前端特定
        CSS / CSS3 动画
        JavaScript 动画
        Web字体嵌入
        Icon 字体
        图形和图表
        CSS Sprite（如glue）
        DOM操作（如jQuery、React等等）
        模板引擎（如JSX、Handlebars、JSP、Mustache等等）
    软件工程
        版本管理（如git、svn）
        包管理（如npm、bower）
        依赖管理
        模块化（如CommonJS、WebPack）
    调试
        浏览器调试
        Debug工具
        Wireshark / Charles抓包
        远程设备调试（如Chrome Inspect Devices）
    测试
        单元测试
        服务测试
        UI测试
        集成测试
    性能与优化
        PageSpeed / Yslow 优化
        加载优化（如gzip压缩、缓存等等）
        性能测试（特别是移动Web）
        可用性
        压缩（如Minify、Uglify、CleanCSS等等）
    设计
        切页面
        线框图（Wireframe）
        响应式设计
        网格布局（Grid Layout）
        Flexbox布局
    SEO
        Sitemap（站点地图）
        内部链接建设
        MicroData / MicroFormat
        页面静态内容生成
        H1、H2、H3和strong使用
        Title、Description优化
        页面静态内容生成
后端程序员
    入门
        HTML / CSS
        编程语言：Java / Python / PHP / Ruby等等
        Web框架，如Spring MVC、Flask、Laravel等等
        HTTP协议基础
        CGI基础
    中级篇
        XML和JSON处理
        数据结构与算法
        面向对象编程
        CMS
        API设计
        网络通信协议，如TCP / Socket
    高级篇
        函数式编程
        领域驱动设计
        MVC架构
        运行环境优化，如JVM
        远程调试
    工程化
        版本管理
        单元测试
        依赖管理
        包管理
    基础设施
        虚拟化，如Docker
        自动化部署
        应用包创建、管理、发布
        发布脚本编写
        Web容器，如Jboss
    缓存篇
        应用层缓存
        平台缓存
        数据库端缓存
        分布式缓存
    数据持久化
        SQL
        NoSQL
        ORM
        DBMS
        搜索引擎
    数据库
        查询性能优化
        结构优化
        主从复制、主主复制等等
        伸缩性与高可用性
        备份恢复与容灾
    安全和加密
        认证与会话管理
        加密解密
        数字签名、数字证书
        加密算法
        XSS/CSRF/SQL注入
    监控
        应用性能监控
        异常监控
        日志
        流量监控
    服务
        RESTful
        SOA
        RPC
        MicroServices
    消息
        JMS
        IPC
        MQ
运维开发者
    入门篇
        编写脚本，如Shell、Perl、Rython等等
        编程语言
        Web应用运行基本原理
        HTTP服务器
        应用容器
        命令行，如awk
        CGI
        修复漏洞
    中级篇
        自动化运维
        GNU/Linux操作系统
        编译
        数据库
    高级篇
        分布式文件系统
        分布式存储系统
    云服务
        存储服务，如AWS S3
        计算服务，如AWS Lambda
        托管服务，如AWS EC2
    安全性
    网络
        CCNP / CCNA
    持续集成
        持续集成工具
        自动构建工具
        依赖管理工具
        版本管理工具
    虚拟化
        应用容器虚拟化，如Docker
        环境虚拟化
        操作系统虚拟化
    自动化 (puppet,chef)
        自动化配置
        自动化部署
        进程管理工具，如Supervisor
    监控
        基础设施监控
        日志管理
        监控服务
    负载均衡
        边缘缓存，如（Varnish）
        DNS负载均衡
        CDN










20180726
主要练习部署 和 负载均衡 知识
web 服务器端下游: tomcat、apache httpd、nginx, uwsgi,
	uwsgi，它类似于nginx，通过一个守护进程把不同的http请求转交给子进程并发处理，并且支持多线程的方式，性能较高，
	与其让一个uwsgi服务跑10个进程，不如开10个uwsgi服务，然后用nginx做负载均衡！
	uwsgi本身的负载均衡没有nginx牛逼。所以阉割掉不用。因此uwsgi退化成了wsgi服务器
	nginx 可以一个ip 地址 配置不同端口来实现在 同一台机子上 访问多个不同的网站!!
	nginx 可以集群部署, 同一个网站,但分布多个主机,多个ip,
		https://www.cnblogs.com/lilongsheng1125/p/4978485.html  (nginx 科普)
		https://www.linuxidc.com/Linux/2017-05/143739.htm 	( Keepalived 和 nginx 配合使用 典型集群部署手把手例子)
		https://www.linuxidc.com/Linux/2017-03/141866.htm	( Keepalived 模式方案 )
			Keepalived 管理多个 nginx 节点,分主备节点,主节点死了,备节点顶上!!
			nginx 节点 实现 web服务的负载管理
Keepalived:是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，
	类似的工具还有heartbeat、corosync、pacemaker。
	但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用












20180727
使用 python3 重新开发 django selfweb项目!!
建立独立环境:
	mkvirtualenv django -p python3
	workon django
	pip install django
	pip install uwsgi
	mkdir selfweb_pyth3 && cd selfweb_pyth3
建立项目
	django-admin startproject selfweb_pyth3 /home/william/full_stack/selfweb_pyth3
建立网站
	django-admin startapp web	
尝试运行: 然后刻登录指定链接测试
	python manage.py runserver
	错误:You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): 
		admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them
	先不处理
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    path('admin/', admin.site.urls),
		    # by william
		    path('',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
如果要局域网的机子能访问自己
	在settings.py文件中，找到ALLOWED_HOSTS=[ ]，在中括号中加入你在局域网中的IP。如我在局域网中的IP为192.168.10.133
	所以设置ALLOWED_HOSTS = [ '192.168.10.133'] 
	python manage.py runserver 0.0.0.0:8000	//执行网站服务,添加向外开放段端口
设置简单高并发网站:(使用 uwsgi 多进程)
	在settings.py文件中，设置 ALLOWED_HOSTS=[ ]
	建立selfweb_pyth3/uwsgi.ini:
		[uwsgi]
		chdir = /home/william/full_stack/selfweb_pyth3
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb_pyth3.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb_pyth3/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
如果要局域网的机子能访问自己
	在settings.py文件中，设置 ALLOWED_HOSTS = [ 'xxx.xxx.xxx.xxx']
	selfweb_pyth3/uwsgi.ini: http = 0.0.0.0:8000 
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//启动服务!!
安装数据库:
	sudo apt-get install mysql-server
	sudo apt-get install mysql-client
	mysql 操作教程看 开发_in_linux_log
	还有django用到的python mysqllib 只支持 2.7
	所以需要:
	pip install PyMySQL
	gedit selfweb_pyth3/__init__.py 
	添加:
	import pymysql
	pymysql.install_as_MySQLdb()
添加数据库 mysql:
	数据库,是django网站各种扩展模块的基础,所以,建站之前先要初始化一个数据库
	当migrate过程时,django会给 selfweb/settings.py->INSTALLED_APPS 里提到的模块都建立相应的表单,
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:3***************7
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	配置工程连接这个数据库: 修改 selfweb_pyth3/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb_pyth3',
		        'USER': 'root',
		        'PASSWORD': '3***************7',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错:
	python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
	补充: 
		db_selfweb_pyth3 并不存在与 selweb网站目录里!!,拷贝移植selfweb网站到新机子时,并不带 db_selfweb_pyth3
		关于如何把 db_selfweb也拷贝过去,日后在探究
创建web模块,及建立自定义model模型
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',	//表示 添加 django管理模块 admin
		    'django.contrib.auth',	//表示 添加 django管理模块 admin
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的model 对应的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True,on_delete=models.CASCADE)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		除了web_blogpost 还有一个web_subject,
		web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项 (一对多原理)
		还多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系(多对多原理)
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	要使用admin管理模块: 需要: selfweb/settings.py -> INSTALLED_APPS 含有:
		'django.contrib.admin',	//表示 添加 django管理模块 admin
		'django.contrib.auth',	//表示 添加 django管理模块 admin
	还需要:selfweb/urls.py -> urlpatterns 含有 url(r'^admin/', admin.site.urls)
	python manage.py createsuperuser	//创建管理者:william:3**7q
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
			Django admin后台管理是不支持显示这种many_to_many关系的,因为 'tags' many_to_many关系
			改成 list_display = ('title', 'create_time', 'subject')
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.		
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
			显然 list_display = ('name') 只有name,一项, 不是一个列表,必须加 , 号
			改成 list_display = ('name',)
		System check identified 3 issues (0 silenced).
		错误,不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	关于 admin 进一步定制:https://www.cnblogs.com/zhming26/p/5767158.html
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功










20180731
目前使用 django2.0
	路径分配要使用通配符的话, 需要 import re_path 使用有正则表达式的路径
	view.py 每个def 一般都是定义一个页面的实现方式,如果要像使用print那样调试,可以使用 assert False 主动触发出错页来代替
	例如:
	def hours_ahead(request, offset):
	    try:
	        offset = int(offset)
	    except ValueError:
	        raise Http404()
	    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
	    assert False
	    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
	    return HttpResponse(html)
	django 使用的网页模板 一般使用 .html后缀名, 这个不是一个严格的 html页面文件,里面夹杂着django的一些自家语法.
	利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射
html常用小知识:
	注释符号
	Html
		单行:<!-- -->
		多行:<!-- -->

	javascript
		单行://
		多行:/*  */
		
	Vbscript
		单行:'
		多行:'
		
	ASP <% %>中： 
		单行：' 
		多行：'
	还有跨浏览器管理


















second_brain
初步架构是 
以行号为基础
每行 一条数据指针,每条指针,指向同一条数据 (针对,上十万行后,出现行位转移问题,)
一般来说,一行一段文字
两张数据表, 一个行号表,一个内容表
每一行都有一个属性字节 0位, 换了行位置, 1位, 改变了内容,
由于 行数据指针制度,所以可以一行放置超文本内容(公式,图片,视频链接!!)
按用户分配负载,和database位置空间,而不是按流量
初步发现,使用django应该并不合适.第一版还是用django 吧

任务一:全页文本框
通过建立 html页模板:
	<input> 单行文本框,好像并不合适 
	<br /> 另起一行
	多行文本框 五行、一行50字的文本框，<textarea name="txt" clos=",50" rows="5" warp="virtual"></textarea>
	但是这种多行文本似乎也不理想
	
	参考CKEditor 5 https://ckeditor.com/ckeditor-5/ 的 在线文本编辑框, 这样就建立了一个简单的在线文本编辑.
	<div class="cc" role="textbox" aria-label="Rich Text Editor, main" contenteditable="true">
		<h2>The three greatest thiou learn from traveling</h2>
	这种文本框比较理想
	role 只是识别标记, aria-label只是注释,暂时都未知如何使用
	contenteditable="true" 才表示 当前的这个 div 块,允许编辑!!

回车键监听
	注意js里 跨浏览器的处理方式:
		<div ...onKeyDown="ifenter(event)" >
		function ifenter(e)
		{
			var x
			if(window.event) // IE8 以及更早版本	
			{
				x=e.keyCode;
			}
			else if(e.which) // IE9/Firefox/Chrome/Opera/Safari
			{
				x=e.which;
			}
			......
		}
	通过js 插入html段落: 网上一个 js 片段:
		window.onload = function(){
		var testingText = '<p>hello</p>'
		var rootElement = document.body;
		var newElement = document.createElement("div");
		var newElementHtmlContent = document.createTextNode(testingText);
		rootElement.appendChild(newElement);
		newElement.appendChild(newElementHtmlContent);
		} 
		这段js 是假设放在 <head>段的
		window.onload 表示当<body>加载显示完毕,即html完全显示后 就执行这个function,
		通过 DOM 动态加载一个新段落 <p>hello</p>
		但是 这只能加载 一段 "<p>hello</p>" 字符窜 而不能真的加载一段<p>段落!!
		以下这段才能成功添加一段段落:
			var testingText = "<p>hello william</p>"
			var ccElement = document.body.getElementsByClassName('cc')
			ccElement[0].insertAdjacentHTML("beforeEnd",testingText);	
		原型：insertAdjacentHTML(swhere,stext) 在指定的地方插入html标签语句
		参数：
			swhere:指定插入html标签语句的地方，有四种值可以用：
			1.beforeBegin:插入到标签开始前
			2.afterBegin:插入到标签开始标记后
			3.beforeEnd:插入到标签结束标记前
			4.afterEnd:插入到标签结束标记后
	按键事件  onkeydown、 onkeypress 和 onkeyup这三个事件句柄:
		按键监听句柄书写 可以 onkeydown 也可以 onKeyDown
		onkeydowm 是比较底层的句柄, 不能识别 组合按键和 按键的复用内容,
			比如, g按键 只能传递按键原码,即大写G字符的字符码,不能传递小写g字符码
			shift+1 并不能传递出 感叹号 ! 的字符码
		onkeypress 高级句柄 能识别 组合按键和 按键的复用内容, g按键 可以识别传递 大写字符码或者小写字符码,
			shift+1 能传递出 感叹号 ! 的字符码
		onkeyup 也是底层句柄	
		就是说 onkeydowm / onkeyup 传递的是按键码, 而 onkeypress 传递的是具体的字符码
		当按键一直按住,相当于 连续触发多次 onkeydowm / onkeypress 事件
		暂时只从 firefox 讨论 !!
			按键事件都会传递一个隐含变量 e , 而 e.which 就是传递过来的字符码数字,
			根据事件句柄类型, e.which要么是按键码, 要么是具体的字符码
			还有两个擦差不多的属性变量 e.keycode  e.charcode ,不过都是在跨浏览器上使用的
		通过 fromCharCode 可以把按键码,字符码转换成实际 字符 变量.
		例如: var keychar = String.fromCharCode(e.which)	
	光标控制!!
		'\r'是回车，使光标到行首，return（carriage return）
		'\n'是换行，使光标下移一格，newline（line feed）
		根据 id 跳到 焦点指定的 段落里文本框,光标直接跳到指定段落里的文本框:
			var fui = document.getElementById('dfg')
			fui.focus(); 
			注意,虽然是再<head>写的代码,但不用document.body.getElementById('dfg') 从<body>段寻找
			直接从全页寻找, 而且不像 class标签 得到的不是数组变量,不用使用 fui[xx]指代
		光标 是选区知识的一个部分,必须系统学习 selection 选区内容
		var sel = getSelection()	//选区
		var node = sel.anchorNode	//开始节点, 节点就是<xx>段落
			//鼠标落到的地方所处的段落就是 选区开始作用的段落 (开始节点)
			<div contenteditable="true"...>
			 	<h2>The three greatest</h2>
				<p>hello</p>
				klkkl
				opp
			</div>
			//当鼠标落到 three 这个地方, 那么此刻选取的开始节点是 <h2>段落 中的 #text 文本段落
			//当鼠标落到 hello 这个地方, 那么此刻选取的开始节点是 <p>段落 中的 #text 文本段落
			//当鼠标落到 kikkl或者 opp 这个地方, 那么此刻选取的开始节点是 <div> 段落中的 #text 文本段落
			//一般用户点击时 selection的 anchorNode 只会落在 各个标签段落中的 #text 文本段落
			//所以 node 值一般是 #text
			//如果要 真正落到指定的 tag段落 例如<div> node:div#dfg.cc,一般是 DOM函数获取
			//真正的 tag段落: 每个tag子段落为占一个偏移位置, 每段文本占一个偏移位置
			//tag段落中的#text 文本段落: 每个字符占一个偏移, 注意回车,缩进什么的也算一个字符
		var number = sel.anchorOffset	//开始节点的偏d移
			//当鼠标落到 The 的 h 之后的地方, 此刻开始节点偏移是从<h2>段落里#text 文本段落的第 2 个位置
			//当鼠标落到 hello 的 o 之前的地方, 此刻开始节点偏移是从<p>段落里#text 文本段落的第 4 个位置
			//当鼠标落到 kikkl 的第一个 k 之前的地方, 此刻开始节点偏移是从<div>段落里#text 文本段落第 2 个位置
			//因为 在 <div>段落里<div>段落里#text 文本段落中</P>之后有一个回车和缩进字符才到达位置 kikkl之前
		var fnode = sel.focusNode 	//结束节点  选区最后的段落,
			//一般情况下,开始节点和结束节点是同一个,所以不知道可以怎么用
		var offset = sel.focusOffset	//结束节点偏移, 也是从结束节点的段落里的第 xx 个位置的意思
		var bool = sel.isCollapsed	//选区的开始和结束位置是否重合
			//当开始节点 == 结束节点, 开始节点偏移==结束节点位置, 选区的开始和结束位置就重合, bool==true
			//这个位置点也是光标闪烁的位置点
			//如果是高亮选择的一块区域, 这一次操作选取的区域为 一个 range
			//当 选择高亮 three,时从左到右选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 4, 结束偏移 9
				isCollapsed :false
			//当 选择高亮 three,时从右到左选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 9, 结束偏移 4
				isCollapsed :false			
			//当 选择高亮从 greatest 的第一个 t 到 hello 的第一个l, 即 test hel :
				开始节点 <h2>  结束节点 <p>
				开始节点偏移 14, 结束偏移 3
				isCollapsed :false
				类似这样的跨节点 选择一块分选区能成,是因为 <div contenteditable="true"...>
		var value = sel.rangeCount	//选区的 分选区 个数
			//通过按住 ctrl 我们 多次操作 间断 高亮选择多块区域
			//每一块都作为一个分选区,统计的数字就是 rangcount
			//然而, 开始节点 结束节点 开始节点偏移 结束偏移  都是最新一个分选区区域的对应的内容
			//而之前分选区的这些参数却未知在哪里
		var typ = sel.type	//当前的选区,当前的分选区的类型
			//一个selection 里 可能有很多分选区成员 包括 多个高亮区域,和一般只有一个光标
			//高亮区域的 type是 range 类型
			//光标的 type 是 Caret 类型, 即 collapsed
			//不论是 光标还是 高亮区域 都算入一个 rangeCount 计数
			//但是 高亮区域 和 光标 不能同时存在,
			//某刻,如果有n个 高亮区域 ,那么 selection.rangeCount:n  selection.type= range
			//某刻有光标,那也只能有一个光标, selection.rangeCount:1  selection.type= Caret
		以上光标内容都是 只读 内容,即只能用特定 api 修改, 不能手动修改
		给选区添加一个range
			var ccElement = document.body.getElementsByClassName('cc') //寻找class="cc"的节点 
			var sel = getSelection()  //获取 此刻的 selection 对象 (选区对象)
			if(sel.rangeCount > 0) sel.removeAllRanges(); 
				//如果此刻你见到有光标/高亮区域,说明selection里有分选区成员,这里是都清除他们
			var range = document.createRange();	//新建一个range
  			range.selectNode(ccElement[0]);	//把节点里的所有内容,都放入这个range
			sel.addRange(range);	
				//把这个range 添加到 selection里, 这时,selection 只有一个包含节点内所有内容的高亮区域
				//这时 selection.rangeCount:1  selection.type= range
		光标跳到指定位置:	
			sel.collapse(ccElement[0],1)
				//ccElement[0] 指是 光标要停在的节点, 是tag节点,而不是tag节点里的#text段落
				//1 是 在这节点上对应的偏移地方
				//所以 一个子段落是算 1 个偏移
				//一段字符串算 1 个偏移
				//注意 html 书写为了美观,使用大量缩进键,但是缩进键也算字符串里的字符
				//所以使用这个要非常谨慎
		        sel.collapseToEnd()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最后的那个点.
				//让光标跳到最后的那个逻辑位置
		        sel.collapseToStart()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最前的那个点.
				//让光标跳到最前的那个逻辑位置
		判断指定节点内容是否选上,光标是否在指定节点
			console.log(sel.containsNode(ccElement[0], true))
				//判断 selection对象 比如 光标 落到指定的 节点上,  
				//判断 selection的高亮选区 有没有在 指定节点 选取了部分内容
  			console.log(sel.containsNode(ccElement[0], false))
				//判断 selection的高亮选区 有没有在 指定节点 选取了全部内容
 		删除指定高亮的 文本内容!!
			sel.deleteFromDocument()
		选取扩充至:	
			sel.extend(nodeA, offsetA)	
				//高亮选取一片区域range, 
				//以当前节点,当前偏移位置 (或者某自定义节点,节点偏移)为 开始节点,开始节点偏移, 
				//以 nodeA 为结束节点, offsetA为结束节点偏移
		获选区中其中的一个range
			首先,我们知道,打开的 html 页面,只有一个 selection 对象,而且一直存在, 只不过他的内容不断变换
			selection 里内容,要么是光标,要么是高亮选区range
			如果是光标, 开始节点==结束节点,开始节点偏移==结束节点偏移, rangeCount:1
			Selection { anchorNode: #text, anchorOffset: 17, 
				    focusNode: #text, focusOffset: 17, 
				    isCollapsed: true, rangeCount: 1, 
				    type: "Caret", caretBidiLevel: 0 }
			如果是高亮选区, selection  选中了 多少个高亮选区,就有多少个rangeCount,
			而开始节点,结束节点,开始节点偏移,结束节点偏移 都是最后加入那一个 高亮选区 的参数,
			Selection { anchorNode: #text, anchorOffset: 28, 
				    focusNode: #text, focusOffset: 34, 
				    isCollapsed: false, rangeCount: 4, 
				    type: "Range", caretBidiLevel: 0 }
			然而,如何获得 selection 存着的,靠前的高亮选区 range 呢? 
			range = sel.getRangeAt(index)
				//获得 selection 里 指定序号的 range ,序号0开始 
				//例如 rangeCount:7 表示有7个range ,序号6表示第7个range
		量化移动光标,量化选range
			sel.modify(alter, direction, granularity)
			alter: move 移动光标
			       extend 选range区域
			directtion: forward / right 向前移动/选 (向右)
				    backward / left 向后移动/选 (向左)
			granularity: (量化值)
				"character",按字符
				"word", 按单词
				"sentence", 
				"line", 
				"paragraph", 
				"lineboundary", 
				"sentenceboundary", 
				"paragraphboundary", 
				"documentboundary".
			例如 The three greatest thiou learn from traveling
				sel.modify("move", "forward", "word")
				//点击 greatest 的 a前面时, 光标会出现在最后的t后面
				sel.modify("extend", "backward", "word")
				//点击 thiou 的 o 前面时, thi 被高量选择!			 
		删除 selection 里的 所有 range:  sel.removeAllRanges();
		删除 selection 里的 指定 range:  sel.removeRange(sel.getRangeAt(index))	
		选择节点里的所有内容,包括各种嵌入子节点: sel.selectAllChildren(parentNode)
		通过代码指定一个 selection.
			sel.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)
			例子:
				var one = document.querySelector('.one');
				var two = document.querySelector('.two');
				var aOffset = document.getElementById('aOffset');
				var fOffset = document.getElementById('fOffset');
			    	selection.setBaseAndExtent(one, aOffset.value, two, fOffset.value);
			然后你就看到一段 指定的内容 高亮选中了,此刻 sslection 里也仅有这个range
		sel.toString();
			把 selection 中的文本内容全部转化策成 字符串!!	
	
文本边框消失 CSS !! 
	通过 css实现,例如 <style>#edit{height:500px;width:500px;border:50px none transparent;outline:none}</style>
	首先 boarder:none,表示不显示边框,
	outline:none,也表示 当文本框被点击focus时,边框的显示, 也为none
文本框字体 CSS !!
	大小:	h1 {font-size:3.75em;} /* 60px/16=3.75em */
		h2 {font-size:2.5em;}  /* 40px/16=2.5em */
		p {font-size:0.875em;} /* 14px/16=0.875em */ 	
	颜色:
		直接用 color:#F00;  三原色组合 F00 
背景
	body{background:#001122}
django 外部css 外部script:
	注意没有和nginx一起部署时，DEBUG = True 才能访问django静态资源。
	django 使用 外部css设置简单,但要先理解每一个参数,所以比较耗时间,要引入外部 css 就是相当于引入外部静态资源
	先看 settings.py
	STATIC_URL = '/static/'		//必要,这个是告诉 html可以直接以这个/static为url头,直接获取各静态资源 
					//比如远程客户机浏览器访问
					// http://127.0.0.1:8000/home/william/full_stack/selfweb_pyth3/static/css/base.css
					//可以改为: http://127.0.0.1:8000/tatic/css/base.css 就能访问
					//但似乎 没有也可以实现, 只要有 STATICFILES_DIRS,所以感觉可有可无,可能在真实部署时才有用吧
	STATIC_ROOT = os.path.join(BASE_DIR, 'static')	  //只是声明了一个路径, 没有特殊意义 ,所以非必要 
					//具体线路是:/home/william/full_stack/selfweb_pyth3/static
					//一般也可以这样声明
					//STATIC_ROOT = os.path.join(BASE_DIR, 'static').replace('\\', '/')
	STATICFILES_DIRS = (...)				//必要,这里才是真正定义外部可访问的静态资源链接
	例子一: STATICFILES_DIRS = ( 
			os.path.join(BASE_DIR, 'static'),  //假如 BASE_DIR: /home/william/full_stack/selfweb_pyth3
			)				   //那么 把 BASE_DIR 接上 static 得到一条具体路径:
							   // /home/william/full_stack/selfweb_pyth3/static
							   //这条路径就是 被添加上的一条静态资源路径,假如路径里有文件 body.css yilaao.jpg
							   //浏览器直接访问 http://127.0.0.1:8000/static/yiliao.jpg 就可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/body.css">
							   //就可以加载 对应的 css文件
	例子二:STATICFILES_DIRS = ( 
		     ('css', os.path.join(BASE_DIR, 'static')), //具体线路是:/home/william/full_stack/selfweb_pyth3/static
			)				   //浏览器直接访问 http://127.0.0.1:8000/static/css/yiliao.jpg 可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/css/body.css">
							   //就可以加载 对应的 css文件
	例子三:STATICFILES_DIRS = (
	    ('css', os.path.join(STATIC_ROOT, 'css').replace('\\', '/')),  
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/css
							//访问线路 http://127.0.0.1:8000/static/css/
	    ('img', os.path.join(STATIC_ROOT, 'images').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/images
							//访问线路 http://127.0.0.1:8000/static/img/
	    ('fonts', os.path.join(STATIC_ROOT, 'fonts').replace('\\', '/')), 
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/fonts
							//访问线路 http://127.0.0.1:8000/static/fonts/
	    ('js', os.path.join(STATIC_ROOT, 'js').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/js
							//访问线路 http://127.0.0.1:8000/static/js/
	)
	settings.py设定后,(重点设置是STATICFILES_DIRS) 把要用到的文件放到指定 具体地址后,
	编译 django python manage.py migrate. 

	然后就可以再 .html 上使用外部 css 文件
	有两种使用方式: 
	第一种: 使用 django 的 html 语法.
	{% load static %}	// 在 <!DOCTYPE html> 之前加入
	<link rel="stylesheet" href="{% static '/css/index.css' %}">	
	第二种: 使用标准的 html语法
	<link rel="stylesheet" href="/static/css/body.css">	

	在 .html 上使用外部 js 文件
	<script type="text/javascript" src="/static/js/login.js"></script>


<link>标签的一些补充: 1. 定义文档与外部资源的关系；2. 是链接样式表。
	rel各个属性值配置的意思：
              Alternate -- 定义交替出现的链接 
              Stylesheet -- 定义一个外部加载的样式表 
              Start -- 通知搜索引擎,文档的开始 
              Next -- 记录文档的下一页.(浏览器可以提前加载此页) 
              Prev -- 记录文档的上一页.(定义浏览器的后退键) 
              Contents 
              Index -- 当前文档的索引 
              Glossary -- 词汇 
              Copyright -- 当前文档的版权 
              Chapter -- 当前文档的章节 
              Section -- 作为文档的一部分 
              Subsection -- 作为文档的一小部分 
              Appendix -- 定义文档的附加信息 
              Help -- 链接帮助信息 
              Bookmark -- 书签 	
	例如, <link rel="stylesheet" href="css/bootstrap.css">，引入外部的css文件时，一定不能忘记rel属性的配置。

要着重掌握对 contenteditable 里 innertext 的 光标定位问题!! 还有获取光标所在节点
	<div id="dw" contenteditable="true"></div>
	$('#dw')[0].innerHTML
	console.log($('#dw')[0].innerHTML );就是div中的内容 

	数字转换:https://www.jb51.net/article/45331.htm
	javascript自带parseInt(str)函数
	参数：str，为一个包含数字的字符串
	返回值：
	如果str中最前面几个字符是数字，则返回该数字； 如果str第一个字符不是数字，返回NaN。
	例如：
	parseInt("1234"); //返回1234
	parseInt("1234A"); //返回1234
	parseInt("1234A5"); //返回1234
	parseInt("A1234"); //返回NaN 

	字符窜的处理:https://www.cnblogs.com/l1pe1/p/6197371.html
	



代码片段:
回车后插入字符窜再定位事件方法1:
	e.preventDefault();	//阻止回车原来事件 原来回车事件会插入一个 <div><br/></div> 段
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点		
	var range = document.createRange()	//创建一个range
	range.selectNodeContents(o) 		//把节点里的所有内容都选上,即整个文本段选上
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range
	sel.collapseToEnd()			//光标跑到 selection 逻辑最后的那个 range 里的最后一个位置,
						//就是 刚刚添加的 div文本节点的文本段的最后一个位置
回车后插入字符窜再定位事件方法2:
	e.preventDefault();	//阻止回车原来事件
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点	
	var endOffset = o.childNodes.length;	//获取 o 节点 的子节点个数,由于只有一段文本,一段文本作为一个子节点,所以是1 
	var range = document.createRange()	//创建一个range
	range.setEnd(o,endOffset)		// range 开始地方 在o节点里的endOffset位置
	range.setStart(o,endOffset)		// range 结束地方 在o节点里的endOffset位置
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range,由于setEnd,setStart 设置同一个地方
						//所以光标处于这个位置中,即 div文本节点的文本段的最后一个位置
中段插入方法1:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode.parentElement  	//得到当前 节点的父节点, 
	//注意 #text的父节点是<div>文本节点, 但是 <div>文本节点 的父节点是 id=editor节点
	//注意 光标在#text时,在 <div></div>中任意字符旁边的位置,
	//注意 光标在<div>文本节点时,在 <div></div>中字符串之前或之后的位置,
	//所以需要做if判断!! 							
	if (El == document.getElementById('editor'))
	{	El.insertAdjacentHTML("beforeEnd",htmlcontent) }
	else
	{	El.insertAdjacentHTML("afterEnd",htmlcontent); 	}
中段插入方法2并定位下一行:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode
	if (El.parentElement != document.getElementById('editor'))
	{	El = El.parentElement }
	El.insertAdjacentHTML("afterEnd",htmlcontent)	//确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
	var endOffset = o.childNodes.length;
	var range = document.createRange()	
	range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
	range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
	sel.removeAllRanges()
	sel.addRange(range)
中段插入自调整行号定位下一行
	e.preventDefault();	//阻止回车原来事件
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		linenum = linenum + 1	
		var htmlcontent = "<div>" + linenum + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent) //确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var El1 = El.nextSibling
	El1 = El1.nextSibling
	for (;El1 != null;)		//自调整行号
	{
	var index = El1.innerText.indexOf(":")	//获取第一个":"字符的位置
	var str = El1.innerText.substring(index)
	linenum = linenum + 1
	El1.innerText = linenum + str	
	El1 = El1.nextSibling
	}
		var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
		var endOffset = o.childNodes.length;
		var range = document.createRange()	
		range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
		range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
		sel.removeAllRanges()
		sel.addRange(range)	//定位下一行
加上行号对齐,字符串调整!!(基本完成回车按键, 有bug)
	//阻止回车原来事件
		e.preventDefault();	
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length	
	//前方行号对齐	
		var Ell = document.getElementById('editor').lastChild	
		var lastline = parseInt(Ell.innerText)+1	//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 	
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		var cnt3 = El.innerText.indexOf(":")
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'	
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}

		str0 = str0 + linenum

		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling  	//擦入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )	//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					console.log("templine:"+ templine +"cnt5:"+ cnt5 + "cnt6:" + cnt6)			
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段的 cnt4 == 0 导致,
					//不是最后一阶段 cnt4 绝不等于 0 ,所以 cnt5 绝对不会出现 -1.	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转 以及 附加的字符串处理: 回车时,把光标后的字符串放到插入行)
		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,会添加上述字符串处理
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		sel.removeAllRanges()
		sel.addRange(range)	//简单光标跳转
		if( (range2 == "nothing to do") || (range2.startContainer == El) ) //range2.startContainer也是一个节点
		{	//console.log("nothing to do")	}
		else
		{
			var chofst = range2.startOffset		//光标未跳转所在的文本段位置偏移	
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	console.log("nothing to do 2")	}
			else
			{
				//console.log(chofst)
				//console.log(range2.startContainer.length)			
				var fenhao = o.innerText.indexOf(":")		//插入行的第一个分号的位置
				var str1 = El.innerText.substring(chofst)	//未跳转前光标位置后的字符串
				//console.log(range2)
				//console.log(str1)
				o.innerText = o.innerText + str1		//未跳转前光标位置后的字符串添加到擦插入行
				El.innerText = El.innerText.substr(0,chofst)	//原来位置上的删掉
			
			//以下表演如何把光标重新定位到 #text 文本指定位值
				var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
										//o节点的 子节点是我们寻寻觅觅的 #text 节点
				var range1 = document.createRange()
				range1.selectNodeContents(oo) //把 oo 节点里的所有内容都选上
				range1.setEnd(oo,fenhao+1)	// range1 开始地方 #text 分号后的位置
				range1.setStart(oo,fenhao+1)	// range1 结束地方 #text 分号后的位置
				sel.removeAllRanges()
				sel.addRange(range1)		//光标跳转到插入行的分号后位置
								//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
								//所以浏览器知道我们所指向的是哪个 #text节点
			}
		
		}
回车跳转行号对齐字符窜调整,(解除上述bug)
	//阻止回车原来事件
		e.preventDefault();	//阻止回车原来事件
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length
	//获取光标后字符串
		var str1 = null
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,获取光标后字符串
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		if( (range2 == "nothing to do") || (range2.startContainer == El) )  //判断range在#text节点里,还是<div>节点,
		{	//console.log("nothing to do")	
		}
		else						//range在#text节点里的时候,才继续
		{
			var chofst = range2.startOffset
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	//console.log("nothing to do 2")	
			}
			else
			{
				str1 = El.innerText.substring(chofst)
			}
		
		}	

	//前方行号对齐
		var Ell = document.getElementById('editor').lastChild
		var lastline = parseInt(Ell.innerText)+1		//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 
		var cnt3 = El.innerText.indexOf(":")
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}
		str0 = str0 + linenum
		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling		//插入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转	

		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方 
		//光标简单跳转
		sel.removeAllRanges()	
		sel.addRange(range)	
		//如果 回车后有字符串, 则重新光标跳转
		if( str1 != null )
		{
			
			var fenhao = o.innerText.indexOf(":")
			o.innerText = o.innerText + str1		//str1 放到插入行
			El.innerText = El.innerText.substr(0,chofst)  	//原来位置上的删掉
				
			var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
									//o节点的 子节点是我们寻寻觅觅的 #text 节点
			var range1 = document.createRange()
			range1.selectNodeContents(oo) //把节点里的所有内容都选上
			range1.setEnd(oo,fenhao+1)	// range 开始地方 #text 分号后的位置
			range1.setStart(oo,fenhao+1)	// range 结束地方 #text 分号后的位置
			sel.removeAllRanges()
			sel.addRange(range1)		//光标跳转到插入行的分号后位置
							//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
							//所以浏览器知道我们所指向的是哪个 #text节点
		}
TAB基本实现缩进	(但是 未处理缩进显示问题)
	//阻止tab原来事件
		e.preventDefault()
	//实现
		var sel = getSelection()
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))	//在selection在 #text 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer.parentNode
         		console.log(range)
			var str = patN.innerText.substr(0,range.startOffset)
			var str1 = patN.innerText.substring(range.startOffset)
			var offset = str.length +1
			patN.innerText = str + "\t" + str1
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])	//patN.childNodes[0] 指修改后的 #text
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)		
		}
		else if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))	//在selection在 <div> 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer	
			var str = patN.innerText
			var offset = str.length +1
			patN.innerText = str + "\t"
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)
		}	
退格按键 有bug 未实现 缩行操作
	var sel = getSelection()
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer.parentNode
		if( (patN.innerText.indexOf(":"))+1 ==  range.startOffset )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)			
		}
	}
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer
		if( (patN.innerText.indexOf(":"))+1 ==  patN.innerText.length )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)
			
		}
	}
退格键,基本完成
	//初始化
		var sel = getSelection()
		var range
		var Nod
		var preN = null
		var range1
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer.parentNode
			if( (Nod.innerText.indexOf(":"))+1 ==  range.startOffset )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer
			if( (Nod.innerText.indexOf(":"))+1 ==  Nod.innerText.length )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if(!preN)	//如果 检测到退到第 1 行,则退无可退
		{	return 1		}
		else
		{	var creN = preN 	}
		var LaN = document.getElementById('editor').lastChild
		var lastline_bf = parseInt(LaN.innerText)
		var lastline_af = parseInt(LaN.innerText) - 1
	//前行号对齐
		if (lastline_bf.toString().length - lastline_af.toString().length ) //行号位数少1
		{
			var cnt = parseInt(Nod.innerText) - 1 
			for(;cnt;)
			{
				preN.innerText = preN.innerText.substr(1,preN.innerText.length)
				preN = preN.previousSibling
				cnt--
			}
		}
	//后行号对齐 不管 行号位数是否少1		
		var NexN = Nod.nextSibling
		if (NexN != null)
		{	var linenum = parseInt(NexN.innerText) - 2 }	//复用 回车片段对应修改
		var lastline = parseInt(LaN.innerText) - 1
		var cnt5 = 0
		var index
		var str
		var num0 = null
		var num = null
		for (;NexN != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = NexN.innerText.indexOf(":")
			str = NexN.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			NexN.innerText = num + str
			NexN = NexN.nextSibling
		}	
	//缩行
		Nod.remove()
	//跳转
		range1 = document.createRange() 
		range1.selectNodeContents(creN)
		range1.collapse(false)
		sel.removeAllRanges()
		sel.addRange(range1)
方向左键
if (x == 37 ) //方向左键
	{
		var sel = getSelection()
         		console.log(sel)
		if ( (sel.anchorNode.nodeType == 3) && (sel.anchorNode.parentNode.innerText.indexOf(':') + 1 == sel.anchorOffset ) )
		{	e.preventDefault()	}
		if ( (sel.anchorNode.nodeType == 1) && (sel.anchorNode.innerText.indexOf(':') + 1 == sel.anchorNode.innerText.length ))
		{	e.preventDefault()	}
	}
以上代码片段 仅仅基于 纯文本记录下的操作



html 转义字符: ISO Latin-1字符集: 
&#09; — 制表符Horizontal tab 			&#10; — 换行Line feed 			&#13; — 回车Carriage Return 
&#32; / &nbsp; — Space 				! &#33; — 惊叹号Exclamation mark 	” &#34; &quot; 双引号Quotation mark 
# &#35; — 数字标志Number sign 			$ &#36; — 美元标志Dollar sign 		% &#37; — 百分号Percent sign 
& &#38; &amp; Ampersand 			‘ &#39; — 单引号Apostrophe 		( &#40; — 小括号左边部分Left parenthesis 
) &#41; — 小括号右边部分Right parenthesis 	* &#42; — 星号Asterisk 			+ &#43; — 加号Plus sign 
, &#44; — 逗号Comma 				- &#45; — 连字号Hyphen 			. &#46; — 句号Period (fullstop) 
/ &#47; — 斜杠Solidus (slash) 			0 &#48; — 数字0 Digit 0 		1 &#49; — 数字1 Digit 1
2 &#50; — 数字2 Digit 2 			3 &#51; — 数字3 Digit 3 		4 &#52; — 数字4 Digit 4 
5 &#53; — 数字5 Digit 5 			6 &#54; — 数字6 Digit 6 		7 &#55; — 数字7 Digit 7 
8 &#56; — 数字8 Digit 8 			9 &#57; — 数字9 Digit 9 		: &#58; — 冒号Colon 
; &#59; — 分号Semicolon 			< &#60; &lt; 小于号Less than 		= &#61; — 等于符号Equals sign 
> &#62; &gt; 大于号Greater than 		? &#63; — 问号Question mark 		@ &#64; — Commercial at 
A &#65; — 大写A Capital A 			B &#66; — 大写B Capital B 		C &#67; — 大写C Capital C 
D &#68; — 大写D Capital D 			E &#69; — 大写E Capital E 		F &#70; — 大写F Capital F 
G &#71; — 大写G Capital G 			H &#72; — 大写H Capital H 		I &#73; — 大写J Capital I 
J &#74; — 大写K Capital J 			K &#75; — 大写L Capital K 		L &#76; — 大写K Capital L 
M &#77; — 大写M Capital M 			N &#78; — 大写N Capital N 		O &#79; — 大写O Capital O 
P &#80; — 大写P Capital P 			Q &#81; — 大写Q Capital Q 		R &#82; — 大写R Capital R 
S &#83; — 大写S Capital S 			T &#84; — 大写T Capital T 		U &#85; — 大写U Capital U 
V &#86; — 大写V Capital V 			W &#87; — 大写W Capital W 		X &#88; — 大写X Capital X 
Y &#89; — 大写Y Capital Y 			Z &#90; — 大写Z Capital Z 
[ &#91; --- 中括号左边部分Left square bracket 	\ &#92; --- 反斜杠Reverse solidus (backslash) 
] &#93; — 中括号右边部分Right square bracket 	^ &#94; — Caret 			_ &#95; — 下划线Horizontal bar (underscore) 
` &#96; — 尖重音符Acute accent 			a &#97; — 小写a Small a 
b &#98; — 小写b Small b 			c &#99; — 小写c Small c 		d &#100; — 小写d Small d 
e &#101; — 小写e Small e 			f &#102; — 小写f Small f 		g &#103; — 小写g Small g 
h &#104; — 小写h Small h 			i &#105; — 小写i Small i 		j &#106; — 小写j Small j 
k &#107; — 小写k Small k 			l &#108; — 小写l Small l 		m &#109; — 小写m Small m 
n &#110; — 小写n Small n 			o &#111; — 小写o Small o 		p &#112; — 小写p Small p 
q &#113; — 小写q Small q 			r &#114; — 小写r Small r 		s &#115; — 小写s Small s 
t &#116; — 小写t Small t 			u &#117; — 小写u Small u 		v &#118; — 小写v Small v 
w &#119; — 小写w Small w 			x &#120; — 小写x Small x 		y &#121; — 小写y Small y 
z &#122; — 小写z Small z 			{ &#123; — 大括号左边部分Left curly brace 
| &#124; — 竖线Vertical bar 			} &#125; — 大括号右边部分Right curly brace 
~ &#126; — Tilde 				— &#127; — 未使用Unused 		&#160; &nbsp; 空格Nonbreaking space 
? &#161; &iexcl; Inverted exclamation 		￠ &#162; &cent; 货币分标志Cent sign 	￡ &#163; &pound; 英镑标志Pound sterling 
¤ &#164; &curren; 通用货币标志General currency sign 
￥ &#165; &yen; 日元标志Yen sign 		| &#166; &brvbar; or &brkbar; 断竖线Broken vertical bar 
§ &#167; &sect; 分节号Section sign 		¨ &#168; &uml; or &die; 变音符号Umlaut 
? &#169; &copy; 版权标志Copyright 		a &#170; &ordf; Feminine ordinal 
? &#171; &laquo; Left angle quote, guillemet left 
? &#172; &not Not sign 				? &#173; &shy; Soft hyphen 		? &#174; &reg; 注册商标标志Registered trademark 
ˉ &#175; &macr; or &hibar; 长音符号Macron accent ° &#176; &deg; 度数标志Degree sign 
± &#177; &plusmn; 加或减Plus or minus 		2 &#178; &sup2; 上标2 Superscrīpt two 	3 &#179; &sup3; 上标3 Superscrīpt three 
′ &#180; &acute; 尖重音符Acute accent 		μ &#181; &micro; Micro sign 		? &#182; &para; Paragraph sign 
? &#183; &middot; Middle dot 			? &#184; &cedil; Cedilla 		1 &#185; &sup1; 上标1 Superscrīpt one 
o &#186; &ordm; Masculine ordinal 		? &#187; &raquo; Right angle quote, guillemet right 
? &#188; &frac14; 四分之一Fraction one-fourth 	? &#189; &frac12; 二分之一Fraction one-half 
? &#190; &frac34; 四分之三Fraction three-fourths ? &#191; &iquest; Inverted question mark 
à &#192; &Agrave; Capital A, grave accent 	á &#193; &Aacute; Capital A, acute accent 
? &#194; &Acirc; Capital A, circumflex 		? &#195; &Atilde; Capital A, tilde 	? &#196; &Auml; Capital A, di?esis / umlaut 
? &#197; &Aring; Capital A, ring 		? &#198; &AElig; Capital AE ligature 	? &#199; &Ccedil; Capital C, cedilla 
è &#200; &Egrave; Capital E, grave accent 	é &#201; &Eacute; Capital E, acute accent 
ê &#202; &Ecirc; Capital E, circumflex 		? &#203; &Euml; Capital E, di?esis / umlaut 
ì &#204; &Igrave; Capital I, grave accent 	í &#205; &Iacute; Capital I, acute accent 
? &#206; &Icirc; Capital I, circumflex 		? &#207; &Iuml; Capital I, di?esis / umlaut 
D &#208; &ETH; Capital Eth, Icelandic 		? &#209; &Ntilde; Capital N, tilde 	ò &#210; &Ograve; Capital O, grave accent 
ó &#211; &Oacute; Capital O, acute accent 	? &#212; &Ocirc; Capital O, circumflex 	? &#213; &Otilde; Capital O, tilde 
? &#214; &Ouml; Capital O, di?esis / umlaut 	× &#215; &times; 乘号Multiply sign 	? &#216; &Oslash; Capital O, slash 
ù &#217; &Ugrave; Capital U, grave accent 	ú &#218; &Uacute; Capital U, acute accent 
? &#219; &Ucirc; Capital U, circumflex 		ü &#220; &Uuml; Capital U, di?esis / umlaut 
Y &#221; &Yacute; Capital Y, acute accent 	T &#222; &THORN; Capital Thorn, Icelandic 
? &#223; &szlig; Small sharp s, German sz 	à &#224; &agrave; Small a, grave accent 
á &#225; &aacute; Small a, acute accent 	a &#226; &acirc; Small a, circumflex 
? &#227; &atilde; Small a, tilde 		? &#228; &auml; Small a, di?esis / umlaut 
? &#229; &aring; Small a, ring 			? &#230; &aelig; Small ae ligature 
? &#231; &ccedil; Small c, cedilla 		è &#232; &egrave; Small e, grave accent 
é &#233; &eacute; Small e, acute accent 	ê &#234; &ecirc; Small e, circumflex 
? &#235; &euml; Small e, di?esis / umlaut 	ì &#236; &igrave; Small i, grave accent 
í &#237; &iacute; Small i, acute accent 	? &#238; &icirc; Small i, circumflex 
? &#239; &iuml; Small i, di?esis / umlaut 	e &#240; &eth; Small eth, Icelandic 
? &#241; &ntilde; Small n, tilde 		ò &#242; &ograve; Small o, grave accent 
ó &#243; &oacute; Small o, acute accent 	? &#244; &ocirc; Small o, circumflex 
? &#245; &otilde; Small o, tilde 		? &#246; &ouml; Small o, di?esis / umlaut 
÷ &#247; &divide; 除号Division sign 		? &#248; &oslash; Small o, slash 
ù &#249; &ugrave; Small u, grave accent 	ú &#250; &uacute; Small u, acute accent 
? &#251; &ucirc; Small u, circumflex 		ü &#252; &uuml; Small u, di?esis / umlaut 
y &#253; &yacute; Small y, acute accent 	t &#254; &thorn; Small thorn, Icelandic 
? &#255; &yuml; Small y, umlaut 		symbols, mathematical symbols, and Greek letters 
? &fnof; 	Α &Alpha; 	Β &Beta; 	Γ &Gamma; 	Δ &Delta; 	Ε &Epsilon; 	Ζ &Zeta; 	Η &Eta; 
Θ &Theta; 	Ι &Iota; 	Κ &Kappa; 	Λ &Lambda; 	Μ &Mu; 		Ν &Nu; 		Ξ &Xi; 		Ο &Omicron; 
Π &Pi; 		Ρ &Rho; 	Σ &Sigma; 	Τ &Tau; 	Υ &Upsilon; 	Φ &Phi; 	Χ &Chi; 	Ψ &Psi; 
Ω &Omega; 	α &alpha; 	β &beta; 	γ &gamma; 	δ &delta; 	ε &epsilon; 	ζ &zeta; 	η &eta; 
θ &theta; 	ι &iota; 	κ &kappa; 	λ &lambda; 	μ &mu; 		ν &nu; 		ξ &xi; 		ο &omicron; 
π &pi; 		ρ &rho; 	? &sigmaf; 	σ &sigma; 	τ &tau; 	υ &upsilon; 	φ &phi; 	χ &chi; 
ψ &psi; 	ω &omega; 	? &thetasym; 	? &upsih; 	? &piv; 	? &bull; 	… &hellip; 	′ &prime; 
″ &Prime; 	￣ &oline; 	? &frasl; 	? &weierp; 	? &image; 	? &real; 	? &trade; 	? &alefsym; 	
← &larr; 	↑ &uarr; 	→ &rarr; 	↓ &darr; 	? &harr; 	? &crarr; 	? &lArr; 	? &uArr; 
? &rArr; 	? &dArr; 	? &hArr; 	? &forall; 	? &part; 	?&exist; 	?&empty; 	? &nabla; 
∈ &isin; 	? &notin; 	? &ni; 		∏ &prod; 	∑ &sum; 	? &minus; 	?&lowast; 	√ &radic; 
∝ &prop; 	∞ &infin; 	∠ &ang; 	∧ &and; 	∨ &or; 	∩ &cap; 	∪ &cup; 	∫ &int; 
∴ &there4; 	～ &sim; 	? &cong; 	≈ &asymp; 	≠ &ne; 		≡ &equiv; 	≤ &le; 		≥ &ge; 
? &sub; 	? &sup; 	? &nsub; 	?&sube; 	? &supe; 	⊕ &oplus; 	? &otimes; 	⊥ &perp; 
? &sdot; 	?&lceil; 	? &rceil; 	? &lfloor; 	?&rfloor; 	? &lang; 	? &rang; 	? &loz; 
? &spades; 	? &clubs; 	? &hearts; 	? &diams; 
markup-significant and internationalization characters: 
“ &quot; 	& &amp; 	< &lt; 		> &gt; 		? &OElig; 	? &oelig; 	? &Scaron; 	? &scaron; 
? &Yuml; 	? &circ; 	? &tilde; 	&ensp; 		&emsp; 		&thinsp; 	? &zwnj; 	? &zwj; 	
? &lrm; 	?&rlm; 		– &ndash; 	— &mdash; 	‘ &lsquo; 	’ &rsquo; 	? &sbquo; 	“ &ldquo; 
” &rdquo; 	? &bdquo; 	?&dagger; 	? &Dagger; 	‰ &permil; 	? &lsaquo; 	? &rsaquo; 	€ &euro; 


正则表达式:
((?=[\x21-\x7e]+)[^A-Za-z0-9])
x21-\x7e]+)[^A-Za-z0-9])
这个匹配所有键盘上可见的非字母和数字的符号

var patrn = /[`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]/im;  
     if (!patrn.test(str)) {// 如果包含特殊字符返回false
         return false;
     }
     return true;
这个是输入框防止特殊字符勿输入验证，包括键盘上所有特殊字符的英文和中文状态。需要者可以根据自身需求而定！谢谢！

[^\w\s]+
匹配非空 非字母 非数字 即可

1 数字：^[0-9]*$ 

2 n位的数字：^\d{n}$

3 至少n位的数字：^\d{n,}$ 

4 m-n位的数字：^\d{m,n}$ 

5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 

6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 

7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 

8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 

9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

二、校验字符的表达式

1 汉字：^[\u4e00-\u9fa5]{0,}$ 

2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 

3 长度为3-20的所有字符：^.{3,20}$ 

4 由26个英文字母组成的字符串：^[A-Za-z]+$ 

5 由26个大写英文字母组成的字符串：^[A-Z]+$ 

6 由26个小写英文字母组成的字符串：^[a-z]+$ 

7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 

8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 

9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+

12 禁止输入含有~的字符：[^~\x22]+

三、特殊需求表达式
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 
a、自定义完美的邮箱验证：（java）
^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$
b、（js或jq）
^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$

2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 

3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ 

4 手机号码最新：
    ^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\\d{8}$（java）
    ^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\d{8}$(js或jq)

5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$  

6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 

7 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 

8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 

9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15 钱的输入格式：

16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26 中文字符的正则表达式：[\u4e00-\u9fa5]

27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 

正则表达式可以为空值，不为空则要格式。

格式如下：

^$|^(\d+|\-){7,}$ （"|"后边的是要符合格式。）

如果可以为空的空可以是空格和制表符那就这么写：^\s*$|^(\d+|\-){7,}$

正则表达式不为空用\S匹配，不能有空格可以用[^ ]匹配，[]中^后面是一个空格。

[size=12px]1。^d+$　　//匹配非负整数（正整数 + 0） 
2。^[0-9]*[1-9][0-9]*$　　//匹配正整数 
3。^((-d+)|(0+))$　　//匹配非正整数（负整数 + 0） 
4。^-[0-9]*[1-9][0-9]*$　　//匹配负整数 
5。^-?d+$　　　　//匹配整数 
6。^d+(.d+)?$　　//匹配非负浮点数（正浮点数 + 0） 
7。^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$　　//匹配正浮点数 
8。^((-d+(.d+)?)|(0+(.0+)?))$　　//匹配非正浮点数（负浮点数 + 0） 
9。^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$　　//匹配负浮点数 
10。^(-?d+)(.d+)?$　　//匹配浮点数 
11。^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 
12。^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 
13。^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 
14。^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 
15。^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 
16。^[w-]+(.[w-]+)*@[w-]+(.[w-]+)+$　　　　//匹配email地址 
17。^[a-zA-z]+://匹配(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$　　//匹配url 
18。匹配中文字符的正则表达式： [u4e00-u9fa5]
19。匹配双字节字符(包括汉字在内)：[^x00-xff]
20。应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
String.prototype.len=function(){return this.replace([^x00-xff]/g,"aa").length;}
21。匹配空行的正则表达式：n[s| ]*r
22。匹配HTML标记的正则表达式：/<(.*)>.*</1>|<(.*) />/ 
23。匹配首尾空格的正则表达式：(^s*)|(s*$)

* 正则表达式用例
  * 1、^S+[a-z A-Z]$ 不能为空 不能有空格  只能是英文字母
  * 2、S{6,}         不能为空 六位以上
  * 3、^d+$          不能有空格 不能非数字
  * 4、(.*)(.jpg|.bmp)$ 只能是jpg和bmp格式
  * 5、^d{4}-d{1,2}-d{1,2}$ 只能是2004-10-22格式
  * 6、^0$            至少选一项
  * 7、^0{2,}$        至少选两项
  * 8、^[s|S]{20,}$ 不能为空 二十字以上
  * 9、^+?[a-z0-9](([-+.]|[_]+)?[a-z0-9]+)*@([a-z0-9]+(.|-))+[a-z]{2,6}$邮件
  * 10、w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*([,;]s*w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*)* 输入多个地址用逗号或空格分隔邮件
  * 11、^(([0-9]+))?[0-9]{7,8}$电话号码7位或8位或前面有区号例如（022）87341628
  * 12、^[a-z A-Z 0-9 _]+@[a-z A-Z 0-9 _]+(.[a-z A-Z 0-9 _]+)+(,[a-z A-Z 0-9 _]+@[a-z A-Z 0-9 _]+(.[a-z A-Z 0-9 _]+)+)*$
  *     只能是字母、数字、下划线；必须有@和.同时格式要规范 邮件
  * 13 ^w+@w+(.w+)+(,w+@w+(.w+)+)*$上面表达式也可以写成这样子，更精练。
    14   ^w+((-w+)|(.w+))*@w+((.|-)w+)*.w+$ [/size]



浮窗代码片段:
新闻弹窗: https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  //新闻弹窗
	<head>
	<meta charset="utf-8">
	<title>jquery漂浮广告代码</title>
	<script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	<style>
	</style>
	</head>
	<body>
	<div id="imgDiv" style="position:absolute;left:50px;top:60px;">
	    <div id="a" style="width:20px;height:20px;position:absolute;left:160px;background:salmon;text-align: center;">×</div>
	    <!-- <img src="01.jpg" border="0" /> -->
	    <div style="width:180px;height:180px;background:red;"></div>
	</div>
	 
	<script>
	var xin = true,
	    yin = true;
	var step = 1;
	var delay = 10;
	var $obj;
	$(function() {
	    $obj = $("#imgDiv");
	    var time = window.setInterval("move()", delay);
	    $obj.mouseover(function() {
	        clearInterval(time)
	    });
	    $obj.mouseout(function() {
	        time = window.setInterval("move()", delay)
	    });
	});
	 
	function move() {
	    var left = $obj.offset().left;
	    var top = $obj.offset().top;
	    var L = T = 0; //左边界和顶部边界
	    var R = $(window).width() - $obj.width(); // 右边界
	    var B = $(window).height() - $obj.height(); //下边界
	 
	    //难点:怎样判断广告的4个边框有没有超出可视化范围!
	    if (left < L) {
	        xin = true; // 水平向右移动
	    }
	    if (left > R) {
	        xin = false;
	    }
	    if (top < T) {
	        yin = true;
	    }
	    if (top > B) {
	        yin = false;
	    }
	    //根据有没有超出范围来确定广告的移动方向
	    left += step * (xin == true ? 1 : -1);
	    top  += step * (yin == true ? 1 : -1);
	    // 给div 元素重新定位
	    $obj.offset({
	        top: top,
	        left: left
	    })
	}
	    //关闭
	$(function() {
	    $("#a").click(function() {
	        var b = $("#a").parent();
	        $(b).remove();
	    })
	})
	</script>
	</body>
浮窗广告: https://blog.csdn.net/Jensen_Yao/article/details/64926666
	<style type=text/css>
	  div#roll {
		width: 100px; color: #fff; position: absolute; height: 100px; background-color: #000
	}
	</style>
	<body>
	<H2>JS全屏漂浮广告，移入光标停止移动</H2>
	<div id="roll">我是广告</div>
	<script type=text/javascript>
	  var ggRoll = {
	    roll: document.getElementById("roll"),
	    speed: 20,
	    statusX: 1,
	    statusY: 1,
	    x: 100,
	    y: 300,
	    winW: document.documentElement.clientWidth - document.getElementById("roll").offsetWidth,
	    winH: document.documentElement.clientHeight - document.getElementById("roll").offsetHeight,
	    Go: function () {
	       this.roll.style.left = this.x + 'px';
	       this.roll.style.top = this.y + 'px';
	 
	       this.x = this.x + (this.statusX ? -1 : 1)
	       if (this.x < 0) { this.statusX = 0 }
	       if (this.x > this.winW) { this.statusX = 1 }
	 
	       this.y = this.y + (this.statusY ? -1 : 1)
	       if (this.y < 0) { this.statusY = 0 }
	       if (this.y > this.winH) { this.statusY = 1 }
	 
	     }
	  };
	    var interval = setInterval("ggRoll.Go()", ggRoll.speed);
	    ggRoll.roll.onmouseover = function () { clearInterval(interval) };
	    ggRoll.roll.onmouseout = function () { interval = setInterval("ggRoll.Go()", ggRoll.speed) };
	</script>
	</body>	
固定浮窗: https://www.jb51.net/article/65211.htm
	<style>
	* { font-size:12px; font-family:Verdana,宋体; }
	html, body { margin:0px; padding:0px; overflow:hidden; }
	.b { margin:0px; padding:0px; overflow:auto; }
	.line0 { line-height:20px; background-color:lightyellow;
	padding:0px 15px; }
	.line1 { line-height:18px; background-color:lightblue;
	padding:0px 10px; }
	.w { position:absolute; right:10px; bottom:10px; width:160px; 
	height:240px; overflow:hidden; border:2px groove #281;
	cursor:default; -moz-user-select:none; }
	.t { line-height:20px; height:20px; width:160px;
	overflow:hidden; background-color:#27C; color:white;
	font-weight:bold; border-bottom:1px outset blue;
	text-align:center; }
	.winBody { height:218px; width:160px; overflow-x:hidden;
	overflow-y:auto; border-top:1px inset blue;
	padding:10px; text-indent:10px; background-color:white;
	}
	</style>
	</head>
	<body>
	<div class="w">
	<div class="t">Demo Win - Fixed</div>
	<div class="winBody">Hello world</div>
	<div>//www.jb51.net/</div>
	</div>
	</body>
	<script>
	//测试用，随机产生一定的内容
	for(var i=0; i<400; i++)document.write("<div class=\"line"+(i%2)+"\">"+(new Array(20)).join((Math.random()*1000000).toString(36)+" ")+"<\/div>");
	//代码如下：
	new function(w,b,c,d,o){
	d=document;b=d.body;o=b.childNodes;c="className";
	b.appendChild(w=d.createElement("div"))[c]= "b";
	for(var i=0; i<o.length-1; i++)if(o[i][c]!="w")w.appendChild(o[i]),i--;
	(window.onresize = function(){
	w.style.width = d.documentElement.clientWidth + "px";
	w.style.height = d.documentElement.clientHeight + "px";
	})();
	}
	</script>		
			
固定<div>: https://blog.csdn.net/qq_26817251/article/details/53648685		
	div id="dg" style="z-index: 9999; position: fixed ! important; right: 0px; top: 0px;">
	<table width=""100% style="position: absolute; width:260px; right: 0px; top: 0px;">
	//table 内部控件代码
	</table>
	</div>	
	div position参数设置为fixed 其相对于浏览器为绝对位置，通过设置right和top将div固定在右上角。
	table position参数设置为absolute,其相对于第一层div绝对定位，通过设置right和top将table固定在div容器的右上角。
		
弹出表单表框层: https://blog.csdn.net/Seety_ST/article/details/49020047
	<style>
	/*灰色遮罩层*/
	.fade{
	    width:100%;
	    height:100%;
	    background:rgba(0, 0, 0, 0.5);
	    position: fixed;
	    left: 0;
	    top: 0;
	    z-index: 99;
	}
	/*弹出层*/ 
	.succ-pop{
	    width: 400px;
	    height: 300px;
	    background: #fff;
	    position: fixed;
	    left: 50%;
	    top: 50%;
	    margin-left: -200px;
	    margin-top: -150px;
	    z-index: 999;
	    border-radius: 5px;
	}   
	.succ-pop h3.title{
	    text-align: center;
	    font-size: 22px;
	    color: #ce002c;
	}
	</style>
	<div class="succ-pop">
	    <h3 class="title">
	        中间填写内容
	    </h3>
		<textarea>options space=20 player=true  tempo=80
		</textarea>
	</div>
	<div class="fade"></div>
通用思路上传文件:
	前端:
		<form enctype="multipart/form-data" action="/uploadFile/" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
	后端:
	views.py
		def upload_file(request):
		    if request.method == "POST":    # 请求方法为POST时，进行处理
		        myFile =request.FILES.get("myfile", None)    # 获取上传的文件，如果没有文件，则默认为None
		        if not myFile:
		            returnHttpResponse("no files for upload!")
		        destination = open(os.path.join("./",myFile.name),'wb+')    # 打开特定的文件进行二进制的写操作
		        for chunk in myFile.chunks():      # 分块写入文件
		            destination.write(chunk)
		        destination.close()
		        return HttpResponse("upload over!")			
	urls.py
		urlpatterns = [
			...
			    re_path('uploadFile',views.upload_file),
			...
		]
	通过通用的 html 标准 <form> <input> 组成的 上传模组实现上传文件
		enctype="multipart/form-data" 表示上传非文本而是文件	
		action="/uploadFile/" 表示要访问的新网址是 http://127.0.0.1:8000/uploadFile
		method="post" 访问新网址时 申请的操作, 这里上传一段数据
		type="file" 表示这个input 是给这个 <form> 载入一个文件,具体选择文件路径
		name="myfile" 很重要 后端通过这个项 来寻找正确的文件位置 
		type="submit"  表示这个input, 把这个form 打包 并并向服务器提交内容 
			先建立握手访问,然后提交post申请,获许后才开始上传数据流, 
			最后获得反馈页面,浏览器新建http://127.0.0.1:8000/uploadFile页面显示反馈页面
	远程服务器网址:http://127.0.0.1:8000/uploadFile 接受链接后,移交 def upload_file(request): 处理 
		if request.method == "POST":    # 查看请求方法是否为POST时
		myFile =request.FILES.get("myfile", None) # 允许上传内容,并开始上传内容
			"myfile" 对应前端的 name="myfile"
			内容上传完,会存在 myFile,然后才开始后续处理工作
		return HttpResponse("upload over!")	#处理工作完了,最后返回一个反馈页面			
	整个过程使用标准 html 方案,所以前端不需要另外使用 js 辅助或实现
通用思路上传文件, 但是浏览器不跳转新页面
	只需要修改前端代码为:
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
		<iframe name="frame1" frameborder="0" height="40"></iframe>
	思路是 在原网页 添加一个内嵌页面框, 这样访问 http://127.0.0.1:8000/uploadFile 获得的反馈页内容
	会放入这个内嵌页面框里显示,这样做的好处是 原网页可以直接得到反馈页内容执行交互和信息处理工作
	<form> 添加了 target="frame1",	表示得到的反馈页或内容,不另开新页面显示,而是放到 frame1 里去
	<iframe name="frame1" frameborder="0" height="40"></iframe>	
		<iframe>是标记一个内嵌页面框, 反馈页或者内容会放到这里去
通过 ajax 实现 上传文件
	前端:
		<div>
		        <input type="file" name="file" id="file_upload">
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>
		function FileUpload() {
			var form_data = new FormData();
			var file_info =$( '#file_upload')[0].files[0];
			form_data.append('file',file_info);
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        file_obj = request.FILES.get('file')
	        import os
	        f = open(os.path.join("./",file_obj.name), 'wb+')
	        print(file_obj,type(file_obj))
	        for chunk in file_obj.chunks():
	            f.write(chunk)
	        f.close()
	        print('11111')
	        return HttpResponse('OK')
	urlpatterns = [
	...
	    re_path('upload_ajax',views.upload_ajax),
	...
	]	
	这里通过 jquery 的 ajax 的 实现上传文件,上传工作都通过 js 函数实现
	首先新建填充 一个form数据, 把上传的内容都放入
	然后执行 ajax()函数,实现上传工作 其中填入的数据有
		url:'/upload_ajax/',	要访问的网址链接: http://127.0.0.1:8000/upload_ajax
		type:'POST',		请求类型 post	
		data: form_data,	上传数据
		success: function(callback) {	//成功的回调函数
			console.log(callback)
		}
	执行ajax()时, 浏览器通过子进程访问服务器 并提出 post 上传操作
	服务器后端  def upload_ajax(request): 处理访问, request.FILES.get('file') 允许并开始数据上传
	上传结束,数据存在 file_obj 供 def upload_ajax(request): 继续处理,
	最后返回 反馈页内容, 
	反馈内容被还在执行的 ajax()捕捉,然后返回到当前页面处理, 而不是 浏览器另外开一页面显示!!
通过 ajax 实现 上传 多个文件
	前端:
		<div style="display:block;" >
			<!-- 注意多了multiple,这样可以同时选多个文件, name="file" 为每个选择的文件挂上标签file  -->
		        <input type="file" name="file" id="file_upload" multiple >  
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>	
		function FileUpload() {
			var form_data = new FormData();
			//多文件 依次插入 form_data 队列数据     
			for ( var i=0 ;i < $( '#file_upload')[0].files.length; i++)
			{
				var file_info = $( '#file_upload')[0].files[i];
				form_data.append('file',file_info);
			}
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	# 多文件接收
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        files = request.FILES.getlist('file')	# 使用 getlist, 挖出标签 file 的 form_data 成员
	        print(files,type(files))
	        for f in files:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            dest = open(os.path.join("./",f.name),'wb+')
	            for chunk in f.chunks():
	                dest.write(chunk)
	            dest.close()
	        print('11111')
	        return HttpResponse("ok")	
通用思路上传 多个文件
	前端
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
			<!-- 注意多了multiple,这样可以同时选多个文件, name="myfile" 为每个选择的文件挂上标签myfile  -->		
			<input type="file" name="myfile" multiple />
			<input type="submit" value="upload"/>
		</form>
	后端
	views.py
	# 多文件
	def upload_file(request):
	    if request.method == "POST":    # 请求方法为POST时，进行处理
	        myFiles =request.FILES.getlist("myfile", None)    # 使用 getlist, 挖出标签 myfile 的 form_data 成员
	        if not myFiles:
	            return HttpResponse("no files for upload!")
	        for f in myFiles:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            destination = open(os.path.join("./",f.name),'wb+')    # 打开特定的文件进行二进制的写操作
	            for chunk in f.chunks():
	                destination.write(chunk)
	            destination.close()
	        return HttpResponse("upload over!")






	
	
20180824
坑:
	发现,如果 selection, range 所指的 #text文本 被修改了,机制是原来的#text段落会被新的替换,
	所对应的 selection range 指向了 null ,指向#text文本 的节点指针也会指向null
	null + '0' 不等于字符串"0"
	多个空格只显示一个空格,多个tab只显示一个空格的问题!! css 添加 white-space:pre; 处理
	text-indent:2em  css的首行缩进
 	letter-spacing:2px;	css 字符之间间距
	nodeType == 1 //<div>
	nodeType == 3 //<#text>
	图片要居中, 同一div 使用 text-align: center;css属性 然后<img>里  margin: 0 auto; css属性
	可以令 子 div 并排显示 justify-content: center; display:flex;
	<p>和<div>的间距有区别,p 和 div 都是块元素, p和div作为同级元素的情况下会换行显示,但是行距有区别!!
	<img>间距 用 hspace="50"
	<div> 的间距用{margin:top right bottom left }
		如：{margin:10px 20px 30px 40px}表示该元素与上面的元素相距10px，
		与右边的元素相距20px，与下面的元素相距30px，与左边的元素相距40px;
		使用该属性的时候要注意当上面元素的margin-bottom:10px;下面元素margin-top:10px;那么他们的间距将会合并，
			即他们之间的间距变为10px;	
		如果这两个值不一样，那么浏览器将会取较大值。
		但是如果其中有一个元素设置position为absolute时，间距将不会合并。
		使用该属性时一定要注意与它相关的元素的属性，注意观察他们的position和float属性。
		注意使用的时候 是在 子div里使用,不可在父div里使用让子div继承!!
	<audio>起码要这样子标记: <audio src="/static/music/yuxuanji.mp3" controls autoplay="true"></audio>
		不然无法显示
	网页获取 例如:wget -p -np -k -r https://www.52cmajor.com/tab/editor
		wget https://static.52cmajor.com/static/vextab/ -r -c -np -nH --cut-dirs 2 --restrict-file-names=nocontrol
wget -c -r -np -k -L -p -A '*.js*' https://static.52cmajor.com/static/vextab/
	html显示空格:
		连续的空格一般只显示一个
		white-space:pre; 后才显示多个
	现在是制表符号的显示!!!


五线谱: https://www.52cmajor.com/tab/editor 
	https://my.oschina.net/daxia/blog/1590124
	直接下载整个网页分析 wget -p -np -k -r https://www.52cmajor.com/tab/editor 然后点击网页,
	居然发现功能完好!! 而且还有回播功能,可以移植使用
	这三个直接添加了监听处理,而不需要自己主动在<div>标签上设置监听
        	vexTabEditor.keyup(_.throttle(parseAndRender, 250));
   		vexTabEditor.resize(_.throttle(parseAndRender, 250));
   		$(window).resize(_.throttle(parseAndRender, 250));
	使用 vextab相当奇葩, 最稳妥复用几个 div 把 canvas 包涵进去,不然 background 错亂
	还有,使用 vextab 自带 player 时其实是两个canvas重合的,所以 css.position 应当 relative
	值得wget下来参考的网址: 
		https://www.52cmajor.com/doc?doc=vextab
		http://www.vexflow.com/vextab/tutorial.html

数学公式: http://www.html580.com/11952/demo   JMeditor
	显示使用了 	<link rel="stylesheet" href="/static/css/mathquill.css">

js 数组的大坑
	例如:  var vexTabEditor = $('.vex-tab-editor');
	使用了 jquery 的语法 吧 class="vex-tab-editor" 成员都给 vexTabEditor 变量
	vexTabEditor 应该是 一个数组, vexTabEditor[i] 是每一个数组成员的表述
	但是 这里得到的数组成员没有函数, 只有数组有函数方法:
	vexTabEditor.val() 是可执行的,  vexTabEditor[i].val(),却并不存在
	数组有函数方法 一般只是围绕第一个成员.
	比如 vexTabEditor.val() 得到的是 vexTabEditor[i].value 的值
	但是 数组成员是可以有函数方法的!!
	例如 	var artist = new Array()  创建一个新数组
	artist[i] = new Artist(10, 10, 1000, {scale: 0.8});   数组成员被赋予内容
        artist[j].render(renderer[j]); 	数组成员是可以有函数方法的				
浮窗
	https://blog.csdn.net/yongbosong/article/details/4210693	//移动浮窗
	https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  	//新闻弹窗
	重点参数说明 <div style="z-index:100; position:fixed; width:320px; height:320px; background:#aaa; right: 0px; top: 0px">
	z-index 所在显示的层数,高层数遮盖低层数
	position:fixed; 位置方式, 以当前屏幕窗口为准		
	width:320px; height:320px; <div>等控件大小
	right: 0px; top: 0px 具体位置!!
	弹出表单表框层 学会了如何 遮罩的问题!!
	如果在窗口上摆按钮 那么按钮的 位置方式是position:relative: 是相对窗口的摆放 !!
		<div style="float:left; width:160px; height:auto;"></div>
		<div style="float:left; position:relative; width:30px; height:30px; margin-left:-30px"></div>
		设置position:relative;下方的div是相对于上方的div摆放的,float:left 表示 div是 从左到右放
		position:relative; 配对的位置方法是 margin-left
		margin-left:-30px 是根据 relative得到的位置后,往左退30px 

基本DOM 操作:
	更改CSS ,http://www.w3school.com.cn/js/js_htmldom_css.asp
		document.getElementById("p2").style.color="blue";
		注意,一定要字符串,即使是数字 例如
		document.getElementById("p2").style.xxx="233";
		var Y = (233).toString() + "px"
		document.getElementById("p2").style.xxx= Y  ;		
	更改Id
		 $('你的元素').arrt（‘id’,你要的新id）； 
		var obj = document.getElementById("aa");//获取原来的id = aa的div 
		obj.setAttribute("id","bb"); 
	js 的 event 操作:
		onmousedown="contentbar(event)"	这里一定要填写 event 才能传递 event 内容
		function contentbar(e){...}	这里 可以简单用 e 来获得传递过来的event内容
		e.currentTarget.	//重要 因为	getSelection().anchorNode 里都不能很好得到触发事件的 元素!!
	js鼠标样式: 
		<span style="cursor:auto">Auto</span><br />
		<span style="cursor:crosshair">Crosshair</span><br />
		<span style="cursor:default">Default</span><br />
		<span style="cursor:pointer">Pointer</span><br />
		<span style="cursor:move">Move</span><br />
		<span style="cursor:e-resize">e-resize</span><br />
		<span style="cursor:ne-resize">ne-resize</span><br />
		<span style="cursor:nw-resize">nw-resize</span><br />
		<span style="cursor:n-resize">n-resize</span><br />
		<span style="cursor:se-resize">se-resize</span><br />
		<span style="cursor:sw-resize">sw-resize</span><br />
		<span style="cursor:s-resize">s-resize</span><br />
		<span style="cursor:w-resize">w-resize</span><br />
		<span style="cursor:text">text</span><br />
		<span style="cursor:wait">wait</span><br />
		<span style="cursor:help">help</span>
上传预览:
	https://blog.csdn.net/x550392236/article/details/76690927
django 上传到服务器:	
	https://blog.csdn.net/jiangpf1992/article/details/49406879
django 上传到服务器又不跳转页面: 使用 <iframe>
	https://blog.csdn.net/ling926/article/details/72888831
django + jquery(重写的ajax) + 上传文件服务器 重点
	https://www.cnblogs.com/liaojiafa/p/6231382.html
	https://www.cnblogs.com/jishuweiwang/p/6140132.html
	https://www.cnblogs.com/liyqiang/articles/7858523.html  //成功实现,所以从这参考
	上传文件的主要思路 主要是 直接 打包好一段数据 ,然后给某个网址(例如http://127.0.0.1:8000/upload_file 传过去
		相当于访问网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		如果 服务器后端接受 post 请求 , 远程机就可以 把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个页面 表示上传成功, 远程机另开一个页面 显示 访问 网址 http://127.0.0.1:8000/upload_file 得到的页面
	使用 ajax 上传文件的意义在于 此刻 远程机浏览器显示的页面是 http://127.0.0.1:8000/test1 
		浏览器辟出一个子进程访问 网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		服务器后端接受 post 请求 , 远程机把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个成功页面 表示上传成功, 
		但是 远程机并不会显示这个页面,远程机仍然显示着 http://127.0.0.1:8000/test1 的页面
		返回的成功页面会 转为附加内容 会添加到现在显示的 http://127.0.0.1:8000/test1 的页面中去
以上都是一次上传单个文件的
一次上传多个文件:
	首先 前端: <input type="file" name="file" id="file_upload" multiple >	添加  multiple 可以选多个
	 js 和 后端 都有对应修改,详细看片段
	不论是通用的 还是 ajax 都是建立一个 form 数据队列,然后把独立数据(独立文件),作为一个个成员放入,最后上传
	就是这样完成 文件,数据,多文件,多数据 上传的
	
(django1.10)访问url报错Forbidden (CSRF cookie not set.): xxx
	修改settings.py文件，注释掉
	django.middleware.csrf.CsrfViewMiddleware',

CSS优先级:
	行间>id>class>标签>通配符
		即 stytle="" > #AAA > .BBB >  CCC > * 
	优先级相同,谁后谁优先；优先级不同，优先级高的优先  
	优先级是一种累加的关系，加起来的值越大优先级就越高
		例如  #div3 .dd{...}  这个的优先级是 #div3 和 .dd 累加的优先级
	群组选择器的优先级取决于位置，谁靠后谁的优先级就高，会把前面的样式给覆盖了
		例如以下 必然是 green 
	            div,p,h1{
	                background: red;
	                margin-top: 50px;
	            }
	            div{
	                background: green;
	            }
css推荐模块化,集中化写法:例如
	<div class="uppic">
		<div class="Win" style="">
			<h3 class="title" style="">上传图片</h3>
			<div class="image" style="">
				<img src="/static/img/eye_expression.gif" alt="pleace select a picture " ></img>
			</div>
			<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
				<input type="file" name="myfile" multiple />
				<input type="submit" value="upload"/>
			</form>
			<!-- not use -->
			<iframe name="frame1" frameborder="0" height="40" style="display:none;"></iframe>
	
			<div style="display:block;" >
			        <input type="file" name="file" id="file_upload" multiple >
			        <input type="button" value="上传" onclick="FileUpload()">
			</div>
	
		</div>
		<div class="closeW" onmousedown="closeWin(event)"  style=" "></div>
	</div>
	xx.css:
	.uppic{ display:block; width:80%; height:80%; background:#fff; position: fixed; left: 10%; top: 10%;
		margin-left: 0px; margin-top: 0px; z-index: 999; border-radius: 5px; }   
	.uppic div.Win{ float:left; width:100%; height:100%; background:#dddddd; text-align: center;}
	.uppic div.Win div.image{ width:80%;height:70%;overflow:scroll; margin:0 auto; background:#ddddee; text-align: center; }
	.uppic div.Win h3.title{ text-align: center; font-size: 22px; color: #ce002c; }
	.uppic div.closeW{ float:left; position:relative; background:#cc00cc; width:30px; height:30px; margin-left:-30px;  }
CSS class 与 ID 区别:
	id 是 一对一的 ,  class是 一对多的 
	目前的浏览器还都允许用多个相同ID，一般情况下也能正常显示，不过当你需要用JavaScript通过id来控制div时就会出现错误。	


<ing>自身有 width 和 height , 不一定用到 css上的, 当然css上的也起作用
	但是src 没有内容的情况下, 只显示 alt 的文字内容
	css 的background 没有起作用
	width 和 height 不设置,原尺寸显示
要使图片原尺寸显示,显示不到的又可以滚动显示,用div包裹,加 overflow:scroll;
	<div style="width:80%;height:70%;overflow:scroll;text-align:center; background:#ddddee;">
		<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
	</div>
	如果想单滚动条: 例如 overflow-x: hidden; overflow-y: scroll;
	但是滚动条会看到,很讨厌!!
	使滚动条消失,方法一,再包裹一个尺寸小一点div把里面div的滚动条隐藏掉
	<div style="width:800px; height:700px; overflow:hidden; ">
		<div style="width:820px; height:720px;overflow:scroll;text-align:center; background:#ddddee;">
			<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
		</div>
	</div>
	注意: 第一个div width:800px; height:700px; overflow:hidden;
	      第二个div width:820px; height:720px;overflow:scroll;
	方法二:
	改css:
		scrollbar-3dlight-color:#fff; // 3d亮色阴影边框(threedlightshadow)的外观颜色
		scrollbar-highlight-color:#fff; // 滚动条3d高亮边框(threedhighlight)的外观颜色
		scrollbar-arrow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-shadow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-darkshadow-color:#fff; // 滚动条3d暗色阴影边框(threeddarkshadow)的外观颜色
		scrollbar-base-color:#fff; // 滚动条基准颜色
		scrollbar-track-color:#fff; // 滚动条拖动区域的外观颜色
	滚动条隐藏后操作: 滑轮 y轴；shift+滑轮 x轴;
div 居中与div内容居中: 更多扩展: https://www.thinkcss.com/jiqiao/1460.shtml
	div自身居中：
		使用margin:0 auto
		上下为0，左右自适应的css样式。
	div内容居中:
		1、div内容水平居中CSS： text-align:center
			无论是p还是div都可以对其设置此CSS实现对应对象内的内容水平居中。
		2、div内容垂直居中 行高属性：line-height
			要让div内只有一行的内容垂直居中，通常对div设置的height(高)与line-height(行高)相同，即可实现div内容垂直居中。








20180903
继续填坑:
节点学习:
	<div> XXXXX <span>cccc</span> llll <p>fff</p> kkk </div> oo <div>uu<div>
	对于第一个div来说:
	childNodes: 有 #test( XXXXX ), <span>, #text( llll ), <p>, #test( kkk ), 共 5 个子节点	(算上#text节点)
	children: 有 <span>, <p> 共 2 个子节点		(不算#text节点)
	firstChild 指向 #test( XXXXX ) 子节点		(算上#text节点)
	firstElementChild 指向 <span> 子节点		(不算#text节点)
	innertext 并不好分析,不可信
	lastChild 指向 #test( kkk ) 子节点		(算上#text节点)
	lastElementChild 指向 <p> 子节点		(不算#text节点)
	nextElementSibling 指向 <div>uu<div> 同级节点	(不算#text节点)
	nextSibling 指向 #test( oo ) 同级文本节点	(算上#text节点)
	previousElementSibling,  previousSibling 指向之前的,同理分析可知道具体指向
	parentNode 和 parentElement 一般都直接 指向相同的上级节点,没有据别
插入 html段落内容: insertAdjacentHTML(位置,字符串)
	段落内容写成字符窜 然后使用 insertAdjacentHTML 即可以插入解析
	但是注意 转义字符 的使用
	"&#09;&#09;&#09;<div class=\"spac\">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</div>&#10;&#09;&#09;&#09;<div class=\"igdd\">&#10;&#09;&#09;&#09;&#09;<img class=\"imgs\" src=\"" + src[f] + "\"&#32;alt=\"pic error\" ></img>&#10;&#09;&#09;&#09;&#09;<div class=\"imgi\">" + info[f] + "</div>&#10;&#09;&#09;&#09;</div>&#10;"
	例如这样的 使用了 &#09; 一类转义字符串,但是 html解析时会认可并转成相关字符 会构成#text 文本节点
还有注意常常用到的在节点里挖掘 class 子节点的做法:
	var ff = curNode.getElementsByClassName('tabPreviewer'),
	会得到 curNode 里 所有 class= "tabPreviewer" 的子节点
结合现阶段工作小结:
	接下来打算做的事:构思时间保存链,或者 写功能键内容.
	选择构思时间保存链, 学习体验使用参考区块链
另外建立了blockchain 实验:  lsgo技术团队
	git clone https://github.com/bitcoin/bitcoin.git
	cd bitcoin
	git tag		//查看版本
	git checkout v0.16.1	//选择没有 rc 的一个稳定版本
	git status	//查看版本
	//编译安装..... 后,有 bitcoind,bitcoin-cli两个主要命令, 还有自动建立~/..bitcoin 文件夹
	运行Bitcoin Core 客户端, 注意容易与curl冲突导致意外关闭!!
		bitcoind -printtoconsole	//前台执行 bitcoind初步会同步世界数据!!几乎有 130G!!! 草!!
		bitcoind -daemon		//后台执行
		bitcoin-cli stop		//关闭,切勿 ctrl+c  !! bitcoin-cli是辅助工具
	配置bitcoind
	gedit ~/.bitcoin/bitcoin.conf
	//一个完整索引节点的配置
		txindex=1
		rpcuser=bitcoinrpc
		rpcpassward=CHANGE_THIS
	//或者 这样 当设备资源有限时的配置
		maxconnections=15
		prune=5000
		minrelaytxfee=0.0001
		maxmempool=200
		maxreceivebuffer=2500
		maxsendbuffer=500
		rpcuser=bitcoinrpc
		rpcpassword=CHANGE_THIS
	重新运行 bitcoind 客户端 (Bitcoin Core 客户端), 并重建索引
		bitcoind -printtoconsole -reindex
	比特币核心客户端实现了 JSON-RPC 接口，这个接口可以通过命令行帮助程序 bitcoin-cli 访问，也可以通过编程的形式在程序中访问。
btcoin:使用到的密码学:
	hash:
		ripemd160:
		SHA-256: 几乎每个文件都有一个独一无二的 sha256编码,哪怕 文件之间只差几个字符!!都没有可能相同
			 其实说的是,两个完全不同的文件有极低概率sha256相同,但是两个相近的文件的 sha256 绝对不同!!
	密钥对包含了一个私钥和一个（由私钥导出的唯一）公钥。公钥被用来接收款项，私钥被用来签署一笔交易来花费比特币
	btcoin 构成交易的 要素, 私钥,公钥,钱包地址,
	生成一对公私钥的方法: 椭圆曲线乘法, RSA算法
	比特币的公钥是由私钥通过 椭圆曲线乘法 导出的	
	非对称加密: 公钥加密, 私钥解密 ； 私钥加密,公钥解密 ; 公钥无法推导出私钥
		数字签名:应用:
			1.Alice需要使用具体约定的算法（例如RSA）生成私钥和公钥，私钥自己保留，公钥对外公布。
			2.Alice想要发送消息 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。",
			  Alice使用自己的私钥对消息进行加密，例如加密后的密文是 SHG356g3T4+dh4fh，这个密文就是Alice的数字签名。
			3.Alice将消息明文和数字签名打包一起,并发送到网络中:
			 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			4.网络中的所有人接收到消息后，都可以进行如下操作完成验证：
			  收到消息 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			  使用提供的公钥 gh3giPGFN2jgh3sF 对数字签名 “SHG356g3T4+dh4fh” 进行解密
			  将解密结果与消息明文 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。" 进行对比
			  如果一致，说明消息是Alice亲自发送的，因为只有Alice本人拥有Alice的密钥
			  如果不一致，则说明消息不是Alice发送的，或者虽然消息是Alice发送的但已遭到他人篡改
			问题: 如果黑客占线 发布同样的内容,但是发送黑客自己的公钥和自己生成的签名,
			那么网络人是分不清消息的来源的,可以把黑客误以为 Alice
		数字证书:
			自己生成的公私钥, 公钥向相关权威机构登记并公开,客户可以公开查询的,公私钥不再是随便生成的
python 的hash 计算:crypt hashlib
时间保存链构思:
	一张 conteid hsah表	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	一个用户, 有 一个行表数据表, 一个cnteid数据表, 一个流媒体文件目录
	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	不合理,黑客可以自己随时得到其他人的hash 然后更改自己的时间,然后生成自己的保存块,来欺骗
	构建这个算法要用演绎思维去想,从攻击者手段想如何修改得到合法的时间事件保存块!!!
	算法的核心是保证,保存时间的权威性!

骚操作: 
	ls -lc -t	//查询当前目录下的文件及最后修改时间
	df -hl命令查看磁盘占用情况
	sudo du -sh * 命令查看当前目录下文件的大小
	du -sh .[!.]* 命令查看所有隐藏文件的大小
	频繁利以上两个命令，可追溯想要的文件








20180906
学习了相关 加密算法,发现现阶段构建时间保存链 实在太浪费时间, 还是先优先完成前端基本功能:
	接下来 ,功能按键, 完成媒体文件的修改,提交!!
	还有 批量行处理, 滑轮显示总行数!!
关于 event 的深入
	例如: onmousedown 事件
	e.currentTarget 指的是 设置了 被设置响应事件的 节点 往往一个节点设置了事件, 事件发生时就会显示这个节点
		例如, <span class="newl" onmousedown="cntebar(event)">事件响应时, e.currentTarget一定是 这个设置了事件的span
	e.explicitOriginalTarget 得到的是 具体点击落在的的节点
	e.originalTarget 得到的是 具体点击落在的节点 的 父节点!!
		例如:
<div Id="main" contenteditable="true" onmousedown="point(event)" >
	<div class="vido" cnteid=600 cntety=5 ><span class="svdl" onmousedown="cntebar(event)">&nbsp;</span>15:
		<div class="vidd">
			<video width="320" height="240" controls>
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi">amimal</div>		
		</div>
	</div>
</div>
	设置事件的是 main, 但当鼠标点击落在 animal的 字符串里时, 	explicitOriginalTarget 指的是#text节点, originalTarget指的是 vidi节点
	当鼠标落在 非视频,非animal的字符串时, 即 15 行的空白处时! explicitOriginalTarget 指的是vidd节点, originalTarget也指向 vidd节点
	刚处理完所有按键问题,和 点击问题,发现 还缺一类行数据, 就是 标题行数据
	所以需要规划添加这类行媒体数据格式!! 然后重新调整所有按键操作
	然后就是 媒体行数据的生成页功能,然后ctrl+cv 然后是批量插入,删掉行数据, 
	还有一个就是 方向键操作后的屏幕跟随, 和 滑动显示的 加载行数 !!
	最后是保存上存!!然后就开始做服务器了!!保存到服务器,需要数据回滚操作, 以防保存失败!!!
event 和 this 
	onclick等事件,不仅仅传递event 还可以传递 this, this就是 设置 onlick 的节点!!
	例如 onclick="kkk(this,event)"  function kkk(t,e){}, t和e是自己取的名字,位置对应this,event参数


现在发现 css 关于位置关系的描述非常重要!!需要学习掌握!!










20180913
css位置学习:
CSS 框模型
	---------------------------------------------------------
	|                  外边距 margin (空白透明)              |
	|      ------ 边框 border (线,点,透明)--------------     |
	|      |           内边距 padding (空白透明)       |     |
	|      |      ----------宽 width -----------      |     |
	|      |      |                            |      |     |
	|      |      |                            高     |     |
	|      |      |         element          height   |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      ------------------------------      |     |
	|      |                                   |            |
	|      |                                   |            |
	|      --------------------------------------------     |
	|                                                       |
	|                                                       |
        ---------------------------------------------------------
padding 与 margin 的设置方式
	margin: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	margin: 20px			// 统一 20px 的边距
	margin-top: 10px;
	margin-right: 0.25em;
	margin-bottom: 2ex;
	margin-left: 20%;
	padding: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	padding: 20px			// 统一 20px 的边距
	padding-top: 10px;
	padding-right: 0.25em;
	padding-bottom: 2ex;
	padding-left: 20%;
	
border设置:
  	border:5px solid red;		//边粗, 边样式, 边颜色
	独立设置:
	border 	简写属性，用于把针对四个边的属性设置在一个声明。
	border-style 	用于设置元素所有边框的样式，或者单独地为各边设置边框样式。
	border-width 	简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。
	border-color 	简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。
	border-bottom 	简写属性，用于把下边框的所有属性设置到一个声明中。
	border-bottom-color 	设置元素的下边框的颜色。
	border-bottom-style 	设置元素的下边框的样式。
	border-bottom-width 	设置元素的下边框的宽度。
	border-left 	简写属性，用于把左边框的所有属性设置到一个声明中。
	border-left-color 	设置元素的左边框的颜色。
	border-left-style 	设置元素的左边框的样式。
	border-left-width 	设置元素的左边框的宽度。
	border-right 	简写属性，用于把右边框的所有属性设置到一个声明中。
	border-right-color 	设置元素的右边框的颜色。
	border-right-style 	设置元素的右边框的样式。
	border-right-width 	设置元素的右边框的宽度。
	border-top 	简写属性，用于把上边框的所有属性设置到一个声明中。
	border-top-color 	设置元素的上边框的颜色。
	border-top-style 	设置元素的上边框的样式。
	border-top-width 	设置元素的上边框的宽度。	
margin 外边框合并!!!
	位置相邻的两个元素,不管是 同阶级关系,还是父子关系, 只要他们都设置了margin 而且是两者的margin相贴合,那么就会发生合并
	保留参数值大的margin,消灭调参数值小的margin 	
块元素,行元素
	div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。
	与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”
	display 设置为 block，可以让行内元素（比如 <a> 元素）表现得像块级元素一样
	display 设置为 none，让生成的元素根本没有框,即该框及其所有内容就不再显示，不占用文档中的空间。
CSS 有三种基本的定位机制：普通流、浮动和绝对定位	
	除非专门指定，否则所有框都在普通流中定位。
	块级框 从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。
	行内框 在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。
		垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），
		行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。
position : relative 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。
	relative 配合 top,left,right,bottom 方位属性 使用
	position:relative;left:20px;	//表示 元素在原始位置的基础上,从元素的原始左侧位置加上 20px ,相当于向右移动 20px
					//但是原始位置保留, 即下一个元素的原始位置,根据这个元素的原始位置决定
	relative 是 普通流机制的一部分, 原始位置也是 普通流机制的内容`
position : absolute 按绝对坐标定位 它原本所占的空间不保留。	
	absolute 配合 top,left,right,bottom 方位属性 使用
	position:absolute;left:100px;top:150px;		//以页面 左 上 角为原点,水平加100px,垂直加150px
					//即以左上角为原点,向右移动100px,向下移动150px的位置
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
	position:absolute;left:100px;	//以页面 左 上 角为原点,水平加100px,即以左上角为原点,向右移动100px
					//这里只定义了 水平位置的绝对坐标, 垂直位置绝对坐标没有定义.
					//所以垂直位置 按 原始位置的垂直位置排位, 把这个垂直位置作为绝对坐标
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
position : fixed 固定定位,这是根据浏览器窗口来定位的, 同样, 与absolute 一样是固定定位,
	不保留原始位置!!, 不对往后的元素的位置有影响. 永远保持显示在最前位置!!
position : static（静态定位）：就是普通流的获得的 原始位置,而且忽略 top, bottom, left, right 或者 z-index 声明的参数!	

overflow: 块元素内容 溢出的显示对策
	visible 默认值。内容不会被修剪，会呈现在元素框之外。
	hidden 	内容会被修剪，并且其余内容是不可见的。
	scroll 	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
	auto 	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
	inherit 规定应该从父元素继承 overflow 属性的值。
clip: 只有 position:absolute 绝对定位的元素, 才可以被clip 裁剪显示元素的展示空间即配合 absolute 使用
	position:absolute;left:100px;clip:rect(0px 50px 200px 0px)	//显示局对定位的元素 50*200 空间 内容
	值:
	shape 	设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left)
	auto 	默认值。不应用任何剪裁。
	inherit 	规定应该从父元素继承 clip 属性的值。	
vertical-align 属性设置 同阶级 元素间 的垂直对齐方式 ,不是设置在父元素上,而是设置在有需要的子元素上
	baseline 默认。元素放置在父元素的基线上。
	sub 	垂直对齐文本的下标。
	super 	垂直对齐文本的上标
	top 	把元素的顶端与行中最高元素的顶端对齐
	text-top 把元素的顶端与父元素的 #text 的顶端对齐
	middle 	把此元素放置在父元素的中部。
	bottom 	把元素的顶端与行中最低的元素的顶端对齐。
	text-bottom 	把元素的底端与父元素的 #text的底端对齐。
	length 	 例如 20px -10px
	% 	使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。
	inherit 规定应该从父元素继承 vertical-align 属性的值。
text-align: center;对子元素的对齐要求,设置在父元素上
z-index 元素所在的 显示层数, 层数越高元素遮挡层数低的元素
	如果元素不是绝对定位! 层数不管怎样变化,元素的原始位置依然没有改变!!
	所以 z-index 一般是配合 position:absolute 使用的!!

css 浮动:
	html 排布 有 3个次元 普通流 浮动 绝对定位
	普通流
		默认的元素是按照 html 文本流 一个一个相互影响地排列着 ,这是这时普通流的 元素排列
		普通流的方式下, 每个元素都有自己一个对应的原始位置!!
		即使使用了 relative 每个元素的实际所在位置有了偏移, 但是其原始位置是保留下来,对其他元素的位置有影响的!! 
		默认下普通流的 所有元素都 位于 z-index:0 这一层, 但是文本流 往后元素 可以遮盖 往前元素
		除非 往前元素主动设置z-index > 0 或者 > 往后元素的z-index , 往前元素 才有机会遮盖 往后元素 !
	绝对定位	
		如果只是 absolute 但没有水平/垂直坐标, 会先从文本流得到原来应该的原始坐标作为绝对坐标,
		但是并不保留自己的原始坐标,所以下个元素的原始坐标 与这个定义了absolute的元素没有关系!
		拓展例子: 
			<div>普通1</div>
			<div>绝对2</div>
			<div>普通3</div>
			<div>绝对4</div>
			绝对定位的例子只是position:absolute; 并没有设置水平垂直位置. 这时:
			绝对2 的 原始位置 根据 普通1, 普通3 原始位置 也是根据 普通1 而不是绝对2,所以
			<div>绝对2</div>,<div>普通3</div> 的原始位置都是同一个位置上,普通3 遮盖 绝对2,因为普通3元素比绝对2靠后
			绝对4 的位置是 根据 普通3,普通1,的原始位置得到的,与 绝对2 没有任何关系 
		虽然只是坐标关系变化了, 但是显示的先后顺序还是按着文本流 元素出现的先后顺序来,
		默认下绝对定位 的元素 也都 位于 z-index:0 这一层 文本流 往后元素 可以遮盖 往前元素,也是改z-index改变遮盖关系 
	浮动:
		经过实验,发现浮动,是普通流的升级板,例子说明:
		不使用float,普通流: div元素的排布:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------
 			|        |
			|    2   |
			|        |	
			----------
			--------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1使用 float:left 时:
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |
			|          |  |        |
			|          |  ----------
			------------  --------
			              |   3  |
			              |      |
			              --------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素2使用 float:left 时:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------   --------
 			|        |   |   3  |
			|    2   |   |      |
			|        |   --------
			----------   ----------
 			             |        |
			             |    4   |
			             |        |	
			             ----------
		元素1,2使用 float:left 时:
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4)
 		元素 1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4)
			------------  ----------  --------
			|          |  |        |  |   3  |
			|     1    |  |    2   |  |      |
			|          |  |        |  --------
			|          |  ----------  ----------
			------------              |        |
			                          |    4   |
			                          |        |				
			                          ----------
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4, 元素3高度变得与元素2一样高 )
		元素1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4,元素3高度变得与元素2一样高 )
			------------  ----------  --------
			|          |  |        |  |      |
			|     1    |  |    2   |  |   3  |
			|          |  |        |  |      |
			|          |  ----------  --------
			------------  ----------
			              |        |
			              |    4   |
			              |        |				
			              ----------
		元素1,2,3使用 float:left 时, (假设页面无限宽)
		元素1,2,3,4使用left时: (假设页面无限宽)
			------------  ----------  --------  ----------
			|          |  |        |  |   3  |  |        |
			|     1    |  |    2   |  |      |  |    4   |
			|          |  |        |  --------  |        |
			|          |  ----------            ----------
			------------          
		元素1 使用 float:right 时,	
			----------             ------------
 			|        |             |          |
			|    2   |             |     1    |
			|        |             |          |
			----------             |          |
			--------               ------------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2 使用 float:right 时,
			--------     ----------  ------------
 			|   3  |     |        |  |          |
			|      |     |    2   |  |     1    |
			--------     |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------	
		元素2 使用 float:right 时,
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			--------                   ----------
 			|   3  |                   |        |
			|      |                   |   2    |
			--------                   |        |
			----------                 ----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2,3 使用 float:right 时, (假设页面宽差一点而不能容纳元素4,)
			   --------  ----------  ------------
 			   |   3  |  |        |  |          |
			   |      |  |    2   |  |     1    |
			   --------  |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------
		也就是说 float 也是 普通流的一种扩展形式, 设置了float的元素, 原始位置也是根据float发生了变化
		影响到 普通流 的其他元素的 原始位置!!
		float还可以配合 clear使用:
		元素1,2,3,4使用left时, 元素3使用了clear:left: (假设页面无限宽)
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |	//其实就是说 3 左边不能紧接着 float:left 的元素  
			|          |  |        |
			|          |  ----------
			------------ 		
			--------  ----------
			|   3  |  |        |
			|      |  |    4   |
			--------  |        |
			          ---------- 		
		同理,  clear:right;  其实就是说 元素 右边不能紧接着 float:right 的元素
		clear:both; 就是 左边不能紧接着 float:left 的元素, 右边不能紧接着 float:right 的元素!!
		clear:both; 就是 左边可以紧接着 float:left 的元素, 右边可以紧接着 float:right 的元素!!
		文字段 #text 与 float元素的的位置关系也是值得 讨论 例如:
			<div id=1>...</div>
			<div id=2>~~~~~~~~~~~~~~~~~~~~..... <img>3</img><div>
			其中 div1 float:right,
			其中 div2 text-align:center; 假装---是文本,最后还有一张图片3,
			就会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
		这样子的话也一样`:
			<div id=2>
			<div id=1>...</div>
			~~~~~~~~~~~~~~~~~~~~..... <img>3</img>
			</div>
			其中 div1 float:right,
			其中 div2 text-align:center;
			div1, 文字段 ~~~~~, 图片3 都是 div1 的子元素
			也会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
			注意	text-align:center; 都是对于一行内容来说的,
				对于有 float占据空间的 的 行 文字居中不算 float占据空间 例如 第2,4行明显
				如果文字与某些非float元素 同阶级, 元素排版时算作文字中的一员,共同实现居中
				图片3 与 文字共存的一行, 图片决定行高,文字和图片一起居中	
				图片3 是内联元素，如果是<div>,就不会出现最后的居中显示 ！！！而是div另外一行！！
display:
	inline: 相当于 <p>AA</p> <p>BBB</p> 能以 <p>AABBB</p> 显示
		------
		| AA |              ---------
		------       --->   | AABBB |
		-------             ---------
		| BBB |
		-------
		一般 <span> <a> 称为内联元素, 因为他们 即使默认情况下,不用设置 dispaly:inline时,
		 <span>AA</span> <span>BBB</span> 也会以 <span>AABBB</span> 显示 !!
	block: 对于 内联元素<span> <a> 等设置 dispaly:block时,内联元素的排版如 <div> <p> 这些快元素一样 一个元素占一行,
		                      ------
		                      | AA |
		---------             ------
		| AABBB |    --->     -------
		---------             | BBB |
		                      -------
	inline-block: 对于 每一个元素都看作 块元素, 然后把块元素放在 同一行上 !!
		即 <p>AA</p> <p>BBB</p> 不以 <p>AABBB</p> 显示, 而是 <p>AA</p> <p>BBB</p>
		   <span>AA</span> <span>BBB</span> 不以 <span>AABBB</span> 显示, 而是 <p>AA</p> <p>BBB</p>
		------
		| AA |              ------ -------
		------       --->   | AA | | BBB |
		-------             ------ -------
		| BBB |
		-------

		---------           ------ -------
		| AABBB |    --->   | AA | | BBB |
		---------           ------ -------
		注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
			如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
			所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

	none:	元素不会计入页面排版,不占用位置,所以也不就不能显示, 
		对应类似属性: visibility:hidden, 但是这个属性会把元素计入排版,即会占用位置只是不显示
	注意 inline 说的是元素被假装看作字符,所以特别注意两个元素对象中间隔着的换行空格符号,在浏览器里一律以一个空格显示
	这时但你想两个元素对象紧贴时,你会发现两个inline元素对象 死活不贴在一起,不是设计magin的问题,而是中间隔了个空格的问题!!
	
dispay:flex  display新属性!!,弹性布局,是容器属性, 即设置在父元素上的.
	子元素的float、clear和vertical-align属性将失效。
	display:flex 需要配合以下属性,一起使用
		flex-direction　　容器内项目的排列方向(默认横向排列)　　
		flex-wrap　　容器内项目换行方式
		flex-flow　　以上两个属性的简写方式
		justify-content　　项目在主轴上的对齐方式
		align-items　　项目在交叉轴上如何对齐
		align-content　　定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
	详细: https://www.cnblogs.com/xuyuntao/articles/6391728.html
对子内联元素/(文本内容),强制不转行,父元素添加:
		style  white-space:nowrap;
		(默认一般自动转行)自动换行:word-wrap:break-word;  


		
综合使用: margin: auto;
	  width: 50%;
	  text-align: center;
	    display: block;
	    position: absolute;
	    right: 0px;
	    width: 300px;
	    padding: 10px;
	    float: right; 	
	    overflow: auto; 	
	    line-height: 200px;
	    height: 200px;
	    display: inline-block;
	    vertical-align: middle;
	    top: 50%;
	    left: 50%;
	可以实现各种对齐居中,,









20180914
前提
	额外js 保存全局变量
	以下框都允许点击并输入数据 称为合法文本框
		spac edtx hdda hdti imgi mati adoi vidi
	合法文本 imgi mati adoi vidi 复杂 \n\r处理,
		一般加\n 如果文本末加\n必须紧接加上\r
		一般退格 删 连续个\r与最前\r前的一个字符
		具体按键具体分析:
修正点击和按键操作 !!!
	base:mousu(event) , base:mousd(event) , base:mousm(event)配合使用,
	   √	mousd 先行任务: 合法文本 hdda hdti imgi mati adoi vidi 是否空,空则补上 <nothing>
	   √	实现基本鼠标点击动作,
	   √	能避免光标落入禁区,
	   √	点击标记色指定打开 contentbar
	   √	可做简单文本拖选, 
	  hold	一些地方的点击效果未理想{暂时不处理}
	keyboard.js : keypress(event) : 预处理
	   √	弹窗删除媒体行相关预处理
	   √	sel非空,才接下一步工作
	   √	sel是光标,才接下一步工作	
	keyboard.js : keypress(event) : spec优先处理:
	   √	spec只接受 空格和\b, 并优先处理, 方向键不在 keypress 处理, 
	   √	退格处理,永远不能让spac没有内容!!
	keyboard.js : keypress(event) : 简单的 fixl判断处理: 
	   √	keypress 前方讨论 提高输入速度  不谈论 \r \b 等 keypress部分按键, 后面会详细讨论
	   √	spac不处理,spac以外的合法文本框处理
	   √	不是undefine的按键都算字符输入, 需要改 fixl
	   √	onkeypress 似乎不识别 ctrl shift capslock, 而基本功能键为undefined,例如方向键
	keyboard.js : keypress(event) : \r(回车):
	   √	spac hdda hdti不处理
	   √	合法文本 imgi mati adoi vidi 生效:
	   √		复杂 \n\r处理: 文末加\n\r,不是文末加\r 	统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √	edtx 生效: 插入newl, 都不改变 cnteid 和 oid
	   √		\r作用行有机会变 fixl,插入行是newl,
	   √		其他行对齐:svdl,orgl变wrpl,wrpl有机会变回svdl,而newl,fixl不变
	 hold	屏幕跟随光标显示
	keyboard.js : keypress(event) : \b(退格):
	   √	spac不处理,多此一举
	   √	合法文本  hdda hdti imgi mati adoi vidi 同样的处理,
	   √		复杂\n\r处理,循环检查光标前有多少个连续\r,一次过删掉多个连续\r和\r前的一个字符
	   √			\r前是文本起点,则只退到文本起点文本起点
	   √			统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √			由于 hdda hdti 没有 \n 或 \r， 所以会自动绕过 \n\r处理
	   √		当回到尽头不操作,当空标记为空文本 
	   √	最后 edtx...
	   √		尽头时,删除当前行,把余下的文本接入上一行
	   √		遇到媒体行, 光标依然处在文本行,弹窗询问是否删除遇到的媒体行,抬起,再按一次\b实现删除,
	   √			实现这个功能现在不能笼统写成一个模快,各种边沿代码遍布各处,其他地方标明 弹窗删除媒体行相关
	   √			分布:keypress开头预处理, \b段贯穿全部, closeWin部分
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : tab键
	   √	实现 tab 缩进
	keyboard.js : keydowm(event) : 方向左
	   √	合法文本 spac hdda imgi mati adoi vidi: 左到尽头不作为 
	   √	hdti : 左到尽头到 hdda
	   √	edtx : 左到尽头, 跳到再上一个文本行的文本末位置, 最初文本行文本初位置不作为
	   √	合法文本 imgi mati adoi vidi  复杂\n\r处理,
	   √		循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点
	keyboard.js : keydowm(event) : 方向右
	   √	合法文本 spac hdti imgi mati adoi vidi: 右到尽头不作为 				
	   √	hdda: 右到头到 hdti
	   √	edtx : 左到尽头, 跳到再下一个文本行的文本初位置, 最后文本行文本末位置不作为
	   √	所有都有 复杂\n\r处理,循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点		
	keyboard.js : keydowm(event) : 方向上
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再上一个文本行同样的文本偏移位置, 溢出跳到文本末, 最初文本行不作为
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : 方向下
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再下一个文本行同样的文本偏移位置, 溢出跳到文本末, 最后文本行不作为
	 hold	屏幕跟随光标显示
修组合键操作操作 !!!	（hold）
	ctrl + cv
特殊操作:	（hold）
	媒体元素上滑鼠,放大显示尺寸
	页面上滑鼠, 显示已加载的起始行~结束行







20180918
完整修正媒体生成
前提：
	base:mousu(event) 已经讨论，
	   √	点击标记色指定打开 contentbar
	base.js : closeWin(e)	弹窗关闭 处理
	   √	检查并关闭 媒体删除弹窗 
	   √	检查并关闭 各类媒体生成弹窗
	base.js : upmed(e) 
	   √	打开指定媒体生成弹窗
	base.js : mmedial(event) :
	 doing	媒体生成弹窗 加载好的内容插入行
	...
继续学习css h3 
	注意 width height 关于% 的层次关系, %是相对父元素的!!
	默认margin-top/bottom > 0 ！
	font-size:6vh;  //vh vw 是字体大小等于浏览器screen的 width height 的%比例例如 6%height
	text-align: center; 只对父元素内的 内联元素和#text起作用，对于块元素不起作用
		例如 文本 + <audio> <img> 会显示在一行并居中
		     文本 + <div> + <p>  <div> 和 <p> 都会另一行显示
		     所以 对于子块元素的居中使用 margin: 0 auto; //上下没有间距，左右间距一样
	关于 form 和 input 的关系:
		input是内联元素,是放入line上的内容. 而 font-size:6vh; line-height:6vh; 是描述 line 和文字的高度的
		内联元素都可以被看成特殊的行文本文字,内联元素的位置 与 父元素的 font-size line-height 设置有紧密关系!!
	就是说 font-size, line-height 可以控制内联元素的位置
	注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
		如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
		所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

继续学习js
	iframe relaod:
		window.location.reload(true); 
			//如需刷新iframe，则只需把window替换为响应的iframe的name属性值或ID属性值
			//  https://www.jb51.net/article/65013.htm  
继续学习python:
	python中是没有NULL的，取而代之的是None
	python是把0，空字符串‘’和None都看作False，把其他数值和非空字符串都看作True
		给一个文字串变量里不停加东西!!可以这样子:
		str1 = ""
		for f in files
			str1 += ("helloworld" + str2 + f.name)
这里修正的内容要一个个流程来记录：
	上传插入音频
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入视频:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!	
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入图片:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 pic数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传公式:
	   (jmeditor要点:jme.js onok 告诉如何获得和处理公式,不过是通过jqurey 方式!!)
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed		funcedit 写公式
	 writed		funcview 预览公式
	 writed		- + 添加/减少写好的公式, 可以点击高亮要加删的位置
	 writed		ok 添加到行数据 !!  恢复默认页面(iframe使用reload)
	上传主题:
	 writed	修正主题行:
	 writed		主题行 标题过长隐藏, 使用的 overflow:hidden; 还有 margin-bottom:-0.4em 微调位置
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed		ok 添加到行数据 !!  恢复默认页面 (iframe可以使用reload)
	 writed		主题优先处理 空白内容 按 ok 的 问题!! nullmed 处理
	上传五线谱:
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示, 并排显示效果不理想,还是竖排比较好
	 writed		有教程链接,
	 writed		textarea 按键触发,自动更新乐谱
	 writed		ok 添加到行数据 !!  恢复默认页面  textarea 的 value 值放文本
	添加/缩减行:(当紧邻的行是媒体行时特别有用)
	 writed	+ 后插入一行
	 writed	- 删除当前一行,
	 writed		删除文本行
	 writed		删除媒体行 (借助 \b按键)
			发现了一个大坑:
`				//   sel一直存在的, 但sel的内容可以是null 
				//   当js函数 中 sel.removeAllRanges() 只是把sel的内容设置null
				//   当js函数完毕后 不会默认处理 sel
				//   但是 js 不管是否执行了 e.preventDefault(), js完毕后, sel的内容都不会被另外处理
				//   event 与 sel 是有区别的
				//   特别注意 js 执行了 e.preventDefault(), js完毕后, 之前的获得的 event 没有释放
				//   所以 可以简单重新 触发 同样的 js !!
				//   比如 div id=klj 设置了一个keydown2,当在点击这个div时,sel指向当前div 并生成 event 
				//   按键时会触发keydowm2,例如打开了一个窗口, 而且例如 keydown2 会 把sel指向其他div
				//   如果 keydown2 执行了 e.preventDefault(), 则keydown2结束后, event斌没有自动消除,
				//   下一刻,按键时,即使 sel不指向当前div, 由于event还在,所以会继续触发这个div 的 keydown2
				//   再下一刻, 鼠标点击其他div 这时,keydown2 没有清除的event 会被 鼠标点击默认事件清除
				//   并获得新的 sel 和 event!!!
				//   页面上的逻辑解释 (糊涂做出来的逻辑,狗屎运)
				//	注意 页面上 按键是 main 元素设置的 , 而其他弹窗独立于 main 元素,
				//	点击 标记色时, 传递js 的是 main 的 event, 标记色打开了独立于 main 的 contentbar
				//	标记色js 执行e.preventDefault(), 标记色js结束后 没有清 event
				//	打开了 contentbar 后, 点击+ - 会传递  contentbar 的 event 到 lineadd-js
				//	这时 lineadd-js 也 执行e.preventDefault() 没有清 event
				//	lineadd-js结束后,     现在 event 存在 main-event 和 contentbar-event
				//	这时,我们可以任意继续 触发 注册在 main 的js ,或则	注册在 contentbar 的js	
				//	而不需要关注 sel 是否也指向同样的位置!!	
	closewin 时恢复素材添加页面
	 writed	所有媒体行窗口关闭时都处理
	ok按键 nullmed 处理!!  (主要在 mmedial 添加处理)
	 writed	pic aud pic 未选择,没有名字,未上传 nullmed	(与服务器设计相关,移植别的服务器请修改mmedial)
	 writed	func 没有函数,函数没有名字,nullmed	//已解决 有bug  第二次无法upfuc 其实是 fucitem 问题, mmedial结束前 fucitem = null
 	 writed	tit  有空白框没填 nullmed		//已解决 有bug <nothing> 问题, 
							//已解决 所有非edtx合法文本都有<nothing>问题, 修改 legalTEmpty 赋值解决
							//已解决 tit独有的 bug ,date title 与 方向左右 与 <nothing>
							//已解决 tit 去 \n\r
	 writed	stv 文本没有内容 nullmed
	媒体行 打开 同样的添加页面, 加载已有内容 修改 upmed
	 writed	tit	
	 writed	fuc
	 writed	stv
	skipped 做着做着才发现, 加载已有的 pic aud vid 没有意义!!因为,使用input type=file type=submit 的关系
至此,实现所有基本编辑功能!!! (仅 firefox)
后续发现bug
	非edtx的合法文本去掉所有字符后再加上新字符也会变nothing,只有不清除所有字符的情况下才不会变















20180929
检修,并开始写 后端
	已解决 tab bug: <div><br></div> 无法添加tab  已解决
安装 pycharm
	https://blog.csdn.net/qq_38683692/article/details/79868391
由于是社区板,没有django套件,不过没关系,我就要它的编辑界面,其他都终端编译,
在所在目录新建一个pycharm工程就可以链接整个文件夹,使用 pc 的文本编辑器方便编译,至于其他功能还是 终端实现
取消自动保存,加星号标记 修改未保存

设计一个`独立的页面使用
	loadlast.html
	base1.js	//拷贝复制base的内容,抽出window.onload
	ready.js 	//专门处理 window.onload()
		使用 $.get( "loadfile", fuction(data.status,xhr){readyloadfile(data.status,xhr)} )
		成功回调函数需要 完全定义在 get 里, 然后调用外部函数 readyloadfile() 执行其他操作
	urls.py  views.py 	//添加	loadlast.html , loadfile 请求处理!

每个用户都有自己的数据表,所以,需要动态建表的能力!!
https://blog.csdn.net/siete/article/details/6170755
https://www.cnblogs.com/kimyeee/p/7241754.html
https://blog.csdn.net/weixin_42134789/article/details/80194488

django 添加 .py 文件,跟普通python添加文件一样不需要另外特别注册
	for 文件夹 import py文件
		py文件.函数()
	for 文件夹.py文件 import 函数
		函数()
	for . import XXX    //从 当前文件位置 加入 XXX
	
	sql命令笔记:
		删除table sql语句:
			drop table web_kate_line;
			删表原则,先删子表,再母表
		查看表内容:
			select * from web_kate_line

关于django 动态建立数据表的 问题,非 通过manager migrate 这样静态指令初始化
	经过痛苦的分析过程,高度怀疑是 BaseDatabaseSchemaEditor.create_model(model) 实现动态建表
	但未知 model具体指什么,
	从源码 发现 model 类似构造
    class Migration(models.Model):
        app = models.CharField(max_length=255)
        name = models.CharField(max_length=255)
        applied = models.DateTimeField(default=now)

        class Meta:
            apps = Apps()
            app_label = "migrations"
            db_table = "django_migrations"

        def __str__(self):
            return "Migration %s for %s" % (self.name, self.app) 
	那么 在 models.py 构造的就是可以填入的 model
	那么一个可用的 动态建表的代码像这样:
		class kate_line(models.Model):
		    name = models.CharField(max_length=255,verbose_name='kname')
		    introduce = models.CharField(max_length=255,verbose_name='ksobject')
		from django.db import connection
		with connection.schema_editor() as editor:
		    editor.create_model(kate_line)
		// connection 与 BaseDatabaseSchemaEditor 的关联如上 connection.schema_editor()
		//一定要用 with 因为涉及 __enter__ 和缺参数的问题
		//python __enter__() 问题:https://www.cnblogs.com/DragonFire/p/6764066.html
		//不能直接 connection.schema_editor().create_model(custom_model)
	创建了数据表,添加数据内容:
		base = kate_line(name = 'bilibiliai',
		                 introduce = 'i still love u'
		                 )
		base.save()
		// django 使用 ORM 的方式 访问 数据库
		// 所以 可以这种方式 给 数据表 web_kate_line 写入数据 bilibiliai i still love u
	另外脱离 models.py那种固定方式,可以使用参考dy_model_creat.py 的 create_model 这种自己建立一个class出来!! 
建立一个保存按钮:页面右下角,鼠标移到显示,移开隐藏:
	onmouseover="this.style.opacity=1;" onmouseout="this.style.opacity=0;"
	点击,收集,并上存.json文件!!
新的技术点,自建文件,并上传!!
参考:
	上传显示进度: https://newsn.net/say/jquery_ajax_upload.html
	生成文件: https://www.jianshu.com/p/e7c7a8e4e9dc
	参考:	https://blog.csdn.net/xcymorningsun/article/details/52949848
		https://coderanch.com/t/549940/languages/generate-xml-file-submit-action
		https://stackoverflow.com/questions/6066837/how-to-write-data-from-form-in-html-to-xml-with-javascript
		https://blog.csdn.net/commandboy/article/details/55680654
	frommdata: 重点有即时处理: https://www.javascripture.com/FormData
	blob才是我需要的??:		https://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/
	用blob发即时图片,django后端获得:	https://stackoverflow.com/questions/48097297/upload-an-image-blob-from-ajax-to-django
	js blob 大文件分片传输:		https://www.jianshu.com/p/4d014a45aaf7
	filereader 读取file但是读取的 都是从input choose 获得的文件:	 https://www.cnblogs.com/tianma3798/p/5836484.html
	
	非常直观填了新坑 !! https://blog.csdn.net/hsany330/article/details/52575459
	不过还有 new file 的问题 active...
新坑: File、FileReader、Blob、Fromdata 对象
	一般 file对象是来自用户在一个 <input> 元素上选择文件后返回的FileList对象，也可以是来自由拖放操作生成的 DataTransfer对象
		FileList {0: file, 1: file, length: 2 }
			length: 2
			0: file
				lastModified: 130989987997
				LastModifiedDate: Thu May 26 2011 23:59:00 GMT+0800
				name: "aa.jpg" 
				size: 902047
				type: "image/jpeg"
				webkitRelativePath: ""
				__proto__: File
			1: file
			__proto__: FileList
	FileReader 对 file 对象 blob 对象的 处理过程对象 例子
		var reader = new FileReader();
		reader.onload = function() {
		    console.log(this.result);
		}
		reader.readAsDataURL(file);	//这里是 通过FileReader 读出一个 file 对象的 DataURL
	dataurl: 一般用于把小文件 对应小的 file 对象 转换成 包含数据信息的 url 跟普通的url一样的使用方式:
		DataURI 一般是把 file对象 编译成 base64 斌码 的 一条长字符串
		格式为:		
		data:[<MIME type>][;charset=<charset>][;base64],<encoded data>	
		对应例子:
		<img class='obj' src="data:[<MIME type>][;charset=<charset>][;base64],<encoded data>"
	URL:一般是文件的位置,但如果文件读入到 file 对象里, 
		可以通过 URL.createObjectURL() 对 file对象里的文件建立一个临时的 url
		img.src = window.URL.createObjectURL(file);
  		<img class="obj" src="blob:null/34c9b3b5-9ca9-4b18-9798-xxxxxx">
	blob: blob 跟 file 对象是一样的, 不过 file对象一般是 通过 <input>选入的,但是 blob是凭空创建的
		var arr = ['<h1>hello world</h1>'];
		var blob = new Blob(arr, { "type" : "text/xml" }); // the blob
		slice方法生成blob对象
			var newBlob = Blob.slice(startingBytenum, endindBytenum);
		DataURI（base64）对象转blob对象（二进制）
			function dataURItoBlob(dataURI) { 
				var byteString = atob(dataURI.split(',')[1]); 
				var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; 
				var ab = new ArrayBuffer(byteString.length); 
				var ia = new Uint8Array(ab); 
				for (var i = 0; i < byteString.length; i++) { 
					ia[i] = byteString.charCodeAt(i); 
				} 
				return new Blob([ab], {type: mimeString}); 
			} 
			// atob() 将base64解码 , btoa() 将字符串转码为base64 
			var str = 'javascript'; 
			window.btoa(str) 		//转码结果 "amF2YXNjcmlwdA==" 
			window.atob("amF2YXNjcmlwdA==") //解码结果 "javascript"
	FormData 用于 ajax 或者 XMLHttpRequest 上传数据到服务器!!
		一般可以值直接把 <form> 内容在初始化时放入
			<form id="uploadForm" enctype="multipart/form-data"> 
				<input id="file" type="file" name="file"/> 
				<button id="upload" type="button">upload</button> 
			</form>
			var fdata = new FormData($('#uploadForm')[0]);
		也可以把数据一条一条放入, 通过 append()
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			append 可以加载 file blob 对象,还可以加载一般表单项
		一般 FormData  例子:
			<form id='test-form'>
			  Input1: <input name='input1'><br>
			  Input2: <input name='input2'><br>
			  <input type='submit'>
			</form>
			..
			  testForm.onsubmit = function(event) {
			    event.preventDefault();
			
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			
			    var formData = new FormData(document.getElementById('test-form')); //添加了 input1 input2 表项
 			
			    formData.append('appendedFile1', new Blob(['foo']));	// 添加了 blob 对象
			    formData.append('appendedFile2', new Blob(['bar']), 'bar.txt'); // 添加了 blob 对象
    			    formData.append('appended1', 'appended value');		// 添加了 一般表单项
			
			    request.send(formData);
			
			    console.log(request.response);
			  }
			formData 内容: 这个表内容格式并不正确 已经误导我了!!1
			{
			  "args": {}, 
			  "data": "", 
			  "files": {			// file blob 对象 会加载到 flies 数组
			    "appendedFile1": "foo",
			    "appendedFile2": "bar"
			  }, 
			  "form": {			// 普通表项会加载到 from 数组
			    "appended1": "appended value", 
			    "input1": "dd", 
			    "input2": "ddd"
			  }, 
			  "headers": {
			    "Accept": "*/*", 
			    "Accept-Encoding": "gzip, deflate, br", 
			    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", 
			    "Connection": "close", 
			    "Content-Length": "648", 
			    "Content-Type": "multipart/form-data; boundary=---------------------------56193008011516604521985403512", 
			    "Host": "httpbin.org", 
			    "Origin": "https://www.javascripture.com", 
			    "Referer": "https://www.javascripture.com/FormData", 
			    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0"
			  }, 
			  "json": null, 
			  "origin": "149.28.122.195", 
			  "url": "https://httpbin.org/post"
			}
	ajax 与 XMLHttpRequest , ajax 是 jqurey 的方式  XMLHttpRequest是 标准 DOM
		ajax: 例子1
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			$.ajax({ 
				type: 'POST', 
				url: '/upload', 
				data: fd, 
				processData: false, // 不会将 data 参数序列化字符串,必须false 
				contentType: false, // 根据表单 input 提交的数据使用其默认的 contentType，必须false 
				xhr: function() { 
					var xhr = new window.XMLHttpRequest(); 
					xhr.upload.addEventListener("progress", function(evt) { 
						if (evt.lengthComputable) { 
							var percentComplete = evt.loaded / evt.total; 
							console.log('进度', percentComplete); 
						} 
					}, false); 
					return xhr; 
				} 
			}).success(function (res) { 
				// 拿到提交的结果 
			}).error(function (err) { 
				console.error(err); 
			});
		ajax: 例子2
			$.ajax({ 
				url: '/upload', 
				type: 'POST', 
				cache: false, 
				data: new FormData($('#uploadForm')[0]), 
				processData: false, 
				contentType: false 
			}).done(function(res) { 
			}).fail(function(res) {
			});
		XMLHttpRequest 例子1
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			    var formData = new FormData(document.getElementById('test-form'));		
			    request.send(formData);
	file对象 还有一种创建,非 input 输入的方式:
		var objFile=new File(["First Line Text","Second Line Text"],FileName);
		第一个参数是一个字符串数组。数组中的每一个元素对应着文件中一行的内容。
		第二个参数就是文件名字符串。
		var objFile=new File(["First Line Text","Second Line Text"],FileName,{type: "text/plain", lastModified: date});
		如果是用三个参数的形式
		第三个参数可以设定一些文件的属性，比如文件的MIME，最后更新时间等。 
	js 的 file 对象相关 还有一个 ActiveXObject 不过是微软 activeX 内容,所以不考虑!!
		但是这个涉及到完整的浏览器操作本地文件的过程:
		参考:http://www.cnblogs.com/ayan/archive/2013/04/22/3036072.html
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据补充
	//前端js 查看 formdata 内容的 方式
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
FormData补充:
	FormData类型其实是在XMLHttpRequest 2级定义的，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利。
	构造函数
		创建一个空对象实例
			var formData = new FormData();
			此时可以调用append()方法来添加数据
		使用已有的表单来初始化一个对象实例
			假如现在页面已经有一个表单
			<form id="myForm" action="" method="post">
			    <input type="text" name="name">名字
			    <input type="password" name="psw">密码
			    <input type="submit" value="提交">
			</form>
			我们可以使用这个表单元素作为初始化参数，来实例化一个formData对象
			// 获取页面已有的一个form表单
			var form = document.getElementById("myForm");
			// 用表单来初始化
			var formData = new FormData(form);
			// 我们可以根据name来访问表单中的字段
			var name = formData.get("name"); // 获取名字
			var psw = formData.get("psw"); // 获取密码
			// 当然也可以在此基础上，添加其他数据
			formData.append("token","kshdfiwi3rh");
	操作方法   首先，我们要明确formData里面存储的数据形式，一对key/value组成一条数据，
		key是唯一的，一个key可能对应多个value。如果是使用表单初始化，每一个表单字段对应一条数据，
		它们的HTML name属性即为key值，它们value属性对应value值。
			key value
			k1 	[v1,v2,v3]
			k2 	v4
		获取值
			我们可以通过get(key)/getAll(key)来获取对应的value，
			formData.get("name"); // 获取key为name的第一个值
			formData.getall("name"); // 返回一个数组，获取key为name的所有值
		添加数据
			我们可以通过append(key, value)来添加数据，如果指定的key不存在则会新增一条数据，如果key存在，则添加到数据的末尾
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.get("k1"); // "v1"
			formData.getAll("k1"); // ["v1","v2","v1"]
		设置修改数据
			我们可以通过set(key, value)来设置修改数据，如果指定的key不存在则会新增一条，如果存在，则会修改对应的value值。
			formData.append("k1", "v1");
			formData.set("k1", "1");
			formData.getAll("k1"); // ["1"]
		判断是否该数据
			我们可以通过has(key)来判断是否对应的key值
			formData.append("k1", "v1");
			formData.append("k2",null);		
			formData.has("k1"); 		// true
			formData.has("k2"); 		// true
			formData.has("k3"); 		// false
		删除数据
			通过delete(key)，来删除数据
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.delete("k1");			
			formData.getAll("k1"); 		// []
		遍历
			我们可以通过entries()来获取一个迭代器，然后遍历所有的数据，
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");
			var i = formData.entries();
			i.next(); // {done:false, value:["k1", "v1"]}
			i.next(); // {done:false, value:["k1", "v2"]}
			i.next(); // {done:false, value:["k2", "v1"]}
			i.next(); // {done:true, value:undefined}
			每调用一次next()返回一条数据，数据的顺序由添加的顺序决定
			返回的是一个对象，当其done属性为true时，说明已经遍历完所有的数据，这个也可以作为判断的依据
			返回的对象的value属性以数组形式存储了一对key/value，数组下标0为key，下标1为value，
			如果一个key值对应多个value，会变成多对key/value返回
		我们也可以通过values()方法只获取value值
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");	
			var i = formData.entries();
			i.next(); // {done:false, value:"v1"}
			i.next(); // {done:fase, value:"v2"}
			i.next(); // {done:fase, value:"v1"}
			i.next(); // {done:true, value:undefined}
		发送数据
			我们可以通过xhr来发送数据
			var xhr = new XMLHttpRequest();
			xhr.open("post","login");
			xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			xhr.send(formData);
			这种方式可以来实现文件的异步上传。
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据formdata补充 知道: 
	也就是 file100 是key 但是一个key可以对应很多 value, 而value的类型可以是单纯字符串,可以是file对象 等等 !!
	//前端js 查看 formdata 内容的 方式1 
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
	//查看 formdata 内容的 方式2
	    var i = fd.entries()
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())
关于python读写文件 和 按行读取文件:
	按行读取文件参考: https://www.cnblogs.com/xuxn/archive/2011/07/27/read-a-file-with-python.html 
	    if request.method == "POST":  # 请求方法为POST时，进行处理
		//获取文件
	        file_obj = request.FILES.get('file100')
	        import os
	        f = open(os.path.join("./", file_obj.name), 'wb+')
	        print(file_obj, type(file_obj))
	        for chunk in file_obj.chunks():
	            f.write(chunk)
	        f.close()
		//按行读取文件
	        file = open(os.path.join("./", file_obj.name), 'r')
	        while 1:
	            line = file.readline()
	            if not line:
	                break
	            print(line)  # do something
	        file.close()


接下来就是数据库
	详细参考: https://www.cnblogs.com/ccorz/p/5845711.html
		http://www.liujiangblog.com/course/django/100
		同步现存,增删查改: https://blog.csdn.net/vainfanfan/article/details/80556429?utm_source=blogxgwz0
		系统 django https://code.ziqiangxuetang.com/django/django-queryset-api.html
		重点参考!!
		https://www.cnblogs.com/pythonxiaohu/p/5807059.html
		https://www.cnblogs.com/pythonxiaohu/p/5814247.html
详细学习 models class
	models.AutoField　　自增列 = int(11)
		如果没有的话，默认会生成一个名称为 id 的列，
		如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。 models.AutoField(primary_key=True)
	models.CharField　　字符串字段 
		必须 max_length 参数 CharField(max_length=32)
	models.BooleanField　　布尔类型=tinyint(1)
　　		不能为空，Blank=True 
	models.ComaSeparatedIntegerField　　用逗号分割的数字=varchar
		继承CharField，所以必须 max_lenght参数	例如"12,2,3,4,5"
	models.DateField　　日期类型 date
		对于参数，auto_now = True 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。
	models.DateTimeField　　日期类型 datetime
		同DateField的参数
	models.Decimal　　十进制小数类型 = decimal
		必须指定整数位max_digits和小数位decimal_places
	models.EmailField　　字符串类型（正则表达式邮箱） =varchar
		对字符串进行正则表达式
	models.FloatField　　浮点类型 = double
	models.IntegerField　　整形
	models.BigIntegerField　　长整形
		　　integer_field_ranges = {
		　　　　'SmallIntegerField': (-32768, 32767),
		　　　　'IntegerField': (-2147483648, 2147483647),
		　　　　'BigIntegerField': (-9223372036854775808, 9223372036854775807),
		　　　　'PositiveSmallIntegerField': (0, 32767),
		　　　　'PositiveIntegerField': (0, 2147483647),
		　　}
	models.IPAddressField　　字符串类型（ip4正则表达式）
	models.GenericIPAddressField　　字符串类型（ip4和ip6是可选的）
		参数protocol可以是：both、ipv4、ipv6
		验证时，会根据设置报错
	models.NullBooleanField　　允许为空的布尔类型
	models.PositiveIntegerFiel　　正Integer
	models.PositiveSmallIntegerField　　正smallInteger
	models.SlugField　　减号、下划线、字母、数字
	models.SmallIntegerField　　数字
		数据库中的字段有：tinyint、smallint、int、bigint
	models.TextField　　字符串=longtext
	models.TimeField　　时间 HH:MM[:ss[.uuuuuu]]
	models.URLField　　字符串，地址正则表达式
	models.BinaryField　　二进制
	models.ImageField   图片
	models.FilePathField 文件
连表结构
	一对多:models.ForeignKey(其他表)
	多对多:models.ManyToManyField(其他表)
	一对一:models.ManyToManyField(其他表)
具体操作:建表 读写 修改 使用 连表!!
懂得一个后端调试手段,不需要打开服务器,直接在 终端调试!! python manage.py shell
django mysql 储存 中文 编码问题:
	(1366, "Incorrect string value: '\\xE7\\xAC\\xAC\\xE4\\xB8\\x80...' for column 'cnte' at row 1")
	再 mysql 里 执行命令!!!
	ALTER TABLE web_content MODIFY COLUMN cnte VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;
	参考: https://my.oschina.net/airship/blog/777146
建表:
	    from django.db import connection
	    with connection.schema_editor() as editor:
	        editor.create_model(Content) 	//Content即models.py里定义的,或自己函数定义的class
直接记录连表操作:
区分 子表 母表:
	class Liker (models.Model):
	    nid = models.AutoField(primary_key=True)
	    name = models.CharField(max_length=255,blank=True, null=True)
	
	class Lnum (models.Model):
	    linum = models.CharField(max_length=255,blank=True, null=True)
	
	class Content (models.Model):
	    ctid = models.AutoField(primary_key=True)
	    type = models.CharField(max_length=10)
	    cnte = models.TextField(blank=True, null=True)
	
	class Line(models.Model):
	    lineid = models.AutoField(primary_key=True)
	    content = models.ForeignKey(Content,blank=True,null=True,on_delete=models.CASCADE)
	    liker = models.ManyToManyField(Liker)
	    lnum = models.OneToOneField(Lnum,on_delete=models.CASCADE)
	Line是子表, Liker, Lnum, Content,是母表,
	OneToOneField 建立 一对一 关系
	ForeignKey 建立 一对多 关系
	ManyToManyField 建立 多对多 关系
基本api认识:
	.get 是获得 数据表中符合条件的第一条数据对象
	.filter 是获得 数据表中符合条件 的 一组数据对象 
一对一:	(母表对象可以作为子表对象中的一个字段内容,但是每个母表对象不能重复出现在一个以上的子表对象里)
	查:
		子表原名.objects.get(子表字段=查询数据).母表表名小写.母表字段名   // 获得指定母表指定字段的内容
		例如: 	Line.objects.get(lineid=4).lnum.linum

		母表原名.objects.get(子表名(小写)__子表字段=查询数据).母表字段名	// 反向查找得到  指定母表指定字段的内容
		例如:	Lnum.objects.get(line__lineid=5).linum		//注意到双下滑线在django models里 的独有用法!!

		子表.objects.get(（一对一的子表字段）子表字段__母表字段=查询数据).子表字段	  //反向查询,得到指定子表字段的内容
		例如:	Line.objects.get(lnum__linum='7').lineid
	增:
		先添加母表数据,然后再作为一个对象 赋给新建的子表对象
		
		//方法1 
		母表.objects.create(字段名字=添加的数据)
		子表.objects.create(（定义一对一）外键字段=母表的对象, 子表的字段=添加的数据)
		例如:  	obj1 = a.Lnum.objects.create(linum='233')
			a.Line.objects.create(lnum=obj1)
		
		//方法2
		对象id=母表.objects.create(字段=数据).id
		子表.objects.create(外键_id=对象id,字表字段=数据)
		例如:	id1 = a.Lnum.objects.create(linum='323').id
			a.Line.objects.create(lnum_id=id1)		//注注意到单下滑线在django models里 的独有用法!!
		
		//方法3
		母表对象=母表.objects.create(字段=数据) 
		子表对象=子表(外键=母表对象, 子表字段=数据)
		子表对象.save() 

		//方法4(字典导入)
		母表对象=母表.objects.create(字段=数据)
		dict={'子表字段':"数据"} 
		子表.objects.create(外键=母表对象,**dict)
	改:
		//修改 母表里单个数据,
		母表对象 = 母表.objects.get(字段=数据)    //get()等同于  .filter().first()
		母表对象.字段名=要修改的数据
		母表对象.save()
	
		//修改 多个指定子表对象 里 的母表对象数据,
		子表.objects.filter(字段=数据).update(外键=母表对象, 子表字段=要修改的数据)  //update(), delete()是QuerySet方法
		
		//修改 多个 含母表对象的子表对象 的数据
		子表.objects.filter(外键__母表字段=母表的数据).update(子表字段=要修改的数据)		

		//也可以 通过字典修改
    		dict = {"子表字段":"要修改的数据"}
    		子表.objects.filter(~~~~).update(**dict)
	删:
		子表.objects.get(字段=数据).delete()	//对象和QuerySet都有delete()
		母表.objects.all().delete()	//清空一张表

		母表.objects.filter(字段=数据).delete()
		例如	Lnum.objects.filter(linum='7').delete()

一对多:	(母表对象可以作为子表对象中的一个字段内容, 每个母表对象可以重复出现在一个以上的子表对象里)
	查:
		子表.objects.get(字段=数据).母表.母表字段 	//(找的是母表数据)	
		例如	Line.objects.get(lnum__linum='3').content.cnte
	
		母表.objects.get(子表__字段=数据).母表字段 	//找的是母表数据
		例如	Content.objects.get(line__lineid=4).cnte

		//查询含有指定母表对象的子表对象,方法1
		母表对象 = 母表.objects.get(字段=数据) 
		母表对象.子表_set.all() 	//注意：子表小写_set的写法,它实际上是一个QuerySet,可以用update,delete,all,filter等方法
		例如	obj1 = a.Content.objects.get(ctid=2)
			obj1.line_set.all()

		//方法2
		子表.objects.filter(字段=母表.objects.get(母表字段=数据)) 
		子表.objects.filter(子表外键__母表字段=数据) 	//写法：filter(子表外键字段__母表字段='过滤条件')
		
		//方法3 
		母表对象 = 母表.objects.get(字段=数据).id
		子表.objects.filter(子表外键_id = 母表对象) 	//filter得到QuerySet,写法：filter(子表外键字段_母表主键=母表主键对象) 

		关于 ValueQuerySet 问题:  通过QuerySet的.values()方法，将QuerySet转化为ValuesQuerySet
		子表.objects.filter(子表外键名=母表.objects.get(母表字段=数据)).values('子表外键__母表字段名', '子表字段') 
		子表.objects.filter(子表外键__母表字段=数据).values("子表外键__母表字段", '子表字段')
			获取子表的某一个字段, 和母表的某一个字段，然后构成 ValuesQuerySet
			即获得指定母表字段和对应的子表字段, 构成 字典序列 key:value 输出显示
			获取母表字段写法: 子表外键字段名__母表字段名--适用于values()或filter() 
		如果不加values(),返回的是:
			[<子表: xxx>, <子表: xxx>]这样一个QuerySet集合，
		通过values可以形成一个列表，列表中的每一个元素是一个字典，
		可以通过list()将ValuesQeurySet转化为列表，之后返回给templates
		另外可通过.values_list()将QuerySet转化为ValuesListQuerySet
			返回：[(u'\u7ea2', u'\u7ea2\u889c\u5b50'), (u'\u7ea2', u'\u7ea2\u889c\u5b50')] 
			得到的是一个列表，列表中是多个元组，每个元组是ValuesQuerySet中字典的value，
			常用于从models里将数据取出后动态添加到前端模板中的select选项中
		例如:	Line.objects.filter(content_id=2).values("content__cnte","lnum__linum")
				<QuerySet [{'lnum__linum': '3', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '4', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '5', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '6', 'content__cnte': '第1条信息'}]>
		例如:	Line.objects.filter(content_id=2).values_list("content__cnte","lnum__linum")
				<QuerySet [('第1条信息', '3'), 
					   ('第1条信息', '4'), 
					   ('第1条信息', '5'),
					   ('第1条信息', '6')]>

		最后一条数据,第一条数据:
			xxx.objects.last()
			xxx.objects.first()
	增: 
		子表.objects.create(子表外键=母表.objects.get(母表字段=数据).子表字段=需要添加的数据) 
	
		子表.objects.create(子表外键_id=母表.objects.get(母表字段=数据).id, 子表字段=要添加的数据)

		返回对象 = 子表(子表外键=母表.objects.get(母表字段=数据), 子表字段=要添加的数据) 
		返回对象.save()
	改:
		//写法1 
		子表.objects.filter(子表外键__母表字段=数据).update(子表需要更改的字段=改为什么的数据) 
		//写法2
		子表.objects.filter(子表外键_id=母表.objects.get(母表字段=数据).id).update(子表需要更改的字段=改为什么的数据)
		//写法3 (对应母表的子表的id大于等于1的数据全部修改) 
		母表对象 = 母表.objects.get(字段=数据) 
		母表对象.子表_set.filter(id__gte=1).update(子表字段=改为什么数据)
			__gt 大于 
			__gte 大于等于 
			__lt 小于 
			__lte 小于等于
		
	删:
		子表.objects.get(字段=数据).delete() //对象和QuerySet都有delete() 
		母表.objects.filter(字段=数据).delete() 
多对多:	(一个子表对象里 有包含母表对象的字段, 而这个字段可以包含多个母表对象 这些母表对象也可以被其他 子表对象所有共有)
	建立多对多关系后 ,比如 mysql 会多建立一张表 web_line_liker,而不是在原来的 line表 添加一个 liker_id 字段

	查:
		// 查询并获得 子表对象里 含有的 所有对应多对多母表对象
		返回对象 = 子表.objects.get(字段=数据) 	//写法：子表对象.子表多对多字段.过滤条件(all()/filter())
    		返回对象.外键.all()
		例如:	Line.objects.get(lineid=6).liker.all()
		<QuerySet [<Liker: Liker object (1)>, <Liker: Liker object (2)>, <Liker: Liker object (3)>, 
			   <Liker: Liker object (4)>, <Liker: Liker object (5)>, <Liker: Liker object (6)>, 
			   <Liker: Liker object (7)>, <Liker: Liker object (8)>, <Liker: Liker object (9)>, 
			   <Liker: Liker object (10)>, <Liker: Liker object (11)>, <Liker: Liker object (12)>, 
			   <Liker: Liker object (13)>, <Liker: Liker object (14)>, <Liker: Liker object (15)>, 
			   <Liker: Liker object (16)>, <Liker: Liker object (17)>, <Liker: Liker object (18)>, 
			   <Liker: Liker object (19)>, <Liker: Liker object (20)>, '...(remaining elements truncated)...']>
		
		//反向查询 获得 所有对应多对多母表对象
		母表.objects.filter(子表表名小写__子表字段名=数据)  //母表对象.filter(子表表名小写__子表字段名="过滤条件")	
		例如:	Liker.objects.filter(line__lineid=6)
		<QuerySet [<Liker: Liker object (1)>, <Liker: Liker object (2)>, <Liker: Liker object (3)>, 
			   <Liker: Liker object (4)>, <Liker: Liker object (5)>, <Liker: Liker object (6)>, 
			   <Liker: Liker object (7)>, <Liker: Liker object (8)>, <Liker: Liker object (9)>, 
			   <Liker: Liker object (10)>, <Liker: Liker object (11)>, <Liker: Liker object (12)>, 
			   <Liker: Liker object (13)>, <Liker: Liker object (14)>, <Liker: Liker object (15)>, 
			   <Liker: Liker object (16)>, <Liker: Liker object (17)>, <Liker: Liker object (18)>, 
			   <Liker: Liker object (19)>, <Liker: Liker object (20)>, '...(remaining elements truncated)...']>

		//获得包含母表对象 的 子表对象
		返回对象 = 母表.objects.get(字段=数据)
		返回对象.子表_set.all()		
		例如:	Liker.objects.get(nid=3).line_set.all()

		//获得子表对象方法2
		子表.objects.filter(子表外键=母表.objects.get(母表=数据))	
		子表.objects.filter(子表外键__母表字段=数据)

		//获得子表对象方法3
		返回对象 = 母表.objects.get(字段=数据).id 
		子表.objects.filter(子表外键=返回对象) ##filter得到QuerySet,写法：filter(子表外键字段=母表主键对象),
		此处和一对多略有不同，是子表外键字段而不是外键字段_母表主键
		例如:	obj1 = a.Liker.objects.get(nid=3).nid
			a.Line.objects.filter(liker = obj1)	//注意,不是 filter(liker_id = objs)
		因为 Line 和 Liker 是 多对多关系, Line表 没有 liker_id 字段,也没有liker字段, 他们的关系表现在一张新表里

	增与改	(就是添加关系)
		//写法1 
		返回对象一 = 子表.objects.create(字段=数据)	//如果存在可以使用.get() 
		返回对象二 = 母表.objects.all() 		//创建母表的所有数据QuerySet对象 
		返回对象一.子表外键.add(*返回对象二) 		//写法：子表对象.子表多对多字段.add(*QuerySet对象)	

		//写法2 
		子表对象 = 子表.objects.get(字段=数据) 
		母表对象 = 母表.objects.all() 
		子表对象.子表外键=母表对象 		//注意没有用 *
		子表对象.save() 

		//让子表数据对象 添加指定几个母表数据 
		子表对象 = 子表.objects.get(字段=数据) 
		母表对象 = 母表.objects.filter(字段__in = ["数据一"， "数据二"])  //models默认只能用这种方式得到并集，
										//如需更复杂的过滤逻辑，需使用模块Q 
		子表对象.子表外键.add(*母表对象)	//add是追加模式，如果当前子表数据已经存在母表对应数据，
						//那么执行后，子表原有对应关系不变,会额外增加数据对应 
		子表对象.子表外键.clear()	//是清空子表对应的母表数据 

		//添加一个母表数据
		子表对象=子表.objects.get(字段="数据") 
		母表对象=母表.objects.get(字段="数据") 
		子表对象.子表外键.clear() 
		子表对象.子表外键.add(母表对象) 	//此处没有* 

		//反向插入,即从母表插入
		子表对象=子表.objects.get(字段=数据) 
		母表对象=母表.objects.get(字段=数据) 
		母表对象.子表表名小写_set.add(子表对象) 	//从母表插入子表数据，写法：母表对象.子表名小写_set.add(子表对象)。 

		//让子表所有数据 都添加同一个母表数据
		子表对象=子表.objects.all() 
		母表对象=母表.objects.get(字段=数据) 
		母表对象.子表表名小写_set.add(*子表对象) //另外备注一下:
							//母表对象.子表表名小写_set.clear(),是让所有子表数据去掉母表某一个数据对应,即删除关系
							//母表对象.子表表名小写_set.all().delete(),这里不是删除关系,而是删除涉及的子表对象
		关于_set写法，究竟什么时候使用_set,简单记忆，只有子表才有"子表名小写_set"的写法，得到的是一个QuerySet集合，
		后边可以接.add(),.remove(),.update(),.delete(),.clear()
		使用子表_set的接的add(),.remove(),.update(),.delete(),.clear()
		子表.objects.get/filter 接的 add(),.remove(),.update(),.delete(),.clear() 部分函数功能不一样,例如clear.remove	

	删:	(一般是 删除关联,)
		//从子表来删 写法1 
		子表对象=子表.objects.get(字段=数据) 
		母表对象=母表.objects.all() 
		子表对象.子表外键='' 
		子表对象.save() 
	
		//从子表来删 写法2： 
		子表对象=子表.objects.get(n字段="数据") 
		母表对象=母表.objects.all() 
		子表对象.子表外键.remove(*母表对象) 

		//从子表来删 写法3： 
		子表对象=子表.objects.get(字段="数据") 
		子表对象.子表外键.clear() 

		//从母表来删 写法1:
		子表对象=子表.objects.all() 
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.remove(*子表对象) 
		
		//从母表来删 写法2： 
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.clear() 
	
		//以下不是删除关系,而是删除 指定表对象数据
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.all().delete() #注意有.all() #删除包含对应母表对象所有子表对象及数据 
		例如	Liker.objects.get(nid=4).line_set.all().delete()
			lineid=6 的子表对象, 含有 nid=4 的母表对象!!
			这句话的意思是 删除 lineid=6 的子表对象, 
			而 lineidlineid=6 的子表对象, 包含 Liker母表的所有母表对象, 
			所以, 这些母表对象也要被删除 !! 

		//删除所有子表数据		
		子表.objects.all().delete()
关于 筛选:
	利用双下划线将字段和对应的操作连接起来,例如:
	# 大于，小于  利用双下划线将字段和对应的操作连接起来 
	# models.Tb1.objects.filter(id__gt=1)              # 获取id大于1的值
	# models.Tb1.objects.filter(id__lt=10)             # 获取id小于10的值
	# models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值
	# models.Tb1.objects.all()[10:20]  #取所有数据的10条到20条，分页的时候用的到,注意不是id 10到20 的!!

	注意,XX.objects.filter(description="黑球") 是筛选出一堆符合条件的的数据条成为数组,
	    XX,objects.get(name="kate") 是选出对应的一个对象.
	    filter选出的 数组有 .update()  .delete() 等方法改变数据,
	    get得到的 单个对象,未知道有没有!!!
	    然后其他函数都是在get 和 filter 后面接上的专门处理数据
	现在改变连表关系时的数据排列问题!!
	被 OneToOneField(Lnum,on_delete=models.CASCADE) 指定的 Lnum 无法使用 create()建立新内容
models class 中的 meta 参数:
	abstract = True 	//这个model就是一个抽象类,抽象类不会具体化,只有被继承后才会
	app_label = 'web' 	//当 model 不是在models里定义,需要添加告诉django 这是那个django项目的表单
	db_table = 'Students'	//定义该model在数据库中的表名称,
	managed			//默认值为True，这意味着Django可以使用syncdb和reset命令来创建或移除对应的数据库。
				//默认值为True,如果你不希望这么做，可以把manage的值设置为False	
	ordering		//这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。默认使用升序排列
				//ordering=['order_date'] # 按订单升序排列
				//ordering=['-order_date'] # 按订单降序排列，-表示降序
				//ordering=['?order_date'] # 随机排序，？表示随机
				//ordering=['-pub_date','author'] # 以pub_date为降序，在以author升序排列
	verbose_name		//意思很简单，就是给你的模型类起一个更可读的名字一般定义为中文，例如verbose_name = "学校"

关于执行 sql命令 和 检测数据库表是否存在的 django 操作:
	检测数据库表单是否存在:
		from django.db import connection
		table_name in connection.introspection.table_names()	// in运算 返回true false
	两个重点  Migration connection
	https://code.djangoproject.com/wiki/DynamicModels  //Dynamic models 官方动态数据库教程
	https://docs.djangoproject.com/zh-hans/2.1/topics/db/sql/	//执行纯 sql 指令
	注意 raw 并不好用: 最执行纯 sql指令 的函数 是 execute():
		from django.db import connection
		with connection.cursor() as cursor:
		    cursor.execute('ALTER TABLE web_content MODIFY COLUMN cnte VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')		
		//执行这条 纯 sql指令后  content 可以输入 中文!!

关于删的过程中出现的 连带关系的改变
	母表数据,如果与子表数据联系了,就删除会出错,系统不允许删除
	子表数据删除,会连带母表数据也被删除
	如果母表数据被多个 子表对象共享, 未知 删除某个子表对象,会导致母表对象被删除
	最后发现,使用 django orm 方式
	母表对象必须存在即 已经 save 的情况下才可以 写到 子表里
	删除子表时,连表到的母表并没有删掉! 需要自己删掉!!

models 技巧: select_related prefetch_related

python学习补充:		
	__str__ 是 python的内容,	
	lambda表达式可以理解成为匿名函数，其功能就是定义了一个函数，不过这个函数形式非常简单，通常是一行。过于复杂的函数还是正经定义的好。
		例如:	g = lambda x:x+1
			g(1)
		例如:'__str__' : lambda  self : '%s %s %s %s' % (self.type, self.category, self.title, self.answer),
			xx.__str__()






20181024:
	django 的 数据库 摸得差不多了,开始简单数数据库
	建立三张表
	user:
	自动id 用户名  密码+用户名sha 实名 身份证 信息信用表 save_sha表 line表 xontent表 最大contentid 最大lineid 最后修改时间!!
	line表:
	自动id lineid 一对多content 最后修改时间
	content表:
	自动id contentnum type	 content history  count  最后修改时间 
	
	最后修改时间是服务器自己分配的时间,而不是前端用户点击保存传递过来的时间!!
	另外的信用表记录信用事件,未规划如何使用
	save_sha表 计划 每次save 都产生一个sha, 计划用于防止恶意修改数据 未规划如何使用
	刷新数据库前,先处理内容冲突, 发现冲突,不刷新数据,通知用户先 把修改后的数据拷贝到记事本上,重新刷新后,重新修改!!
		比如说数据库上 14行 本来是 contentid 为40 的内容  type 是text
		不知道是什么问题, 前端保存数据时 提交的信息说 原来 14行是contentid为20的内容 type是pic 的内容,

分析每一个要用到是 数据 的类型!!! 顺便测试建模
	https://docs.djangoproject.com/en/2.1/ref/models/fields/	//参考
	用户名: models.CharField(max_length=100),
	密码+用户名sha (64位16进制):  models.CharField(max_length=100), 
		用64个字符保存吧,或者 64位16进制数字 转成32个char字节,再保存!!	//不好实现
	实名: models.CharField(max_length=100), 但是要求中文!!
	身份证 (种类:数字) models.CharField(max_length=100),
	信息信用表 models.CharField(max_length=100),
	save_sha表,line表,xontent表: models.CharField(max_length=100), 表名字
		关于 models.CharField(max_length=xx), 一定要填 max_length, 但是注意 他是按照 asscii 编码来算字符
		但我们 改成utf编码后,是按照utf来数字符的, 比如 max_length=23 表示最多 23 个 utf 字符.
		除了 max_length=xx 一般还使用通用的 blank=True, null=True, 表示可以填入空字符!!
		    
	最大contentid, 最大lineid,大整数, contentid, count: IntegerField(Field)  即可 -2147483648 ～ 2147483647  足以应付1300.0000 行
		关于models.IntegerField(), 一般使用通用参数 blank=True, null=True 就好了
		填入的 是数字内容 	
	最后修改时间: 我们使用 DateTimeField : https://blog.csdn.net/liereli/article/details/79790303 参考:
		关于 models.DateTimeField(blank=True, null=True), 这个本质是继承字符串的一种格式
		一般的格式是这样的: 2018-10-27 15:19:32.175228. 
		我们填写要当成字符串填写: 例如   
			'datetime': models.DateTimeField(blank=True, null=True),
			datetime='2019-10-22 21:49:05.456263'
		此外 DateTimeField 还有自己独有的参数: auto_now_add=True auto_now=True
			auto_now_add=True 表示 但我们xx.save()等方式写入一条新数据记录时, DateTimeField 字段会自己获得系统时间
				并存入到 DateTimeField 字段里, 当下次修改这条记录时,不会自动这个 DateTimeField 字段 的内容
			auto_now=True 表示,不管我们更新还是修改 一条数据记录时, DateTimeField 字段会自己获得系统时间,
				并存入到 DateTimeField 字段里,
		另外, 不使用 auto_now=True 或者 auto_now_add=True 可以通过以下方式获得系统时间
			from datetime import datetime
			from datetime import timezone
			datetime=datetime.now().replace(tzinfo=timezone.utc)
	content, history : textfield
		关于 models.TextField(blank=True, null=True), 一般 使用blank=True, null=True 参数 允许空字符输入就好了
		TextField() 一般就是可以输入不限个字符的 CharField
	使用动态建模,过程: 整体未遇到什么坑
		fields = {
		    'user': models.CharField(max_length=100),
		    'pw_sha': models.CharField(max_length=64),
		    'realname': models.CharField(max_length=100),
		    'pesonalid': models.CharField(max_length=100),
		    'XXXtable': models.CharField(max_length=100),
		    'content': models.TextField(blank=True, null=True),
		    'count': models.IntegerField(blank=True, null=True),
		    'datetime': models.DateTimeField(blank=True, null=True),
		}
		options = {
		    'ordering': ['user', 'count', 'datetime'],
		    'verbose_name': 'william_test',
		}
		admin = {}
		from django.utils.encoding import smart_str  #  convert unicode to string
		
		custom_model = create_model('william',
		                            fields,
		                            options=options,
		                            app_label='web',
		                            module='web',
		                            admin=admin
		                            )
		install(custom_model)		//之前都是定义模型参数,这里就是建立实体mysql库
		with connection.cursor() as cursor:	//这里是 修改指定字段可以输入中文
		    cursor.execute(
		        'ALTER TABLE web_william MODIFY COLUMN user VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
field 主要参数 详解
	https://www.jianshu.com/p/79a418826357		//通用 field 参数讲解
	https://www.cnblogs.com/linxiyue/p/3662535.html	//通用 field 参数讲解
	通用的:
		verbose_name: 这是 字段 在 admin 管理页面显示的通俗名字 一般如 verbose_name='书本名字'
		null	: 允许空字符
		blank	: 也有允许空字符的意思?? 一般和null 一起使用 blank=True, null=True 表示允许空字符
非通用的
	auto_now :使用解释如 DateTimeField 所说
	auto_now_add :使用解释如 DateTimeField 所说
	on_delete: 用于连表字段 models.ForeignKey(其他表) models.ManyToManyField(其他表)  
		多对多(ManyToManyField)没有 on_delete 参数 !!!
		值一般可 =
		models.CASCADE:这就是默认的选项，级联删除，母表数据被删,这边子表的数据也要被删
		models.DO_NOTHING: 母表数据被删,这边子表什么都不做
		models.PROTECT: 保护模式，如果采用该选项，母表数据被删的时候，会抛出ProtectedError错误。
		models.SET_NULL: 置空模式，母表数据被删的时候，子表的这个外键连表字段会被置空,
			前提这个外键连表字段要设置 blank=True, null=True,定义该字段的时候，允许为空。
		models.SET_DEFAULT: 置默认值，母表数据被删的时候，子表的这个外键连表字段设置为默认值，
			所以定义子表的这个外键连表字段的时候注意加上一个默认值。
		models.SET(): 自定义一个值，,母表数据被删的时候，子表的这个外键连表字段设置为某个指定内容!!
			SET()使用例子:
			    user = models.ForeignKey(USER, on_delete=models.SET( USER.objects.get(id=100) )
基本数据库的坑补得差不多了,现在需要 js 和 py 对 xml 的处理问题, 
	考虑到多媒体文件不是单行字符串数据, 对应的content 需要塞入多行内容,所以需要使用xml
	js找来了一个生成 xml 文件的库函数 xmlwriter.js,但是要做补充, 自己写自己的 tofromstring, 具体还是要说明一下!!
	这里主要学习 字符串的 replace 函数 把 & < > " 等字符转成转义字符,避免注入攻击
	然后就是python的了!!有多种方法,优先使用ElementTree 高速!!
		例如 example.xml
		<?xml version="1.0"?>
		<doc>

		<Line><Cndt>1:1:1:256:0</Cndt>
		<Cnte> 这是第一篇文章的开头</Cnte>
		</Line>
			
		<Line><Cndt>1:1:2:257:0</Cndt>
		<Cnte> 床前明月光</Cnte>
		</Line>
		
		</doc>

		import xml.etree.ElementTree as ET
		tree = ET.ElementTree(file='example.xml')
		root = tree.getroot()	
		root[0].tag	//Line
		root[0][0].tag	//Cndt
		root[0][1].tag	//Cnte
		root[0][1].tag	//这是第一篇文章的开头
	python 写 xml 同样 使用 ET 参考 : https://www.cnblogs.com/AlwinXu/p/5483177.html
	js 读 xml,主要使用 原生DOM方式,原生js 使用 window.XMLHttpRequest 或者 window.DOMParser 方式 
		https://blog.csdn.net/u013719339/article/details/73181122
		https://blog.csdn.net/zxyudia/article/details/62891849
		http://www.w3school.com.cn/tiy/t.asp?f=xmle_node_parsertest_1
	还要解决 django的 GET 请求!!其实也就是:
	if request.method == "GET":  # 请求方法为GET时，进行处理
		return render('/static/clients/clie001/example.xml')
	但是,关于,django 这个 request 的详细内容,可以看 http://djangobook.py3k.cn/appendixH/
python 读文件片段 
        file = open(os.path.join("./", file_obj.name), 'r')
        while 1:
            line = file.readline()
            if not line:
                break
            print(line)  # do something
        file.close()
现在搭路 前端写xml 传到后端 后端存数据库 然后后端读取数据库写xml:
	前端写xml,只使用 Kate Bobe spac 三个tag
	然后后端 先检查 <>符号和 tag 然后直接把 Cnte 的全部内容写入 数据库
	检查建立数据库表单出现的问题!!
		textfield 是不能使用: ALTER TABLE web_william MODIFY COLUMN user VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL 来更改 字符编码的
		应该使用: 'ALTER TABLE web_william MODIFY COLUMN user TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL
		mysql 这句话的意思:
			ALTER TABLE web_william 	//选择表
			MODIFY COLUMN user		//更改字段内容
			VARCHAR(100) /TEXT		//如果这个字段是 charfield 那么使用 VARCHAR(100) 限制多少个字符!!
							  字符个数与字符编码有关系,并不是8bit数据为一个字符
							  如果这个字段是 textfield 那么是并不限制字符个数的!!
			CHARACTER SET utf8 COLLATE utf8_general_ci	//表示 字符编码设置为 utf-8
			NOT NULL / NULL  		//表示这个字段 不允许空 或者允许空 状态
	python 补坑:
		python没有 switch !! 最好还是使用 if elif 代替	
		password-sha 格式  用户名<签名>密码 转成的sha256	
		数字转字符串 int(xx) 数字字符窜转数字 str('xxx')
		注意.子表对象不能直接对包含的母表对象内容直接修改:只能通过反向查询获得母表对象然后母表对象对自身内容进行更改
			例如不能 23line.content.count = 1
				 23line.save()
			只能反向查询  cnt = Cnte.objects.get(line0001__linenum=23)
				cnt.count = 1
				cnt.save()
		例如:needyou<i dont like it>123456 -> 574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B
		一定要添加一条 userlist 用户数据 才可以好好模拟接下来的事情!!
		还有 使用 objects.get()不存在的数据条可能会出错,所以适合使用 try: expect: 而不是 if: else:
		python Elementtree 处理 xml 的重点 以及处理 复杂的编码准换关系 :
			ET 不能有 包含子tag的text 但是可以通过tostring和fromstring 转换格式来存储,
			然而也有问题
			参考: https://www.zybuluo.com/Alston/note/778377
			先:cnte = ET.tostring(child[1],encoding='utf-8') 
			使用tostring 只能获取整段子内容字符串格式,但是不是一般的字符串对象,是有很多其他继承内容的 特殊字符串对象
			然后 必须先解码: cnte.decode('utf-8'), 显然这个decode是这个字符串特有的继承函数
			然后才把解码后的字符串写入数据库 写入的内容是 <ss><a>喜欢你</a></ss>
			然后重新读出来后使用 formstring 就可以完美重构 Element对象内容:
			        kk1 = lucy[6].linecnte.content
				xmlcnte = ET.fromstring(kk1)
			如果不decode, 直接把字符串写入数据库,
			那么写入的内容是 b'<ss><a>\54\57\64\</a></ss>'
			重新读出来也是 这个奇怪的字符串内容,
			读出来的这个奇怪字符串是一个普通的字符串对象,没有继承,所以不可以使用 decode
			直接 fromstring 也会出错.
			另外补充: tostring的得到字符串 也是 b'<ss><a>\54\57\64\</a></ss>'
				但是这个tostring的字符串是特殊字符串,所以可以直接 fromstring 回去 不出错!!
			xml 节点换行美化问题:
			节点结构:
			<kate age=12 tall='6feet'> hello all </kate>
			   |    \	 /             |        |    |
			  tag     attrib              text     tag  tail
			注意 tostring 会把 tail 的字符内容也算入
			很多时候我们需要节点换行,其实就是在tail添加 \n 符号  
			关于根节点的的 换行,使用 Elementtree库的话,	直接在 root.text='\n'就好.
			因为.text赋值的内容紧贴着<root> 而不是紧贴</root>,也不会在中间
			注意 tostring 会把 tail 的字符内容也算入字符串,但是 append时会忽略tail的内容
		python 比较 字符串 使用 == 当两个字符串完全相同,true 否则 false
		python 初始化数组有两个类型:
			aa = []
			bb = {}
			使用[]的 无法使用 aa[2] = 90, 给成员赋值,只能 使用 aa.append(90)	
			使用{}的 可以使用 aa[1] = 89, 的方式赋值
    后端接收xml参考片段:
    # 接收 xml 文件
    if request.method == "POST":  # 请求方法为POST时，进行处理
        print('2222')
        file_obj = request.FILES.get('file100')
        import os
        f = open(os.path.join("./", file_obj.name), 'wb+')
        print(file_obj, type(file_obj))
        for chunk in file_obj.chunks():
            f.write(chunk)
        f.close()
        print('xml file get')



        # 检查并生成数据库表单
        from django.db import models
        from django.db import connection
        from web.dy_model_creat import create_model
        from web.dy_model_creat import install
        table_name = 'web_userlist'
        fields = {
            'user': models.CharField(max_length=32),
            'pwsha': models.CharField(max_length=64),
            'realname': models.CharField(max_length=64),
            'pesonid': models.CharField(max_length=100),
            'trusttb': models.CharField(max_length=100),
            'svshatb': models.CharField(max_length=100),
            'linetb': models.CharField(max_length=100),
            'cntetb': models.CharField(max_length=100),
            'blinenum': models.IntegerField(blank=True, null=True),
            'bcntenum': models.IntegerField(blank=True, null=True),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['user', 'datetime'],
            'verbose_name': '用户列表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Userlist = create_model('userlist',
                                fields,
                                options=options,
                                app_label='web',
                                module='web',
                                admin=admin
                                )
        if  table_name in connection.introspection.table_names() :
            pass
        else :
            install(Userlist)
            with connection.cursor() as cursor:
                cursor.execute(
                    'ALTER TABLE web_userlist MODIFY COLUMN user VARCHAR(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
                cursor.execute(
                    'ALTER TABLE web_userlist MODIFY COLUMN realname VARCHAR(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
        #添加 用户 使用try expect 而不是 if else 
        try:
            user = Userlist.objects.get(user='needyou', pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B')
            ltb = 'web_' + user.linetb
            ctb = 'web_' + user.cntetb
            biglinenum = user.blinenum
            bigcntenum = user.bcntenum
            print(ltb,ctb,'///////////////////////////////////////////////')
        except:
            Userlist.objects.create(user='needyou',    #needyou<i dont like it>123456
                                pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B',
                                realname='下半世',
                                pesonid='chinaid:33987117809046775',
                                trusttb='trust0001',
                                svshatb='svsha0001',
                                linetb='line0001',
                                cntetb='cnte0001',
                                blinenum=0,
                                bcntenum=255,
                                datetime='2019-10-22 21:49:05.4587')
            ltb = 'web_line0001'
            ctb = 'web_cnte0001'
            biglinenum = 0
            bigcntenum = 255

        #添加 用户相关数据表
        fields = {
            'cntenum': models.IntegerField(blank=True, null=True),
            'type': models.CharField(max_length=10),
            'content': models.TextField(blank=True, null=True),
            'history': models.TextField(blank=True, null=True),
            'count': models.IntegerField(blank=True, null=True),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['cntenum', 'datetime'],
            'verbose_name': '0001内容表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Cnte = create_model('cnte0001',
                            fields,
                            options=options,
                            app_label='web',
                            module='web',
                            admin=admin
                            )
        if  ctb in connection.introspection.table_names() :
            pass
        else :
            install(Cnte)
            with connection.cursor() as cursor:
                cursor.execute(
                    'ALTER TABLE web_cnte0001 MODIFY COLUMN content TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NULL')
                cursor.execute(
                    'ALTER TABLE web_cnte0001 MODIFY COLUMN history TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NULL')
            #创建 空内容行
            Cnte.objects.create(cntenum=0,
                                type='edit',
                                content='<Cnte>&lt;br&gt;</Cnte>\n',
                                count=0
                                )

        fields = {
            'linenum': models.IntegerField(blank=True, null=True),
            'linecnte': models.ForeignKey(Cnte, blank=True, null=True, on_delete=models.CASCADE),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['linenum', 'linecnte', 'datetime'],
            'verbose_name': '0001行表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Line = create_model('line0001',
                            fields,
                            options=options,
                            app_label='web',
                            module='web',
                            admin=admin
                            )
        if ltb in connection.introspection.table_names():
            pass
        else:
            install(Line)

        #读取xml文件并写入数据到数据库
        from datetime import datetime
        from datetime import timezone
        dt = datetime.now().replace(tzinfo=timezone.utc)

        import xml.etree.ElementTree as ET
        from xml.etree.ElementTree import Element
        from xml.etree.ElementTree import ElementTree
        tree = ET.parse('testfile')
        root = tree.getroot()
        epty = '<Cnte>&lt;br&gt;</Cnte>\n'
        for child in root:
            # print(child[0].text)
            strl = child[0].text
            if 'newl' in strl:
                strl = strl.split(':')
                typ = strl[1]       # 不能使用 type 变量,只能使用typ
                cnte = ET.tostring(child[1],encoding='utf-8')
                cnte = cnte.decode('utf-8')
                # print(cnte.decode('utf-8'))
                # print(lucy[4].linecnte.content, kong, '::::::', cnte == epty)
                if cnte == epty :
                    # print('yes')
                    content = Cnte.objects.get(cntenum=0)
                else:
                    bigcntenum += 1
                    contentnum = bigcntenum
                    content = Cnte.objects.create(cntenum = contentnum,
                                              type = typ,
                                              content = cnte,
                                              count = 0,
                                              datetime = dt)
                numl = int(strl[2])
                if numl > biglinenum :
                    Line.objects.create(linenum = numl,
                                        linecnte = content,
                                        datetime = dt)
                    Tom = Cnte.objects.get(line0001__linenum = numl)    #反向查询
                    Tom.count += 1
                    Tom.save()
                    biglinenum += 1
                else:
                    Tom = Line.objects.get(linenum = numl)
                    Tom.linecnte = content
                    Tom.save()
                    Tom = Cnte.objects.get(line0001__linenum = numl)    #反向查询
                    Tom.count += 1
                    Tom.save()
        user = Userlist.objects.get(user='needyou',
                         pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B')
        user.blinenum = biglinenum
        user.bcntenum = bigcntenum
        user.datetime = dt
        user.save()


        #读数据库 生成xml文件  注意 node 点不能共用
        parser = ET.XMLParser(encoding="utf-8")
        doc = Element('doc')
        lucy = Line.objects.filter(linenum__lte = user.blinenum )
        kate = lucy.values_list('linenum','linecnte__cntenum','linecnte__type')
        i = 0
        xmlline = {}
        xmlcndt = {}
        xmlcnte = {}
        for baby in lucy :
            kity=baby.linecnte.content
            xmlcndt[i] = Element('Cndt')
            xmlcndt[i].text = str(kate[i][0]) +':'+ str(kate[i][1]) +':'+ kate[i][2]
            xmlcndt[i].tail = '\n'
            xmlcnte[i] = ET.fromstring(kity)
            xmlcnte[i].tail = '\n'
            xmlline[i] = Element("Line")
            xmlline[i].append(xmlcndt[i])
            xmlline[i].append(xmlcnte[i])
            xmlline[i].tail = '\n\n'
            doc.append(xmlline[i])
            i += 1
        doc.text='\n\n'       #这个提交的text内容,紧贴在<doc>后,并不是紧贴在在</doc>前
        creTree = ElementTree(doc)
        creTree.write("Lexicon.xml",encoding="utf-8", xml_declaration=True)
	









20181106
后端读取数据库写xml 传到前端并刷新页面 !!		
	前端的这个请求
	$.get("../loadfile", function(data,status,xhr){ readyloadfile(data,status,xhr) } )
	注意最终只是当前页面获得了一个数据文件或者数据页面,并没有 新建页面 或者 内容覆盖当前页面
	对应的后端只能发 template 里的文件,
	def loadf(request):
	    dy_model_creat_log()
	    if request.method == "GET":  # 请求方法为GET时，进行处理
	        return render(request,'bili.html') 	# template 里的 bili.html
		或者 return render(request,'kk.xml') 	# template 里的 kk.xml
	其他 文件夹里的都显示出错!!
	return render(request,'/static/clients/clie001/bili.html')
	return render(request,'/static/clients/clie001/kk.xml')	

		
	然而,前端使用这段代码:
	    if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
	        xmlhttp=new XMLHttpRequest();
	    } else {// code for IE6, IE5
	        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	    }
	    xmlhttp.open("GET","/static/clients/clie001/kk.xml",false);
	    xmlhttp.send();
	    xmlDoc=xmlhttp.responseXML;     //获取video2里的值：video2.mp4
	    var xmlvar = xmlDoc.getElementsByTagName("Cnte")[1] //.childNodes[0].nodeValue;
	    console.log(xmlvar)
	并不需要通过后端自定义的程序, djanggo 自动提交/static/clients/clie001/kk.xml文件!!
	注意最终只是当前页面获得了一个数据文件或者数据页面,并没有 新建页面 或者 内容覆盖当前页面

	js创建新页面的 并跳转 三种方式
	1.a标签
		a标签:
		<a href="http://www.jb51.net" title="脚本之家">Welcome</a>
		<a href= “javascript:history.go(-1)”>  :上一个页面，就是前一个页面
		<a href= “javascript:history.go(1)”>  :下一个页面，就是后一个页面
		<a href="http://www.jb51.net" title="脚本之家" target="_blank">Welcome</a>
	2 . location对象的href属性：
		window.location.href="http://www.jb51.net";      //当前页面,获得新页面覆盖,没有另外建立新页面
	3.open :
		window.open(“http://www.w3schools.com”,”_blank”);     //在另外新建窗口中打开窗口
		_self 表示当前窗口
		_blank 表示新窗口
		_parent 表示父窗口
		_top 表示顶层窗口
		这里注意 这些 方法都是要提交后端请求,重新获得页面上内容的,
	现在我们尝试实现的的需求是,把当前信息放到新页面显示,不过好像是不可能实现,还是需要访问服务器获取内容!!
	这样就得需要巧妙的设计,这里就先不讨论了
	学到了 foreach
	var arr = ["one","two","three"];

	//只能遍历 这样这种写法只是表面修改 实际上没有改变数组本身内容!
	arr.forEach(function(part){ 
	  part = "four";
	  return "four";
	})	
	//这种写法 就可以修改 数组本身内容!
	arr.forEach(function(part, index, theArray) {
  		theArray[index] = "hello world";
	});
	
	//这种写法可以修改 数组本身内容
	var spac = '3:4:5:6:7'
	spac = spac.split(':')
	spac.forEach(function(a,b,c){
		spacnum = parseInt(a)
		c[b] = 'y'
		for(;spacnum > 1;){
        		c[b] += 'y'
        		spacnum -= 1
        	}
		console.log(c[b])
	})
	spac = spac[0] + ' << ' + spac[3] 
	console.log(spac)
	
以下这段不成熟的片段,实现了从 xml 读取数据到 页面!!
    //更新网页, 假设 xml里 是连续的行!! 不是分散的行!!
    var ff = document.getElementsByClassName('main')
    var flnum = parseInt(ff[0].firstElementChild.children[1].innerText)
    var llnum = parseInt(ff[0].lastElementChild.children[1].innerText)
    var linod = null
    var clnum = null
	var boby = null
	var spac = null
	var spacnum = null
	var kate = []
	var bobe = []
	var rlikn = null
	var flikn = null
	var htmlcnte = null
    var kl = null


    //var root = r.getElementsByTagName('doc')
    //console.log(r)

    var parser = new DOMParser();
    var tree = r.children[0].innerHTML
    tree = '<root>' + tree + '</root>'
    //tree = tree.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")
    //tree = tree.replace(/<br>/g, "<br></br>")
    var xmldom = parser.parseFromString( tree , 'text/xml')
    var root = xmldom.getElementsByTagName('root')
    //root[0].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")

    //var kl = root[0].innerHTML
    //kl =  kl.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")
    console.log(root[0].innerHTML)
    console.log(xmldom)

    //root[0].innerHTML = kl



    var El = root[0].firstElementChild
    while ( El != null) {
        boby = El.children[0].innerHTML.split(':')
        clnum = parseInt(boby[0])
        if (( clnum <= llnum ) && ( clnum >= llnum )) {
            linod = ff[0].children[clnum-flnum]
            switch (boby[2]){
                case "edit" :
                    htmlcnte = '&#10;&#09;<div class="edit" cnteid="' + boby[1] + '" cntety="1"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span><div class="edtx">' + El.children[1].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&") + '</div></div>'
                    break
                case "hdty" :
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    spac = ' '
                    for(;spacnum > 1;){
                        spac += ' '
                        spacnum -= 1
                    }
                    rlikn = (El.children[1].children[3].innerHTML.split(':'))[1]
                    flikn = (El.children[1].children[4].innerHTML.split(':'))[1]
		            htmlcnte = '&#10;&#09;<div class="hdty" cnteid="' + boby[1] + '" cntety="7"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '" style="font-size:0.84em; font-weight:normal;">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="hdda">' + El.children[1].children[1].innerHTML + '</div>&#10;&#09;&#09;<div class="spac">' + spac + '</div>&#10;&#09;&#09;<div class="hdti">' + El.children[1].children[2].innerHTML + '</div>&#10;&#09;&#09;<div class="hdcr" contenteditable="false">&#10;&#09;&#09;&#09;<div class="rlik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="rlikn">' + rlikn + '</div>&#10;&#09;&#09;&#09;<div class="flik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="flikn">' + flikn + '</div>&#10;&#09;&#09;&#09;<div class="othrc">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "imgt" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')                                                     case "edit" :
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="imgt" cnteid="' + boby[1] + '" cntety="2" contenteditable="false"><span class=""orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="imgd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){  //发现了 spac 比 bobe kate 多 一项
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="igdd">&#10;&#09;&#09;&#09;&#09;<img class="imgs" src="' + bobe[i].innerHTML + '" alt="pic error">&#10;&#09;&#09;&#09;&#09;<div class="imgi" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "adio" :
                    htmlcnte = '&#10;&#09;<div class="adio" cnteid="' + boby[1] + '" cntety="4" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="adod">&#10;&#09;&#09;&#09;<audio src="' + El.children[1].children[1].innerHTML + '" controls=""></audio>&#10;&#09;&#09;&#09;<div class="adoi" contenteditable="true">' + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "math" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="math" cnteid="' + boby[1] + '" cntety="3" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="matd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="mtdd">&#10;&#09;&#09;&#09;&#09;<p>' + bobe[i].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")  + '</p>&#10;&#09;&#09;&#09;&#09;<div class="mati" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "vido" :
                    htmlcnte = '&#10;&#09;<div class="vido" cnteid="' + boby[1] + '" cntety="5" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="vidd">&#10;&#09;&#09;&#09;<video controls="" width="320" height="240">&#10;&#09;&#09;&#09;&#09;<source src="' + El.children[1].children[1].innerHTML + '" type="video/mp4">&#10;&#09;&#09;&#09;</video>&#10;&#09;&#09;&#09;<div class="vidi" contenteditable="true">'  + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "stav" :
                    spac = ' '
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    for(;spacnum > 1;){
        	            spac += ' '
        	            spacnum -= 1
                    }
                    htmlcnte = '&#10;&#09;<div class="stav" cnteid="' + boby[1] + '" cntety="6" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="stad">&#10;&#09;&#09;&#09;<div style="white-space:pre; display:none;">&#10;<textarea class="vex-tab-editor">' + El.children[1].children[1].innerHTML + '</textarea>&#10;&#09;&#09;&#09;&#09;<p id="errorTip" class="text-danger"></p>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + spac + '</div>&#10;&#09;&#09;&#09;<div>&#10;&#09;&#09;&#09;&#09;<div class="tab-preview-container" style="margin-left:50px;">&#10;&#09;&#09;&#09;&#09;&#09;<canvas class="tabPreviewer"></canvas>&#10;&#09;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
		    }

            linod.insertAdjacentHTML("afterEnd",htmlcnte)
            linod.remove()
        }else{
            linod = ff[0].lastElementChild
            switch (boby[2]){
                case "edit" :
                    htmlcnte = '&#10;&#09;<div class="edit" cnteid="' + boby[1] + '" cntety="1"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span><div class="edtx">' + El.children[1].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&") + '</div></div>'
                    break
                case "hdty" :
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    spac = ' '
                    for(;spacnum > 1;){
                        spac += ' '
                        spacnum -= 1
                    }
                    rlikn = (El.children[1].children[3].innerHTML.split(':'))[1]
                    flikn = (El.children[1].children[4].innerHTML.split(':'))[1]
		            htmlcnte = '&#10;&#09;<div class="hdty" cnteid="' + boby[1] + '" cntety="7"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '" style="font-size:0.84em; font-weight:normal;">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="hdda">' + El.children[1].children[1].innerHTML + '</div>&#10;&#09;&#09;<div class="spac">' + spac + '</div>&#10;&#09;&#09;<div class="hdti">' + El.children[1].children[2].innerHTML + '</div>&#10;&#09;&#09;<div class="hdcr" contenteditable="false">&#10;&#09;&#09;&#09;<div class="rlik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="rlikn">' + rlikn + '</div>&#10;&#09;&#09;&#09;<div class="flik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="flikn">' + flikn + '</div>&#10;&#09;&#09;&#09;<div class="othrc">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "imgt" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    console.log(spac)
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    console.log(spac)
                    console.log(bobe)
                    htmlcnte = '&#10;&#09;<div class="imgt" cnteid="' + boby[1] + '" cntety="2" contenteditable="false"><span class=""orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="imgd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="igdd">&#10;&#09;&#09;&#09;&#09;<img class="imgs" src="' + bobe[i].innerHTML + '" alt="pic error">&#10;&#09;&#09;&#09;&#09;<div class="imgi" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "adio" :
                    htmlcnte = '&#10;&#09;<div class="adio" cnteid="' + boby[1] + '" cntety="4" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="adod">&#10;&#09;&#09;&#09;<audio src="' + El.children[1].children[1].innerHTML + '" controls=""></audio>&#10;&#09;&#09;&#09;<div class="adoi" contenteditable="true">' + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "math" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="math" cnteid="' + boby[1] + '" cntety="3" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="matd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="mtdd">&#10;&#09;&#09;&#09;&#09;<p>' + bobe[i].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")  + '</p>&#10;&#09;&#09;&#09;&#09;<div class="mati" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "vido" :
                    htmlcnte = '&#10;&#09;<div class="vido" cnteid="' + boby[1] + '" cntety="5" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="vidd">&#10;&#09;&#09;&#09;<video controls="" width="320" height="240">&#10;&#09;&#09;&#09;&#09;<source src="' + El.children[1].children[1].innerHTML + '" type="video/mp4">&#10;&#09;&#09;&#09;</video>&#10;&#09;&#09;&#09;<div class="vidi" contenteditable="true">'  + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "stav" :
                    spac = ' '
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    for(;spacnum > 1;){
        	            spac += ' '
        	            spacnum -= 1
                    }
                    htmlcnte = '&#10;&#09;<div class="stav" cnteid="' + boby[1] + '" cntety="6" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="stad">&#10;&#09;&#09;&#09;<div style="white-space:pre; display:none;">&#10;<textarea class="vex-tab-editor">' + El.children[1].children[1].innerHTML + '</textarea>&#10;&#09;&#09;&#09;&#09;<p id="errorTip" class="text-danger"></p>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + spac + '</div>&#10;&#09;&#09;&#09;<div>&#10;&#09;&#09;&#09;&#09;<div class="tab-preview-container" style="margin-left:50px;">&#10;&#09;&#09;&#09;&#09;&#09;<canvas class="tabPreviewer"></canvas>&#10;&#09;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break

            }
            //console.log(linod)
            linod.insertAdjacentHTML("afterEnd",htmlcnte)
        }
        console.log(El)
        El = El.nextElementSibling
    }
    // 统一处理行号格式
    spacnum = ff[0].lastElementChild.children[1].innerText.length
    linod = ff[0].firstElementChild
    while ( linod != null) {
        boby = spacnum - linod.children[1].innerText.length
        for(;boby > 0;){
    	    linod.children[1].innerText = '0' + linod.children[1].innerText
            boby -= 1
        }
        console.log(linod , linod.nextElementSibling)
        linod = linod.nextElementSibling
    }

    onloadlast()

当中遇到了很多设计上的问题, 例如 <spac>10:10:10:</spac>, 应该改为 <spac>10:10:10</spac>
使用 原生js parser 分析 xml 有很多坑, 重点是, 使用parser分析的xml文件必须是一个规范的xml
以下:
	<kate> < </kate>
	<kate> <br> </kate>
	都不是规范的 xml 文件的内容,要分析这样的文件,或者改成这样子, parser都会崩溃
因为 parser 这么严格的特点
那么就要重新考虑,假如 行内容 要显示 禁忌符号 < > & " 的 xml和数据库的内容存放 问题

附加补充:特殊符号:http://w13.loxa.edu.tw/ctjh930220/








20181124
处理了 wrap 
考虑以下情景:
	原来:  	line32 -> cnte47	line55之后没有line
	后来可以出现以下各种情形
	1,	line32_mewl,  line33_wrap-> cnte47
	2,	line32_newl,	没有line -> cnte47
	3,	line32_wrapl-> cnte46,	line33-> cnte47
	4,	line20_wrapl-> cnte47,	line32-> cnte60
	5,	line20_wrapl-> cnte47,	line32_newl
	....
后来想到一个合理的 cnte count 改变策略
	line_newl时, 如果line本存在,先把当前line指向的cnte_count-1,然后line再指向新cnte,并新cnte_count+1
		     如果line新建,line再指向新cnte,并cnte_count+1
	line_wrap时, 当前line指向的cnte_count-1,然后line再指向新cnte,并新cnte_count+1
	line_fxl时, 获得cnte的content 比较讲究,
			如果 xml的数据条是 = <br> 就直接用特定的哦空白cnte
			如果 != <br> xml获得 cntenum != 0 则是新cnte,需要建立另外存储
			否则 就是就就内容,直接从库里取得内容,
				获得的内容需要添加history,并修改当前内容
				还要注意有时候fixl但是cnte 到最后还是没有变化,所以不算修改
				所以不用添加history,什么都不用做
		    然后就是修改line指向
			如果是新行,行号大于现有的 建立新指向
			如果是指向没有变,那么什么都不变
			不过有种例外,如果本来有的行内容变成空白的cnte,并不是在cnte本身修改成空白cnte
			而是让line直接指向特定的空白cnte!!!
然后是整合到一块!
	首先为了跟好测试,原来用于调试而建立的分立系统就是不需要动了,另外建立新的内容来整合测试
原来的分立测试,页面右下角 onclick="savefile(this,event) 然后 整合xml testfile传到服务器 项目根目录
	服务器 views.saveline 处理并写入数据表单 web_cnte0001 web_line0001 然后整洁读出数据到 lexicon.xml存在项目根目录
	手动把 lexicon.xml 拷贝到 clie001 的kkl.xml, 
	还不要 忘了ready.js loadfile 
		$.get("/static/clients/clie001/kk1.xml", function(data,status,xhr){ readyloadfile(data,status,xhr) } )
		还有 onloadlast 通过加载 kkl.xml 来展示内容
	首先, 关闭 $.get 加载 loadtest_new 来测试 数据库新建立数据条
	然后打开 $.get 加载loadtedt_空白来检测
		由于历史原因, new 需要多次 saveline 才行,不然不能接着做wrap测试
	如此类推,loadtest_wrap 调试 wrap后 刷写数据库
		loadtest_build_for_fix 为 fix建立调试环境
		loadtest_fix1 调试 fix
		loadtest_fix2 调试 带 wrap的fix
	注意 在 base1.js 的多媒体内容上传都在 clie001 了,先不管
	
整合测试,直接使用新的数据表单和函数 不要与分立测试共用,另外这里我都使用加 2 的命令方式
	另外 django的 架构很有问题,我使用views.saveline2,他还是跳回到分立测试的 views.saveline函数,
	就是 onclick="savefile(this,event) 收集变化内容 上传服务器 然后 saline 存数据库,然后重获 xml返回,
	最后更新页面!!! 
	记录未完
	接下来还没有实现 httpresponse 返回文件和更新页面的问题
	网上看到了一个 download文件的例程函数: http://www.cnblogs.com/crystaltu/p/9228454.html
def download(request):  
    """                                                                           
    Send a file through Django without loading the whole file into                
    memory at once. The FileWrapper will turn the file object into an             
    iterator for chunks of 8KB.                                                   
    """   
      
    #读取mongodb的文件到临时文件中  
    fileid_=request.GET["fileid"]  
    filepath_ = ('%s/%s'%(MEDIA_ROOT, fileid_)) #文件全路径  
    file_=TFiles.objects.get(fileid=int(fileid_))  
    filename_=file_.filename  
    filetype_=file_.filetype  
  
    if os.path.isfile(filepath_):  
        pass  
    else:  
        mongoLoad(fileid_)  
      
    #下载文件  
    def readFile(fn, buf_size=262144):#大文件下载，设定缓存大小  
        f = open(fn, "rb")  
        while True:#循环读取  
            c = f.read(buf_size)  
            if c:  
                yield c  
            else:  
                break  
        f.close()  
    response = HttpResponse(readFile(filepath_), content_type='APPLICATION/OCTET-STREAM') #设定文件头，这种设定可以让任意文件都能正确下载，而且已知文本文件不是本地打开  
    response['Content-Disposition'] = 'attachment; filename='+filename_.encode('utf-8') + filetype_.encode('utf-8')#设定传输给客户端的文件名称  
    response['Content-Length'] = os.path.getsize(filepath_)#传输给客户端的文件大小  
    return response
	
	尝试修改迎合自己需求!!			













20181106
后端读取数据库写xml 传到前端并刷新页面 !!
重点问题:
	django  save1() save2()	自动纠错? save1()函数错误,执行save2()?
	firefox 缓存问题 shift+crtl+delect 删缓存 ,
		关闭缓存 about:config 页面
			browser.cache.disk.enable = false
			browser.cache.memory.enable = false
			browser.cache.offline.enable = false
	jquery $.get() $.post() django 可以处理为 静态资源路径STATICFILES_DIRS的内容, 
		也可以是urlpatterns,自己注册的内容
		





20181205
建立登录界面:
	使用模板, 模板中 第3方登录图标 使用diaplay:flex 出现了不必要的下滑线,需要使用bootstrap框架的css 来解决
	但是发现使用 bootstrap 框架会绑架了 body 标签
	自己 body 设计的参数不再起作用!	
	关于使用 span 放置 特殊符号,比如 密码图案还有 ::before ::after 的使用
	改变 inpput 预填充文字的颜色例如:
		input::-webkit-input-placeholder { /* WebKit, Blink, Edge */
		    color:    #909;
		}
		input:-moz-placeholder { /* Mozilla Firefox 4 to 18 */
		   color:    #909;
		}
		input::-moz-placeholder { /* Mozilla Firefox 19+ */
		   color:    #909;
		}
		input:-ms-input-placeholder { /* Internet Explorer 10-11 */
		   color:    #909;
		}
js 补习:
	一般的 js 数组 array 和 html 的DOM 数组对象还是有所区别的
	例如 array 可以使用 pop() 获得最后一个成员, 但是 DOM对象数组咩没有这样的函数
	例如 classList 一个 典型的 Dom对象数组:
		<div id="demo" class="wrap-login100 p-l-55 p-r-55 p-t-65 p-b-54 login-log">
		获得
		var demo=document.getElementById("demo").classList;
		添加add()  
		demo.add("style");
		删除remove()
		demo.remove("style");
		包含contains()
		var is=demo.contains("style");
		console.log(is);//返回false
		其他属性：
		demo.length;//获取class的个数-1
		demo.item(0);//获取第一个类名
		原生通过正则对class的操作 










20181213
对于表单内容的验证,使用 login 例子本身自带的 Validate js 模板,再补上 正则表达式子来判断!!
在一个页面上画一个按钮，有四种办法：
    <input type="button" /> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。
    <input type="submit" /> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。
    <button> 这个按钮放在 form 中也会点击自动提交， (即<form> 里的 button 会默认点击触发 submmit 事件!!)
	比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 	value 值不同；可能还有其他的浏览器兼容问题（葛亮）。
    其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。
对于 form submit的 加强学习:
例子!
<form>
    标题：<input type="text" name="title" /><br />
    内容：<textarea name="content"><textarea/><br />
    <button>提交</button>
</form>
方法1
$('button').on('click', function() {

    $('form').on('submit', function() {
        var title = $('inpur[name=title]').val(),
            content = $('textarea').val();

        $(this).ajaxSubmit({
            type: 'post', // 提交方式 get/post
            url: 'your url', // 需要提交的 url
            data: {
                'title': title,
                'content': content
            },
            success: function(data) { // data 保存提交后返回的数据，一般为 json 数据
                // 此处可对 data 作相关处理
                alert('提交成功！');
            }
            $(this).resetForm(); // 提交后重置表单
        });
        return false; // 阻止表单自动提交事件
    });
});
方法2
    $('form').on('submit', function() {
        var title = $('inpur[name=title]').val(),
            content = $('textarea').val();

        $(this).ajaxSubmit({
            type: 'post', // 提交方式 get/post
            url: 'your url', // 需要提交的 url
            data: {
                'title': title,
                'content': content
            },
            success: function(data) { // data 保存提交后返回的数据，一般为 json 数据
                // 此处可对 data 作相关处理
                alert('提交成功！');
            }
            $(this).resetForm(); // 提交后重置表单
        });
        return false; // 阻止表单自动提交事件
    });
首先form 里的 button 默认触发 form submit事件,如果我们选择了方法2,
	jquery 会给submit事件注册一个行为, 
	这样每当submit事件触发时先预处理(就是 on('submit', function() {}) 的function 内容),然后再执行默认的表单submit事件
	注意如果 这个预处理function return false 时, 预处理function后,不会继续执行默认的 submit 操作!!
如果我们选择了方法1,
	我们要知道, 点击button时,触发 submit事件的同时,也触发了 onclick, 不过似乎先执行onclick事件,后执行submit
	jquery 会给onclick事件注册一个行为,
	而这个onclick事件又会重新注册一个 submit前预处理行为
	即每一次 onclick时,都会 重新注册一个 submit前预处理行为
	onclick后轮到 submit事件执行时,会按着最新注册的预处理 执行一次,然后在submit表单内容到服务器
	当然 如果 最新注册的预处理function 也遇到return false 时,不会继续执行默认的 submit 操作!!
HTML <form> 标签的 enctype 属性
	application/x-www-form-urlencoded 	在发送前编码所有字符（默认）
	multipart/form-data 	不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
	text/plain 	空格转换为 "+" 加号，但不对特殊字符编码。
form submit 但不跳转 例子
	 <html>    
	  <body>    
	      
	  <form action="/api/user/register" method="post" id="registSubmit" >    
	      <input type="text" id="id_input_text" name="nm_input_text" />    
	      <input type="submit" id="id_submit" name="nm_submit" value="提交" />    
	  </form>         
	  </body>    
	  </html> 
	
	$('#registSubmit').on('submit', function(event){
	      registPost()
	     event.preventDefault() //阻止form表单默认提交
	})
	
	function registPost () {     
	   $.ajax({
	       type: "POST",
	       url: "/api/user/register",
	       data: $('#registSubmit').serialize(),
	       success: function(message) {
	     			console.log(message)
	   		},
	       fail: function(err){
				console.log(err)
		   	},
	    /*
	     或者用jquery.form.min.js提交
	     $('#registSubmit').ajaxSubmit(function(message){
	        console.log(message);
	     })
	     */
	}
form submit 后 django后端获取数据和处理:
html:input设置:
	<input class="input100" type="text" name="username" placeholder="请输入用户名" autocomplete="off">
	<input class="input100" type="password" name="pass" placeholder="请输入密码">
	print(request)
		<WSGIRequest: POST '/login/'>
	print(request.POST)
		<QueryDict: {'pass': ['12345678Qq'], 'username': ['ss']}>
	print(request.path)
		/login/
	print(request.method)
		POST
	print(request.session)
		<django.contrib.sessions.backends.db.SessionStore object at 0x7f0e8a597ac8>
        print(request.COOKIES)
		{}
	print(request.raw_post_data)  // django 1.6以后 是request.body
		b'username=ss&pass=12345678Qq'
        print(request.POST.get('username'))
		ss
        print(request.POST['username'])
		ss
        print(request.POST.getlist('username'))
		['ss']
需要 前后端都要检测 表单的输入内容,使用正则表达式匹配
	前端 js
	    //正则判断 密码至少包含大写字母，小写字母，数字，且不小于于8位,不大于16!!
	    var re = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[^]{8,16}$/
	    //正则判断 正确的邮箱格式 !!
	    var re1 = /^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{1,5}|[0-9]{1,3})(\]?)$/
	    //正则判断  正确 11位 手机号码
	    var re2 = /^1\d{10}$/
	    //正则判断 含有标点符号
	    var re3 = /^((?=[\x21-\x7e]+)[^A-Za-z0-9])$/
	    //正则判断 密码至少包含大写字母，小写字母，数字，且不小于于8位,不大于16,且不含特殊符号除了'_'
	    var re4 = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z0-9_]{8,16}$/
	    //正则判断 只能 字母数字下划线 汉字 至少大于5个字符
	    var re5 = /[A-Za-z0-9_\u4e00-\u9fa5]{5,}$/
	    // 只要含有 @  因为username 可以 phone email name 所以 验证邮箱要附加条件
	    var re6 = /^(?=.*[@])[^]{1,}$/
		然后
		    var loginput = $('.validate-loginput .input100');
		    var reginput = $('.validate-reginput .input100');
		for(...){
			if( re4.test( $(loginput[i]).val().trim() ) ) ..	//正则匹配, 这个test()是原生js正则表达式自带的
			if( $(reginput[i]).val().trim().match(re1) ) ..		//或者这样正则匹配
		}
	后端 python 
		import re
		注意 python re 不接受这样的写法:
			    // 只要含有 @  因为username 可以 phone email name 所以 验证邮箱要附加条件
			    ^(?=.*[@])[^]{1,}$
			中的 [^] ,这个表示没有不该出现的,即,所有字符都可以出现
			但是python 不允许, 这样, ^ 就得必须带内容 比如[^a],表示不允许a出现
			如果要表示所有字符都可以出现 ,可以使用. 即
			    ^(?=.*[@]).{1,}$
后端用户密码加密解密验证过程!!
	使用 django 自带的框架好了:
	django的密码加密验证  安装加密算法 的使用教程
		https://django.readthedocs.io/en/2.1.x/topics/auth/passwords.html 
	setting.py 添加:
		PASSWORD_HASHERS = (
		    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
		    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
		    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
		    'django.contrib.auth.hashers.BCryptPasswordHasher',
		    'django.contrib.auth.hashers.SHA1PasswordHasher',
		    'django.contrib.auth.hashers.MD5PasswordHasher',
		    'django.contrib.auth.hashers.UnsaltedMD5PasswordHasher',
		    'django.contrib.auth.hashers.CryptPasswordHasher',
		    'django.contrib.auth.hashers.Argon2PasswordHasher',
		)
        表示密码的编码加密算法有: md5 unsalted_md5 pbkdf2_sha256 pbkdf2_sha1 bcrypt_sha256 aargon2 等
        bcrypt_sha256 需要另外安装库 pip install django[bcpt]
        argon2 需要另外安装库 pip install django[argon2]
	要使用的地方添加:
	from django.contrib.auth.hashers import make_password, check_password
        sha_pwd = make_password('needyou2<i dont like it>1234567', None, 'argon2')
        print(check_password('needyou2<i dont like it>1234567', '919c77acf44af0773fbe493d335e374f'))
	make_password: 根据密码生成加密串,数据库保存加密串而不是密码,减低帐号风险
		参数1:是要加密的密码串,例如这里 needyou2<i dont like it>1234567
		参数2: None 表示 每次生成的加密串都可以不一样,这个根据加密算法的性质看
		参数3: 选择一种加密算法
		结果是一条长长的加密字符串,例如 argon2$argon2i$v=19$m=512,t=2,p=2$dlVScVpodzVUTjRm$s9/1A8TEW3fpV0nslRUUkA
	check_password:
		直接检查秘密是否对上
		参数1:是密码串
		参数2:是加密串
		枚举,把 密码串重新加密后得到 加密串, 再跟已有的加密串比对!
		注意有些算法, 同一个密码串可以加密出多个不一样的加密串,
		但是由于是枚举比对的,所以只要 加密串曾经是这个密码串加密出来的,就可以匹配!!!
		而且不用告诉是什么算法加密的,函数会根据 加密串自动分析!!
django中render()与render_to_response()区别
	render()与render_to_response()均是django中用来显示模板页面的，但是在django1.3之后，render()便比render_to_response()更加招人待见！
	最明显的就是前者会自动使用RequestContext，而后者需要coding进去，例如：
		render(request,'share.html', {'registAdd': registAdd})
		render_to_response('share.html',{'registAdd':registAdd},context_instance = RequestContext(request)


做图片验证码:captcha
	https://blog.csdn.net/teavamc/article/details/77566781
	https://baijiahao.baidu.com/s?id=1592206104048546399&wfr=spider&for=pc
	https://blog.csdn.net/hejunw/article/details/80158473
	https://blog.csdn.net/u014745194/article/details/73997737
	https://stackoverflow.com/questions/34471102/python-nameerror-name-include-is-not-defined 关于 include 找不到
	https://django-simple-captcha.readthedocs.io/en/latest/usage.html#example-usage-for-ajax-form
	http://www.cnblogs.com/zhaijunming5/p/7570180.html
这个 captcha 非常棘手!!
	主要不知道如何单单揪出来 结合自定义的表格!!!!,也不知道如何处理样式!!
	整理captcha 的使用过程!!!
	安装: pip install django-simple-captcha
	settings.py 配置:
		INSTALLED_APPS = [
			....
			'captcha',
		]
		# django_simple_captcha 验证码配置其他配置项查看文档
		# 默认格式
		CAPTCHA_OUTPUT_FORMAT = '%(image)s %(text_field)s %(hidden_field)s '
		CAPTCHA_NOISE_FUNCTIONS = ('captcha.helpers.noise_null', # 没有样式
		    # 'captcha.helpers.noise_arcs', # 线
		    # 'captcha.helpers.noise_dots', # 点
		)
		# 图片中的文字为随机英文字母，如 mdsh
		# CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.random_char_challenge'
		 # 图片中的文字为数字表达式，如2+2=
		CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.math_challenge'
		# 超时(minutes)
		CAPTCHA_TIMEOUT = 1
	urls.py 配置:
		from django.conf.urls import url, include
		urlpatterns = [
		    .......
		    url(r'^captcha/', include('captcha.urls')),
		    url('load_test22',userctrl.some_view),	//专门 为检验 captcha建立的链接!!,例子一般写在views.py里.
		}						//这里自定义 到 userctrl.py里
	建立forms.py:
		from django import forms
		from captcha.fields import CaptchaField
		class LoginForms(forms.Form):
		    email = forms.CharField(label="邮箱", max_length=128)
		    password = forms.CharField(label="密码", max_length=128, widget=forms.PasswordInput)
		    captcha = CaptchaField()
	自定义的 userctl.py:
		from web.forms import LoginForms
		def some_view(request):
		    if request.POST:
		        form = LoginForms(request.POST)
		
		        # Validate the form: the captcha field will automatically
		        # check the input
		        if form.is_valid():
		            human = True
		            return HttpResponse('hahah')
		        else:
		            return HttpResponseRedirect('/load_test22/')
		    else:
		        form = LoginForms()

		    #return render_to_response('loadtest.html',{'login_form':form},context_instance =RequestContext(request))
		    return render(request, 'loadtest.html', {'login_form':form})
	loadtest.html 在合适的地方加上:
		<form action='.' method='POST' style="display:none">
		    {% csrf_token %}
		    {{ login_form }}
		<input type="submit" value='submit' />
		</form>
		-->
	这样,当我们`登录 127.0..../load_test22/ 传递userctl.some_view 内容`
		就会打开 loadtest.html
		login_form 会被自动替代!!
		其中 login_form.captcha 对应的内容是
	<input type="hidden" name="csrfmiddlewaretoken" value="dE16z9Ppx5aMrpGPdouOr6g2R9yO02X2seIiFKaqaPkiXYqjnMDkRMIIBQcqQzV5">
	<img src="/captcha/image/2924b20cacc3a722fd0a9b6685c46ca9fe73a799/" alt="captcha" class="captcha">
	<input autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" id="id_captcha_1" name="captcha_1" type="text">
	<input id="id_captcha_0" name="captcha_0" type="hidden" value="2924b20cacc3a722fd0a9b6685c46ca9fe73a799">
	由于 form action='.' 所以 submit后, 会重新的登录 127.0..../load_test22/ -> userctl.some_view
		form = LoginForms(request.POST)
		form.is_valid()
		直接 验证套装 captcha 的容,判断内容是否正确!!
	这种处理看着简单,但是用起来起来非但复杂,而且不好2次修改,只适合很模式化的登录注册页面设计! 也不通用!!!!!!,所以推荐自己写!!!
	特别是 对于 captcha 的 css 设计非常困难, 单独拆出来使用也麻烦
	单独拆出来使用的 思路 html里 {{ login_form.captcha }}
		或者 class LoginForms(forms.Form) 只有 captcha = CaptchaField()
自己做 验证码图片
	https://www.cnblogs.com/cq146637/p/7831387.html
	https://github.com/happy-python/check_code/blob/master/core/tools.py
	双方都有些错误,最后组合成功!!!
	urls.py 配置:
	urlpatterns = [
	    re_path(r'check_code',userctrl.check_code),
	    .......
	}
	userctl.py 添加!!:
		import random
		from PIL import Image, ImageDraw, ImageFont, ImageFilter
		from io import BytesIO
		
		def check_code(request):
		    stream = BytesIO()          #开辟一块内存空间，不用写在外存，减少读写操作
		    img, code = create_validate_code()
		    img.save(stream,'PNG')
		    img.save('idencode.png')  # 保存验证码图片 到项目根目录!!
		    print(code)
		    request.session['CheckCode'] = code
		    return HttpResponse(stream.getvalue())
		
		_letter_cases = "abcdefghjkmnpqrstuvwxy"  # 小写字母，去除可能干扰的i，l，o，z
		_upper_cases = _letter_cases.upper()  # 大写字母
		_numbers = ''.join(map(str, range(3, 10)))  # 数字
		init_chars = _letter_cases + _upper_cases + _numbers
		
		
		def create_validate_code(size=(120, 30),
		                         chars=init_chars,
		                         img_type="GIF",
		                         mode="RGB",
		                         bg_color=(255, 255, 255),
		                         fg_color=(0, 0, 255),
		                         font_size=18,
		                         font_type="Monaco.ttf",
		                         length=4,
		                         draw_lines=True,
		                         n_line=(1, 2),
		                         draw_points=True,
		                         point_chance = 2):
		
		    '''
		    生成验证码图片
		    @param size: 图片的大小，格式（宽，高），默认为(120, 30)
		    @param chars: 允许的字符集合，格式字符串
		    @param img_type: 图片保存的格式，默认为GIF，可选的为GIF，JPEG，TIFF，PNG
		    @param mode: 图片模式，默认为RGB
		    @param bg_color: 背景颜色，默认为白色
		    @param fg_color: 前景色，验证码字符颜色，默认为蓝色#0000FF
		    @param font_size: 验证码字体大小
		    @param font_type: 验证码字体
		    @param length: 验证码字符个数
		    @param draw_lines: 是否划干扰线
		    @param n_lines: 干扰线的条数范围，格式元组，默认为(1, 2)，只有draw_lines为True时有效
		    @param draw_points: 是否画干扰点
		    @param point_chance: 干扰点出现的概率，大小范围[0, 100]
		    @return: [0]: PIL Image实例
		    @return: [1]: 验证码图片中的字符串
		    '''
		    width, height = size  # 宽， 高
		    img = Image.new(mode, size, bg_color)  # 创建图形
		    draw = ImageDraw.Draw(img)  # 创建画笔
		
		    def get_chars():
		        '''生成给定长度的字符串，返回列表格式'''
		        return random.sample(chars, length)
		
		    def create_lines():
		        '''绘制干扰线'''
		        line_num = random.randint(*n_line)  # 干扰线条数
		        for i in range(line_num):
		            # 起始点
		            begin = (random.randint(0, size[0]), random.randint(0, size[1]))
		            # 结束点
		            end = (random.randint(0, size[0]), random.randint(0, size[1]))
		            draw.line([begin, end], fill=(0, 0, 0))
		
		    def create_points():
		        '''绘制干扰点'''
		        chance = min(100, max(0, int(point_chance)))  # 大小限制在[0, 100]
		        for w in range(width):
		            for h in range(height):
		                tmp = random.randint(0, 100)
		                if tmp > 100 - chance:
		                    draw.point((w, h), fill=(0, 0, 0))
		
		    def create_strs():
		        '''绘制验证码字符'''
		        c_chars = get_chars()
		        strs = ' '.join(c_chars)  # 字符前后以空格隔开
		        font = ImageFont.truetype(font_type, font_size)
		        font_width, font_height = font.getsize(strs)
		        draw.text(((width - font_width) / 3, (height - font_height) / 3),
		                    strs, font=font, fill=fg_color)
		        return ''.join(c_chars)
			
		    if draw_lines:
		        create_lines()
		    if draw_points:
		        create_points()
		    strs = create_strs()
		
		    # 图形扭曲参数
		    params = [1 - float(random.randint(1, 2)) / 100,
		              0,
		              0,
		              0,
		              1 - float(random.randint(1, 10)) / 100,
		              float(random.randint(1, 2)) / 500,
		              0.001,
		              float(random.randint(1, 2)) / 500
		              ]
		    img = img.transform(size, Image.PERSPECTIVE, params)  # 创建扭曲
		
		    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)  # 滤镜，边界加强（阈值更大）
		
		    return img, strs

	userctl.py 修改!!:		
		def login(request):
			...
		        code = request.POST.get('check_code')
		        if code.upper() == request.session['CheckCode'].upper():
		            print('验证码正确')
		        else:
		            print('验证码错误')	
	然后 作为测试的 我们使用 127.0...../load_test,所以 loadtest.html 添加
		<form...>
			<div>
                    		<input type="text" class="form-control" placeholder="请输入验证码" name="check_code">
			        <img src="/check_code" onclick="changeCheckCode(this);">
			</div>
		</form>
	<img src="/check_code"就是会访问  def check_code(request): 获得图片数据	
	form submit 提交后会在 	def login(request): 的
		        code = request.POST.get('check_code')
		        if code.upper() == request.session['CheckCode'].upper():
		进行验证码的检测!!
cookie 操作问题!!!
`	http://www.yihaomen.com/article/python/277.htm
	http://www.cnblogs.com/skying555/p/4964112.html	

	每个HttpRequest对象都对应一个COOKIES对象,该对象是字典形式.!!
	例如  对于 127.0.0.1:8000/load_test,
		和 127.0.0.1:8000/load_test33, 是两个不一样的对象,所以 两个不一样的cookie 
	session 的概念有点区别, 是浏览器没有,但是 服务器后端会生成并存储的, 是数据加密串!!
		用来区别,每一个浏览器机器登录状态
		比如 A 远程电脑 登录 127.0.0.1:8000/load_test, 或者 127.0.0.1:8000/load_test33, 他们都共用一个 session 
		比如 用户A和用户B 的登录 127.0.0.1:8000/load_test 都修改 使用同一个 session
		用户 A使用时 ,这个session记录 用户A 的状态, 轮到用户B登录时,session会发现不是用户A在使用,会根据操作变成用户B的状态
		而用 B 远程电脑登录时, 服务器会新建 一个 session 数据 专门为 电脑B服务
		session 存在服务器上的是加密内容,从远程电脑登录时 会获得内容(cookie)和机器码(ip,电脑识别id等)加密后,
		与存在电脑的加密内容匹配 识别身份!!!
	实验:
	userctl.py 添加:
		from django.template import loader ,Context
		from django.http import HttpResponse
		def check_cookiesession(request):
		    # response = HttpResponse("hello world")	# 也可以这样!
		    response = render_to_response('loadtest.html', {}), #给 django 架构的request 设置 返回数据
		    cookie_v = 'user=12345&session=yutuusjis'
		    response.set_cookie('my_cookie1', cookie_v)	 #给 request 设置cookies ,即这个设定的cookies 会传给远程客户端浏览器保存
		    return response
	urls.py 添加:
		urlpatterns = [
		    url('load_test33', userctrl.check_cookiesession),
		    ...
		}
	这样 登录 127.0.0.1:8000/load_test33 服务端会 执行  check_cookiesession  然后设置cookie添加内容,最后传回浏览器,
	浏览器就得到关于这个页面的 cookie
	上面介绍了 服务端 即 django 设置cookie 的api
		response.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False, samesite=None)
		expires: 有效期 格式: 例如字符串:  "Wdy, DD-Mon-YY HH:MM:SS GMT" or a datetime.datetime object in UTC
	        max_age默认:None ,cookie需要延续的时间（以秒为单位） 如果参数是\ None`` ，这个cookie会延续到浏览器关闭为止。
		path 默认是"/" ,cookie生效的路径前缀。 浏览器只会把cookie回传给带有该路径的页面，
			这样你可以避免将cookie传给站点中的其他的应用,当你不是控制你的站点的顶层时，这样做是特别有用的。
		domain 默认None,这个cookie有效的站点。 你可以使用这个参数设置一个跨站点（cross-domain）的cookie。 
			比如，\ domain=".example.com" 可以设置一个在\ www.example.com 、\ www2.example.com 
			以及\ an.other.sub.domain.example.com 站点下都可读到的cookie。
			如果这个参数被设成\ None ，cookie将只能在设置它的站点下可以读到。
		False 默认False ,如果设置为 True ，浏览器将通过HTTPS来回传cookie。
		我们说的 set_cookie 是添加一条cookie数据条, 每条数据条都有效期, 所有关于当前页面的 cookie数据条 都放入一个文件里,
	那么用户如何获得当前页面的cookies? 使用js:
		function getCookie(c_name)
		{
		if (document.cookie.length>0)
		  {
		  c_start=document.cookie.indexOf(c_name + "=")
		  if (c_start!=-1)
		    {
		    c_start=c_start + c_name.length+1
		    c_end=document.cookie.indexOf(";",c_start)
		    if (c_end==-1) c_end=document.cookie.length
		    console.log(document.cookie.substring(c_start,c_end))
		    return unescape(document.cookie.substring(c_start,c_end))
		    }
		  }
		return ""
		}
	例如 cookie 中有一项内容是 my_cookie1 = user=12345&session=yutuusjis
	getCookie('my_cookies1') 就得到 user=12345&session=yutuusjis 的内容
	如果 服务器 需要 获得远程客户端页面 的cookies,
		实时上 http 给服务器提交 request 时,会附带浏览器当前页附带的cookies
		远程服务器 只要:
			value = request.COOKIES["my_cookie1"] 
			也可以i:
			value = request.COOKIES.get('sessionid', None)	
		就可以获得 user=12345&session=yutuusjis 的cookie内容!!
	上面介绍 创建cookie 是 服务器自己创建了传回 远程客户端,但是也可以页面自己生成
		function setCookie(c_name,value,expiredays)
		{
			var exdate=new Date()
			exdate.setDate(exdate.getDate()+expiredays)
			document.cookie=c_name+ "=" +escape(value)+
			((expiredays==null) ? "" : ";expires="+exdate.toGMTString())
		}
		expiredays 是有效 日期 !!
	然后 分析 session!!
		上面说过 session 是服务器保存 运城登录用户的状态信息
		让django项目支持session,则必须在settings.py中指定
		INSTALLED_APPS = [
		....	
		    'django.contrib.sessions',
		]

		MIDDLEWARE = [
		    'django.contrib.sessions.middleware.SessionMiddleware',
		    #'django.middleware.csrf.CsrfViewMiddleware',  #禁用跨站请求伪造的中间件
		......
		]
		还有一点，在django处理请求的过程中，需要经过中间件的过滤，涉及到跨站请求伪造时，django会把请求阻止过滤掉，
		所以我们要在setting.py中禁用跨站请求伪造的中间件，如果不禁用，
		默认情况django使用 django.contrib.sessions.models.Session将session存储在你的数据库中
		mysql 查看 session表:
			mysql -u root -p		
			mysql> use db_selfweb_pyth3
			mysql> select * from django_session;
			可以看到
			每条数据哟有 三个内容 
			session_key session_data expire_date
			而 session_key session_data 都是加密的内容  expire_date 是有效时间
			注意 这里 一条数据 就是 一个session文件, 对应一台登录远程客户端的 状态信息
			注意 这里的 expire_date 与 cookie 的 expire_date 不一样,这里对应着整个session文件,
			而 cookie 的 expire_date 仅仅是cookie文件的一条cookie数据!
		服务器会生成session 但是申生成的 session数据 但并不会 回传到运程客户端!
			#get 从数据库获得 对应远程客户端的 session 数据条 fav_color 的内容! 
			# 注意根据 request 据可以区别是那个 远程端发来的请求
				fav_color = request.session['fav_color']     
			#set 为对应对应远程客户端 添加 一条 fav_color=blue session数据条,并加密存入数据库
				request.session['fav_color'] = 'blue'           #set
			# 判断 对应远程客户端的session 文件 是否 有fav_color session数据条!! 
			'fav_color' in request.session
			# 获得 session数据条
				fav_color = request.session.get('fav_color', 'red')
		
		安全匹配
			用户登录了网站后,一直处于登录状态的做法!!!
			登录成功后, 服务器 会建立 session数据条: 比如 user=william,加密存入数据库,
			也生成 cookie user=william 返回 运程客户端!!
			当 远程客户端执行下一步访问 数据内容时, 会返回 含有  cookie user=william 的请求
			服务器检查 发现 跟 session 的 user=william 一致,于是允许继续访问!! 实现一直处于登录状态
			注意:
				cookie是明文, 容易获取拷贝!!
				服务端匹配 cookie 和 session 要用 专门api, 不要用以下蠢方法:
					A = requwst.COOKIE['user']
					B = requwst.session['user']
					if A == B .....
				因为这样就没有用上session 的加密 抗安全的风险!!,因为这是明文比对,
				人家只要搞到cookie 就可以骗过 服务器 黑入账户!!
				很遗憾, 我发现网上都是 这样子的明文比对, django的例程好像也是这样子!!
				只能自己干了!!
				根据 request.META 结合 cookies 使用!!
		从 django shell 处理 查看 session内容		
			python manage.py shell
			>>> from django.contrib.sessions.models import Session
			>>> s=Session.objects.all()
			>>> for i in s:
			...     i.get_decoded()
			... 
			{'williamcolor': 'blue', 'CheckCode': 'QNYy'}
			{'_auth_user_id': '1', '_auth_user_backend': 'django.contrib.auth.backends.ModelBackend', '_auth_user_hash': '95cf94e3674d7a5ef33a4eabf0d8f3bd18442be2'}
			{'williamcolor': 'blue', 'CheckCode': 'awqp'}
			>>> 
input 输入提示 的方式:https://blog.csdn.net/qq_41573860/article/details/82750116

email:使用邮箱发送验证消息!!
	settings.py
		# email_for_sending check
		EMAIL_HOST = "smtp.163.com"   # 服务器
		EMAIL_PORT = 25               # 一般情况下都为25
		EMAIL_HOST_USER = "xxxxxxm@163.com"   # 账号
		EMAIL_HOST_PASSWORD = "AAAAAAAAAaa"  # 密码
		EMAIL_USE_TLS = False             # 一般都为False
		EMAIL_FROM = "xxxxxxxm@163.com"        # 邮箱来自
	userctl.py
		from random import Random # 用于生成随机码
		from django.core.mail import send_mail # 发送邮件模块
		from selfweb_pyth3.settings import EMAIL_FROM  # setting.py添加的的配置信息		

		# 生成随机字符串
		def random_str(randomlength=8):
		    str = ''
		    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'
		    length = len(chars) - 1
		    random = Random()
		    for i in range(randomlength):
		        str+=chars[random.randint(0, length)]
		    return str
		
		# 利用  xxxxxxm@163.com 给 dddd@qq.com ssssss@qq.com 发邮件 的例子
		code = random_str(16)
		receiver = 'dddd@qq.com'
		receiver2 = 'ssssss@qq.com'
		email_title = "注册激活链接"
		email_body = "请点击下面的链接激活你的账号:http://127.0.0.1:8000/active/{0}".format(code)
		send_status = send_mail(email_title, email_body, EMAIL_FROM, [receiver,receiver2])
		print(send_status)
解决了 svg 标签 的 问题!!
	登录页面用到的符号是 svg 矢量图, 而我们用到的库是 iconic : http://zavoloklom.github.io/material-design-iconic-font/icons.html
	注意 原来有很多这样的 icon 库, 不如 font-awsome: http://fontawesome.dashgame.com/
	注意,不同库 ,图标与对应的 unicode标识码不一样!!!!
	注意,一般用法是
		下载了库:
		然后库里面的整合 css 包含!!
		<link rel="stylesheet" type="text/css" href="/static/css/logincss/fonts/iconic/css/material-design-iconic-font.min.css">
		<i class="fa fa-shield"></i>
	但是这里,我们这样用: 通过使用 标识码,需要类似这样设置!
		<span class="focus-input100" data-symbol="&#xf2c8;/&#xf15a;"></span>
		.focus-input100 {
		  position: absolute;
		  display: block;
		  width: 100%;
		  height: 100%;
		  top: -10px;
		  left: 0;
		  pointer-events: none;
		}
		
		.focus-input100::after {
		  content: attr(data-symbol);
		  font-family: Material-Design-Iconic-Font;
		  color: #adadad;
		  font-size: 30px;
		
		  display: -webkit-box;
		  display: -webkit-flex;
		  display: -moz-box;
		  display: -ms-flexbox;
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  position: absolute;
		  height: calc(100% - 20px);
		  bottom: 0;
		  left: 0;
		  padding-left: 13px;
		  padding-top: 3px;
		}
		
		.focus-input100::before {
		  content: "";
		  display: block;
		  position: absolute;
		  bottom: -2px;
		  left: 0;
		  width: 0;
		  height: 2px;
		  background: #7f7f7f;
		  -webkit-transition: all 0.4s;
		  -o-transition: all 0.4s;
		  -moz-transition: all 0.4s;
		  transition: all 0.4s;
		}
根本上解决 数据库支持中文问题!!:
1、创建数据库 （注意设置 数据的字符编码）
由于Django自带的orm是data_first类型的ORM，使用前必须先创建数据库
create database day70 default character set utf8 collate utf8_general_ci;
2、修改project中的settings.py文件中设置  连接 MySQL数据库（Django默认使用的是sqllite数据库）

注意到 models.py 的表单类,其中一个项目要改变属性时,需要 重性 make migrations 和 migrate
	注意,属性migrate改变不一定成功!!例如 本身存char数据的 改变成存 int, 如果char数据已存在的数据有abc 而不是123,migrate失败
	数据表单不会接受改变
	如果char 已存在的数据 都是 123这里数字字符串, 那么转成int时, 以int的123重新存储! 所以 migrate会成功,表单会改变!!

django 并发问题 数据库锁
考虑 stateb 的并发修改访问问题!!
	使用django 的锁功能!! select for update
	使用 select for update 数据库查询
	select ... for update 是数据库层面上专门用来解决并发取数据后再修改的场景的，
	主流的关系数据库 比如mysql、postgresql都支持这个功能， 新版的Django ORM甚至直接提供了这个功能的shortcut 。 
	关于它的更多介绍，你可以搜索你使用的数据库的介绍文档。
	使用 select for update 后，我们的代码可能会变成这样：

from django.db import transaction
class NotificationController(object):

    ... ...

    def mark_as_readed(self, notification_id):
        # 手动让select for update和update语句发生在一个完整的事务里面
        with transaction.commit_on_success():
            # 使用select_for_update来保证并发请求同时只有一个请求在处理，其他的请求
            # 等待锁释放
            notification = Notification.objects.select_for_update().get(pk=notification_id)
            # 没有必要重复标记一个已经读过的通知
            if notication.has_readed:
                return

            notification.has_readed = True
            notification.save()
            # 在这里更新我们的计数器，嗯，我感觉好极了
            self.update_unread_count(-1)
注意: transaction.commit_on_success() 不再支持使用:
	使用 transaction.atomic()
	还有 django 的这个锁的原理是,其实是,建立了一个沙箱,
	select_for_update() 是数据库底层级别的加锁,就是说是数据库本身自带的!
	这里只不过是 django 做了个通用封装!!
	还有 select_for_update() 只能在  with transaction.atomic(): 下生效
	出了 django的沙箱是不允许使用的!
	django的transaction沙箱就是一套原子操作框架! 
		先挂起要使用的资源,允许其他访问但不允许更改,然后划了一个内存空间,做好了一些系列的操作后,
		刷写挂起了的资源.最后解放资源,允许其他访问去修改!
	注意 在沙箱 select_for_update().get() 会 完全锁住了表单的某行数据, 当沙箱过程没有结束!!!!
		当 另外的 使用 with transaction.atomic(): select_for_update().get() 请求同一行数据时,这个get就被阻塞等待!
		而其他 普通.get 请求同一行数据时,不会被阻塞还是可以获得访问的,但那是修改数据使用 .save()时会被被阻塞等待了!
	比如
		A 请求:
	        with transaction.atomic():
	            kk = williamtest.objects.select_for_update().get(text = 'buk')
	            print('uuui')
	            kk.text ='opt4'
	            kk.save()
	            time.sleep(60)
		B请求:
	        trydd = williamtest.objects.get(text='buk')
	        trydd.text  = 'tre'
	        print('78')
	        trydd.save()
	        print('90')
	A使用沙箱获取了 buk的那行数据, 并把改成 opt4, 并.save(),然后再沙箱空等60S,沙箱过程未结束,所以 数据库里还是buk,还没变成opt4
	B在A处于沙箱过程未结束时 普通地 get同一条数据,可以获得! ,但是改成 tre 后 .save 被阻塞了!
	最后沙箱空等结束,退出了 transaction.atomic() 沙箱, 数据库buk变成了 opt4
	然后B请求的 .save也不再阻塞了,最后 opt4 又变成了 tre  !!!









20190101:
一些坑:
关于 datetime 格式和使用片段!
	from datetime import datetime
        ####
        dt = datetime.today()
        # statetb.objects.create(date=dt,usernum=0,flag='1')
        dt2=statetb.objects.get(date="2018-12-29" )
        dt2.flag= '67'
        dt2.save()
        print(dt2.flag)
关于 数据库锁 和并发问题的 测试片段:
class williamtest(models.Model):
    text = models.CharField(max_length=100,blank=True,null=True)
    number = models.IntegerField(blank=True,null=True)
def william_test(str=None,num=None):
    try:
        trydd = williamtest.objects.get(text='buk')
        print('iiiu')
        with transaction.atomic():
            kk = williamtest.objects.select_for_update().get(text = 'buk')
            print('uuui')
            kk.text ='opt4'
            kk.save()
            time.sleep(60)
    except williamtest.DoesNotExist:
        with transaction.atomic():
            kk = williamtest.objects.select_for_update().get(text = 'Tom')
            print('atomic')
            kk.text ='lio'
            time.sleep(10)
            kk.save()
    #williamtest.objects.create(text='super',number=90,)

def william_test2():
    try:
        trydd = williamtest.objects.get(text='buk')
        trydd.text  = 'tre'
        print('78')
        trydd.save()
        print('90')
    except:
        print('fail')

transaction.atomic()下,不能执行动态生成表单的功能,那么就不知道如何解决 可能同时生成相同表单的并发问题,
幸亏,生成表单这个操作,从mysql底层看来就自己加入了并发处理!!,所以不需要 transaction.atomic()下 操作!
from django.db.utils import InternalError
    try:
        install(UserList)
        with connection.cursor() as cursor:
            cursor.execute(order_1[0]+listtbn+order_1[1])
            cursor.execute(order_1[0]+listtbn+order_1[2])
    except InternalError:	# 已有表单的情况下,生成相同表单会出错!! 属于 InternalError
        print('create userlist error')


mysql: 数据执行命令
	insert into web_statetb values(5,'2019-01-08',0,'1');	# 插入一条数据
	delete from web_mailcheckcode where mail = '418128064@qq.com';	# 删一条数据
	update web_statetb set flag='1' where id=2; # 修改一条数据
	#批量drop 表
		select concat('drop table ',table_name,';') from information_schema.tables where table_name like 'web_cntex%';
		结果集合粘出来




继续实现,
	password 比对正确后, 生成uid和分配动态密码的cookies,和session,还要测试session的时效性
	注意不能把用户密码写入cookies,风险太大!!
	通过再通过获得的用户cookies, 加载内容和修改刷新内容!!
	之前就测试过,不通过默认静态方式获得 xml 文件,而是通过传统的 httpresponse获得! 查看 postget 函数!!


测试帐号:
	你好大家_
	1234567Ww
	1234567Ww
	418128064@qq.com
	p8WW91
后续才加上的功能和处理!
	忘记密码,通过动态页面设置!
	由于只有 uid 和 email 唯一!!, 而username phone可以多个, 所以要处理多个同名处理
	跨页面的coskies 和 session 传递 处理的问题!!比如搜索页面我们要使用新页面的!!
动态生成数据表单的出现的冲突问题:
def william_tbtest(request):
    fields = {
        'cntenum': models.IntegerField(blank=True, null=True),
        'type': models.CharField(max_length=10),
        'content': models.TextField(blank=True, null=True),
        'count': models.IntegerField(blank=True, null=True),
        'datetime': models.DateTimeField(blank=True, null=True),
    }
    options = {
        'ordering': ['cntenum', 'datetime'],
        'verbose_name': '并发表',
    }
    admin = {}
    tb1 = create_model('tbtest1',
                    fields,
                    options=options,
                    app_label='web',
                    module='web',
                    admin=admin
                    )
    #install(tb1)
    #tb1.objects.create(cntenum=22,
    #                   type= 'person',
    #                   content = 'Tom',
    #                   count = 50
    #                   )
    print(tb1.objects.get(type='person'))

    tb2 = create_model('tbtest2',
                    fields,
                    options=options,
                    app_label='web',
                    module='web',
                    admin=admin
                    )
    #install(tb2)
    #tb2.objects.create(cntenum=13,
    #                   type= 'animal',
    #                   content = 'rabbit',
    #                   count = 20
    #                   )

    print(tb2.objects.get(type='animal'))	#当执行到这里,(1054, "Unknown column 'web_tbtest1.cntenum' in 'field list'")
    return  HttpResponse('done')
	(1054, "Unknown column 'web_tbtest1.cntenum' in 'field list'")
	https://dynamic-models.readthedocs.io/en/latest/pdfindex.html#synchronising-processes	#链接
	清除后台缓存:https://codeday.me/bug/20180507/162192.html (没用)
	不管是 migration cache 什么的都找不到方法,
	然后后面发现:
		之所以发生这种情况,就是因为 第一次  create_model 时,会修改了共用的 fields 变量
		然后 第二次 create_model 时, 会使用被修改的共用变量,然后会嵌入附加错误!
		注意,动态model 生成后,用到的fields也就不再使用了,删除了也没有关系!
		所以共用的全局变量 fields 不能直接使用,而是深度复制出的副本,
		import copy
		f1 = copy.deepcopy(fields)
还有时区问题!
	django setting.py
	TIME_ZONE = 'UTC'  # 'UTC'(标准时区,格林彼治时间) 'Asia/Shanghai'(东八区) 
	USE_TZ = True
	表示使用 UTC 标准时间, 这时
	from datetime import datetime
	datetime.now() 得到的是 TIME_ZONE 设置的时区的时间 与  USE_TZ = True 没有关系!
	datetime.utcnow() 得到的是 标准时区的时间	
	
	from datetime import timezone
	dt = datetime.now().replace(tzinfo=timezone.utc)	把当前时区的时间变成标准时区时间

	dt = datetime.today()	感觉与 now()没区别
	datetime.now().date() 获取日期部分

	from datetime import timezone
	import pytz
	datetime.today().replace(tzinfo=timezone.utc).astimezone(pytz.timezone('Asia/Shanghai')).date()
	# 使用 datetime 的timezone 把获得的时间转成 utc时间, 又使用 astimezone 和 pytz.timezone,转成东八区时间,最后取日期部分 
	#.replace(tzinfo=timezone.utc) 看似多此一举,但是 now(),utcnow(),today()直接astimezone 换成东八区时间是不可能的,
	#所以需要 replace 这一步!
使用reload 机制!!!
	//document.body.reload()        //没有这样子的reload
	window.location.reload()	
遇到了一个世纪问题,幸亏解决了!!
	http://www.yihaomen.com/article/python/342.htm
	例如
	Tom = cntetb.objects.get(line0002__linenum=numl)  # 反向查询
	line0002__linenum 是不确定的,所以需要替换掉
	line0002__linenum=numl get()函数看来是字典参数!
	所以我们构造字典参数!代入
	所以相当于!!
	kk = {'line0002__linenum':'num'}
	Tom = cntetb.objects.get(**kk)
视频作为背景!
	重点是 position:fixed; 还有 z-index:-11 层数必须负数
	注意 Video 放在 login div 上, 所以, z-index:-11 是相对 同 logindiv 其他子 模块而言的,
	即只放在 login div 的最底图层 显示!!
	还有关于视频拖伸播放问题!!!1
	例子:
	video.vibagrd{
	            margin: 0px;
	            padding: 0px;
	
	            position: fixed;
	            right: 0px;
	            bottom: 0px;
	
	            object-fit:fill;		/*这个是视频填充拉伸整个height width 定义的页面意思*/
	            height: 80%;
	            width: 100%;
	            left: 0%;
	            top: 10%;
	            /*加滤镜*/
	            /*-webkit-filter: grayscale(100%);*/
	            /*filter:grayscale(100%);*/
	            z-index:-11
	}
	video.vibagrd source{
	
	            height: 100%;
	            width: 100%;
	        }
	<div class="login" >
	
		<video class="vibagrd" autoplay loop muted poster="/static/img/bg-01.jpg" id="bgvid">
			<!--<source src="polina.webm" type="video/webm">-->
			<source src="/static/video/qbhn.mp4" type="video/mp4">
		</video>
			
		.....
	</div>

django 定时程序:
	https://www.cnblogs.com/perfe/p/6198213.html		////crontab   海关与定时调用终端执行命令
	https://blog.csdn.net/sinat_21302587/article/details/72831002		/// crontab 可用!!!
	https://crontab.guru/examples.html	//// crontab 定时格式编写

	https://www.cnblogs.com/dengshihuang/p/8258621.html

	https://blog.csdn.net/qq_21570029/article/details/80772561		///apscheduler 
重点讨论 crontab
	crontab 这个第三方本来不是 django 独有的,而是传统的 linux 软件
	使用 crongtab 定时任务,即使 django项目没有 runserver , 定时任务还是会照样执行 !!!!
	使用例子: https://blog.csdn.net/sinat_21302587/article/details/72831002		/// crontab 可用!!!
	安装:
	 pip install django-crontab
	setting.py
		INSTALLED_APPS = [
		    'django_crontab',
			.....
		]
		CRONJOBS = [	# 这里是添加 定时任务!!!
		    ('*/5 * * * *', 'web.cron.test','>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
	
		    ('21 21 * * *', 'web.cron.east8test', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
		    ('31 14 * * *', 'web.cron.utctest', 'TZ=UTC', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),	
		    ('21 23 * * *', 'web.cron.statetbtest', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
		
		]
		至于格式 详细要百度: 常用的
			*/5 * * * *   定时的设置 ,这里的 每隔5分钟, 31 14 * * * 这里是 每天的 14时31分
			注意,这些时间默认是以当地系统时区 为准, 要是以其他时区的话也可以设置,但是未找到可行方法
			目前通过 CRON_TZ=  TZ= 的 都是失败的!!  
			比如这样设置 TZ=UTC 其实并不可行!!
			('31 14 * * *', 'web.cron.utctest', 'TZ=UTC', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
			web.cron.utctest 等,是要执行的任务!!
			>>/home/william/full_stack/selfweb_pyth3/crontabtest.log 执行过程中print等输出的信息都放入这里!!
	任务:
	跟 views.py 同目录 新建 cron.py 写要执行的任务:
	def statetbtest():
	    print('\n\r///////////////// statetb test /////////////////////')
	    kl = statetb.objects.first().date
	    print(kl)

	最后 :
	 python manage.py crontab add  会把 CRONJOBS 里的所有任务都加载 并定时执行,
		并不需要 django project runserver 下才运行
	 	所以执行相当独立
	显示当前的定时任务  python manage.py crontab show 
	关闭并删除所有正在执行的定时任务 python manage.py crontab remove

	crontab 需要用到的功能不多,重点关注的部分有 
		定时执行只能按当前系统时区为准,如果 与django项目是 UTC 等其他时区为准,要注意变换
		定时的格式写法参考  https://crontab.guru/examples.html
		crontab 执行的任务 是相对 django 项目的runserver 独立的, 
		定时任务可以访问 django 项目 各种资源,例如数据库等


	













20190117
先 总结 docker tmux vim ssh 效率工具的学习 :
ssh: 
	scp root@149.28.122.195:/root note2 /home/william/temp   //从运城服务器下载文件 到 本地目录 /home/william/temp
	scp /home/william/full_stack/selfweb/full_stack_note  root@149.28.122.195:/root/	 //把本地文件上传到远程服务器
	ssh root@149.28.122.195		//登录远程服务器 root用户


tmux:
	ctrl + b  加  %   左右分屏.
	ctrl + b  加  "   上下分屏,
	ctrl + b  加  :  命令行 输入 copy  滚动 log 记录
	ctrl + b  加  方向键 换分屏
	ctrl + b  加  c  新键 session(对话)
	ctrl + b  加  数字 换 session 
		session 与 分屏, 相似,又不一样!!
	ctrl + b  加  &  关闭当前 session
	ctrl + b  加  x  关闭当前 分屏
	ctrl + b  加  z  最大化当前分屏 或 退出最大化

	vim :
	打开文件后 , 处于命令行模式, 
	i 命令 开始 输入模式, 
	esc 回到 命令行模式
	: 添加附加命令 的命令
		:wq  保存并退出
		:q!  不保存然后退出
	
docker:
	参考:
	https://blog.csdn.net/cow66/article/details/80096253
	https://blog.csdn.net/bskfnvjtlyzmv867/article/details/81044217
	docker run -it --name redis-master redis /bin/bash    新建一个名字为

	ps命令在docker容器不存在	
	apt-get update && apt-get install procps

        docker pull ubuntu
        docker pull redis
                (pull 下载的 是 专门的镜像 如 ubuntu 是 ubuntu 的镜像, redis 是 专门用于redis数据库服务 的linux系统镜像 )
        docker images (可以看到都，下载了那些镜像)
                REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
                haproxy             latest              fd5f07592ca9        5 days ago          72.1MB
                redis               latest              5d2989ac9711        3 weeks ago         95MB
                ubuntu              latest              1d9c17228a9e        3 weeks ago         86.7MB
                django              latest              eb40dcf64078        2 years ago         436MB

        docker ps -a    （显示所有容器的情况）
        CONTAINER ID  IMAGE      COMMAND                  CREATED        STATUS                    PORTS                    NAMES
        b6a40392708f  haproxy    "/docker-entrypoint.…"   22 hours ago   Up 22 hours               0.0.0.0:6301->6301/tcp   HAProxy
        edfe38f25c4f  django     "/bin/bash"              22 hours ago   Up 22 hours                                        APP2
        73a540d60130  django     "/bin/bash"              22 hours ago   Up 22 hours                                        APP1
        7db27ac7fc76  redis      "docker-entrypoint.s…"   22 hours ago   Up 22 hours               6379/tcp                 redis-slave2
        73b92aeaf7f9  redis      "docker-entrypoint.s…"   22 hours ago   Exited (0) 14 hours ago                            redis-slave1
        6745d8b53e8d  redis      "docker-entrypoint.s…"   22 hours ago   Up 12 hours               6379/tcp                 redis-master
        9f82795ba41e  ubuntu     "/bin/bash"              36 hours ago   Exited (0) 18 hours ago                            web
                （所谓容器 就是 通过 镜像安装在 docker 小型系统, 一个镜像可以安装多个 容器）
                （比如，通过 同一个镜像redis，在docker 安装了 3个相互独立的容器， redis-master redis-slave1 redis-slave2 ）
                （这3个容器 也就是我们理解的服务器节点，操作系统，或者说是三台相互独立运行的电脑！）
                （STATES 是这些容器当前的状态， Up xx hours 表示这个容器节点已经开机xx个小时，Exited表示 这个容器节点已经关机 ）

        创建一个容器：
        docker run -it --name redis-master redis /bin/bash      （使用redis 镜像 创建一个名字为 redis-master 的容器节点,并启动容器）
                （-it 表示创建运行容器后 并进入容器的命令行终端）
		 (docker ps 显示 Up ,即开机运行状态)
	
	通过 run 进入 容器命令行终端后 , exit命令 , 推出容器终端,容器关机, docker ps 显示 Exited ,即关机状态
	
	再次启动容器:
	docker start redis-master

	启动容器后,才可以 登录 容器终端
	第一种登录方式 :docker exec -it redis-master /bin/bash , 
		输入 exit 时, 容器依然工作,只是退出登录终端而已
	第二种登录方式: docker attach redis-master
		输入 exit 时, 容器也会关机!

	移除一个容器
		docker rm redis-master
	
	注意对容器 的操作 可以 用 自定义的容器 名字, 也可以是 容器的id 
		比如 docker start redis-master  等于  docker start 6745d8b53e8d 

        docker info     （显示docker 的 基本信息！）
	        Containers: 7
	         Running: 5
	         Paused: 0
	         Stopped: 2
	        Images: 4
	        Server Version: 18.09.0
	        Storage Driver: overlay2
	         Backing Filesystem: extfs
	         Supports d_type: true
	         Native Overlay Diff: true
	        Logging Driver: json-file
	        Cgroup Driver: cgroupfs
	        Plugins:
	         Volume: local
	         Network: bridge host macvlan null overlay
	         Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
	        Swarm: inactive
	        Runtimes: runc
	        Default Runtime: runc
	        Init Binary: docker-init
	        containerd version: c4446665cb9c30056f4998ed953e6d4ff22c7c39
	        runc version: 4fc53a81fb7c994640722ac585fa9ca548971871
	        init version: fec3683
	        Security Options:
	         apparmor
	         seccomp
	          Profile: default
	        Kernel Version: 4.4.0-127-generic
	        Operating System: Ubuntu 16.04.4 LTS
	        OSType: linux
	        Architecture: x86_64
	        CPUs: 1
	        Total Memory: 488.1MiB
	        Name: william
	        ID: NIX6:DNXE:T664:QSWG:3WFC:OE46:PQER:2ONA:ZX76:XWCK:PJAL:WI54
	        Docker Root Dir: /var/lib/docker
	        Debug Mode (client): false
	        Debug Mode (server): false
	        Registry: https://index.docker.io/v1/
	        Labels:
	        Experimental: false
	        Insecure Registries:
	         127.0.0.0/8
	        Live Restore Enabled: false
	        Product License: Community Engine
	
	        WARNING: No swap limit support

在重构之前先学习好 集群 和 负载均衡 分布 高并发 的 实际操作应用
	主流是 java + spring框架 +dubbo分布式任务 SOA 
	未来需要 可能用上的有 redis(缓存数据库) elasticsearch(搜索引擎) Celery(分布式) Dubbo(分布式基于java)
先名词解释几个概念
	集群: 多个服务器一起只实现 一项特定服务,这些服务器是一个集群 cluster
	分片: 集群的服务器,每一个服务器是一个节点,负责特定服务的某部分,或则被分配存放部分内容数据,这种行为是分片
	高并发: 指一个服务器可以同时处理的连接数众多
	负载均衡: 指把业务请求分给多个 都是处理相同任务的服务器处理,摊分工作量	
	
	一般 我们用 nginx的服务器 处理 负载均衡, 把接到的业务分配各个业务处理服务器,
	但是这个ngnix服务器的吞吐量可能就是这个网站处理连接请求的天花板了
	使用 uwsgi 提高 单个服务器并发处理 业务请求的 数量
	多个服务器专门用来处理业务请求 是 业务处理服务器集群
	每个业务处理服务器的内容都是一样的,他们分担众多业务请求工作
	多个服务器专门用来保存数据 是 数据库服务器集群
	每个数据库服务器不是都保存相同的数据,数据是分布存在不同的服务器的,这时数据库的分片保存
	整个数据库集群一起实现一个完整的数库, 即所有分片

	
目标千万级pv 和亿级pv (一天有千万次浏览)
案例参考:
	像百度等巨型公司除了会采用常规的mysql及oracle数据库库外，会在性能要求更高的领域，大量的使用nosql数据库（非关系型的数据库），
	然后前端在加DNS，负载均衡，分布式的读写分离，最后依然是拆业务，拆库，。。。逐步细化，然后每个点又可以是一组或多组机器。
	数据库层的硬件好坏也会决定访问量的多少，尤其是要考虑磁盘IO的问题，大公司往往在性价比上做文章，
	比如核心业务采用硬件netapp/emc及san光纤架构，对于资源数据存储，如图片视频，会采用sas或固态ssd盘，
	如果数据超大，可以采取热点分取分存的方法：如：最常访问的10-20%使用ssd存储，中间的20-30%采用sas盘，最后的40-50%可以采用廉价的sata。

一例日千万pv架构说明：
    1,架构中直接引入软件名称的模块，是个人推荐使用的，如Haproxy、Hadoop等；
    2,关于全局负载均衡，看成本投入情况，可以使用商业的产品，如F5-GTM，开源方案便是自搭智能DNS；
    3,本地负载均衡方案，可以考虑F5-LTM或成熟的开源解决方案LVS；
    4,代理层为什么推荐大家使用Haproxy？Haproxy是一个非常优秀的反向代理软件，十分高效、稳定。国内top 10的互联网公司都有在使用；
    5,缓存层可以使用squid或Varnish，个人更倾向Varnish。配置灵活、运行稳定，提供非常便利的管理接口。
	为啥在缓存层前面加一层代理？优点非常多，列举如下：
    	A 根据应用配置URI路由规则，集中热点来提高后端缓存的命中率；
    	B 轻松划分网站频道、版块，更好对应用进步组织、规划；
    	C 对URI进行一般性安全过滤，抵御注入攻击；
    	D 弹性调配硬件资源，应对突发事件产生大流量；
    	E 可回收宝贵的公网ip资源；
    6,应用层开源技术方案非常多且成熟，在此不详细描述；
    7,数据库层主流开源解决方案mysql是首选，主从复制（一主对多从）是目前比较靠谱的模式；
    8,于Nosql，应用场景不多说，可参考“给部门做的Mongodb技术交流PPT”文章，redis、memcached等作为热点数据存储、数据库缓存都非常理想；
    9,网DNS扮演的角色非常重要，一定要消灭code中出现的内网IP地址，很大程度减少因IP变更、服务器故障而修改源码的情况，同时也便于维护；
    10,内网LB适用在内部WEB接口、多台数据库Slave、多台Nosql Slave、公共服务等应用的负载均衡，可以使用LVS、Haproxy来实现，
       可用性要求不高的应用可行直接使用Localhost DNS轮询；
    11,hadoop适合海量数据的存储与处理，如做网站日志分析、用户数据挖掘等；
    12,管理集群，平台的核心，运维的阵地；
    13,以上粗略介绍了架构的几个组成部分，如大家有对哪块有疑问或感兴趣都可以展开来讨论，也可以通过weibo与我交流：http://t.qq.com/yorkoliu

负载均衡技术的详细介绍 https://www.cnblogs.com/chanshuyi/p/how-loadbalance-works.html
	https://www.cnblogs.com/rjzheng/p/10263562.html 
	DNS轮询 比如说就是,百度挂在 电信,还是 联通,还是移动的服务器上,分流 移动 电信 联通 用户的访问
	LVS : 一个网站的最前方,把访问的链接分流转发,
	Nginx : LVS 分流过来的 一般会在 Nginx上再分流,或者直接处理,最后把内容直接返回 远程客户端,或者先回到 lvs,由lvs 返回远程客户端
	三种机制:
	DR: LVS 分配给下级服务器,处理,处理结果,下级服务器自己直接返回到网络!
	NAT,FULL-NAT: LVS 分配给下级服务器,处理,处理结果,下级服务器把结果返回 LVS,LVS再返回到网络!
	Tunnel: 之前的模式都是修改数据包的 IP头,MAC头什么的实现装发, Tunnel是直接外部再封装一个IP头后装,透过外加头转发到下级服务器,
		下级服务器会把额外加上的 IP 头 拆掉,最后处理结果直接返回到网络!
	Nginx相似的软件还有apche、squid、lighttpd等负载均衡软件,综合说 Nginx 比较高效,不容易堵塞,造成压力!!! 
数据库 集群分片处理:
	就是使用多个服务器 组合共同存储数据 !!
	重点 redis 数据库, Mysql 数据库  
	MySql Replication
	Mysql PXC 集群方案（ Percona XtraDB Cluster ）

参考:
	亿级pv与负载均衡:
	https://www.cnblogs.com/rjzheng/p/10263562.html
	https://www.cnblogs.com/chanshuyi/p/how-loadbalance-works.html


	Django并行分布式框架 Celery
	https://blog.csdn.net/huanhuani/article/details/81202480 Django并行分布式框架 Celery
	https://blog.csdn.net/max229max/article/details/51463632

	Django redis
	https://mengkang.net/356.html  ///// redis 数据类型
	https://www.cnblogs.com/fuhuixiang/p/4174896.html 
	http://www.cnblogs.com/zjchao/p/8903552.html
	https://www.cnblogs.com/jiangchunsheng/p/9151257.html
	https://www.cnblogs.com/yuanermen/p/5717885.html   ///redis 集群
	https://www.cnblogs.com/cjsblog/p/9048545.html	  ///redis 集群 分片 重要参考



	Mysql 
	https://blog.csdn.net/annotation_yang/article/details/80860988		/////集群
	https://www.cnblogs.com/robbinluobo/p/8294782.html      ///mysql 高可用方案


	搭建参考例子
	https://blog.csdn.net/cow66/article/details/80096253   /// Docker + Django + Redis 搭建 集群分布负载均衡 很好的启蒙例子 
	https://blog.csdn.net/xun527/article/details/78375735	/// 一 django电商平台的搭建例子
	https://blog.csdn.net/kangshuo2471781030/article/details/79253578	/////千万级PV规模高性能高并发网站架构详解


django 和 redis:
	redis 数据内容格式: key:value value可以:字符串,列表,hash值,set,zset 等等
	安装:
	pip3 install django-redis
	配置:settings.py
		# redis 缓存服务器 
			CACHES = {
			    'default': {
			        'BACKEND': 'redis_cache.cache.RedisCache',
			        'LOCATION': '127.0.0.1:6379',
			        "OPTIONS": {
			            "CLIENT_CLASS": "redis_cache.client.DefaultClient",
			        },
			    },
			}
			REDIS_TIMEOUT=7*24*60*60
			CUBES_REDIS_TIMEOUT=60*60
			NEVER_REDIS_TIMEOUT=365*24*60*60
	代码测试:
		from django.core.cache import cache #引入缓存模块 
		from django.conf import settings	# 其实 这个 settings 既有 django 全局设置的内容,
							# 也有本地projrct selfweb的settings内容 
		cache.set('v', '555', 60*60) #写入key为v，值为555的缓存，有效期30分钟 
		cache.has_key('v') #判断key为v是否存在 
		cache.get('v') #获取key为v的缓存
    		cache.set('word', 'helloworld', settings.NEVER_REDIS_TIMEOUT)
	或者:
        	from django_redis import get_redis_connection
        	conn = get_redis_connection("default")
        	conn.hset('n1','k1','v1') 
	或者:
		session 用 redis存储开启方式
		setting.py
	redis 存非cache 的例子!!
		安装pip3 install redis 
		import redis
		conn = redis.Redis(host='10.0.0.10',port=6379)
		conn.set('k1','v1') # 向远程redis中写入了一个键值对
		val = conn.get('k1') # 获取键值对
		print(val)	

			SESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎
        	        SESSION_CACHE_ALIAS = 'default'  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置
	redit 集群,分片 https://www.cnblogs.com/cjsblog/p/9048545.html
		redit 本是独立与django 的模块, django 通过插件接口访问!
		多个节点(服务器),(比如36个节点)一起提供一个数据库的 访问, 是这个 redis数据库的集群
		主从节点, 比如 36个当中有 12个master节点,24个slave节点,即,每个master节点,都有 2个副本节点(slave)
			他们这3个节点数据同步, 外部只访问master节点, master节点挂了,其中一个slave节点会补上充当master节点
		redis 含 16384个 hash slots, 一般平均分摊给12个节点组(1 master 2 slave)
			然后 redis 的 数据条: key:value 会 存入被指定的 hash slots里, 
			相当于 这个redis数据库被分12片,分存数据内容
	redis一般用于 存 session cache celery 等

	redis 集群分片操作例子: *号重点
		https://www.cnblogs.com/cxbhakim/p/9151720.html    // docker 实现 redis 集群搭建
		https://www.cnblogs.com/zhaohuhu/p/9140673.html         //redis 是内存数据库的理解  *
		https://blog.csdn.net/cow66/article/details/80096253	/// Docker + Django + Redis 搭建 集群分布负载均衡  *
									///没有 主从故障切换
			主要思想是 通过宿主机编辑好配置文件 然后传到容器里执行!!
		http://www.cnblogs.com/vipzhou/p/8580495.html		///Docker下redis的主从、持久化配置 哨兵系统     *
									///有 主从故障切换
                https://www.cnblogs.com/linkenpark/p/7841608.html       /// python redis sentinel 实现master故障切换   *
		https://blog.csdn.net/lfgxiaogang/article/details/78020408      
									///redis sentinel 高可用（HA）方案部署，及python应用示例     *

                https://blog.csdn.net/ownfire/article/details/51546543  ///搭建redis-sentinel(哨兵机制)集群
                https://blog.csdn.net/yingxiake/article/details/51671335        ///配置哨兵监控Redis运行情况
                https://www.sunzhongwei.com/test-redis-replication-with-sentinel.html   ///测试 redis replication & sentinel & python
                http://www.cnblogs.com/janehoo/p/6118961.html           ///Redis多机常用架构-sentinel
                        /// 哨兵和 redis数据库  是相互独立， 可以运行在相互独立的节点上！！，不一定要都运行在同个节点上！
                https://www.cnblogs.com/kazihuo/p/9109824.html          /// sentinel + cluster 共同集成 高可用的 数据分片主从故障切换 先cluster 后 sentinel  *
                https://blog.csdn.net/xlnhaha/article/details/80987368  /// sentinel + cluster 例子2

		https://www.cnblogs.com/zhanchenjin/p/5379112.html     ///Redis Sentinel + Cluster  *


		https://www.cnblogs.com/lianggp/articles/8136222.html		///docker + redis-cluster
		
		例子实践进程:
			Docker + Django + Redis  实现了 web应用均衡访问, redis主从实现,
			但是 redis master故障模拟切换没有实现
			通过参考 Docker下redis的主从、持久化配置 实现了 主从模拟故障切换,
			但是, redis-master 挂了 web应用没有 切换到访问新 master !!
			应该说 redis-master 改了, 但是 django还是链接原来的 master 没有转换新的 master !!!  
			所以 应该从 django 的 app 入手
			先 单方面 实现 sentinel，然后单方面实现 cluster 最后在 cluster 上实现 sentinel

在 django redis 简单主从数据库 基础上 实现 sentinel ( 单方面 实现 sentinel，)
	( https://blog.csdn.net/cow66/article/details/80096253 ) 基础上 添加 sentinel
        首先，关闭所有 容器！！
        docker stop HAProxy APP1 APP2 redis-master redis-slave1 redis-slave2
        打开所有容器
        docker start redis-master redis-slave1 redis-slave2 APP1 APP2 HAProxy   //开机注意顺序
        在tmux 建立7个终端方便操作：
        先新建 7个 docker所在的宿主机终端，然后 有6个进入容器终端，剩下一个宿主终端
        进入 redis-master容器终端 ：  docker exec -it redis-master /bin/bash
        进入 redis-slave1容器终端 ：  docker exec -it redis-slave1 /bin/bash
        进入 redis-slave2容器终端 ：  docker exec -it redis-slave2 /bin/bash
        进入 APP1 容器终端 ：  docker exec -it APP1 /bin/bash
        进入 APP2 容器终端 ：  docker exec -it APP2 /bin/bash
        进入 HAProxy 容器终端 ：  docker exec -it HAProxy /bin/bash

        进入各个redis服务器终端， 删除 所有原来的sentinel.conf
        重新修改 sentinel 配置
                在宿主机操作：
                        vim sentinel.conf  ：
                                /////////////
                                port 10011                                              // 哨兵的 端口用 10011
                                sentinel monitor mymaster 172.17.0.2 6379 1             // 1 表示 至少有1个 哨兵节点 支持，才能当master
                                sentinel down-after-milliseconds mymaster 60000
                                sentinel failover-timeout mymaster 180000
                                sentinel parallel-syncs mymaster 1
                                //////////
                        放到 redis 容器：
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-master | awk '{print $3}')
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-slave1 | awk '{print $3}')
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-slave2 | awk '{print $3}')
                redis 容器终端操作：
                        cp /data/sentinel.conf /usr/local/bin/sentinel.conf
        修改 django webapp 节点程序：
                都在宿主机上操作：
                        docker inspect HAProxy APP1 APP2 redis-master redis-slave1 redis-slave2 |grep IPAddress      //查看 redis节点 的 ip
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.7",
                                    "IPAddress": "172.17.0.7",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.5",
                                    "IPAddress": "172.17.0.5",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.6",
                                    "IPAddress": "172.17.0.6",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.2",
                                    "IPAddress": "172.17.0.2",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.3",
                                    "IPAddress": "172.17.0.3",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.4",
                                    "IPAddress": "172.17.0.4",
                        可以发现 redis-master redis-slave1 redis-slave2 分别为 172.17.0.2， 172.17.0.3， 172.17.0.4
                        这次实验默认使用 redis-master redis-slave1 redis-slave2 分别为 172.17.0.2， 172.17.0.3， 172.17.0.4 这个初始参数
                        （新建容器的时候就应该使用静态分配的ip，减少很多不必要麻烦处理）
                        由于 建立容器时的不谨慎， 容器都是开机后获得 动态 IP 所以要知道 redis 节点的 ip
                        修改APP内容：
                                # APP 1
                                cd ~/Projects/Django/App1/dockerweb/redisweb/
                                vim helloworld/views.py
                                # APP 2
                                cd ~/Projects/Django/App2/dockerweb/redisweb/
                                vim helloworld/views.py
//////////////////

from django.shortcuts import render

# Create your views here
from django.http import HttpResponse
import redis
from redis.sentinel import Sentinel
def hello(requset):
    # 加载 哨兵的节点， 注意 之前设置 哨兵节点的 端口是 10011
    sentinel = Sentinel([('172.17.0.2', 10011),('172.17.0.3', 10011),('172.17.0.4', 10011)], socket_timeout=0.2)
    print(sentinel.discover_master('mymaster'))         # 通过 哨兵节点 获得 redis数据库master节点的 ip和端口
    print(sentinel.discover_slaves('mymaster'))         # 通过 哨兵节点 获得 redis数据库slaves节点的 ip和端口
    slave = sentinel.slave_for('mymaster', socket_timeout=0.1)          # 获得一个 redis数据库slave节点 接口
    print('stu_num: ',slave.get('stu_num'))             # 获得数据库数据并打印数据
    master = sentinel.master_for('mymaster', socket_timeout=0.1)        # 获得一个 redis数据库master节点 接口
    master.set('app_info', 'HelloWorld-APP1')           # 给数据库写入一个数据  # 在APP2节点修改为HelloWorld-APP2
    print('app_info: ',master.get('app_info'))
    app_info = bytes.decode(slave.get('app_info'))
    stu_num_info = int(master.get('stu_num'))
    info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    return HttpResponse(info)

    #r = redis.Redis(host='db', port=6379, db=0)
    # 在APP2节点修改为HelloWorld-APP2
    #r.set('app_info', 'HelloWorld-APP1')
    #app_info = bytes.decode(r.get('app_info'))
    #stu_num_info = int(r.get('stu_num'))
    #info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    #return HttpResponse(info)

def hello__dsdsds (request):
    return HttpResponse('helloworld')

////////////

        在所有redis容器 启动 redis数据库 节点
                cd /usr/local/bin/

                # master:
                //注意曾经的哨兵系统工作时会修改 redis.conf 里的内容，所以重新启动数据库需要先更新回初始设置
                cp /data/redis-master.conf /usr/local/bin/redis.conf
                redis-server redis.conf

                # slave1 slave2
                //注意曾经的哨兵系统工作时会修改 redis.conf 里的内容，所以重新启动数据库需要先更新回初始设置
                cp /data/redis-slave.conf /usr/local/bin/redis.conf
                redis-server redis.conf

        同在 redis容器终端下 启动 sentinel 节点服务
                redis-sentinel sentinel.conf
                //// 也可以这样？？？  redis-server sentinel.conf --sentinel
                sentinel 和 redis数据库 是相互独立的，
                实际部署 sentinel 和 redis数据库 应该 放在不同的服务器物理机子 独立运行
                即放在不同的容器上执行
                这次图方便 sentinel 和 redis数据库 放同一容器上了

        APP容器终端下启动  App
                cd /usr/src/app/dockerweb/redisweb
                python manage.py migrate

                # APP1:
                python manage.py runserver 0.0.0.0:8001

                # APP2:
                python manage.py runserver 0.0.0.0:8002
        HAProxy 容器终端下：
                启动HAProxy程序
                cd /usr/local/sbin
                haproxy -f haproxy.cfg

        浏览器登陆： 149.28.122.195:6301 成功
        然后 kill掉 master服务， 登陆时出错，那是因为哨兵还没完成同步处理
        过会 登陆， 又好了，
        把原来的master服务 重新加入，会被降级为 slave！


ssh自动断开问题: https://www.cnblogs.com/aoyihuashao/p/3298950.html
	


redis 单方面实现 cluster实验  (这里cluster 指的是 分片集群 shrding cluster)
	(https://blog.csdn.net/qq_22211217/article/details/80436996)
	(https://redis.io/topics/cluster-tutorial/)
	停止所有容器 ,不管以前的容器, 使用新建的容器测试!!!
	需要 ruby 参与 分片: 添加 ruby 镜像: docker pull ruby
	创建测试用的 网段(局域网): docker network create redis-net
	#查看网段信息
		docker network ls
		docker network inspect  redis-net  | grep "Gateway" |  grep --color=auto -P '(\d{1,3}.){3}\d{1,3}' -o
		172.18.0.1 (查到这个网段的网关IP)
	创建配置文件模版
		pwd
		/root
		mkdir ./redis-cluster ##在home 目录下创建 集群配置文件加
		cd ./redis-cluster    ##在创建目录中
		vim redis-cluster.tmpl  ##创建模版件
/////////////
port ${PORT}                        ##节点端口
cluster-enabled yes                 ##cluster集群模式
cluster-config-file nodes.conf      ##集群配置名
cluster-node-timeout 5000           ##超时时间  
cluster-announce-ip 172.18.0.1      ##实际为各节点网卡分配ip  先用上网关ip代替
cluster-announce-port ${PORT}       ##节点映射端口
cluster-announce-bus-port 1${PORT}  ##节点总线端
appendonly yes                      ##持久化模式
////////////
	终端命令  批量创建节点配置文件
		for port in `seq 7010 7015`; do \
		  mkdir -p ./${port}/conf \
		  && PORT=${port} envsubst < ./redis-cluster.tmpl > ./${port}/conf/redis.conf \
		  && mkdir -p ./${port}/data; \
		done
	还要批量修改 /root/redis-cluster/${port}/conf/redis.conf 的 cluster-announce-ip 
		分别为 六个将要建立的节点 的 ip 172.18.0.2/3/4/5/6/7
	然后,检查:
		在 /root/redis-cluster # tree
			.
			├── 7010
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7011
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7012
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7013
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7014
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7015
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			└── redis-cluster.tmpl
			
			18 directories, 25 files
		在 /root/redis-cluster # cat 701*/conf/redis.conf
			port 7010
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.2
			cluster-announce-port 7010
			cluster-announce-bus-port 17010
			appendonly yes

			port 7011
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.3
			cluster-announce-port 7011
			cluster-announce-bus-port 17011
			appendonly yes
			
			port 7012
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.4
			cluster-announce-port 7012
			cluster-announce-bus-port 17012
			appendonly yes
			
			port 7013
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.5
			cluster-announce-port 7013
			cluster-announce-bus-port 17013
			appendonly yes
			
			port 7014
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.6
			cluster-announce-port 7014
			cluster-announce-bus-port 17014
			appendonly yes
			
			port 7015
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.7
			cluster-announce-port 7015
			cluster-announce-bus-port 17015
			appendonly yes
			
	宿主机终端批量新建启动容器 并 启动redis 服务
		for port in `seq 7010 7015`; do \
		  docker run -d -ti -p ${port}:${port} -p 1${port}:1${port} \
		  --privileged=true -v /root/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \
		  --privileged=true -v /root/redis-cluster/${port}/data:/data \
		  --restart always --name redis-${port} --net redis-net \
		  --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf; \
		done
		备注：命令译为  循环7010 - 7015  运行redis 容器 并运行 redis服务
		docker  run            运行
		-d                          守护进程模式
		--restart always     保持容器启动
		--name redis-710* 容器起名
		--net redis-net    容器使用虚拟网卡
		-p                        指定宿主机器与容器端口映射 701*:701*
		-P                        指定宿主机与容器redis总线端口映射 1701*:1701*
		 --privileged=true -v /root/redis-cluster/701*/conf/redis.conf:/usr/local/etc/redis/redis.conf
		    付权将宿主701*节点文件挂载到容器/usr/local/etc/redis/redis.conf 文件中
		--privileged=true -v /root/redis-cluster/${port}/data:/data \
		   付权将宿主701*/data目录挂载到容器/data目录中
		--sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf;
		   容器根据挂载的配置文件启动 redis服务端
	查看网段ip分配情况: docker network inspect redis-net
		[
		    {
		        "Name": "redis-net",
		        "Id": "738f3ba557ea37f27d3d8ba6839ce962bd76fd2ffc24b8ea5c752ced7c3f6df6",
		        "Created": "2019-01-26T13:36:00.113700469Z",
		        "Scope": "local",
		        "Driver": "bridge",
		        "EnableIPv6": false,
		        "IPAM": {
		            "Driver": "default",
		            "Options": {},
		            "Config": [
		                {
		                    "Subnet": "172.18.0.0/16",
		                    "Gateway": "172.18.0.1"
		                }
		            ]
		        },
		        "Internal": false,
		        "Attachable": false,
		        "Ingress": false,
		        "ConfigFrom": {
		            "Network": ""
		        },
		        "ConfigOnly": false,
		        "Containers": {
		            "07da0eb6dc9be4e38c7d3c8426b1181ad9dd89489bee1a79d4928be05664d9a0": {
		                "Name": "redis-7014",
		                "EndpointID": "156a352401c46f85eb8c04c0bb94b83620541c9a8a9d67364dedba60cde14981",
		                "MacAddress": "02:42:ac:12:00:06",
		                "IPv4Address": "172.18.0.6/16",
		                "IPv6Address": ""
		            },
		            "1640364a670c4eafdef9593bca23b41b923f1182a5e6cac604261ebced77d2eb": {
		                "Name": "redis-7015",
		                "EndpointID": "1eb2db7ace2ff6fbb0cfdfa95eb220ed2d8a73cbca7e457a18de8a5e2015eeda",
		                "MacAddress": "02:42:ac:12:00:07",
		                "IPv4Address": "172.18.0.7/16",
		                "IPv6Address": ""
		            },
		            "4266d49967b191a420413dbc80d35049a8f3b893c8bad7e6ea3757c9f793ef94": {
		                "Name": "redis-7013",
		                "EndpointID": "16cbed49c75e578f939ade3ef06aaf3a52c58f284fd065e5d2c9db5fda0062f5",
		                "MacAddress": "02:42:ac:12:00:05",
		                "IPv4Address": "172.18.0.5/16",
		                "IPv6Address": ""
		            },
		            "88459f13cf11a256c0c9df7aa19c5fb615b9b4eb89911cf9a3335f9a8bf71c07": {
		                "Name": "redis-cluster",
		                "EndpointID": "ac1cc0cc86985d53aa193601868cfe5b9210f00b0cd2409d13244cc6ce19a6ae",
		                "MacAddress": "02:42:ac:12:00:08",
		                "IPv4Address": "172.18.0.8/16",
		                "IPv6Address": ""
		            },
		            "bd57b93856da61535dc83235a19625a1417dbfd0833b88c8b668aa288b8174af": {
		                "Name": "redis-7012",
		                "EndpointID": "7cbf8cef0ff4e9ba6192db08bf539a24ae0f605a669152ff4c2df77ad7eef6b2",
		                "MacAddress": "02:42:ac:12:00:04",
		                "IPv4Address": "172.18.0.4/16",
		                "IPv6Address": ""
		            },
		            "e2d11bc6682bdab96713631b1352b51790ee94c8bd05d854a92f45a9da93ab65": {
		                "Name": "redis-7010",
		                "EndpointID": "60975dd5073934ee28d47e9a0495347ac295e0915ffd7d085713af3d6a742dd2",
		                "MacAddress": "02:42:ac:12:00:02",
		                "IPv4Address": "172.18.0.2/16",
		                "IPv6Address": ""
		            },
		            "f36fc8b2efaa14dcbc2b5c49d641a9f3d7ed501bc5a3891d420902369fd03fee": {
		                "Name": "redis-7011",
		                "EndpointID": "b24ac4af7db62086f457bbfc221330d1a4670864f2e6fdd39b7d879aed288813",
		                "MacAddress": "02:42:ac:12:00:03",
		                "IPv4Address": "172.18.0.3/16",
		                "IPv6Address": ""
		            }
		        },
		        "Options": {},
		        "Labels": {}
		    }
		]
		检查 redis-701* 容器 的 ip 正好 跟 被分配持有的 redis.conf配置文件的 cluster-announce-ip  一致!
		不一致的就要删除容器 好好修改重新建立容器:
		/////补充知识
		#  批量 删除指定容器!!
		for port in `seq 7010 7015`; do \
		  docker stop redis-${port};
		  docker rm redis-${port};
		done
	开始启动redis-cluster集群				
		echo yes | docker run -i --rm --net redis-net ruby sh -c '\
		  gem install redis \
		  && wget http://download.redis.io/redis-stable/src/redis-trib.rb \
		  && ruby redis-trib.rb create --replicas 1 \
		  '"$(for port in `seq 7010 7015`; do \
		    echo -n "$(docker inspect --format '{{ (index .NetworkSettings.Networks "redis-net").IPAddress }}' "redis-${port}")":${port} ' ' ; \
		  done)
		实际上就是 建立并启动 可以执行ruby程序的 容器 :docker run --net redis-net ruby
		然后在这个容器 执行
		gem install redis  //安装 ruby 的 redia 插件
		wget http://download.redis.io/redis-stable/src/redis-trib.rb   // 获得实现 cluster 的 ruby 脚本
		ruby redis-trib.rb create --replicas 1 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 	//开始执行 cluster 集群
		不过遇到了问题:
		WARNING: redis-trib.rb is not longer available!
		You should use redis-cli instead.
		
		All commands and features belonging to redis-trib.rb have been moved
		to redis-cli.
		In order to use them you should call redis-cli with the --cluster
		option followed by the subcommand name, arguments and options.
		
		Use the following syntax:
		redis-cli --cluster SUBCOMMAND [ARGUMENTS] [OPTIONS]
		
		Example:
		redis-cli --cluster create 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 --cluster-replicas 1

		To get help about all subcommands, type:
		redis-cli --cluster help
		问题表示, redis-trib.rb 不再提供cluster 服务, redis 本身redis-cli 已经可以实现:
		也就说 这个ruby 容器白建立的!! 删掉
	建立一个新 redis 容器,用来实现 redis-cluster
		docker run -it --name redls-cluster --net redis-net ruby /bin/bash
		cd /usr/local/bin
		redis-cli --cluster create 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 --cluster-replicas 1		//执行 cluster, --cluster-replicas 1 的 1 表示 1主1从
			>>> Performing hash slots allocation on 6 nodes...
			Master[0] -> Slots 0 - 5460
			Master[1] -> Slots 5461 - 10922
			Master[2] -> Slots 10923 - 16383
			Adding replica 172.18.0.5:7013 to 172.18.0.2:7010
			Adding replica 172.18.0.6:7014 to 172.18.0.3:7011
			Adding replica 172.18.0.7:7015 to 172.18.0.4:7012
			M: 5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010
			   slots:[0-5460] (5461 slots) master
			M: 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011
			   slots:[5461-10922] (5462 slots) master
			M: e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012
			   slots:[10923-16383] (5461 slots) master
			S: b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013
			   replicates 5d9495381e8ca8a72cd62009053f79745dc485b3
			S: 77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014
			   replicates 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23
			S: 25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015
			   replicates e5cee718cb7a59db06d86255d45714218518e2ba
			Can I set the above configuration? (type 'yes' to accept): yes
			>>> Nodes configuration updated
			>>> Assign a different config epoch to each node
			>>> Sending CLUSTER MEET messages to join the cluster
			Waiting for the cluster to join
			..
			>>> Performing Cluster Check (using node 172.18.0.2:7010)
			M: 5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010
			   slots:[0-5460] (5461 slots) master
			   1 additional replica(s)
			M: e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012
			   slots:[10923-16383] (5461 slots) master
			   1 additional replica(s)
			S: 25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015
			   slots: (0 slots) slave
			   replicates e5cee718cb7a59db06d86255d45714218518e2ba
			S: 77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014
			   slots: (0 slots) slave
			   replicates 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23
			S: b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013
			   slots: (0 slots) slave
			   replicates 5d9495381e8ca8a72cd62009053f79745dc485b3
			M: 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011
			   slots:[5461-10922] (5462 slots) master
			   1 additional replica(s)
			[OK] All nodes agree about slots configuration.
			>>> Check for open slots...
			>>> Check slots coverage...
			[OK] All 16384 slots covered.
	貌似成功cluster了, 接下来就是测试 !!!
		在任一节点/宿主容器上查看信息:
root@88459f13cf11:/usr/local/bin# redis-cli -c -h 172.18.0.2 -p 7010 cluster nodes
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548522635159 3 connected 10923-16383
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548522634000 6 connected
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548522634156 5 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 myself,master - 0 1548522634000 1 connected 0-5460
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 slave 5d9495381e8ca8a72cd62009053f79745dc485b3 0 1548522634557 4 connected
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 master - 0 1548522633000 2 connected 5461-10922
		
		redis-cli -c -h 172.18.0.2 -p 7010	//集群模式登录 节点  get set 实验
		172.18.0.2:7010> get foo
		-> Redirected to slot [12182] located at 172.18.0.4:7012
		(nil)
		172.18.0.4:7012> keys *
		(empty list or set)
		172.18.0.4:7012> get Tom
		-> Redirected to slot [9233] located at 172.18.0.3:7011
		(nil)
		172.18.0.3:7011> keys *
		1) "tom"
		172.18.0.3:7011> set jim age11
		-> Redirected to slot [4115] located at 172.18.0.2:7010
		OK
		172.18.0.2:7010> key *
		(error) ERR unknown command `key`, with args beginning with: `*`, 
		172.18.0.2:7010> keys *
		1) "jim"
		2) "kate"
		172.18.0.2:7010> set bob age15
		-> Redirected to slot [8955] located at 172.18.0.3:7011
		OK
		172.18.0.3:7011> set zeta age10
		OK
		172.18.0.3:7011> set anna age5
		-> Redirected to slot [15278] located at 172.18.0.4:7012
		OK
		172.18.0.4:7012> keys *
		1) "anna"
		172.18.0.4:7012> set fuli age7
		OK
		172.18.0.4:7012> keys *
		1) "anna"
		2) "fuli"
		172.18.0.4:7012> get tom
		-> Redirected to slot [8919] located at 172.18.0.3:7011
		"age12"
		172.18.0.3:7011> 
		可以看到 set get 数据 会自动跳到 所属 hash slot 的节点 进行数据保存!!!
	模拟故障1: 当master挂了, slave 会变成 master!!!
		比如直接 docker stop redis-7010 
		检查 网络 :
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes   //先接入  172.18.0.3:7011 然后检查所有节点网络         
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524513000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524513817 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548524310644 1548524309000 1 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524513516 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524512513 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524512814 3 connected 10923-16383
			注意, 看到了 172.18.0.2:7010@17010 master,fail  172.18.0.5:7013@17013 master
			hash-solt:0-5460 的 master节点挂了, 172.18.0.5:7013 作为 slave 节点 变成了 master 继续工作
			注意 redis-cli -c -h 172.18.0.2 -p 7010 cluster nodes //这是先接入 172.18.0.2:7010 然后检查所有节点网络 
			但是,由于这时, 172.18.0.2:7010不能接入,所以 这条指令也就失败了
		操作:redis-cli -c -h 172.18.0.3 -p 7011
			172.18.0.3:7011> get jim	//获取 存于   hash-slot:0-5460 的数据
			-> Redirected to slot [4115] located at 172.18.0.5:7013
			"age11"
			172.18.0.5:7013>  			
			// 换到了 172.18.0.5:7013 节点了!!!
		重新打开 172.18.0.2:7010 , 这个本来的master节点变成了slave节点
			docker start redis-7010 (注意 创建redis-701*的容器,设置了自动运行redis-server, 所以不用额外打开服务)
						(另外,创建容器时的设置,也不能通过 kill -9 来杀掉这个进程,所以只能通过 docker stop来模拟故障)
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524688000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524690000 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 slave b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 0 1548524690000 7 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524691313 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524690311 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524689307 3 connected 10923-16383
			可以看到  172.18.0.2:7010 变成 slave

	模拟故障2: 某 hash-slot 集群的 master slave 节点都挂了,redis 数据库阻塞停摆
		docker stop redis-7010 redis-7013
		检查 网络 :
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548525099000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548525100000 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548525051488 1548525050000 8 connected 0-5460
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master,fail - 1548524979292 1548524978591 7 connected
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548525100428 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548525099425 3 connected 10923-16383
			可见:
			172.18.0.5:7013@17013 master,fail
			172.18.0.2:7010@17010 master,fail
		操作:redis-cli -c -h 172.18.0.3 -p 7011
			172.18.0.3:7011> get jim	//获取 存于   hash-slot:0-5460 的数据 失败 (即故障的hash-solt集群 )
			(error) CLUSTERDOWN The cluster is down	
			172.18.0.3:7011> get tom	//获取 存于   hash-slott:5461-10922  的数据 (即自己本身 也失败)
			(error) CLUSTERDOWN The cluster is down
			172.18.0.5:7013> 
		重新打开 172.18.0.2:7010, 172.18.0.5:7013 , 
			docker start redis-7010 redis-7013  
				(注意,先打开redis-7010, 因为创建容器时,没有使用静态地址)
				(如果先创建 redis-7013 ,redis-7013会继承172.18.0.2,redis-7010会继承172.18.0.5)
				(跟他们 redis-conf 设置的 不匹配,redis-server启动失败)
			当然只 docker start redis-7010 也可以,
			但是只 docker start redis-7010 就不行,也是因为ip冲突,redis-server启动失败)
			然后
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes   //先接入  172.18.0.3:7011 然后检查所有节点网络         
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524513000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524513817 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548524310644 1548524309000 1 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524513516 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524512513 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524512814 3 connected 10923-16383				
			cluster网络又好了!! redis数据可以重新工作!!!
	模拟故障3: 上面的cluster 是通过 redis-cluster容器节点 创建集群的,那么, redis-cluster容器节点挂了呢?
		结果没有影响,  redis-cluster容器节点 创建了集群后,就没有 redis-cluster容器节点 的事情了
		即使所有节点都挂了!!
			docker stop redis-7010 redis-7011 redis-7012 redis-7013 redis-7014 redis-7015 redis-cluster
		重新,启动所有 数据库节点:
			docker start redis-7010 redis-7011 redis-7012 redis-7013 redis-7014 redis-7015
			redis数据库,照样如常工作,不需要重新创建集群
		就是说, redis数据节点 一旦创建好分片集群,就能自我管理并工作, 不需要其他管理节点介入
	尝试加入 sentinel (虽然感觉没有加入的意义!!! 因为cluster本身实现了 故障主从切换!!)
		sentinel 配置文件: sentinel-forcluster.conf
//////////
protected-mode no 
port 10011
daemonize yes
logfile "/var/log/sentinel.log"
sentinel monitor mymaster1 172.18.0.2:7010 1
sentinel monitor mymaster2 172.18.0.3:7011 1
sentinel monitor mymaster3 172.18.0.4:7012 1
sentinel down-after-milliseconds mymaster1 10000
sentinel down-after-milliseconds mymaster2 10000
sentinel down-after-milliseconds mymaster3 10000
sentinel parallel-syncs mymaster1 1
sentinel parallel-syncs mymaster2 1
sentinel parallel-syncs mymaster3 1
sentinel failover-timeout mymaster1 15000
sentinel failover-timeout mymaster2 15000
sentinel failover-timeout mymaster3 15000
//////////
		// 这才是 正确的 宿主机拷贝数据到 容器的 方法!!
		docker cp sentinel-forcluster.conf redis-7010:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7011:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7012:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7013:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7014:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7015:/usr/local/bin/sentinel.conf
		然后在容器开启 sentinel 节点,这里 我们在数据库本身开启打开sentinel服务,就懒得用新的容器实现了!!!
		在 6 个容器里分别执行sentinel  : cd /usr/local/bin/ && redis-sentinel sentinel.conf &
		然后出错:
			*** FATAL CONFIG FILE ERROR ***
			Reading the configuration file, at line 5
			>>> 'sentinel monitor mymaster1 172.18.0.2:7010 1'
			Unrecognized sentinel configuration statement.
		发现不能执行, 然后 我换了 3个独立节点 执行 sentinel
		出现同样错误!!
		看来 sentinel 和 cluster 是冲突的 !!!,cluster本身也实现了 故障主从切换, 
		所以sentinel不知道载在这个基础上如何工作了!!
	接入django 测试：
		修改之前 APP1 APP2 的内容： vim helloworld/views.py 添加
//////////////////////
from rediscluster import StrictRedisCluster

def hello (requset):
    redis_nodes = [
        {'host':'172.18.0.2','port':7010},
        {'host':'172.18.0.3','port':7011},
        {'host':'172.18.0.4','port':7012},
        {'host':'172.18.0.5','port':7013},
        {'host':'172.18.0.6','port':7014},
        {'host':'172.18.0.7','port':7015},
    ]
    try:
        redisconn = StrictRedisCluster(startup_nodes=redis_nodes)
    except Exception:
        print('connect Error')
        return HttpResponse('Connect Error!')

    print(redisconn.get('jim'))
    print(redisconn.get('tom'))
    print(redisconn.get('anna'))
    print(redisconn.get('fuji'))
    redisconn.set('app_info', 'HelloWorld-APP1')	# APP2 改为 APP2
    app_info = bytes.decode(redisconn.get('app_info'))
    stu_num_info = int(redisconn.get('stu_num'))
    info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    return HttpResponse(info) 
/////////////////////
		由于 APP1 APP2 跟 redis-7010 不是一个网段，所以需要建立连接到 redis-net network
			docker network connect redis-net  APP2
			docker network connect redis-net  APP1
		最后成功启动！！		
	
	putty 下载上传远程文件
		pscp E:\dukto\20190128 root@149.28.1xx.1xx:/root          //上传
		pscp root@149.28.1xx.1xx:root/note2 E:\dukto\      //下载
	

	最后,需要深入处理的有:
		如何操作实现读写分离,貌似所有操作都在master节点上,无法把读任务分摊到slave节点? 
		接入django 测试!!


mysql 集群 PXC (pxc是用于高一致集群的 Mysql 软件版本):
	参考: 
	https://blog.csdn.net/weixin_41141219/article/details/82767832  ///Docker 搭建pxc集群 + haproxy + keepalived 高可用（一）
	https://blog.csdn.net/qq_39409110/article/details/82288953     ////Docker 搭建pxc集群 + haproxy + keepalived 高可用（二）
	https://blog.csdn.net/qq_39409110/article/details/82289621     ////Docker 搭建pxc集群 + haproxy + keepalived 高可用（三）
	https://blog.csdn.net/qq_21108311/article/details/82223269   ////直接使用docker 的pxc 镜像,外挂docker volume备份数据库内容
	https://blog.csdn.net/fuckluy/article/details/80450868	////centos安装pxc, 主要讲解 my.cnf 配置参数!!!
	http://www.cnblogs.com/lyhabc/archive/2017/05/05/6812284.html	///// MySQL集群PXC的搭建   版本旧
	https://www.cnblogs.com/zejin2008/p/5475285.html	/////MySQL PXC 高可用集群搭建     版本旧
	http://www.cnblogs.com/kevingrace/p/5685371.html	/////  MySQL高可用方案－PXC环境部署记录   背景知识丰富    版本旧
				//// 模拟故障 和 恢复   重要
	https://www.percona.com/doc/percona-xtradb-cluster/5.5/howtos/centos_howto.html   ////官网部署教程   版本旧
	https://www.biaodianfu.com/centos-7-2-install-percona.html     //yum源 安装冲突问题,    没什么参考价值
	https://blog.csdn.net/wzhwho/article/details/4179154  //关selinux
	https://www.linuxidc.com/Linux/2017-05/143930.htm      ///PXC5.7(Percona XtraDB Cluster)集群部署	tar安装,参考有限
	https://hacpai.com/article/1536650134710	///centos7安装pxc5.7,  使用xtrabackup-v2数据同步     参考最多!!!!!
	https://www.clevernetsystems.com/running-percona-xtradb-cluster-rhel7/      ///pxc 常用指令
	https://www.cnblogs.com/ivictor/p/4837750.html		/////Docker官方CentOS镜像无法启动mysqld的总结
	https://www.jianshu.com/p/7cccdaa2d177   ///centos7 安装 mysql5.7
	http://blog.51cto.com/11819159/1933718	 /// 认识到 yum 安装的一些细节, 认识 basedir和datadir,本来想解决:
						 /// [ERROR] Can't find error-message file '/usr/local/mysql/share/mysql/errmsg.sys'.
						 /// 最后这个问题通过 清除已生成文件,重新初始化 mysald 解决!!!!
	/// yum 安装的一些细节: 作者的 basedir指定的是/usr/local/mysql/；后面突然想到了basedir指定是数据库的bin，lib之列的文件，
	///但是因为是yum安装的，所有这些文件默认的路径是在/usr/share/mysql下面，所以basedir这个参数可以并不需要指定，
	///或者直接指定到/usr/share/mysql/这个目录下面。
	
	
	知识点				
		PXC+Replication多主多从MySQL集群搭建
		MYCAT轻松实现mysql读写分离
		MySQL5.7.18已经支持基于事务的主从复制和读写分离
		而 pxc 做得更远!! 保持数据库高一致性,和每个节点数据保持相同,均可读写
		通过 docker 提供的傻瓜包镜像不好 参透,还是个实战好理解!
		为了锻炼 部署数据库集群到多个服务器的操作, 不直接使用 docker 提供 预装pxc镜像,
		需要实践 在 centos 部署 pxc57 的经验!!!
		需要本机 docker 实验了!!  远程机器资源严重不足 !!! 主要怀疑 pxc 最小的InnoDB_bffer_pool 为 128MB
		而对于 512 mb 内存的远程服务器机子来说就无法玩下去!!
	准备:
		首先在自己的 pc上 安装 docker:  https://blog.csdn.net/bingzhongdehuoyan/article/details/79411479
		docker pull centos  //下载docker上的centos镜像,默认最新最简centos7 镜像
		建立模拟局域网络:
			sudo docker network create pxc-net --subnet=172.22.0.0/16 --ip-range=172.22.0.0/16 --gateway=172.22.0.1      
			//16 是掩码范围的意思即：255.255.0.0
			网络查看: sudo docker network inspect pxc-net
		新建启动5个容器点 指定 pxc-net网络里的静态IP
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.2 -itd --name=pxc-node1 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.3 -itd --name=pxc-node2 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.4 -itd --name=pxc-node3 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.5 -itd --name=pxc-node4 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.6 -itd --name=pxc-node5 centos /usr/sbin/init
			(由于 docker 使用 centos建立的容器 执行 systemctl 会出错：Failed to get D-Bus connection: Operation not permitted
			 所以 docker run 的时候 加上 --privileged=true /usr/sbin/init)
			容器内查看centos 版本信息
				cat /etc/redhat-release
				CentOS Linux release 7.6.1810 (Core)	
		容器内centos 关闭 防火墙 和 行为监督 selinux！
			iptable： https://blog.csdn.net/wailaizhu/article/details/53488954
			selinux： https://www.cnblogs.com/activiti/p/7552677.html
			然而 精简 centos 镜像 并没有安装 iptable 和 selinux可以不理会！！
		登陆 5个node 准备 安装同样内容
			docker exec -it pxc-node_XXX bash		//登陆 node1/2/3/4/5	
	部署安装 pxc57( 也叫 pxc5.7)
		目前最通用的是 pxc57 版本, 网上很多使用参考都太旧了,参考价值有限, 
		旧版本 pxc 都需要自己手动安装必要的依赖包,比如:
			yum -y groupinstall Base Compatibility libraries Debugging Tools Dial-up Networking suppport Hardware monitoring utilities Performance Tools Development tools
		或者: 		
			rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
			yum install perl-IO-Socket-SSL perl-DBD-MySQL perl-Time-HiRes socat nc -y
		或者:
			yum install -y git scons gcc gcc-c++ openssl check cmake bison boost-devel asio-devel libaio-devel ncurses-devel readline-devel pam-devel socat
		实际上,虽然我的centos精简,缺少很多东西,但是如果是安装最新的的 pxc 不需要自己主动去添加依赖包!!
		pxc57 安装过程自我添加 依赖包!!!!
		所以以上安装依赖包的操作  不需要 !!!
		主要部署安装参考:  https://hacpai.com/article/1536650134710   //////centos7 部署安装 pxc57
	完整已经填好所有坑的部署安装方法:  假设我们部署5个节点 pxc-node1/2/3/4/5
		所有容器机子都安装:
			yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm //安装源
			yum install Percona-XtraDB-Cluster-57 -y	//直接安装 pxc57
		pxc的配置文件除了 传统的 my.cnf 还有他所包含的子文件,
		所有机子的 my.cnf都添加以下配置内容:
	[client]
	default-character-set = utf8mb4
	[mysqld]
	user=mysql
	skip_ssl
	sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'
	slow_query_log=ON
	slow_query_log_file=/var/lib/mysql/mysql-slow.log
	general_log=ON
	general_log_file=/var/lib/mysql/log-mysql.log
	long_query_time = 1
	explicit_defaults_for_timestamp = 1
	innodb_buffer_pool_instances = 1		//教程说8 不合适,因为注意>1  表示缓存大于1G  ?? 不知道那看到的  
	innodb_buffer_pool_dump_at_shutdown = 1
	log_timestamps=system
	character-set-server = utf8mb4
	collation-server = utf8mb4_unicode_ci
	max_connections=10000

		然后 第一台机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
	
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://					//wsrep已有,不用写上
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.2				//第一台机子的 ip
	# Cluster name
	wsrep_cluster_name=pxc-cluster
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc1					//需要修改!!
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc_user:123456"			//需要修改!!

		其他机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
		
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://172.22.0.2,172.22.0.3,172.22.0.4,172.22.0.5,172.22.0.6	//需要改
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.2/3/4/5/6				//node2,3,4,5 各自 ip地址
	# Cluster name
	wsrep_cluster_name=pxc-cluster
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc2/3/4/5					//需要修改!!node2,3,4,5 各自定义
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc_user:123456"			//需要修改!!
		然后 首次启动第一台机子 node1:
			systemctl start mysql@bootstrap.service
			grep 'temporary password' /var/log/mysqld.log	//获得暂时密码
			mysql -uroot -p		//登录 输入 暂时密码
			ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';  //修改root 密码
			CREATE USER 'pxc_user'@'localhost' IDENTIFIED BY '123456';	//创建热备份账户!!
			GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456';	//提权!!!!
			GRANT ALL PRIVILEGES ON *.* TO 'pxc_user'@'%' IDENTIFIED BY '123456';
			GRANT ALL PRIVILEGES ON *.* TO 'pxc_user'@'localhost' IDENTIFIED BY '123456';
			至此 第一台机子就部署好了,
		然后第二台机子 node2:
			直接 systemctl start mysql 就好了, 机子会加入到集群里,如果加入集群失败,会直接初始化失败
			成功后 mysql -uroot -p  输入同步过来的密码 123456 就可以登录!!
			这里 添加的表单,数据, 直接就开始同步到 第一台机子了!!!,
			可以直接在第一机子登录查看
		然后的三四五台机子.
			跟第二台操作一样,  systemctl start mysql 便可自动加入集群!!
		然后数据库关闭操作:
			一般: 其他节点 systemctl stop mysql 直接关闭!!!
			      第一节点 最后,且 通过 systemctl stop mysql@bootstrap.service 关闭!!!!!
			重新启动的话, 第一节点 先打开systemctl start mysql@bootstrap.service 
				其他节点 陆续打开 systemctl start mysql

	模拟故障分析!!
		假设只加入了 node2
			node1 无法  systemctl stop mysql , 我们尝试直接 kill -9 强制删除
			结果 只剩下 node2, 突然的故障无法让剩下的node2, 自举为首节点, 所以不能读写数据库,数据库直接崩溃!!!
			node2 systemctl stop mysql 常规关掉.
			这时 node1 因为是kill 强制删除的, 重新 systemctl stop mysql@bootstrap.service ,错误!!! 
			查看 /var/log/mysqld.log,说不是最后关闭节点,所以丧失首节点地位!!!
			降级为子节点: 这样子整个集群就没了首节点!!了,都是子节点
			
			node1重新强制成为首节点: 
				vi /var/lib/mysql/grastate.dat , safe_to_bootstrap: 1	//置1
				systemctl start mysql@bootstrap.service
		假如加入了 node2 node3
			1,直接 kill -9 强制 关闭 node1
			  突发故障,却剩下了 node2, node3, 两者很快自举出一个首节点(可能是node2,也可能node3)!!
			  这时数据库仍可以正常读写和同步!!
			2,这时 node3  systemctl stop mysql 正常关闭, 程序上推举node2最后节点,成为首节点
			  这时,数据库仍然正常读写.
			  node2虽然作为最后节点,也是首节点,但是关闭时还是 systemctl stop mysql 指令
			  就是说, node2 当初什么指令打开,最后也什么指令关闭	
			3,node2作为新的首节点, 数据库重新打开时,先打开 node2 而且换成指令 systemctl start mysql@bootstrap.service 打开!
			  然后 node1 node3 作为子节点, 需要 systemctl start mysql 打开!
			  这时 node1出错, cat /var/log/mysqld.log 查看日志发现
			  原来node1被创建人默认为永远的首节点, 所以 wsrep_cluster_address=gcomm:// 可以什么都不写
			  如今沦为子节点 wsrep_cluster_address=gcomm:// 如果没有ip 就不可能找到属于自己集群的首节点,加入集群!!
			  所以需要 vi /etc/percona-xtradb-cluster.conf.d/wsrep.cnf:
				wsrep_cluster_address=gcomm://   改回:
				wsrep_cluster_address=gcomm://172.22.0.2,172.22.0.3,172.22.0.4,172.22.0.5,172.22.0.6	
				就是说 作为首节点 wsrep_cluster_address=gcomm:// 填不填ip 都没有关系.
				但是首节点也有可能沦为子节点 ,所以统一填上更合理!!
			  然后 通过 systemctl start mysql 假如集群
			4,这时 node2 第一个想正常关闭,通过指令 systemctl stop mysql@bootstrap.service
			  而不是 systemctl stop mysql,
			  因为 node2 是 systemctl start mysql@bootstrap.service 打开的, 
			  不管他是不是最后正常关闭都要通过指令 systemctl stop mysql@bootstrap.service
			  首节点变成 node1 node3 其中一个,
			5,如果想 node1 变回 首节点, node3就得先正常关闭 systemctl stop mysql
			  最后 node1 也 通过 systemctl stop mysql 正常关闭
			6,总结的 重点就是说,数据库不完全崩溃的情况下!!!!!, 最后正常关闭的节点,就是下次数据开启的首节点
			  (像第一种讨论的情况只有两个节点, 一个不正常关闭,整个数据库就完全崩溃!!,
			   最后一个节点正常关闭也不会成为下次数据库开启的首节点)
			  节点当初是什么指令打开,就同样指令关闭!!!
		三个节点以上情况,参考3个节点情况同样讨论!!!

	部署安装集群 填坑 分析 :
		不管安装 旧pxc,还是新的pxc57 第一次启动时时都会遇到这个大坑,这个坑问题并不在于漏装依赖包的问题!!
		我们从分析入手:
			第一次启动直接出错: Job for mysqld.service failed because the control process exited with error code. See "systemctl status mysqld.service" and "journalctl -xe" for details.
			我们可以透过 systemctl status mysqld.service  或者 journalctl -xe 查看日志,发现爱呢问题:
			systemctl status mysqld.service 是针对 mysql 第一次启动的日志,
			journalctl -xe 却是 容器启动到此刻系统发布的所有记录的日志
		我们从中查看 ERROR 问题
			发现什么mysql: Can't create directory '/var/lib/mysql/' (Errcode: 17 - File exists) 
			但似乎不是重点.继续发现 [ERROR] InnoDB: Operating system error number 13 in a file operation.			
			错误 !!!! 即访问拒绝错误!!
			网上都没有关闭 seliunx ,但是本来就是没有安装 selinux
			然而,已经是root权限运行centos 了,  针对 pxc 出现的这个问题, 我们可以验证仅仅安装mysql也出现
			pxc是高级版本的mysql, 如果安装启动mysql出现问题,那么就不是pxc 高级模块部分初始化引起的问题!!
		所以先 关闭,重装 再打开 pxc-node1 容器, 安装测试 mysql5.7:
			参考 https://www.jianshu.com/p/7cccdaa2d177   ///centos7 安装 mysql5.7
			//首次密码修改问题
			ERROR 1819 (HY000): Your password does not satisfy the current policy requirements
			参考: https://blog.csdn.net/hello_world_qwp/article/details/79551789
			果然,安装了,也发现同样的问题 InnoDB 权限问题!!!
		一开始 怀疑是 用户权限问题!! 经学习mysql 不能从属 root 用户下工作,不然会出现很多问题
			mysal初始化启动时,应该添加 --user=mysql,即 msqld --uer=mysql
			就是说 使 mysql 的工作文件从属到 一个 mysql 的用户名下,
			虽然假定永远处于 root 下操作,不明白为啥还要分到 mysql 下,
			问题仍然处在
		尝试dmesg,会发现最新的像这样子的错误!!
			audit: type=1400 audit(1548838487.195:1022): apparmor="DENIED" operation="open" profile="/usr/sbin/mysqld" name="/proc/2821/status" pid=12504 comm="mysqld" requested_mask="r" denied_mask="r" fsuid=0 ouid=0
			谷歌 发现是是一个 apparmor 的程序引起
			然而,渐渐精简的centos 并没有,原来是 宿主的,虽然在容器里执行dmesg, 但是得到的却是宿主机开机到现在的日志记录!!!
			怀疑 宿主的 apparmor 阻碍了 容器 的 mysqld 初始化
			apparmor(监督强制软件访问行为的软件,跟 selinux 一样作用) 阻碍的 docker
			apparmor监督注册程序的访问内容, 当程序访问管辖外的内容时,会禁止行为
			主要指通过 路径分析实现监督:
			宿主机 安装了 mysql, 执行程序路径 /usr/sbin/mysqld
			容器 也安装了 mysql, 执行程序路径也是 /usr/sbin/mysqld
			一个是宿主机里的路径,一个数容器里的路径,但是apparmor只辨认 /usr/sbin/mysqld 不管实际位置
			这里 apparmor 只允许 /usr/sbin/mysqld 这个路径执行文件,访问指定的文件目录,
			但是 挂在 docker里的目录的路径显然超出了管辖范围外,所以禁止操作,
			变相 导致 容器 的InnoDB 没有访问权限
			所以禁用apparmor 关于mysql配置文件,参考: https://www.helplib.com/MySQL/article_176
			//查看监督
			sudo aa-status
			//取消监督某某
			sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable
			sudo apparmor_parser -R  /etc/apparmor.d/usr.sbin.mysqld
			sudo /etc/init.d/apparmor   ///重新启动
			//恢复监督某某
			sudo rm /etc/apparmor.d/disable/usr.sbin.mysqld
			sudo /etc/init.d/apparmor   ///重新启动
			删除各种冲突内容!! 最后重新 start mysqld 注意 不是 mysql
			service mysqld start  
			成功!!!!
		查到是宿主 apparmor 的行为, 与mysql无关,我们重新开始部署安装 pxc57
			不需要 依赖包,!!
			直接安装源,然后安装pxc57,
			配置 my.cnf 加上
			[mysqld]
			user=mysql
			然后第一次运行:service mysql start
			也没问题了!!
		然后开始部署: 
			部署开始,启动第一台机子的时候需要  systemctl start mysql@bootstrap.service
			出错!! 分析,由于 机子已经经历了首次启动,所以 使用这个部署启动的时候会出现莫名奇妙的错误
			其实就是初始化冲突问题, 一般
			重装, 配置好 my.cnf 所有内容后 才 systemctl start mysql@bootstrap.service 执行第一次启动
			也可以,删除以下文件夹后 重新执行 systemctl start mysql@bootstrap.service
			rm -rf /var/run/mysqld/ && rm -rf /var/lib/mysql/ && rm -rf /var/log/mysqld.log
			其实就是 删除 .cnf 配置的: pid-file,  datadir,  log-error 
			然后再就可以相当于重新执行 首启动
			成功!!!
		然后加入节点 出错:
			出现了 xtrabackup 运行失败的 信息
			既然 xtrabackup 也开始工作,就是说集群开始了,那么寻找错误就不能只从子节点分析
			子节点 只是 说 xtrabackup 运行错误, 怎样错误,并没有说!!
			而且也会出现:
			Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock'
			ERROR! mysqld_safe with PID 5737 has already exited: FAILURE
			这样的迷惑信息!! 
			实际上,因为 xtrabackup 工作失败后,一系列初始化就停了,于是会出现很多后续错误迷惑而找不到真正的出错点!!
			热备份 高可用关键 xtrabackup
			xtrabackup 出错,可能不仅仅是子节点的问题,也有可能是第一节点的问题!!
			xtrabackup 是节点之间实现热备份同步的程序!! 其实就是共同使用一个统一用户帐号实现,
			节点间自动使用嗯这个帐号登录更新数据!
			然后从 第一节点发现, 原来并第一节点还没有建立这个 统一账户,grant没有建立新帐号,只是给帐号提权
		建立帐号后,继续出错!!
			Error: failed to execute query LOCK TABLES FOR BACKUP: Access denied; you need (at least one of) the RELOAD privilege(s) for this operation
			这个是 帐号建立了,但还没有提权,,,,提权后
			就成功了

	pxc/mysql填坑思路:
		https://www.cnblogs.com/ivictor/p/5146247.html		//填坑思路
		先尝试发现问题!!
		systemctl status mysqld.service
		journalctl -xe
		demesg
		vi /var/log/mysqld.log
		一般mysql 启动时第一时间启动日志系统,即 生成并输出/var/log/mysqld.log
		如果出错在于 生成mysqld.log 之前,就系统问题,重要关注systemctl status mysqld.service,journalctl -xe 内容
		特别关注 dmesg 内容!! 
		这里注意 dmesg 从来是是宿主开机以来的日志记录, 不管这条指令是在容器还是宿主机运行!!
		如果生成了 mysqld.log ,一般就是 my.cnf 即文件配置配置问题,
			或者没有进入 mysql 初始化某些指令的问题, 当然也有可能还是系统问题!!
		重点,不要先考虑 是 安装出撮问题,因为安装时 complete 表示成功安装,一般是内部外部的配置问题导致不能启动!!
		journalctl -xe 把日志从开始位置开始列出, 并不合适,应该 journalctl -n 直接从最后的日志显示内容!!!!
 
		
	附加----使用过的指令:
		yum provide ls		//缺 所以安装 ls 工具
		yum install initscripts		//centos 没有 service 命令 只有 systemctl,如果要使用需要自己添加 
		yum install wget	//添加 wget
		vi /var/log/mysqld.log   或者  cat /var/log/mysqld.log      //查看 运行日志文件
		mysqld --initialize && mysqld install	// mysql 的初始化!! (pxc不建议使用!!)
	 	////  关闭,重装 再打开 pxc-node1/2/3/4/5 容器  ////
		sudo docker stop pxc-node1 && sudo docker rm pxc-node1 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.2 -itd --name=pxc-node1 centos /usr/sbin/init && sudo docker exec -it pxc-node1 bash

		sudo docker stop pxc-node2 && sudo docker rm pxc-node2 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.3 -itd --name=pxc-node2 centos /usr/sbin/init && sudo docker exec -it pxc-node2 bash

		sudo docker stop pxc-node3 && sudo docker rm pxc-node3 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.4 -itd --name=pxc-node3 centos /usr/sbin/init && sudo docker exec -it pxc-node3 bash

		sudo docker stop pxc-node4 && sudo docker rm pxc-node4 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.5 -itd --name=pxc-node4 centos /usr/sbin/init && sudo docker exec -it pxc-node4 bash

		sudo docker stop pxc-node5 && sudo docker rm pxc-node5 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.6 -itd --name=pxc-node5 centos /usr/sbin/init && sudo docker exec -it pxc-node5 bash
		
		yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm	///安装最新的pxc 官方源
		////// pxc 常用指令
		service mysql start to start this cluster’s node
		service mysql bootstrap-pxc to start this node as the first node of the cluster
		service mysql status to check the status of this cluster’s node
		service mysql stop to stop this cluster’s node
 		///// selinux 常用指令
		查看SELinux状态：1、
		/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态
			SELinux status:                 enabled
		getenforce                 ##也可以用这个命令检查
		关闭SELinux：
			临时关闭（不用重启机器）：
			setenforce 0                  ##设置SELinux 成为permissive模式
                        setenforce 1 			设置SELinux 成为enforcing模式
		修改配置文件需要重启机器：
			修改/etc/selinux/config 文件
			将SELINUX=enforcing改为SELINUX=disabled
			重启机器即可

建立在 pxc 集群之上的 分片集群!!! (即分布式集群)
实现 Mycat + pcx 的 分片集群
再建立一个 pxc 集群
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.12 -itd --name=pxc2-node1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.13 -itd --name=pxc2-node2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.14 -itd --name=pxc2-node3 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.15 -itd --name=pxc2-node4 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.16 -itd --name=pxc2-node5 centos /usr/sbin/init
		
		sudo docker exec -it pxc2-node1 /bin/bash 	//pxc2-node1/2/3/4/5
		//都按装 pxc57
		yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm //安装源
		yum install Percona-XtraDB-Cluster-57 -y	//直接安装 pxc57
	所有机子的 /etc/my.cnf
	[client]
	default-character-set = utf8mb4
	[mysqld]
	user=mysql
	skip_ssl
	sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'
	slow_query_log=ON
	slow_query_log_file=/var/lib/mysql/mysql-slow.log
	general_log=ON
	general_log_file=/var/lib/mysql/log-mysql.log
	long_query_time = 1
	explicit_defaults_for_timestamp = 1
	innodb_buffer_pool_instances = 1		//教程说8 不合适,因为注意>1  表示缓存大于1G  ?? 不知道那看到的  
	innodb_buffer_pool_dump_at_shutdown = 1
	log_timestamps=system
	character-set-server = utf8mb4
	collation-server = utf8mb4_unicode_ci
	max_connections=10000

	然后 所有机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
	
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://172.22.0.12,172.22.0.13,172.22.0.14,172.22.0.15,172.22.0.16	//需要改
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.12/13/14/15/16				//每一台机子的 ip
	# Cluster name
	wsrep_cluster_name=pxc2-cluster					//第二个独立的 pxc 集群
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc2-1/2/3/4/5					//每一台机子的名字 需要修改!!
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc2_user:123456"			//需要修改!!

		然后 首次启动第一台机子 node1:
			systemctl start mysql@bootstrap.service
			grep 'temporary password' /var/log/mysqld.log	//获得暂时密码
			mysql -uroot -p		//登录 输入 暂时密码
			ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';  //修改root 密码
			CREATE USER 'pxc2_user'@'localhost' IDENTIFIED BY '123456';	//创建热备份账户!!
			GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456';	//提权!!!!
			GRANT ALL PRIVILEGES ON *.* TO 'pxc2_user'@'%' IDENTIFIED BY '123456';
			GRANT ALL PRIVILEGES ON *.* TO 'pxc2_user'@'localhost' IDENTIFIED BY '123456';
			至此 第一台机子就部署好了,
		然后第二台机子 node2:
			直接 systemctl start mysql 就好了, 机子会加入到集群里,如果加入集群失败,会直接初始化失败
			成功后 mysql -uroot -p  输入同步过来的密码 123456 就可以登录!!
			这里 添加的表单,数据, 直接就开始同步到 第一台机子了!!!,
			可以直接在第一机子登录查看
		然后的三四五台机子.
			跟第二台操作一样,  systemctl start mysql 便可自动加入集群!!
		然后数据库关闭操作:
			一般: 其他节点 systemctl stop mysql 直接关闭!!!
			      第一节点 最后,且 通过 systemctl stop mysql@bootstrap.service 关闭!!!!!
			重新启动的话, 第一节点 先打开systemctl start mysql@bootstrap.service 
				其他节点 陆续打开 systemctl start mysql
	最后,注意关机后若重新启动数据库, 需要查看上次关闭最后关闭的节点,所以要
	cat /var/lib/mysql/grastate.dat	1
	查看 safe_to_bootstrap: 1 则是最后关闭的节点,必须第一打开这个节点!! systemctl start mysql@bootstrap.service 
 	然后, 这个pxc2 集群和 之前的pxc集群 成功相互独立共存!!
	后面为 建立 mycat 分片集群准备!!

安装数据库可视化工具,辅助数据库搭建部署测试!!:
	MysqlWorkbench: https://blog.csdn.net/qq_34256348/article/details/78342897
	navicat: (未安装使用,不合适,只有win版本)
	
	由于 docker 把容器的 局域网映射出来了, 所以可以用 可视化工具假装链接远程数据库那样那样子查看操作节点所以的数据库


maycat 分片 集群 部署:
	再建立3个 mycat 节点
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.101 -itd --name=mycat-node1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.102 -itd --name=mycat-node2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.103 -itd --name=mycat-node3 centos /usr/sbin/init
	然后进入每个 节点 命令行窗口操作 !!!
	需要安装java
		登录官网:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html
		下载最新的 jdk11 : jdk-11.0.2_linux-x64_bin.tar.gz  (手动安装的方法放弃,因为更需要麻烦的配置)
		yum 装 java
		先 java -version 查看已安装的,如果有安装的,如果版本太低就选择卸载:
		yum -y remove java-1.7.0-openjdk*  //卸载旧的 jdk
		yum -y list java*  //查看软件库的 java版本更新 情况
		yum -y install java-11-openjdk*	   //安装查看到的新的 jdk
	安装其他辅助工具:
		yum -y install tree
		yum -y install wget
		//还是缺乏一些常用的命令: ifconfig 等
		寻找 ifconfig 所在 软件包
			yum provides ifconfig			
			yum whatprovides ifconfig	//或者这条
		yum -y install net-tools	//安装
		寻找 netstat 所在 软件包
	安装mycat:
		安装包的位置: 	http://dl.mycat.io/
		获取,解压安装包
			cd /root
			wget http://dl.mycat.io/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz
			tar -zxvf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz
		环境变量添加 mycat 位置!!
			vi /etc/profile 添加:
			export MYCAT_HOME=/root/mycat
			使环境变量生效 source /etc/profile
		改变mycat用户和组
			groupadd mycat
			adduser -r -g mycat mycat
			chown -R mycat.mycat /root/mycat  //修改mycat目录所属mycat用户
		对以下三个重要配置文件备份!!
			cp /root/mycat/conf/schema.xml /root/mycat/conf/schema.xmlbackup
			cp /root/mycat/conf/rule.xml /root/mycat/conf/rule.xmlbackup
			cp /root/mycat/conf/server.xml /root/mycat/conf/server.xmlbackup
	测试mycat:(仅仅第一个mycat节点做的测试,熟悉上手mycat)
		修改 schema.xml !!! 使得只设置 一个 合法 的 datahoat  
			(注意,一个datahost 是一个存储集群,可以是一个pxc集群,然后只存储分片内容!!)
////////////////////////
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

        <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
                <!-- auto sharding by id (long) -->
                <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />

                <!-- global table is auto cloned to all defined data nodes ,so can join
                        with any table whose sharding node is in the same data node -->
                <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                <table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2" />

                <!-- random sharding using mod sharind rule -->
                <table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2,dn3"
                           rule="mod-long" />
                <table name="employee" primaryKey="ID" dataNode="dn1,dn2"
                           rule="sharding-by-intfile" />
                <table name="customer" primaryKey="ID" dataNode="dn1,dn2"
                           rule="sharding-by-intfile">
                        <childTable name="orders" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id">
                                <childTable name="order_items" joinKey="order_id"
                                                        parentKey="id" />
                        </childTable>
                        <childTable name="customer_addr" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id" />
                </table>
        </schema>

        <dataNode name="dn1" dataHost="localhost1" database="db1" />
        <dataNode name="dn2" dataHost="localhost1" database="db2" />
        <dataNode name="dn3" dataHost="localhost1" database="db3" /> 

        <dataHost name="localhost1" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="hostM1" url="localhost:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="hostS2" url="localhost:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="hostS1" url="localhost:3316" user="root" password="123456" />
        </dataHost>

</mycat:schema>
////////////////////////
			简单分析下 mycat 登记了 TESTDB 这个数据库!
			这个也登记了在 mycat 之下的多个 tables 而这些表的数据都会参与分片操作!!
			比如: rule="auto-sharding-long" ,这时表的分片规则,这里每5000000条数据分到一个节点分片来存储
			dataNode="dn1,dn2,dn3" 表示登记的这个表有3个分片节点. 所以最多也只有 15000000 条,超出会出错.
			<dataNode name="dn1" dataHost="localhost1" database="db1" /> 描述一个分片节点的参数
				name="dn1" 分片节点的名字, 随便起
				dataHost="localhost1" 分片节点所在的物理服务器机集群名字,随便起
				database="db1" 分片节点所在的物理服务器机集群的真实数据库的真实名字db1,
				就是说 travelrecord数据表,应该属于TESTDB数据库的,
				但是实际是分开保存在 db1,db2,db3数据库里!! 
			关于 dataHost 物理服务器机集群 的定义!!
			maxCon="1000" minCon="10" 最多允许并发1000次连接,最小并发10次连接, balance暂时不清楚
			<writeHost host="hostM1" 定义的是第一组读写分离操作,
			<writeHost host="hostS1" 定义的是第二组读写分离操作,
				当中都包含登录实际数据库的帐号密码信息
			一般按默认来执行第一组读写分离操作 当服务器集群中相关节点出现故障时才转向其他组读写分离操作	
		启动mycat :  /root/mycat/bin/mycat start
			注意 实际数据库 db1,db2,db3 必须先建立好!!!!!! 不然在后面连接数据库的过程中会出错
			登录mycat 使用 mysql 命令, 意味着maycat节点还需要额外安装一个 mysql 数据库 
			当然,不安装数据库的可以使用其他安装了mysql数据库 节点来远程访问 这个 mycat!!
			登录 mycat :  mysql -uroot -p123456 -h127.0.0.1 -P8066
			或者 : mysql -uroot -p123456 -h127.0.0.1 -P8066
			注意: 登录 ip:8066 使用的root帐号, 与实际mysql的root 不是同一个帐号!!
				比如 mysql 帐号是 root:aaabbb, mycat帐号是:root:111222
				那么 mysql -uroot -paaabbb    登录mysql
				     mysql -uroot -p111222 -P8066 -h127.0.0.1 登录mycat
				     mysql -uroot -p111222    错误, 因为登录mysql 却用了mycat的帐号
				     mysql -uroot -paaabbb -P8066 -h127.0.0.1  错误, 因为登录mycat 却用了mysql的帐号
			这时进入的不是真正的 mysql ,而是虚拟的mysql 即mycat
			使用 原来的sql命令在这里操作,最终会被mycat 分配到真正的 mysql 数据库节点上!!
			例如上述 schema.xml 设置的 分片节点,设置到同 172.22.0.101 节点下的 mysql 数据库 的 db1,db2,db3数据库
			所以使用mycat前, 必须先在mysql建立好 数据库 db1,db2,db3
		测试:(再mycat输入 sql命令)
			CREATE TABLE travelrecord (
			  id BIGINT(20) NOT NULL,
			  title VARCHAR(100) NOT NULL,
			  PRIMARY KEY (id)
			) ENGINE=INNODB DEFAULT CHARSET=utf8
				//虽然在mycat 看到了TESTDB数据库 存在 travelrecord 表, 但是实体mysql数据库上并没有
				//所以,这条命令会 在 db1,db2,db3 实体数据库上 建立起 travelrecord 表
			插入数据:
			INSERT INTO travelrecord(ID,TITLE) VALUES(1,'goods1');
			INSERT INTO travelrecord(ID,TITLE) VALUES(2,'goods2'); 
			INSERT INTO travelrecord(ID,TITLE) VALUES(3,'goods3');
				//根据分片rule 这三条会存在 db1.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(5000001,'goods5000001');
				//根据分片rule 这一条会存在 db2.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(10000001,'goods10000001');
				//根据分片rule 这一条会存在 db3.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(15000001,'goods15000001');
				//根据分片rule,每个分片最多只有5000000条数据, 这一条会出错,因为没有 db4.travelrecord 来承载

	配置mycat节点1 与多个 pxc 集群的连接 !!!
		pxc 和 pxc2 集群 分别建立 shard1 shard2 数据库 作为两个即将被使用的节点!! 
		mycat节点1: 修改 schema.xml
///////////////
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

        <schema name="WILLIAM" checkSQLschema="false" sqlMaxLimit="100">
                <!-- auto sharding by id (long) -->
                <table name="lover" dataNode="dn1,dn2" rule="auto-sharding-long" />
        </schema>

        <dataNode name="dn1" dataHost="pxc_1" database="shard1" />
        <dataNode name="dn2" dataHost="pxc_2" database="shard2" />

        <dataHost name="pxc_1" maxCon="1000" minCon="10" balance="2"
                          writeType="1" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="w1" url="172.22.0.2:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="r11" url="172.22.0.4:3306" user="root" password="123456" />
			<readHost host="r12" url="172.22.0.5:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="w2" url="172.22.0.3:3316" user="root" password="123456" >
                        <readHost host="r21" url="172.22.0.5:3306" user="root" password="123456" />
			<readHost host="r22" url="172.22.0.6:3306" user="root" password="123456" />
                </writeHost>
        </dataHost>

        <dataHost name="pxc_2" maxCon="1000" minCon="10" balance="2"
                          writeType="1" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="w1" url="172.22.0.12:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="r11" url="172.22.0.14:3306" user="root" password="123456" />
			<readHost host="r12" url="172.22.0.15:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="w2" url="172.22.0.13:3316" user="root" password="123456" >
                        <readHost host="r21" url="172.22.0.15:3306" user="root" password="123456" />
			<readHost host="r22" url="172.22.0.16:3306" user="root" password="123456" />
                </writeHost>
        </dataHost>

</mycat:schema>
///////////////
		然后 server.xml需要修改:
///////////////
        <user name="root" defaultAccount="true">
                <property name="password">123456</property>
                <property name="schemas">WILLIAM</property>		//改这里

                <!-- 表级 DML 权限设置 -->
                <!-- 
                <privileges check="false">
                        <schema name="TESTDB" dml="0110" >
                                <table name="tb01" dml="0000"></table>
                                <table name="tb02" dml="1111"></table>
                        </schema>
                </privileges>
                 -->
        </user>

        <user name="user">
                <property name="password">user</property>
                <property name="schemas">WILLIAM</property>		//改这里
                <property name="readOnly">true</property>
        </user>
///////////////
		然后启动发现失败:
		mycat console 看到了问题:
jvm 1    | Caused by: io.mycat.config.util.ConfigException: Illegal table conf : table [ LOVER ] rule function [ rang-long ] partition size : 3 > table datanode size : 2, please make sure table datanode size = function partition size
		就是说 rule="auto-sharding-long" 要求起码有3个节点,,但是,我们只建立了两个pxc集群,没有第三个集群承担第三个节点
		产看 rule.xml,最后 知道要修改 autopartition-long.txt,把第三节点屏蔽掉!
		然后重启 mycat 成功 !!!
		mycat节点1:执行:
			CREATE TABLE lover (
			  id BIGINT(20) NOT NULL,
			  title VARCHAR(100) NOT NULL,
			  PRIMARY KEY (id)
			) ENGINE=INNODB DEFAULT CHARSET=utf8
			INSERT INTO lover(ID,TITLE) VALUES(1,'misa_1');
			INSERT INTO lover(ID,TITLE) VALUES(2,'alita_2'); 
			INSERT INTO lover(ID,TITLE) VALUES(3,'cuter_3'); 
			INSERT INTO lover(ID,TITLE) VALUES(5000001,'marina_5000001'); 
			INSERT INTO lover(ID,TITLE) VALUES(5000002,'alsa_5000002');
		查看对应的 pxc集群 的数据情况!! 测试分片均衡成功
		
	mycat节点 集群预备:
		按照 配置mycat节点 与多个 pxc 集群的连接 
		重复配置 mycat 的节点2 节点3
		注意,这两个节点可以只安装了 jdk11 和 mycat, 不再需要安装 mysql,
		因为最终都是从远程登录 所有 mycat 节点的
		这些节点都可以 独立 访问 pxc集群,
		测试:
		mycat节点2:执行:
			INSERT INTO lover(ID,TITLE) VALUES(4,'luna_4');
		mycat节点3:执行:
			INSERT INTO lover(ID,TITLE) VALUES(5000003,'ayumi_5000003');
			查看pxc集群数据的存储情况
			都不需要再次执行 create lover 表的操作, 因为已经存在,这三个节点都指向操作同一个 WILLIAM 数据库
			而3者是相互独立的, 所以就进一步建立集群,可以实现数据访问流的分流减压
	mycat节点 安装使用 xinetd 网络微服务,方便 haproxy 节点 对 mycat服务状况监控
		yum -y install xinetd
		检查/etc/xinetd.conf的末尾是否有 includedir /etc/xinetd.d
			cat /etc/xinetd.conf
		检查是否有 /etc/xinetd.d 文件夹 : ls /etc/xinetd.d
		添加 mycat 状态检测服务: 
			vi /etc/xinetd.d/mycat_status  
//////////////////  
service mycat_status
{
        flags = REUSE
        socket_type = stream
        port = 48700
        wait = no
        user = root
        server = /usr/local/bin/mycat_status
        log_on_failure += USERID
        disable = no
}
//////////////////
			解释:
			        socket_type = stream 
					## 封包处理方式，Stream为TCP数据包
					## 使用该标记的socket_type为stream，需要设置wait为no
			        port = 48700 ## 服务监听端口 
			        wait = no ## 表示不需等待，即服务将以多线程的方式运行 
			        user = root ## 执行此服务进程的用户 
			        server = /usr/local/bin/mycat_status ## 需要启动的服务脚本 
			        log_on_failure += USERID ## 登录失败记录的内容 
			        disable = no ## 要启动服务，将此参数设置为no 
		添加 /usr/local/bin/mycat_status 服务脚本: vi /usr/local/bin/mycat_status
/////////////////
#!/bin/bash
#/usr/local/mycat/bin/mycat_status
# This script checks if a mycat server is healthy running on localhost. It will
# return:
#
# "HTTP/1.x 200 OK\r" (if mycat is running smoothly)
#
# "HTTP/1.x 503 Internal Server Error\r" (else)
mycat=`/root/mycat/bin/mycat status | grep 'not running' | wc -l`
if [ "$mycat" = "0" ];
then
/bin/echo -e "HTTP/1.1 200 OK\r\n"
else
/bin/echo -e "HTTP/1.1 503 Service Unavailable\r\n"
fi
/////////////////
		给脚本添加执行权限: chmod a+x /usr/local/bin/mycat_status
		/etc/services 中加入 mycat_status 服务: vi /etc/services 添加
			mycat_status    48700/tcp               # mycat_status
		重启 xinetd: systemctl restart xinetd
		验证mycat_status服务是否成功启动: netstat -antup|grep 48700
		脚本测试,直接输入命令: /usr/local/bin/mycat_status 		
	
	创建节点 安装 HAProxy
		添加两个 节点 为haproxy 服务 
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.111 -itd --name=hapro1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.112 -itd --name=hapro2 centos /usr/sbin/init
		进入节点 使用 yum 安装 haproxy 参考: 
			https://blog.csdn.net/aboutmn/article/details/87180266 //这里是haproxy1.8
			https://blog.csdn.net/weixin_42859280/article/details/83796029 //这里是centos7自带的haproxy1.5
		使用通用的	haproxy1.5 就好了
		yum list |grep haproxy
			haproxy.x86_64                            1.5.18-8.el7                   base   
			pcp-pmda-haproxy.x86_64                   4.1.0-5.el7_6                  updates
		yum -y install haproxy
	测试 haproxy 建立 mycat集群: 
		由于使用 电脑资源不够, 直接配置 haproxy + mycat + pxc 会容易崩溃!!所以简化操作!!
		mycat不接 pxc 集群 ,相对地都接到 172.22.0.101 的mysql 的db1 db2 两个分片数据库,简单模拟分片均衡
		配置 haproxy: vi /etc/haproxy/haproxy.cfg
		添加三组配置,和其他信息
/////////////  注意,写到文件时,不要 把 ## 标注的注释也写上
## golbal下添加节点信息
    node        hap_node1
    description haproxy_node1_for_mycat_clusters


listen admin_status
    bind :48800  ## 只绑端口
    stats uri /admin_status ##统计页面
    stats auth admin:admin ## 设置统计页面认证的用户和密码 
    mode http
    option httplog ## 启用日志记录HTTP请求

listen mycat_servers
    bind :3307	
    mode tcp
    option tcplog  ## 记录TCP请求日志
    option tcpka ## 是否允许向server和client发送keepalive
    option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测
    balance roundrobin ## 定义负载均衡算法，可用于"defaults"、"listen"和"backend"中,默认为轮询方式
    server mycat_01 172.22.0.101:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_02 172.22.0.102:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_03 172.22.0.103:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    timeout server 20000

listen mycat_admin
    bind :3308	
    mode tcp
    option tcplog  ## 记录TCP请求日志
    option tcpka ## 是否允许向server和client发送keepalive
    option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测
    balance roundrobin ## 定义负载均衡算法，可用于"defaults"、"listen"和"backend"中,默认为轮询方式
    server mycat_01 172.22.0.101:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_02 172.22.0.102:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_03 172.22.0.103:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    timeout server 20000
/////////////
		根据/etc/haproxy/haproxy.cfg 配置:
		添加haproxy用户组和用户	(yum按装后似乎可以跳过这步)
			groupadd haproxy
			useradd -g haproxy haproxy
		创建chroot运行的路径	(yum按装后似乎可以跳过这步)
			mkdir /var/lib/haproxy
		启动 haproxy
			systemctl start haproxy
		测试,
			mysql -uroot -p123456 -h172.22.0.111 -P3307
			插入一条数据:
				use WILLIAM; 
				INSERT INTO lover(ID,TITLE) VALUES(5000003,'fiya_5000003');
			( 注意使用命令行的 mysql端,不要使用 mysql workbench ,发现
			  mysql workbench 除了 直接连mysql外 链接到mysql中间件都不稳定!! )
			然后自己浏览器输入 http://172.22.0.111:48800/admin_status
			可以查看到 haproxy 的状态信息!!
			分析一个流程:
				当 mysql -uroot -p123456 -h172.22.0.111 -P3307
				haproxy 会选出一个 mycat节点 连接,然后 haproxy也建立起这次连接对话 session,并维持
				然后 我们接下来的
					use WILLIAM; 
					INSERT INTO lover(ID,TITLE) VALUES(5000003,'fiya_5000003');
				都算入到这次对话的数据传输内容!!
				然而当我们一段时间步操作, 然后再操作时,比如 select * from lover
				ERROR 2013 (HY000): Lost connection to MySQL server during query
				随表示出错,其实就是 haproxy 维护的这次对话表示已经超时,所以就断开了!!!
				当我们再 select * from lover, haproxy会重新建立起新的对话, 选择新的 mycat节点成功继续操作!!!
				关于超时问题, 还是因为不太熟悉设置 haproxy 的超时机制!!!
		继续配置haproxy节点2
			跟 haproxy节点1 同理配置, 只是 haproxy.cfg golbal的 node description 信息设置成节点2的!!		
			    node        hap_node2
			    description haproxy_node2_for_mycat_clusters
		这下子其实 haproxy 节点1 节点2 都分别独立实现了 对 mycat的集群了!!
	接下来,加入keepalived, 实现 haproxy 的双机热备!!
		再 haproxy 节点上 直接yum安装(centos7 自带 1.3.5,版本) :yum -y install keepalived
		先备份 keepalived 配置文件: cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.confbackup
			因为值得后面参考学习!!
		配置 keepalived : vi /etc/keepalived/keepalived.conf
			参考:https://blog.csdn.net/l1028386804/article/details/76397064	
//////////////////// haproxy节点1的
! Configuration File for keepalived

global_defs {
   router_id khnode_in111
}

vrrp_script chk_haproxy {
	script "/etc/keepalived/haproxy_check.sh"
	interval 2
	weight 2
}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 120
    nopreempt
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        chk_haproxy
    }
    virtual_ipaddress {
        172.22.0.120
    }
}
////////////////////

//////////////////// haproxy节点2的
! Configuration File for keepalived

global_defs {
   router_id khnode_in112
}

vrrp_script chk_haproxy {
	script "/etc/keepalived/haproxy_check.sh"
	interval 2
	weight 2
}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 110
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        chk_haproxy
    }
    virtual_ipaddress {
        172.22.0.120
    }
}

////////////////////
		添加对应的 检查脚本: 
			mkdir -p /usr/local/keepalived/log
			vi /etc/keepalived/haproxy_check.sh
///////////////////
#!/bin/bash
START_HAPROXY="systemctl start haproxy"
STOP_HAPROXY="systemctl stop haproxy"
LOG_FILE="/usr/local/keepalived/log/haproxy-check.log"
HAPS=`ps -C haproxy --no-header |wc -l`

date "+%Y-%m-%d %H:%M:%S" >> $LOG_FILE
echo "check haproxy status" >> $LOG_FILE
if [ $HAPS -eq 0 ];then
    echo $START_HAPROXY >> $LOG_FILE
    $START_HAPROXY >> $LOG_FILE 2>&1
    sleep 3 
    if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then
        echo "start haproxy failed, killall keepalived" >> $LOG_FILE
        killall keepalived 
    fi 
fi
///////////////////
		给脚本赋执行权限： chmod +x /etc/keepalived/haproxy_check.sh
		打开 keepalived: systemctl start keepalived
		然而并没有启动成功 : 查看安装配置 cat /etc/sysconfig/keepalived 找出记录日志地方,寻问题!!
		后来发现,服务器启动死在 keepalived -D 这一步上,似乎需要补上 rsyslog 日志系统才能正常工作
		当然,直接跳过 直接使用 keepalived -P 也可以得到我们期望 成功启动 的结果
			不过就要 透过 kill -9 xxx 来 关闭!!!
		补全日志系统 rsyslog:
			yum install -y rsyslog
		然后直接 systemctl start rsyslog 
		然后重新启动 keepalived : systemctl start keepalived //还是启动失败,
		这时 tail -f /var/log/messages 便可以看到 keepalived 启动错误的日志信息 
			Feb 16 12:30:08 3daaa8cfd4f7 Keepalived_healthcheckers[4667]: IPVS: Can't initialize ipvs: Protocol not available
			Feb 16 12:30:08 3daaa8cfd4f7 Keepalived_healthcheckers[4667]: Stopped
		这涉及到kernel内核级别的ipvs 模块!!!!
		解决办法: (参考:http://www.mamicode.com/info-detail-2128337.html) 
			宿主机安装 sudo apt-get install ipvsadm
		然后 宿主机执行 ipvsadm 
			IP Virtual Server version 1.2.1 (size=4096)
			Prot LocalAddress:Port Scheduler Flags
			  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
		然后宿主机检查: lsmod | grep ip_vs                        
			ip_vs                 151552  0
			nf_conntrack          131072  9 	xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ipv4,nf_nat,ipt_MASQUERADE,nf_nat_ipv4,xt_nat,nf_conntrack_netlink,ip_vs
			libcrc32c              16384  3 nf_conntrack,nf_nat,ip_vs
			表示已经正常启动 ip_vs 模块了
		然后 keepalived 常规启动 systemctl start keepalived 便不再出错了!!!
	关于keepalived + haproxy + mycat + pxc 的方案就先不继续下去了,因为机子貌似撑不起
		现在是  keepalived + haproxy + mycat + mysql 方案, 只是末端的数据库是 mysql 而不是pxc集群!!
		有机会再完整实现 keepalived + haproxy + mycat + pxc 方案
		整个集群框架理应改应该是这样子的: (keepalived + haproxy + mycat + pxc)
						      

                                       keepalived make a VIP as enter IP							
                                      -----------(172.22.0.120)----------
                                      |                                 |
                              ----------------                    ----------------         
                              | keepalived1  |   <------------>   | keepalived2  |
                              | haproxy1     |                    | haproxy2     |
                              | 172.22.0.111 |                    | 172.22.0.112 |
                              | p:3307->8066 |                    | p:3307->8066 |
                              | p:3308->9066 |                    | p:3308->9066 |
                              ----------------                    ----------------
                                 /       \   \                     /    /    \
                                /         \   \                   /    /      \
                  ----------------              ----------------             ----------------
                  | mycat1       |              | mycat2       |             | mycat3       |
                  | 172.22.0.101 |              | 172.22.0.102 |             | 172.22.0.103 |
		  |p:8066        |              |p:8066        |             |p:8066        |
                  | for databases|              | for databases|             | for databases|
                  |p:9066        |              |p:9066        |             |p:9066        |
                  | manage mycat |              | manage mycat |             | manage mycat |
                  ----------------              ----------------             ----------------
                          /      \                   /    \                   /       \
                         /                          /      \                           \
  -----------------------------------------------------   -----------------------------------------------------
  |                  pxc  as  shard1                  |   |                 pxc2  as  shard2                  |
  |                                                   |   |                                                   |
  |       ----------------     ----------------       |   |       ----------------     ----------------       |
  |       |  pxc-node1   |     |  pxc-node2   |       |   |       |  pxc2-node1  |     |  pxc2-node2  |       | 
  |       |  172.22.0.2  |     |  172.22.0.3  |       |   |       | 172.22.0.12  |     | 172.22.0.13  |       |
  |       | write1_node  |     | write2_node  |       |   |       | write1_node  |     | write2_node  |       |
  |       | p:3306       |     | p:3306       |       |   |       | p:3306       |     | p:3306       |       |
  |       ----------------     ----------------       |   |       ----------------     ----------------       |
  |          /         \         /          \         |   |          /         \         /          \         |
  | ---------------  ---------------  --------------- |   | ---------------  ---------------  --------------- |
  | | pxc-node3   |  | pxc-node4   |  | pxc-node5   | |   | | pxc2-node3  |  | pxc2-node4  |  | pxc2-node5  | |
  | | 172.22.0.4  |  | 172.22.0.5  |  | 172.22.0.6  | |   | | 172.22.0.14 |  | 172.22.0.15 |  | 172.22.0.16 | |
  | | read1_node1 |  | read1_node2 |  | read2_node2 | |   | | read1_node1 |  | read1_node2 |  | read2_node2 | |
  | | p:3306      |  | read2_node1 |  | p:3306      | |   | | p:3306      |  | read2_node1 |  | p:3306      | |
  | |             |  | p:3306      |  |             | |   | |             |  | p:3306      |  |             | |
  | ---------------  ---------------  --------------- |   | ---------------  ---------------  --------------- |
  -----------------------------------------------------   -----------------------------------------------------
	参考:
		mycat安装参考: https://blog.csdn.net/promise2017/article/details/79326535
			      https://www.cnblogs.com/linjiqin/p/7879903.html
		mycat实现mysql分片集群:https://www.uol123.com/2018/01/16/mycat-mysql.html
				      https://blog.csdn.net/weixin_42582592/article/details/82919039
		mycat+pxc分片集群参考: https://www.cnblogs.com/reblue520/p/10338496.html
		HAProxy实现 mycat集群: https://blog.csdn.net/l1028386804/article/details/75331934
				       https://blog.csdn.net/u012758088/article/details/78654628
		keepalived + haproxy + mycat + pxc : https://blog.csdn.net/l1028386804/article/details/76397064
					https://blog.csdn.net/qq_36586867/article/details/81508032
			这种集群方案针对的是 短连接方案,恰恰访问数据库的确算短连接!!
			如果是关于 维护长连接(长时间),考虑使用 zookeeper 而不是 keepalived

		Mycat配置文件schema.xml: https://blog.csdn.net/l1028386804/article/details/53385637
		mycat配置简单介绍 : http://www.cnblogs.com/wang-meng/p/5861301.html
		mycat自身集群使用 HAProxy : https://blog.csdn.net/l1028386804/article/details/75331934
		mycat1.6.5 问题排错参考(我安装的是这个): https://rorschachchan.github.io/2018/07/05/Mycat%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/
		mycat管理端口9066: https://blog.csdn.net/zhouchang3/article/details/54382550
		mycat连接管理数据库，操作表时报ERROR 3009 (HY000): java.lang.IllegalArgumentException: Invalid DataSource:0
			https://blog.csdn.net/jaryle/article/details/76830202
		haproxy 超时机制: https://blog.csdn.net/zhaoyangjian724/article/details/51145045 
附加:
vi 常用命令:
	全选:	 	ggvG或者ggVG
	全部复制:	ggyG
	全部删除:	ggvGd
	显示行号:	:set number
	跳到第一行:      按两次“g”
	跳到最后一行：	按“G”,即“shift+g”

最后: 启动 pxc 注意 注意先找到第一节点启动 !!!!!














20190201

	Hadoop spark
	分布式计算

	docker:
		不需要他深入,上述已经够用
	mangoDB:
		https://www.cnblogs.com/nulige/p/7613721.html		//副本集 和 sharding cluster 两种集群

	压力测试:
		https://blog.csdn.net/a13124837937/article/details/79628838    /// jmeter
		https://www.cnblogs.com/kazihuo/p/7986681.html  ///压力测试 Nxginl 例子
	HAProxy:
		上述pxc集群已经足够理解了!!
		
	Nginx:



centos7 mongoDB4 sahrding cluster集群
	就是 外围客户 通过 路由器集任意一个节点, 访问 config 集群,获得数据的位置信息,然后访问 shard 集群 获得数据信息
	停止所有容器:
		sudo docker stop $(sudo docker ps -a -q) //  stop停止所有容器
		sudo docker restart $(sudo docker ps -a -q) //  restart所有容器,但是是逐个restart,,, 不是全关再全开
		sudo docker rm $(sudo docker ps -a -q) //补充   remove删除所有容器
	先建立新局域网络!!!
		sudo docker network create mongodb-net --subnet=172.23.0.0/16 --ip-range=172.23.0.0/16 --gateway=172.23.0.1
	网络查看: sudo docker network inspect pxc-net
	新建启动5个容器点 指定 pxc-net网络里的静态IP
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.2 -itd --name=mgdb-shd11 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.3 -itd --name=mgdb-shd12 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.4 -itd --name=mgdb-shd13 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.5 -itd --name=mgdb-shd21 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.6 -itd --name=mgdb-shd22 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.7 -itd --name=mgdb-shd23 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.8 -itd --name=mgdb-shd31 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.9 -itd --name=mgdb-shd32 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.10 -itd --name=mgdb-shd33 centos /usr/sbin/init

		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.11 -itd --name=mgdb-cofg1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.12 -itd --name=mgdb-cofg2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.13 -itd --name=mgdb-cofg3 centos /usr/sbin/init

		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.14 -itd --name=mgdb-mogs1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.15 -itd --name=mgdb-mogs2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.16 -itd --name=mgdb-mogs3 centos /usr/sbin/init
		(由于 docker 使用 centos建立的容器 执行 systemctl 会出错：Failed to get D-Bus connection: Operation not permitted
		所以 docker run 的时候 加上 --privileged=true /usr/sbin/init)
		附加,开启所有 节点:
			sudo docker start mgdb-shd11 mgdb-shd12 mgdb-shd13 mgdb-shd21 mgdb-shd22 mgdb-shd23 mgdb-shd31 mgdb-shd32 mgdb-shd33 mgdb-cofg1 mgdb-cofg2 mgdb-cofg3 mgdb-mogs1 mgdb-mogs2 mgdb-mogs3
	容器内查看centos 版本信息
		cat /etc/redhat-release
		CentOS Linux release 7.6.1810 (Core)		      
	每个 centos7 节点都先 yum 安装 mongodb4:
		参考: https://blog.csdn.net/bigtree_3721/article/details/82768056
	vi /etc/yum.repos.d/mongodb-org-4.0.repo	//添加:
		[mongodb-org-4.0]
		name=MongoDB Repository
		baseurl=https://repo.mongodb.org/yum/redhat/7Server/mongodb-org/4.0/x86_64/
		gpgcheck=1
		enabled=1
		gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc
	yum makecache 
	yum install -y mongodb-org	//安装 mongodb
	rpm -ql mongodb-org-server	//查看安装的路径!!
		/etc/mongod.conf
		/lib/systemd/system/mongod.service
		/usr/bin/mongod
		/usr/share/doc/mongodb-org-server-4.0.5
		/usr/share/doc/mongodb-org-server-4.0.5/LICENSE-Community.txt
		/usr/share/doc/mongodb-org-server-4.0.5/MPL-2
		/usr/share/doc/mongodb-org-server-4.0.5/README
		/usr/share/doc/mongodb-org-server-4.0.5/THIRD-PARTY-NOTICES
		/usr/share/man/man1/mongod.1
		/var/lib/mongo
		/var/log/mongodb
		/var/log/mongodb/mongod.log
		/var/run/mongodb
	其他:
		8.MongoDB操作：
		8.1关闭、启动、重启MongoDB
		# service mongod restart
		Redirecting to /bin/systemctl restart mongod.service
		8.2 设置开启启动：
		# service mongod restart
		Redirecting to /bin/systemctl restart mongod.service
		9.删除mongoDB：
		#sudo service mongod stop
		#sudo yum erase $(rpm -qa | grep mongodb-org)
		#sudo rm -r /var/log/mongodb
		#sudo rm -r /var/lib/mongo
	开始集群配置: 参考:
		https://www.cnblogs.com/hehexiaoxia/p/6061043.html
		http://www.lanceyan.com/tech/arch/mongodb_shard1.html
		http://feed.askmaclean.com/archives/mongdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html
	分片集群组合:
		mongs : 172.23.0.14:20000, 172.23.0.15:20000, 172.23.0.16:20000
		cnfig : 172.23.0.11:20000, 172.23.0.12:20000, 172.23.0.13:20000
		shrd1 : 172.23.0.2:20000, 172.23.0.3:20000, 172.23.0.4:20000
		shrd2 : 172.23.0.5:20000, 172.23.0.6:20000, 172.23.0.7:20000
		shrd3 : 172.23.0.8:20000, 172.23.0.9:20000, 172.23.0.10:20000
	shard1 节点 都这样 启动节点服务!!!
		mkdir -p /data/shard1/data
		mkdir -p /data/shard1/log
		/usr/bin/mongod --shardsvr --replSet shard1 --port 20000 --dbpath /data/shard1/data  --logpath /data/shard1/log/shard1.log  --oplogSize 10 --fork --bind_ip_all
			--shardsvr 指定作为  分片集群的节点
			--replSet  指定集群名字
			--port     端口是 20000
			--dbpath   数据放置路径
			--logpath  记录日志位置
			--oplogSize 把整体缓存设置变小, 因为只是测试,没有必要用大缓存
			--fork     以新的进程运作
			必须加上--bind_ip_all 不然其他节点不能访问,经踩坑,发现 不加, mongo服务不能 通过 ip 地址登录,只能本地登录
			即, 不能 mongo 172.23.0.xx:20000 登录,只能 mongo 127.0.0.1:20000登录	
	shard2 节点 启动节点服务
		mkdir -p /data/shard2/data
		mkdir -p /data/shard2/log
		/usr/bin/mongod --shardsvr --replSet shard2 --port 20000 --dbpath /data/shard2/data  --logpath /data/shard2/log/shard2.log  --oplogSize 10 --fork --bind_ip_all	
	shard3 节点 启动节点服务
		mkdir -p /data/shard3/data
		mkdir -p /data/shard3/log
		/usr/bin/mongod --shardsvr --replSet shard3 --port 20000 --dbpath /data/shard3/data  --logpath /data/shard3/log/shard3.log  --oplogSize 10 --fork --bind_ip_all
	config 节点 启动节点服务
		mkdir -p /data/config/data
		mkdir -p /data/config/log
		/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork --bind_ip_all
			--configsvr 指定作为  config集群的节点
 	然后开始配置 shard 和 config 集群 !!
	选择 config 集群的 其中一个节点执行配置即可,配置自动贯穿整个集群:
	比如 cofg1 节点,登录 cofg1 节点再登录 172.23.0.11:20000 mongo命令端
	当然从其他 容器节点 登录 172.23.0.11:20000 mongo命令端 也是可以的, 172.23.0.11:20000,
		mongo 172.23.0.11:20000
		> use admin
		switched to db admin
		> config = { _id:"cfgReplSet", configsvr:true, members:[
		... {_id:0,host:"172.23.0.11:20000"},
		... {_id:1,host:"172.23.0.12:20000"},
		... {_id:2,host:"172.23.0.13:20000"}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
			.....
		}

		配置插曲: (出错,无法 连接  172.23.0.13:20000  等等!!)
		> rs.initiate(config);		
		{
		        "operationTime" : Timestamp(0, 0),
		        "ok" : 0,
		        "errmsg" : "replSetInitiate quorum check failed because not all proposed set members responded affirmatively: 172.23.0.12:20000 failed with Error connecting to 172.23.0.12:20000 :: caused by :: Connection refused, 172.23.0.13:20000 failed with Error connecting to 172.23.0.13:20000 :: caused by :: Connection refused",
		        "code" : 74,
		        "codeName" : "NodeNotFound",
		        "$gleStats" : {
		                "lastOpTime" : Timestamp(0, 0),
		                "electionId" : ObjectId("000000000000000000000000")
		        },
		        "lastCommittedOpTime" : Timestamp(0, 0),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(0, 0),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		查看log 发现!!!!!!
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] ** WARNING: This server is bound to localhost.
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          Remote systems will be unable to connect to this server.
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          Start the server with --bind_ip <address> to specify	which IP
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          addresses it should serve responses from, or with --bind_ip_all to
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          bind to all interfaces. If this behavior is desired, start the
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          server with --bind_ip 127.0.0.1 to disable this warning.

		/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork 
		不够,需要添加 --bind_ip_all (就是这里发现需要补上 --bind_ip_all 的 坑)
		所有节点服务重新加上这个启动!!
		然后重新设置 成功
		
	shard1集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样 添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd11 节点配置:
		mongo 172.23.0.2:20000
		> use admin
		switched to db admin
		> config = { _id:"shard1", members:[
		... {_id:0,host:"172.23.0.2:20000"},
		... {_id:1,host:"172.23.0.3:20000"},
		... {_id:2,host:"172.23.0.4:20000",arbiterOnly:true}
		... ]}
			//arbiter 是仲裁的意思,这里的分片集群使用 副本集 的方式
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549301987, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549301987, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard1:SECONDARY>
		配置插曲:
		配置错{_id:2,host:"172.23.0.4:20000"},应该是 {_id:2,host:"172.23.0.4:20000",arbiterOnly:true}才对,
		需要重新配置,通过指令重新配置  Replica set 相当麻烦, 
		还不如节点重新处理安装mongo 服务 !!,然后重新 rs.initiate()

	shard2集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd21 节点配置:
		mongo 172.23.0.5:20000
		> use admin
		switched to db admin
		> config = { _id:"shard2", members:[
		... {_id:0,host:"172.23.0.5:20000"},
		... {_id:1,host:"172.23.0.6:20000"},
		... {_id:2,host:"172.23.0.7:20000",arbiterOnly:true}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549299260, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549299260, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard2:SECONDARY>	
	shard3集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd31 节点配置:
		mongo 172.23.0.8:20000
		> use admin
		switched to db admin
		> config = { _id:"shard3", members:[
		... {_id:0,host:"172.23.0.8:20000"},
		... {_id:1,host:"172.23.0.9:20000"},
		... {_id:2,host:"172.23.0.10:20000",arbiterOnly:true}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549302444, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549302444, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard3:SECONDARY> 

	然后 开始 创建和匹配 mongos 节点 (路由器节点)
	mongos 所有节点 启动节点服务
		mkdir -p /data/mongos/data
		mkdir -p /data/mongos/log
		/usr/bin/mongos --configdb cfgReplSet/172.23.0.11:20000,172.23.0.12:20000,172.23.0.13:20000 --port 20000  --logpath /data/mongos/log/mongos.log --fork --bind_ip_all
	这时 shard1/2/3  副本集方式做好集群, config 以主从方式也做了集群!! mongs 都各自地挂上了 config集群		
	mongos 之间不分主从,各自独立工作,就是像是并联的节点,充当路由作用
	这时配置路由器,添加分片配置,其实就是 链接 config集群 和 shard1/2/3 集群,实现分片集群
	选择其中一个mongos节点 配置即可,配置自动贯穿整个集群
		mongo 172.23.0.14:20000
		mong0s> use admin
		mong0s> sh.addShard("shard1/172.23.0.2:20000,172.23.0.3:20000,172.23.0.4:20000");
		mong0s> sh.addShard("shard2/172.23.0.5:20000,172.23.0.6:20000,172.23.0.7:20000");
		mong0s> sh.addShard("shard3/172.23.0.8:20000,172.23.0.9:20000,172.23.0.10:20000");
		mong0s> sh.status();	//查看mongs 的状态
		--- Sharding Status --- 
		  sharding version: {
		        "_id" : 1,
		        "minCompatibleVersion" : 5,
		        "currentVersion" : 6,
		        "clusterId" : ObjectId("5c586218e6d1cfea52eda72a")
		  }
		  shards:
		        {  "_id" : "shard1",  "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",  "state" : 1 }
		        {  "_id" : "shard2",  "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",  "state" : 1 }
		        {  "_id" : "shard3",  "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",  "state" : 1 }
		  active mongoses:
		        "4.0.5" : 3
		  autosplit:
		        Currently enabled: yes
		  balancer:
		        Currently enabled:  yes
		        Currently running:  no
		        Failed balancer rounds in last 5 attempts:  0
		        Migration Results for the last 24 hours: 
		                No recent migrations
		  databases:
		        {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
		                config.system.sessions
		                        shard key: { "_id" : 1 }
		                        unique: false
		                        balancing: true
		                        chunks:
		                                shard1  1
		                        { "_id" : { "$minKey" : 1 } } -->> { "_id" : { "$maxKey" : 1 } } on : shard1 Timestamp(1, 0) 
		mong0s> db.runCommand({listShards:1});	//检查，显示shard配置：
		{
		        "shards" : [
		                {
		                        "_id" : "shard1",
		                        "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",
		                        "state" : 1
		                },
		                {
		                        "_id" : "shard2",
		                        "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",
		                        "state" : 1
		                },
		                {
		                        "_id" : "shard3",
		                        "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",
		                        "state" : 1
		                }
		        ],
		        "ok" : 1,
		        "operationTime" : Timestamp(1549381266, 2),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549381266, 2),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		登出 172.23.0.14 mongos容器节点, 然后登入172.23.0.15 mongos容器节点, 然后登录172.23.0.15 的命令界面
		mongos> sh.status();	//查看mongs 的状态
		mongos> db.runCommand({listShards:1});	//检查，显示shard配置：
		发现 其实  172.23.0.15 的 mongs节点也关联上, 也就说 一个mongos节点 添加分片配置后,所有mongos节点都好了!!
		实质是透过, mongos 配置了 config 节点集群的shard1/2/3数据分片信息,而不是配置 mongos 节点本身!!!!!
	至此所有配置 完毕!!!
	数据库可实现 分片集群!!
	实现开机自启动:(集群的节点在这已经配置好了,以后集群节点直接打开后,集群数据库就可以直接工作)
	首先 centos7 支持两种 自启动方式:
		systemctl 和 chkconfig
	参考:
		https://blog.csdn.net/lfgxiaogang/article/details/78924308	//cent7,systemctl方式自启动!!	
		https://www.cnblogs.com/dongling/p/6232730.html		// chkconfig 开机启动!!
		https://www.cnblogs.com/niocai/archive/2012/07/12/2587780.html // chkconfig 开机启动追加问题
	yum 安装 mongodb 时候,都默认设置了 systemctl的自启动,所以要所有节点都要先关闭!!
		systemctl disable mongod.service 
	然后,我选择并开始使用  chkconfig 实现自定义的开机自启动
	shard1 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard1	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard1 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard1 --port 20000 --dbpath /data/shard1/data  --logpath /data/shard1/log/shard1.log  --oplogSize 10 --fork --bind_ip_all
		
		chown root.root /etc/rc.d/init.d/mongod_shard1 && chmod 755 /etc/rc.d/init.d/mongod_shard1 && chkconfig --add mongod_shard1 && chkconfig --levels 245 mongod_shard1 off
		插曲:附加笔记:
		# chkconfig: 2345 90 10   中:
			其中2345是默认启动级别，级别有0-6共7个级别。
				等级0表示：表示关机 　　
				等级1表示：单用户模式 　　
				等级2表示：无网络连接的多用户命令行模式 　　
				等级3表示：有网络连接的多用户命令行模式 　　
				等级4表示：不可用 　　
				等级5表示：带图形界面的多用户模式 　　
				等级6表示：重新启动
			90指启动优先级别 级别分0-100,数字越大,优先级别越低
			10指关闭优先级别 级别分0-100,数字越大,优先级别越低
		# description:    就是随意的自己写的描述信息!!
			如果出现 service myservice does not support chkconfig 的错误
			是因为脚本文件没有 # chkconfig和 # description 这些项
		chown root.root /etc/rc.d/init.d/mongod_shard1		//改变权限
		chmod 755 /etc/rc.d/init.d/mongod_shard1		//所有用户都可以执行，单只有root可以修改
		chkconfig --add mongod_shard1				//将mysqld 放入linux启动管理体系中
		chkconfig --list mongod_shard1				//查看全部服务在各运行级状态
		chkconfig --levels 245 mongod_shard1 off		//只要运行级别3启动，其他都关闭,并不改变 mongod_shard1内容!!
	shard2 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard2	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard2 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard2 --port 20000 --dbpath /data/shard2/data  --logpath /data/shard2/log/shard2.log  --oplogSize 10 --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_shard2 && chmod 755 /etc/rc.d/init.d/mongod_shard2 && chkconfig --add mongod_shard2 && chkconfig --levels 245 mongod_shard2 off
	shard3 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard3	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard3 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard3 --port 20000 --dbpath /data/shard3/data  --logpath /data/shard3/log/shard3.log  --oplogSize 10 --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_shard3 && chmod 755 /etc/rc.d/init.d/mongod_shard3 && chkconfig --add mongod_shard3 && chkconfig --levels 245 mongod_shard3 off
	config集群的节点:
		vi /etc/rc.d/init.d/mongod_cofg	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_confg node1 start on 
			/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_cofg && chmod 755 /etc/rc.d/init.d/mongod_cofg && chkconfig --add mongod_cofg && chkconfig --levels 245 mongod_cofg off
	mongos 集群的节点:
		vi /etc/rc.d/init.d/mongod_mogs	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_confg node1/2/3 start on 
			/usr/bin/mongos --configdb cfgReplSet/172.23.0.11:20000,172.23.0.12:20000,172.23.0.13:20000 --port 20000  --logpath /data/mongos/log/mongos.log --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_mogs && chmod 755 /etc/rc.d/init.d/mongod_mogs && chkconfig --add mongod_mogs && chkconfig --levels 245 mongod_mogs off

	至此,自启动的配置也做好了,
	最后便是读写测试:
	mongo 数据库基本操作:
		==> 数据操作：
			插入数据：db.collection.insert
			查询数据：db.collection.find()
			更新数据：db.collection.update()
			删除数据：db.collection.remove()
		==> collection操作：
			新建collection：
			sh.shardCollection("xxx.yyy",{col1: 1, col2: 1})
			删除collection：
			db.yyy.drop()
		==> db操作：
			新建db
				sh.enableSharding("xxx")
			删除db：
				use xxx
				db.dropDatabase();

	批量数据测试:
	登录任意 一个mongos节点命令窗:
	新建数据库 williamblog 并设置允许使用分片均衡
	mongos>sh.enableSharding("williamblog");
	{
	        "ok" : 1,
	        "operationTime" : Timestamp(1549383200, 2),
	        "$clusterTime" : {
	                "clusterTime" : Timestamp(1549383200, 2),
	                "signature" : {
	                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
	                        "keyId" : NumberLong(0)
	                }
	        }
	}
	在 williamblog 数据库 声明一个数据表 testtab,他的 age name项都是 这个表的数据实现分片均衡的 处理标识
	mongos>sh.shardCollection("williamblog.testtab2",{age: 1, name: 1});	
	{
	        "collectionsharded" : "williamblog.testtab",
	        "collectionUUID" : UUID("967dab62-2d2f-4e44-b121-6b79ba425eb7"),
	        "ok" : 1,
	        "operationTime" : Timestamp(1549383349, 8),
	        "$clusterTime" : {
	                "clusterTime" : Timestamp(1549383349, 8),
	                "signature" : {
	                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
	                        "keyId" : NumberLong(0)
	                }
	        }
	}
	批量写入一段数据
	mongos>use williamblog	//必须!!! 不然不是在 williamblog.testtab 添加内容!!
				//而是在其他不知道是什么地方新建一个不分片均衡数据表 testtab的添加数据!!
	mongos>for (i=1;i<=10000;i++) db.testtab.insert({name: "user"+i, age: (i%150)});   
	WriteResult({ "nInserted" : 1 })
	检查状态
	mongos> sh.status();
	--- Sharding Status --- 
	  sharding version: {
	        "_id" : 1,
	        "minCompatibleVersion" : 5,
	        "currentVersion" : 6,
	        "clusterId" : ObjectId("5c586218e6d1cfea52eda72a")
	  }
	  shards:
	        {  "_id" : "shard1",  "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",  "state" : 1 }
	        {  "_id" : "shard2",  "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",  "state" : 1 }
	        {  "_id" : "shard3",  "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",  "state" : 1 }
	  active mongoses:
	        "4.0.5" : 3
	  autosplit:
	        Currently enabled: yes
	  balancer:
	        Currently enabled:  yes
	        Currently running:  no
	        Failed balancer rounds in last 5 attempts:  0
	        Migration Results for the last 24 hours: 
	                No recent migrations
	  databases:
	        {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
	                config.system.sessions
	                        shard key: { "_id" : 1 }
	                        unique: false
	                        balancing: true
	                        chunks:
	                                shard1  1
	                        { "_id" : { "$minKey" : 1 } } -->> { "_id" : { "$maxKey" : 1 } } on : shard1 Timestamp(1, 0) 
	        {  "_id" : "williamblog",  "primary" : "shard3",  "partitioned" : true,  "version" : {  "uuid" : UUID("85c6a65a-dbfe-4ce3-b61a-d636f60df1a7"),  "lastMod" : 1 } }
	                williamblog.testtab
	                        shard key: { "age" : 1, "name" : 1 }
	                        unique: false
	                        balancing: true
	                        chunks:
	                                shard3  1
	                        { "age" : { "$minKey" : 1 }, "name" : { "$minKey" : 1 } } -->> { "age" : { "$maxKey" : 1 }, "name" : 	{ "$maxKey" : 1 } } on : shard3 Timestamp(1, 0) 
	可以看到, chunks 只有 shard3  1 一个分片,这就奇怪了,感觉就是没有实现分片均衡的样子,所有数据都放到 shard3 里
		多鞋机次批量数据也这样,后来飞发现可能是 chunks 数据块大小问题, mongo默认数据块大小是 64mb
		而我们的批量数据还是没有超过 64mb,所以就都放在同一个数据块上面.
		所以尝试 修改 chunks 的数据块大小
		use config
		db.settings.save( { _id:"chunksize", value: 20 } )	//块大小是 变成20mb
		然后后再重新批量写次数据,就发现分片了!!
                williamblog.testtab
                        shard key: { "age" : 1, "name" : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1  41
                                shard2  41
                                shard3  41
                        too many chunks to print, use verbose if you want to force print
		每个数据表 williamblog.testtab 数据 分布在三个shard集群上, 每个shard集群都有41个数据块,
		每个数据块都有一部分williamblog.testtab 数据表的内容!!
	balancing 功能是开启着的吗就是说mongo每隔一段时间都会检查 数据的集群分布,务求做到分片均衡!!
		在这里, shard key: { "age" : 1, "name" : 1 } 表示数据 是按照平分数据到 shard集群的方式存数据的!!
		balancing 也按照这种规律监管数据库,
		假如某刻,shard1 有1个数据块,shard2 有2个, shard3 有120个
		那么一段时间后被 balancing 监管发现, balancing会试图 搬迁平分数据, 务求最后 每个shard 都分得41个数据块的方向努力!!
	所以 其实分片设置是成功的,mongoDB 会根据数据实际情况自动分片,我一直以为没有分片,是设置上什么错误,
		其实只不过是各种原因,数据库未选择执行分片而已!! 这里是写入数据还不足以超过(数据块的大小导致)
	
	至此,monodb 分偏集群完成!!
	最后附加上 mogodb 分片股管理的深入参考:
		https://www.cnblogs.com/zhoujinyi/p/4668218.html	//分片管理!!	
		https://www.cnblogs.com/chenmh/p/8954584.html   //数据分片策略研究
		https://blog.csdn.net/wellschen/article/details/82499429 //测试时发现 数据不分块分片的问题!
		https://blog.csdn.net/wellschen/article/details/82499429 //补充的数据分片不成功的问题探

		









	
	

20190217
	未学习 的主流 工具
	nginx
	hoodloop
	electicsearch
学习 electicsearch 先不考录集群安装,先考虑使用!!
	直接使用docker版本:
		sudo docker pull docker.elastic.co/elasticsearch/elasticsearch:6.6.0
		sudo docker run -p 9200:9200 -p 9300:9300 --name=ES -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:6.6.0
		后面实验使用的是 6.1.1 版本,所以 把 6.6.0 版本删除,没必要存在多不同版本的镜像,够用就可以!!!
		sudo docker images 	//查看镜像的 ID	
		sudo docker rmi xxxxx	//根据ID:xxxxx 删除镜像 
	建立一个 docker 程序栈!!
		补充安装 docker-compose 插件:
			sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose		//直接下载 bin 文件
			sudo chmod +x /usr/local/bin/docker-compose   //配置执行权限
		建立一个 项目目录..full_stack/electicsearch_test,包含程序栈运行的所有内容!!!
		.
		├── books
		│   ├── 10007.txt
		│   ├── 10007.txt.rsrc
		│   ├── 103.txt
		│   ....
		│
		├── docker-compose.yml
		├── Dockerfile
		├── package.json
		├── public
		│   ├── app.js
		│   ├── index.html
		│   └── styles.css
		└── server
		    ├── app.js
		    ├── connection.js
		    ├── load_data.js
		    └── search.js
		/public - 目录保存是前端 Vue.js Web应用js代码 
		/server - 目录保存服务器后端 Node.js 源代码	
		docker-compose.yml 文件定义全部的应用程序栈,每个被定义的容器都将端口转发到宿主机系统（localhost）上，
		    以便于我们在宿主机上去访问和调试 Node API、Elasticsearch 实例和前端 Web 应用程序
		    gs-api - 后端应用程序逻辑使用的 Node.js 容器
		    gs-frontend - 前端 Web 应用程序使用的 Ngnix 容器。
		    gs-search - 保存和搜索数据的 Elasticsearch 容器。
		Dockerfile  由于 gs-frontend gs-search 是使用下载现成的镜像,gs-api却是使用自己定义配置内容的nodejs镜像,
			所以 需要 这个文件来 告诉生成自定义 nodejs 镜像的步骤!!!
		.dockerignore  生成自定义镜像 是从一个现成的镜像,配置和拷贝内容得到的
			这个文件中记录了 那些内容是不需要的,所以不用拷贝到自定义镜像里
		然后 cd 到 项目文件夹 里 操作: 
文件分析:
/////// docker-compose.yml /////////
version: '3'

services:			# 定义一个程序栈
  api: # Node.js App
    container_name: gs-api	# gs-api 容器
    build: .			# 需要使用重新生成的自定义镜像
    ports:			# 容器端口 映射到 宿主端口
      - "3000:3000" # Expose API port	
      - "9229:9229" # Expose Node process debug port (disable in production)
    environment: # Set ENV vars  设置环境变量
     - NODE_ENV=local
     - ES_HOST=elasticsearch
     - PORT=3000
    volumes: # Attach local book data directory 宿主机的指定文件夹 映射 容器的 /usr/src/app/books, 即数据存到宿主机
     - ./books:/usr/src/app/books

  frontend: # Nginx Server For Frontend App
    container_name: gs-frontend
    image: nginx			# 使用网络下载的现成镜像
    volumes: # Serve local "public" dir
      - ./public:/usr/share/nginx/html	# 宿主机的指定文件夹 映射 容器 这里是映射放 网页文件的地方!!!
    ports:				# 容器端口 映射到 宿主端口
      - "8080:80" # Forward site to localhost:8080

  elasticsearch: # Elasticsearch Instance
    container_name: gs-search
    image: docker.elastic.co/elasticsearch/elasticsearch:6.1.1
    volumes: # Persist ES data in seperate "esdata" volume
      - esdata:/usr/share/elasticsearch/data	#本来是 想宿主机的指定文件夹映射到容器, 即想在宿主机存放ES 的索引数据库,
    environment:
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - discovery.type=single-node
    ports: # Expose Elasticsearch ports
      - "9300:9300"
      - "9200:9200"

volumes: # Define seperate volume for Elasticsearch data
  esdata:			# 由于没有 指定定义 esdata, 所以 外部文档映射容器并没有实现
////////////////////////////////////

/////// Dockerfile /////////
# Use Node v8.9.0 LTS
FROM node:carbon		# 自定义镜像 基于网上下载的 node:carbon 镜像

# Setup app working directory
WORKDIR /usr/src/app		# 在自定义镜像上建立一个工作文档

# Copy package.json and package-lock.json
COPY package*.json ./		# 其实只把当前 项目目录 的 package.json,拷贝到 自定义镜像建立的工作文档

# Install app dependencies
RUN npm install			# 自定义镜像建立的工作文档里 执行npm 安装,即根据 package.json 安装 软件 
				# 由于安装过程中会检测到 所要安装软件的版本变化问题,所以npm会自生成 package-lock.json
				# package-lock.json 记录 npm 最终安装的软件 信息
# Copy sourcecode
COPY . .			# 把 项目目录 的所有内容 都 拷贝到 自定义镜像建立的工作文档 
				# 会去鉴别 .dockerignore 提供的黑名单,并不拷贝黑名单上的内容
				# 其实实际上,重点是拷贝了 server 文件夹 到 自定义镜像里

# Start app
CMD [ "npm", "start" ]		# 给自定义镜像 添加 开机执行的命令, 
				# 这里npm start 是指根据 package.json 配置 运行已经安装的软件!!!
////////////////////////////
	
////////// package.json /////////////
{
  "name": "guttenberg-search",
  "version": "0.0.1",
  "description": "Source code for Elasticsearch tutorial using 100 classic open source books.",
  "scripts": {
    "start": "node --inspect=0.0.0.0:9229 server/app.js"	# npm start 实际就是启动了这个node后端服务,不断监听连接 
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/triestpa/guttenberg-search.git"
  },
  "author": "patrick.triest@gmail.com",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/triestpa/guttenberg-search/issues"
  },
  "homepage": "https://github.com/triestpa/guttenberg-search#readme",
  "dependencies": {
    "elasticsearch": "13.3.1",
    "joi": "13.0.1",
    "koa": "2.4.1",
    "koa-joi-validate": "0.5.1",
    "koa-router": "7.2.1"
  }
}
/////////////////////////////////////

//////// .dockerignore /////////
node_modules/		# 这是避免拷贝任何 node_modules 名字的文件夹, 不限路径 
npm-debug.log		
books/
public/
////////////////////////////////
		到此为止, 基本分析完 一个docker-compose如何 构造 程序栈
		接下来, 继续完成整个整个程序栈
		添加 public/index.html 文件,并添加如下测试页面内容。
			<html><body>Hello World From The Frontend Container</body></html>
			注意, public 是以映射到 gs-frontend 容器的 !!
		添加 server/app.js 文件,并添加 Node.js 执行的 连接监听后端代码
			const Koa = require('koa')
			const app = new Koa()
			
			app.use(async (ctx, next) => {
			  ctx.body = 'Hello World From the Backend Container'
			})
			
			const port = process.env.PORT || 3000
			
			app.listen(port, err => {
			  if (err) console.error(err)
			  console.log(`App Listening on Port ${port}`)
			})
			注意, server 并不是映射的方式到 gs-api,而是通过构建自定义镜像时拷贝入镜像的 !!!
		然后开始 构建程序栈, sudo docker-compose build 
			其实就是扫一便相关文件 (docker-compose.yml Dockerfile .dockerignore) 
			如果发现需要自建键像,就自建镜像!!!
//////////////// 执行log ////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker-compose build

frontend uses an image, skipping
elasticsearch uses an image, skipping
Building api
Step 1/6 : FROM node:carbon
carbon: Pulling from library/node
741437d97401: Pull complete
34d8874714d7: Pull complete
0a108aa26679: Pull complete
7f0334c36886: Pull complete
65c95cb8b3be: Pull complete
a36b708560f8: Pull complete
81a7e69fab67: Pull complete
a88b577be604: Pull complete
Digest: sha256:a8a9d8eaab36bbd188612375a54fb7f57418458812dabd50769ddd3598bc24fc
Status: Downloaded newer image for node:carbon
 ---> 4f01e5319662
Step 2/6 : WORKDIR /usr/src/app
Removing intermediate container 304ae5a57d51
 ---> 85e1dc7a8b13
Step 3/6 : COPY package*.json ./
 ---> 94c248e69c79
Step 4/6 : RUN npm install
 ---> Running in 7a492633d063
npm WARN deprecated joi@10.6.0: This version is no longer maintained. Please upgrade to the latest version.
npm WARN deprecated hoek@5.0.4: This version is no longer maintained. Please upgrade to the latest version.
npm notice created a lockfile as package-lock.json. You should commit this file.
added 71 packages from 32 contributors and audited 93 packages in 15.887s
found 2 vulnerabilities (1 low, 1 moderate)
  run `npm audit fix` to fix them, or `npm audit` for details
Removing intermediate container 7a492633d063
 ---> c419ec45a179
Step 5/6 : COPY . .
 ---> 27d81e48e490
Step 6/6 : CMD [ "npm", "start" ]
 ---> Running in cc5522c616a7
Removing intermediate container cc5522c616a7
 ---> 1e3b367c4e6d
Successfully built 1e3b367c4e6d
Successfully tagged electicsearch_test_api:latest			
/////////////////////////////////////////////////
		然后执行 docker-compose up 去启动整个应用程序栈,
			也是根据相关文件 (docker-compose.yml Dockerfile .dockerignore)
			在这里才开始构建容器 和 启动容器!!!
//////////////// 执行log ////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker-compose up 
Creating network "electicsearch_test_default" with the default driver
Creating volume "electicsearch_test_esdata" with default driver
Pulling frontend (nginx:)...
latest: Pulling from library/nginx
6ae821421a7d: Pull complete
da4474e5966c: Pull complete
eb2aec2b9c9f: Pull complete
Pulling elasticsearch (docker.elastic.co/elasticsearch/elasticsearch:6.1.1)...
85432449fd0f: Pull complete
ed29febfeb5c: Pull complete
3a63b77751ff: Pull complete
c564c50fb69d: Pull complete
b1a7ef0a5528: Pull complete
9af7b1014a51: Pull complete
Creating gs-api      ... done
Creating gs-search   ... done
Creating gs-frontend ... done
Attaching to gs-frontend, gs-api, gs-search
gs-api           | 
gs-api           | > guttenberg-search@0.0.1 start /usr/src/app
gs-api           | > node --inspect=0.0.0.0:9229 server/app.js
gs-api           | 
gs-api           | Debugger listening on ws://0.0.0.0:9229/d8f7cfca-e9a8-46e4-b34a-da148c130373
gs-api           | For help see https://nodejs.org/en/docs/inspector
gs-api           | App Listening on Port 3000
gs-search        | [2019-02-19T09:51:59,796][WARN ][o.e.b.JNANatives         ] Unable to lock JVM Memory: error=12, reason=Cannot allocate memory
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] This can result in part of the JVM being swapped out.
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] Increase RLIMIT_MEMLOCK, soft limit: 65536, hard limit: 65536
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] These can be adjusted by modifying /etc/security/limits.conf, for example: 
gs-search        |      # allow user 'elasticsearch' mlockall
gs-search        |      elasticsearch soft memlock unlimited
gs-search        |      elasticsearch hard memlock unlimited
gs-search        | [2019-02-19T09:51:59,799][WARN ][o.e.b.JNANatives         ] If you are logged in interactively, you will have to re-login for the new limits to take effect.
gs-search        | [2019-02-19T09:51:59,933][INFO ][o.e.n.Node               ] [] initializing ...
gs-search        | [2019-02-19T09:52:00,076][INFO ][o.e.e.NodeEnvironment    ] [4TpwwJi] using [1] data paths, mounts [[/usr/share/elasticsearch/data (/dev/sda1)]], net usable_space [147.7gb], net total_space [428.2gb], types [ext4]
gs-search        | [2019-02-19T09:52:00,076][INFO ][o.e.e.NodeEnvironment    ] [4TpwwJi] heap size [494.9mb], compressed ordinary object pointers [true]
gs-search        | [2019-02-19T09:52:00,078][INFO ][o.e.n.Node               ] node name [4TpwwJi] derived from node ID [4TpwwJiLQ0Sw4BQGQX99aQ]; set [node.name] to override
gs-search        | [2019-02-19T09:52:00,079][INFO ][o.e.n.Node               ] version[6.1.1], pid[1], build[bd92e7f/2017-12-17T20:23:25.338Z], OS[Linux/4.15.0-45-generic/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_151/25.151-b12]
gs-search        | [2019-02-19T09:52:00,079][INFO ][o.e.n.Node               ] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -XX:+HeapDumpOnOutOfMemoryError, -Des.cgroups.hierarchy.override=/, -Xms512m, -Xmx512m, -Des.path.home=/usr/share/elasticsearch, -Des.path.conf=/usr/share/elasticsearch/config]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [aggs-matrix-stats]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [analysis-common]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [ingest-common]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-expression]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-mustache]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-painless]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [mapper-extras]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [parent-join]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [percolator]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [reindex]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [repository-url]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [transport-netty4]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [tribe]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [ingest-geoip]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [ingest-user-agent]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [x-pack]
gs-search        | [2019-02-19T09:52:04,149][INFO ][o.e.x.m.j.p.l.CppLogMessageHandler] [controller/120] [Main.cc@128] controller (64 bit): Version 6.1.1 (Build c508cf991ee61c) Copyright (c) 2017 Elasticsearch BV
gs-search        | [2019-02-19T09:52:04,524][INFO ][o.e.d.DiscoveryModule    ] [4TpwwJi] using discovery type [single-node]
gs-search        | [2019-02-19T09:52:05,113][INFO ][o.e.n.Node               ] initialized
gs-search        | [2019-02-19T09:52:05,113][INFO ][o.e.n.Node               ] [4TpwwJi] starting ...
gs-search        | [2019-02-19T09:52:05,237][INFO ][o.e.t.TransportService   ] [4TpwwJi] publish_address {172.18.0.4:9300}, bound_addresses {0.0.0.0:9300}
gs-search        | [2019-02-19T09:52:05,256][WARN ][o.e.b.BootstrapChecks    ] [4TpwwJi] memory locking requested for elasticsearch process but memory is not locked
gs-search        | [2019-02-19T09:52:05,256][WARN ][o.e.b.BootstrapChecks    ] [4TpwwJi] max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
gs-search        | [2019-02-19T09:52:05,349][INFO ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [4TpwwJi] publish_address {172.18.0.4:9200}, bound_addresses {0.0.0.0:9200}
gs-search        | [2019-02-19T09:52:05,349][INFO ][o.e.n.Node               ] [4TpwwJi] started
gs-search        | [2019-02-19T09:52:05,475][INFO ][o.e.g.GatewayService     ] [4TpwwJi] recovered [0] indices into cluster_state
gs-search        | [2019-02-19T09:52:06,281][INFO ][o.e.l.LicenseService     ] [4TpwwJi] license [0c6db8a3-2495-4956-ae4f-645d4b64eaa9] mode [basic] - valid
gs-search        | [2019-02-19T09:52:15,253][INFO ][o.e.c.m.MetaDataCreateIndexService] [4TpwwJi] [.monitoring-es-6-2019.02.19] creating index, cause [auto(bulk api)], templates [.monitoring-es], shards [1]/[1], mappings [doc]
gs-frontend      | 172.18.0.1 - - [19/Feb/2019:09:53:08 +0000] "GET / HTTP/1.1" 200 66 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0" "-"
gs-frontend      | 172.18.0.1 - - [19/Feb/2019:09:53:08 +0000] "GET /favicon.ico HTTP/1.1" 404 153 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0" "-"
gs-frontend      | 2019/02/19 09:53:08 [error] 7#7: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.18.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "localhost:8080"
/////////////////////////////////////////////////
		宿主机浏览器 登录 localhost:8080  localhost:3000  localhost:9200 
		分别 访问了 gs-frontend, gs-api, gs-search, 三个节点,都可以成功看到相关内容!!!
		最后,我们可以 登录 gs-api 容器 查看 /usr/src/app 的内容来 分析根据 Dockerfile 建立镜像的情况

	接下来就是在这个 程序栈,实验 electicsearch
		我们的实验是建立一个电子书信息内容搜索服务!!!
		首先是建立电子书数据( 有100本明著,来自古登堡项目 ),在项目目录下执行
			wget https://cdn.patricktriest.com/data/books.zip
			unar books.zip
		得到 books/文件夹 而这个文件夹及其内容根据程序栈设置,会映射到 gs-api 的/usr/src/app/books
		书本都有统一的格式,可供机器分析: 
		假设打开的是 219-0.txt,
		你将注意到它开头是一个公开访问的协议，接下来是一些标识这本书的书名、作者、发行日期、语言和字符编码的行。
			Title: Heart of Darkness

			Author: Joseph Conrad
			
			Release Date: February 1995 [EBook #219]
			Last Updated: September 7, 2016
			
			Language: English
			
			Character set encoding: UTF-8
		在 *** START OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 后，
		在 *** END OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 前,是这本书的正式内容。
		而 *** END OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 后,是这本书更详细的协议版本。
		然后,测试 后端服务器 访问 search 服务器的情况!!!
			添加 server/connection.js 文件,添加内容:
////////////////
const elasticsearch = require('elasticsearch')		//自建镜像添加了ES的 js 的接口,所以可以被node.js使用

// Core ES variables for this project
const index = 'library'
const type = 'novel'
const port = 9200
const host = process.env.ES_HOST || 'localhost'
const client = new elasticsearch.Client({ host: { host, port } })	//建立一个到 gs-search 的连接

/** Check the ES connection status */
async function checkConnection () {
  let isConnected = false
  while (!isConnected) {
    console.log('Connecting to ES')
    try {
      const health = await client.cluster.health({})
      console.log(health)
      isConnected = true
    } catch (err) {
      console.log('Connection Failed, Retrying...', err)
    }
  }
}
////////////////
			由于 server 内容改变了, 需要重建镜像!! sudo docker-compose build 
			重建重开容器,这次选择后台执行程序栈 docker-compose up -d
			程序栈起来后执行: sudo docker exec gs-api "node" "server/connection.js" 会有以下信息
				{ cluster_name: 'docker-cluster',
				  status: 'yellow',
				  timed_out: false,
				  number_of_nodes: 1,
				  number_of_data_nodes: 1,
				  active_primary_shards: 1,
				  active_shards: 1,
				  relocating_shards: 0,
				  initializing_shards: 0,
				  unassigned_shards: 1,
				  delayed_unassigned_shards: 0,
				  number_of_pending_tasks: 0,
				  number_of_in_flight_fetch: 0,
				  task_max_waiting_in_queue_millis: 0,
				  active_shards_percent_as_number: 50 }
				表示 gs-api 连接 gs-search 成功 !!!
			(注意,重建镜像后,之前的旧自建镜像会保留,所以需要手动去清理,
			为了避免麻烦为啥 不把 server 作为映射目录到 镜像? 
			是为了执行安全,因为,node正在执行server的监听js,而你又在此刻更新js, node执行会出错吧)
		server/connection.js 是 gs-api 连接 gs-search 的 接口, 接下来完善这个接口js文件
///////////// server/connection.js /////////////////
const elasticsearch = require('elasticsearch')		//使用 ES 的 javascript api接口

// Core ES variables for this project
const index = 'library'
const type = 'novel'
const port = 9200
const host = process.env.ES_HOST || 'localhost'
const client = new elasticsearch.Client({ host: { host, port } })	//建立一个到 gs-search 的连接

/** Check the ES connection status */
async function checkConnection () {
  let isConnected = false
  while (!isConnected) {
    console.log('Connecting to ES')
    try {
      const health = await client.cluster.health({})	//查看集群的 运行情况
      console.log(health)
      isConnected = true
    } catch (err) {
      console.log('Connection Failed, Retrying...', err)
    }
  }
}

/** Clear the index, recreate it, and add mappings */
async function resetIndex (index) {			//重置 索引
  if (await client.indices.exists({ index })) {			
    await client.indices.delete({ index })	
  }

  await client.indices.create({ index })	//创建一个索引
  await putBookMapping()			//为索引定义一个映射, 相当于给sql数据库定义一个table
}

/** Add book section schema mapping to ES */	
async function putBookMapping () {		//为 索引定义了一个映射。
  const schema = {
    title: { type: 'keyword' },
    author: { type: 'keyword' },
    location: { type: 'integer' },
    text: { type: 'text' }
  }

  return client.indices.putMapping({ index, type, body: { properties: schema } })
}


module.exports = {
  client, index, type, checkConnection, resetIndex	//导出对外发布的属性和函数，这样其它模块就可以访问
}

//checkConnection()
////////////////////////////////////////////////////
		接下来是读取图书的数据, 生成用于能被 ES 实际执行搜索的合法文档,放入 electiicearch 服务器的索引里,
			添加 server/load_data.js 文件
///////////////// server/load_data.js //////////////
const fs = require('fs')
const path = require('path')
const esConnection = require('./connection')		//引用刚刚写的 connection 接口

/** Clear ES index, parse and index all files from the books directory */
async function readAndInsertBooks () {
  try {
    // Clear previous ES index				//重置索引
    await esConnection.resetIndex(esConnection.index)	//原教程出现的bug, 必须加上 esConnection.index
							//如果重置索引失败,会引起后续的众多问题!!!
  } catch (err) {
    console.error(err)
  }

  try {							//读取 电子书数据, 建立 ES 映射文件
    // Read books directory
    let files = fs.readdirSync('./books').filter(file => file.slice(-4) === '.txt')
    console.log(`Found ${files.length} Files`)

    // Read each book file, and index each paragraph in elasticsearch
    for (let file of files) {
      console.log(`Reading File - ${file}`)
      const filePath = path.join('./books', file)
      const { title, author, paragraphs } = parseBookFile(filePath)	//分析 一本电子数内容 并分割段落建立映射内容
      await insertBookData(title, author, paragraphs)			//递交内容到 ES 索引 形成映射文件
    }
  } catch (err) {
    console.error(err)
  }
}


/** Read an individual book text file, and extract the title, author, and paragraphs */
function parseBookFile (filePath) {
  // Read text file
  const book = fs.readFileSync(filePath, 'utf8')		//从文件系统中读取书的文本

  // Find book title and author					//使用正则表达式 解析书名,作者
  const title = book.match(/^Title:\s(.+)$/m)[1]		
  const authorMatch = book.match(/^Author:\s(.+)$/m)
  const author = (!authorMatch || authorMatch[1].trim() === '') ? 'Unknown Author' : authorMatch[1]

  console.log(`Reading Book - ${title} By ${author}`)

  // Find Guttenberg metadata header and footer		//通过匹配 “古登堡项目” 的头部和尾部，识别书的正文内容。
  const startOfBookMatch = book.match(/^\*{3}\s*START OF (THIS|THE) PROJECT GUTENBERG EBOOK.+\*{3}$/m)
  const startOfBookIndex = startOfBookMatch.index + startOfBookMatch[0].length
  const endOfBookIndex = book.match(/^\*{3}\s*END OF (THIS|THE) PROJECT GUTENBERG EBOOK.+\*{3}$/m).index

  // Clean book text and split into array of paragraphs	//提取书的内容文本,分割每个段落到它的数组中,清理文本并删除空白行
  const paragraphs = book
    .slice(startOfBookIndex, endOfBookIndex) // Remove Guttenberg header and footer
    .split(/\n\s+\n/g) // Split each paragraph into it's own array entry
    .map(line => line.replace(/\r\n/g, ' ').trim()) // Remove paragraph line breaks and whitespace
    .map(line => line.replace(/_/g, '')) // Guttenberg uses "_" to signify italics.  We'll remove it, since it makes the raw text look messy.
    .filter((line) => (line && line.length !== '')) // Remove empty lines

  console.log(`Parsed ${paragraphs.length} Paragraphs\n`)
  return { title, author, paragraphs }	//返回构建的对象，这个对象包含书名、作者、以及书中各段落的数组 paragraphs
}


//这个函数将使用书名、作者和附加元数据的段落位置来索引书中的每个段落。我们通过批量操作来插入段落，它比逐个段落插入要快的多。
/** Bulk index the book data in Elasticsearch */
async function insertBookData (title, author, paragraphs) {
  let bulkOps = [] // Array to store bulk operations

  // Add an index operation for each section in the book
  for (let i = 0; i < paragraphs.length; i++) {
    // Describe action
    bulkOps.push({ index: { _index: esConnection.index, _type: esConnection.type } })

    // Add document
    bulkOps.push({
      author,
      title,
      location: i,
      text: paragraphs[i]
    })

    if (i > 0 && i % 500 === 0) { // Do bulk insert in 500 paragraph batches
      await esConnection.client.bulk({ body: bulkOps })
      bulkOps = []
      console.log(`Indexed Paragraphs ${i - 499} - ${i}`)
    }
  }

  // Insert remainder of bulk ops array
  await esConnection.client.bulk({ body: bulkOps })
  console.log(`Indexed Paragraphs ${paragraphs.length - (bulkOps.length / 2)} - ${paragraphs.length}\n\n\n`)
}

readAndInsertBooks()
////////////////////////////////////////////////////	
			然后 重建重启程序栈,快捷命令: sudo docker-compose up -d --build
				相当于sudo docker-compose build  加 sudo docker-compose up -d 
				(注意 手动删除多余的旧镜像)
				docker-compose logs -f api   //从 Node 应用程序中查看实时日志
			然后执行 sudo docker exec gs-api "node" "server/load_data.js"
				gs-api 读取电子书数据文件并生成映射内容 上传到 gs-search 的 book 索引
////////////////////// 部分执行log ///////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker exec gs-api "node" "server/load_data.js"
Found 100 Files
Reading File - 10.txt
Reading Book - The King James Bible By Unknown Author
Parsed 24609 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 1000
Indexed Paragraphs 1001 - 1500
Indexed Paragraphs 1501 - 2000
Indexed Paragraphs 2001 - 2500
.........



Reading File - 10007.txt
Reading Book - Carmilla By J. Sheridan LeFanu
Parsed 681 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 681



Reading File - 103.txt
Reading Book - Around the World in 80 Days By Jules Verne
Parsed 1720 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 1000
Indexed Paragraphs 1001 - 1500
Indexed Paragraphs 1501 - 1720



Reading File - 1080.txt
Reading Book - A Modest Proposal By Jonathan Swift
Parsed 39 Paragraphs

Indexed Paragraphs 0 - 39



Reading File - 11-0.txt
Reading Book - Alice’s Adventures in Wonderland By Lewis Carroll
Parsed 820 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 820

...........

/////////////////////////////////////////////////////////////
		然后,我们就可以执行搜索了测试了
		浏览器执行:
			http://localhost:9200/library/_search?q=text:Java&pretty
			这是直接访问 gs-search 节点执行的极其简单的 搜索操作.
			浏览器会看到一堆json内容返回.
			而且只是从 ES 索引中找到合适的 映射文件
			然后返回映射文件 而已!!! 不是真正意义上的搜索功能!!
		真实的搜索的一种常规场景应该是这样子的!!!
			后端服务器,对数据库 执行的分析 生成映射文件 存入  ES服务器
			映射文件包含了 数据片段外,还包含了真是数据的位置信息 !!!!
			
			[client] <---> [gs-frontend] <----> [gs-api]
			                                        ^ 
								|
                                                                v
			                                   [gs-search]
			client只能访问 前端服务器即web应用服务器, 搜索请求由 前端传递到后端,后端传递到ES服务器
			ES 返回,合适的 映射文件内容.给后端,后端再返回 前端
			client看到许多结果,其实 都是 ES 的映射文件而已,当 client点击其中一个 结果
			就是 请求打开 这个映射文件的指向的数据真实位置, 请求从client传到前端传到后端,
			后端把 指定位置的数据库信息 读出 返回前端再返回client
			当然也有直接 从 前端 直接访问 ES 获取搜索的 映射文件,(可能安全性会差些吧)
		接下来我们的实验是.
			client 搜索请求,经 前端,后端到 ES
			结果映射文件经 ES, 后端, 前端, 到 client 
			client 点击一个结果, 依然是 经 前端,后端到 ES
			ES收集这个结果对应的映射文件附近的映射文件,经 ES, 后端, 前端, 到 client
			与一般场景有所区别,是因为仅仅这个例子映射文本就记录了全部所需要的信息,
			不需要通过映射文本寻找读取后端的 电子书数据!!
	开始 ES 实验:
		gs-api 容易 添加 使用 ES 搜索的功能模块
///////////// server/search.js //////////////
const { client, index, type } = require('./connection')		//使用 server/connection.js 接口

module.exports = {
  /** Query ES index for the provided term */
  queryTerm (term, offset = 0) {	//搜索 关键字 得到 结果
    const body = {
      from: offset,		//from - 允许我们分页查询结果。默认每个查询返回 10 个结果，from: 10 将允许我们取回 10-20 的结果。
      query: { match: {		
        text: {		
          query: term,		//query - 这里我们指定要查询的词。
          operator: 'and',	//operator - 搜索行为；本例中，我们使用 and 操作去对查询中包含所有字元（要查询的词）的结果来确定优先顺序。
          fuzziness: 'auto'	//fuzziness - 对拼写错误的容错调整，auto 的默认为 fuzziness: 2。模糊值越高，结果越需要更多校正。
        } } },
      highlight: { fields: { text: {} } }	//highlights - 结果返回一个额外的字段包含 HTML，以显示精确的文本字集和查询中匹配的关键词。
    }

    return client.search({ index, type, body })		
  },		// 一定要添加 , 号

  /** Get the specified range of paragraphs from a book */
  getParagraphs (bookTitle, startLocation, endLocation) {	//根据当前选择的搜索结果(映射文件),获得其前后各5片映射文件
    const filter = [						//目的是后面取其段落文本片段组成 结果文章 显示!! 
      { term: { title: bookTitle } },
      { range: { location: { gte: startLocation, lte: endLocation } } }
    ]

    const body = {
      size: endLocation - startLocation,
      sort: { location: 'asc' },
      query: { bool: { filter } }
    }

    return client.search({ index, type, body })
  }

}
/////////////////////////////////////////////		
		更新 server/app.js 内容, 使 gs-api 成为一个简单完整的后端服务器
		这些代码将为 Koa.js Node API 服务器导入服务器依赖，设置简单的日志，以及错误处理。 
////////////////////// server/app.js ///////////////////////

const Koa = require('koa')
const Router = require('koa-router')
const joi = require('joi')
const validate = require('koa-joi-validate')
const search = require('./search')

const app = new Koa()
const router = new Router()

// Log each request to the console
app.use(async (ctx, next) => {
  const start = Date.now()
  await next()
  const ms = Date.now() - start
  console.log('${ctx.method} ${ctx.url} - ${ms}')
})

// Log percolated errors to the console
app.on('error', err => {
  console.error('Server Error', err)
})

// Set permissive CORS header
app.use(async (ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', '*')
  return next()
})

// ADD ENDPOINTS HERE
/**
 * GET /search
 * Search for a term in the library
 * Query Params -
 * term: string under 60 characters
 * offset: positive integer
 */				
router.get('/search',			//根据 前端 获得/search请求, 后端向es获取搜索数据
  validate({				//http://localhost:3000/search,,, 就是执行到后端服务器的这个地方 获取搜索功能
    query: {
      term: joi.string().max(60).required(),		//添加一些使用 Joi 和 Koa-Joi-Validate 库的中间件，以对输入做校验
      offset: joi.number().integer().min(0).default(0)
    }
  }),
  async (ctx, next) => {
    const { term, offset } = ctx.request.query
    ctx.body = await search.queryTerm(term, offset)	//后端向es获取搜索数据
  }
)
/**
 * GET /paragraphs
 * Get a range of paragraphs from the specified book
 * Query Params -
 * bookTitle: string under 256 characters
 * start: positive integer
 * end: positive integer greater than start
 */
router.get('/paragraphs',	//根据 前端 获得 /paragraphs请求, 后端向es获取结果附近的文本段落
  validate({
    query: {
      bookTitle: joi.string().max(256).required(),	//添加一些使用 Joi 和 Koa-Joi-Validate 库的中间件，以对输入做校验
      start: joi.number().integer().min(0).default(0),
      end: joi.number().integer().greater(joi.ref('start')).default(10)
    }
  }),
  async (ctx, next) => {
    const { bookTitle, start, end } = ctx.request.query
    ctx.body = await search.getParagraphs(bookTitle, start, end)	//后端向es获取结果附近的文本段落

  }
)

const port = process.env.PORT || 3000

app					//建立监听程序
  .use(router.routes())
  .use(router.allowedMethods())
  .listen(port, err => {
    if (err) throw err
    console.log('App Listening on Port ${port}')
  })
////////////////////////////////////////////////////////////
		接着 我们给前端服务 添加 web 应用 ,允许其与 客户端交互
		添加 /public/app.js
		这是 一个 基于 vue 的简单 js 程序!!
		只定义了一些共享的数据属性，以及添加了检索和分页搜索结果的方法。
		为防止每次按键一次都调用 API，搜索输入有一个 100 毫秒的除颤功能 
/////////////////// /public/app.js /////////////////////
const vm = new Vue ({
  el: '#vue-instance',
  data () {
    return {
      baseUrl: 'http://localhost:3000', // API url  后端gs-api 访问接口
      searchTerm: 'Hello World', // Default search term
      searchDebounce: null, // Timeout for search bar debounce
      searchResults: [], // Displayed search results
      numHits: null, // Total search results found
      searchOffset: 0, // Search result pagination offset

      selectedParagraph: null, // Selected paragraph object
      bookOffset: 0, // Offset for book paragraphs being displayed
      paragraphs: [] // Paragraphs being displayed in book preview window
    }
  },
  async created () {
    this.searchResults = await this.search() // Search for default term
  },
  methods: {
    /** Debounce search input by 100 ms */
    onSearchInput () {
      clearTimeout(this.searchDebounce)
      this.searchDebounce = setTimeout(async () => {
        this.searchOffset = 0
        this.searchResults = await this.search()
      }, 100)
    },
    /** Call API to search for inputted term */
    async search () {				// 搜索请求
      const response = await axios.get(`${this.baseUrl}/search`, { params: { term: this.searchTerm, offset: this.searchOffset } })
      this.numHits = response.data.hits.total	//
      return response.data.hits.hits
    },
    /** Get next page of search results */
    async nextResultsPage () {
      if (this.numHits > 10) {
        this.searchOffset += 10
        if (this.searchOffset + 10 > this.numHits) { this.searchOffset = this.numHits - 10}
        this.searchResults = await this.search()
        document.documentElement.scrollTop = 0
      }
    },
    /** Get previous page of search results */
    async prevResultsPage () {
      this.searchOffset -= 10
      if (this.searchOffset < 0) { this.searchOffset = 0 }
      this.searchResults = await this.search()
      document.documentElement.scrollTop = 0
    },

    /** Call the API to get current page of paragraphs */
    async getParagraphs (bookTitle, offset) {	// 获取结果所在文章
      try {
        this.bookOffset = offset
        const start = this.bookOffset
        const end = this.bookOffset + 10
        const response = await axios.get(`${this.baseUrl}/paragraphs`, { params: { bookTitle, start, end } })
        console.log(response.data)
        return response.data.hits.hits
      } catch (err) {
        console.error(err)
      }
    },
    /** Get next page (next 10 paragraphs) of selected book */
    async nextBookPage () {
      this.$refs.bookModal.scrollTop = 0
      this.paragraphs = await this.getParagraphs(this.selectedParagraph._source.title, this.bookOffset + 10)
    },
    /** Get previous page (previous 10 paragraphs) of selected book */
    async prevBookPage () {
      this.$refs.bookModal.scrollTop = 0
      this.paragraphs = await this.getParagraphs(this.selectedParagraph._source.title, this.bookOffset - 10)
    },
    /** Display paragraphs from selected book in modal window */
    async showBookModal (searchHit) {		//显示结果文本, 这里会经历一个 获取 围绕结果上下文段落的 get过程
      try {
        document.body.style.overflow = 'hidden'
        this.selectedParagraph = searchHit
        this.paragraphs = await this.getParagraphs(searchHit._source.title, searchHit._source.location - 5)
        console.log(searchHit._source.title, ' ', searchHit._source.location)
      } catch (err) {
        console.error(err)
      }
    },
    /** Close the book detail modal */
    closeBookModal () {
      //console.log('wiliam/n/r')
      document.body.style.overflow = 'auto'
      this.selectedParagraph = null
    }
  }
})
////////////////////////////////////////////////////////
		完善前端 web应用的 页面样板
		还有 css ui 样式
/////////////////// /public/index.html /////////////////
<!--
<html><body>Hello World From The Frontend Container</body></html>
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Elastic Library</title>
  <meta name="description" content="Literary Classic Search Engine.">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" rel="stylesheet" type="text/css" />
  <link href="https://cdn.muicss.com/mui-0.9.20/css/mui.min.css" rel="stylesheet" type="text/css" />
  <link href="https://fonts.googleapis.com/css?family=EB+Garamond:400,700|Open+Sans" rel="stylesheet">
  <link href="styles.css" rel="stylesheet" />
</head>
<body>
<div class="app-container" id="vue-instance">
    <!-- Search Bar Header -->
    <div class="mui-panel">
      <div class="mui-textfield">
        <input v-model="searchTerm" type="text" v-on:keyup="onSearchInput()">
        <label>Search</label>
      </div>
    </div>

    <!-- Search Metadata Card -->
    <div class="mui-panel">
      <div class="mui--text-headline">{{ numHits }} Hits</div>
      <div class="mui--text-subhead">Displaying Results {{ searchOffset }} - {{ searchOffset + 9 }}</div>
    </div>

    <!-- Top Pagination Card -->
    <div class="mui-panel pagination-panel">
        <button class="mui-btn mui-btn--flat" v-on:click="prevResultsPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextResultsPage()">Next Page</button>
    </div>

    <!-- Search Results Card List -->
    <div class="search-results" ref="searchResults">
      <div class="mui-panel" v-for="hit in searchResults" v-on:click="showBookModal(hit)">
        <div class="mui--text-title" v-html="hit.highlight.text[0]"></div>
        <div class="mui-divider"></div>
        <div class="mui--text-subhead">{{ hit._source.title }} - {{ hit._source.author }}</div>
        <div class="mui--text-body2">Location {{ hit._source.location }}</div>
      </div>
    </div>

    <!-- Bottom Pagination Card -->
    <div class="mui-panel pagination-panel">
        <button class="mui-btn mui-btn--flat" v-on:click="prevResultsPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextResultsPage()">Next Page</button>
    </div>

    <!-- INSERT BOOK MODAL HERE -->
    <!-- Book Paragraphs Modal Window -->
    <div v-if="selectedParagraph" ref="bookModal" class="book-modal">
      <div class="paragraphs-container">
        <!-- Book Section Metadata -->
        <div class="title-row">
          <div class="mui--text-display2 all-caps">{{ selectedParagraph._source.title }}</div>
          <div class="mui--text-display1">{{ selectedParagraph._source.author }}</div>
        </div>
        <br>
        <div class="mui-divider"></div>
        <div class="mui--text-subhead locations-label">Locations {{ bookOffset - 5 }} to {{ bookOffset + 5 }}</div>
        <div class="mui-divider"></div>
        <br>

        <!-- Book Paragraphs -->
        <div v-for="paragraph in paragraphs">	//这里显然轮选显示 paragraphs段落数组的 每个段落 paragraph
          <div v-if="paragraph._source.location === selectedParagraph._source.location" class="mui--text-body2">
            <strong>{{ paragraph._source.text }}</strong>
          </div>
          <div v-else class="mui--text-body1">
            {{ paragraph._source.text }}	
          </div>
          <br>
        </div>
      </div>

      <!-- Book Pagination Footer -->
      <div class="modal-footer">
        <button class="mui-btn mui-btn--flat" v-on:click="prevBookPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="closeBookModal()">Close</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextBookPage()">Next Page</button>
      </div>
    </div>


</div>
<script src="https://cdn.muicss.com/mui-0.9.28/js/mui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.3/vue.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.17.0/axios.min.js"></script>
<script src="app.js"></script>
</body>
</html>
////////////////////////////////////////////////////////
////////////////// public/styles.css//////////////////
body { font-family: 'EB Garamond', serif; }

.mui-textfield > input, .mui-btn, .mui--text-subhead, .mui-panel > .mui--text-headline {
  font-family: 'Open Sans', sans-serif;
}

.all-caps { text-transform: uppercase; }
.app-container { padding: 16px; }
.search-results em { font-weight: bold; }
.book-modal > button { width: 100%; }
.search-results .mui-divider { margin: 14px 0; }

.search-results {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
}

.search-results > div {
  flex-basis: 45%;
  box-sizing: border-box;
  cursor: pointer;
}

@media (max-width: 600px) {
  .search-results > div { flex-basis: 100%; }
}

.paragraphs-container {
  max-width: 800px;
  margin: 0 auto;
  margin-bottom: 48px;
}

.paragraphs-container .mui--text-body1, .paragraphs-container .mui--text-body2 {
  font-size: 1.8rem;
  line-height: 35px;
}

.book-modal {
  width: 100%;
  height: 100%;
  padding: 40px 10%;
  box-sizing: border-box;
  margin: 0 auto;
  background-color: white;
  overflow-y: scroll;
  position: fixed;
  top: 0;
  left: 0;
}

.pagination-panel {
  display: flex;
  justify-content: space-between;
}

.title-row {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

@media (max-width: 600px) {
  .title-row{ 
    flex-direction: column; 
    text-align: center;
    align-items: center
  }
}

.locations-label {
  text-align: center;
  margin: 8px;
}

.modal-footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: space-around;
  background: white;
}
//////////////////////////////////////////////////////
		最后 重建重启程序栈: sudo docker-compose up -d --build     (注意 手动删除多余的旧镜像)
		登录 http://localhost:8080/ 就可以体验到效果!!!!
	最后在项目文件夹里:
		sudo docker-compose stop	//停止整个 service ,就是关闭容器!
		sudo docker-compose up -d	//重新开启整个 service	 或者 sudo docker-compose stop

	
	参考:
		Docker 和 Elasticsearch 构建一个全文搜索应用程序 (上述例子参考尝试了):
			教程相当有启发性,还开拓的不小其他技能点!!!!,当然也有几个漏洞
			https://www.zcfy.cc/article/building-a-full-text-search-app-using-docker-and-elasticsearch
		docker简易搭建ElasticSearch集群: (未尝试集群)
			https://blog.csdn.net/belonghuang157405/article/details/83301937
	首先想学习到如何 实现 一个 docker 程序栈:
		即通过把需要使用的资源整合,然后通过脚本,自动创建运行容器集群,提供特定的服务!!
		一般我们模拟搭建一个网站会 使用多个docker容器来模拟多个服务器,然后集群生成服务!!
		一般手动过程繁琐复杂,但是通过 docker-compose 插件, 可以把手动过程简单集成到脚本文本,
		通过运行脚本即可 一键实现!
	










20190220
今天就补全 hadoop spark: 
	zookeeper Hbase Hive Sqoop 需要拓展的内容
	参考: 
		http://dblab.xmu.edu.cn/blog/1709-2/ 	//理论
		https://www.jianshu.com/p/4801bb7ab9e0			//集群参考
		https://github.com/big-data-europe/docker-spark		//集群参考
		https://dxysun.com/2018/04/16/centosForSpark/		//有用 不过只有两台机...集群参考!!







		


?????????????????????????????????????
工作小结:
	写出了html范本,基本构建富文本内容方式(未完善),(test1.html, base.js, body.css)
	第一版,纯文本 test1.js 搭配 test1.html 这句
<body>
	<div Id="editor" contenteditable="true" onKeypress="ifenter(event)" onKeydown="ifdown(event)" onKeyUp="ifup(event)"><div>1:</div></div>
</body>
	第二版,加入媒体行!!
	后来发现超过1000行,处理速度就开始卡了, 先尝试优化,不行的话,就使用框选编译方式,
	开始设计数据库和表单!!!
		发现还要添加的内容:
		spac 禁止中文输入问题!!
		关于上传文件的规范,要筛选处理,涉及安全,不能什么文件都能传
	第三版,(未开始)
	所谓框选:
			--------------
			.            .
			.            .
			|            |
			|            |
			|            |
		      ------------------
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      ------------------
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			.            .
			.            .
			--------------


设计:
1,每行都有行号,行号前有标记色 
	每一行前的标记色,新建, 修改, 换行! 无操作, 某行内容既换行,又修改时,设为修改色 
	行号标记色点击可以选择该行的编辑内容,即行内容变换填充!!
	前端显示: cnteid 和 oid 的分配就是不用在前端做了,放到后端 !!
	orgl : transparency cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	newl : yellow cnteid:0, oid:0
	svdl : green cnteid:0(空行)/cnteid:xx(非空行), oid:yy  (>=0)
	wrpl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	fixl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
2,回车, 退格键,方向键, 粘贴组合键, tab键, 方向左键, 还有鼠标点击  
	回车要自动添加新行号,转行,回车后字符串处理, 修改标记色和id,
		注意多媒体行无法使用回车, 相邻多媒体行中间插入行操作放入cntebar里
	tab按键:当在一个div里只有文字才能完美实现距离问题,和缩进!!
	退格键:不能退到行号处!!
	方向键, 上下左右都要处理!!(只能捕捉并跳到 edtx 区!!,禁止出现在其他区域!!)
3,公式编写,使用的一个开源库: JMEditor: http://www.html580.com/11952
4,五线谱
	使用 vextab 掌握 多段谱,而不是一段谱

??,显示尺寸问题!!缩放网页时,
	公式 直接设置 style="font-size:80px;"
	五线谱:  artist = new Artist(10, 10, 1000, {scale: 0.8});
		10 和 10 都是位置偏移
		1000是长度
		{scale: 0.8} 是 高度 0 ~ 无穷

?? 多媒体行的间隔问题处理, spec 除了只允许输入空格,允许左右方向键 和上下方向按键 但是中文输入法可以突破输入的问题(未解决)
	
??,定时 触发事件!!! 还有流文件上传事件!! 浮动按钮 ,	

??,输入日期格式 例如 20180819 ,自动成为标题数据.可以手动改回文本数据

??,批量 定位 增删内容
	保守加载的内容有10万行内容,浏览器压力会非常大,所以,应该提供批量功能
	另外,提供右下角统计数据 滑动鼠标时显示已经加载的 行数据数 起始行-结束行:一共行数
??,页面
	用户主页是编辑页面
	搜索主页可调,一般是详细博客或者关键字博客嵌套页面
	关注人页面是,详细博客嵌套页面
	其他页面!!(科研小说教育..)
	主题发展
3,行号数据表 与 数据实体数据表
	具体 数据条放在独立的数据表里, 每条数据条都有独立的序号 conteid
	行号 放在独立的数据表里, 行号数据保存 对应的conteid 指向具体数据
	流媒体数据 放在另外独立的数据表里. 提供url访问 当
		流媒体数据先上传到数据库,生成链接供行号指向,没有行号指向的流媒体文件,一个月后会被物理清除,不可修复!! 
	数据条类型:
		空数据(特殊的文本数据 cntety:1), cnteid 指定为0 (其他每行用户数据各占一个独立的cnteid)
		另外前 256 个 cnteid 保留 为各种衍生功能标记做预留,例如识别代码段实时调试
		文本数据, cntety:1 
		图片数据, cntety:2 可以多个 ( 图片url + 图片加密编码字符串 + 缩略图 + 间隔数) 多个之间可以添加空格手动控制间隔
		数学公式, cntety:3 可以多个 ( 文本数据 + 间隔数 )  多个之间可以添加空格手动控制间隔 
		音频数据, cntety:4 单个 (音频url + 音频加密编码字符串 + 音频片段/降码音频)
		视频数据, cntety:5 单个 (视频url + 视频加密编码字符串 + 视频裁剪缩略采样)
		五线谱,   cntety:6 其实是纯文本,就是 vextab 语言纯文本
	 	主题,     cntety:7 数据(推荐时间日期 + 简单标题 + 收藏数/注水数 间隔数 )
			前端显示 推荐时间日期 + 间隔 + 简单标题 + 收藏数/注水数星号(收藏数/注水数) + 扩展按钮
		(扩展文本数据,可以标记超链接和 v2.0再考虑如何改,)
	mmedl:生成数据行
		如果该行为 newl, 则 更改时  cnteid 不改
		如果 其他xxxl 行数据变其他类型数据时 cnteid 设新id
		这种修改机制会 很容易 浪费许多孤立cnteid 即么中间的一些cnteid没有内容,没有行号指向
		所以(后期要做一个回收表!!) 
??,时间信任保存
	所有流媒体内容 经过sha加密  行数据内容是 缩略图/音频片段 + 链接 + 256位加密码,
		其中   缩略图/音频片段 + 256位加密码, 计入保存时间加密, 链接不计入!!
	文本类内容(包括五线谱编码) 经过sha加密  行数据内容就是 文本内容!! 直接计入保存时间加密,
	每行内容都有最后的修改日期!! 不过这条信息只有作者可看,运营方可看.
	依照政策删除敏感内容后造成 保存链断裂 导致的 发布事件时间信任度问题
	五线谱内容可以显示每次更新的内容!!状态!!
	先不考虑完美的 保存链算法, 先简单实现产品,所以重点先在于确定哪些内容才是需要写进数据库的内容!!!!
??,收藏推广
	可以关注别人,不设立粉丝
	星号是 实名收藏为收藏数, 匿名收藏为注水数,注水数每季度清零一清,
	用户实名收藏记录永久, 匿名收藏记录 半年一清
??,举报 与 依照政策删除敏感内容
	初步通知 出版者 让其主动修改或删除或不作为
	若鉴别为真犯规,
		方案一,要求主动删除,替换内容,不然,强制注销账户
		方案二,运营方直接删除
		这些删除涉及真正的物理删除, 会造成其他用户的时间信任保存链断裂
		所以运营方应该设计并仅运营方拥有的一个特殊的亢余数据库来修补 其他用户的时间信任保存链断裂的 问题!
		当亢余数据库非常大,必须做修正工作,记录每一位涉及的用户!! 给出他们一个重新编排时间信任保存链的权利
??,首先做一个网页模板方案一:
	/////////////////////////////////////////文本
	<div class="edit" cnteid="0" cntety="1"><span class="newl">&nbsp;</span><span class="lid" oid="0">1087:</span><div class="edtx">	我有一只船<br></div></div>
	/////////////////////////////////////////标题
	<div class="hdty" cnteid="0" cntety="7"><span class="newl">&nbsp;</span><span class="lid" oid="0" style="font-size:0.84em; font-weight:normal;">1085:</span>
		<div class="hdda">20181001</div>
		<div class="spac">          </div>
		<div class="hdti">今天我背了一首诗</div>
		<div class="hdcr" contenteditable="false">
			<div class="rlik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>			
			</div>
			<div class="rlikn">0</div>
			<div class="flik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>
			</div>
			<div class="flikn">0</div>
			<div class="othrc">
				<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>		
			</div>
		</div>
	</div>
	/////////////////////////////////////////图片
	<div class="imgt" cnteid="432" cntety="2" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="16">1064:</span>
		<div class="imgd">
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/child.gif" alt="pic error">
				<div class="imgi" contenteditable="true">child</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////视频
	<div class="vido" cnteid="600" cntety="5" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="19">1070:</span>
		<div class="vidd">
			<video controls="" width="320" height="240">
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi" contenteditable="true">amimal</div>		
		</div>
	</div>
	/////////////////////////////////////////音频
	<div class="adio" cnteid="0" cntety="4" contenteditable="false"><span class="newl">&nbsp;</span><span class="lid" oid="0">1068:</span>
		<div class="adod">
			<audio src="/static/music/yuxuanji.mp3" controls=""></audio>
			<div class="adoi" contenteditable="true">Hanser-鱼玄机</div>		
		</div>
	</div>
	/////////////////////////////////////////乐谱
	<div class="stav" cnteid="694" cntety="6" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="23">1074:</span>
		<div class="stad">
			<div style="white-space:pre; display:none;">
<textarea class="vex-tab-editor">options space=20 player=true  tempo=80
tabstave
  notation=true
  key=A time=4/4

  notes :q =|: (5/2.5/3.7/4) :8 7-5h6/3 ^3^ 5h6-7/5 ^3^ :q 7V/4 |
  notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :h p5/4
  text :w, |#segno, ,|, :hd, , #tr

</textarea>
        			<p id="errorTip" class="text-danger"></p>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div>
				<div class="tab-preview-container" style="margin-left:50px;">
					<canvas class="tabPreviewer"></canvas>
				</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////公式
	<div class="math" cnteid="683" cntety="3" contenteditable="false"><span class="fixl">&nbsp;</span><span class="lid" oid="18">1066:</span>
		<div class="matd">
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><big mathquill-command-id="43">∫</big><sub class="non-leaf limit" mathquill-command-id="45" mathquill-block-id="46" style="left: -0.25em;"><var mathquill-command-id="51">x</var><span mathquill-command-id="52" class="binary-operator">+</span><var mathquill-command-id="53">y</var></sub><sup class="non-leaf limit" mathquill-command-id="48" mathquill-block-id="49" style="left: -1.8125em; margin-right: -0.775em;"><var mathquill-command-id="55">x</var><sup class="non-leaf" mathquill-command-id="57" mathquill-block-id="58"><span mathquill-command-id="60">2</span></sup></sup><span class="fraction non-leaf" mathquill-command-id="61"><span class="numerator" mathquill-block-id="62"><var mathquill-command-id="73">y</var><sup class="non-leaf" mathquill-command-id="68" mathquill-block-id="69"><span mathquill-command-id="74">4</span><span mathquill-command-id="75" class="binary-operator">+</span><var mathquill-command-id="76">x</var></sup></span><span class="denominator" mathquill-block-id="63"><var mathquill-command-id="83">x</var><sub class="non-leaf" mathquill-command-id="85" mathquill-block-id="86"><var mathquill-command-id="89">i</var></sub></span><span style="display:inline-block;width:0">&nbsp;</span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function A</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><sup class="nthroot non-leaf" mathquill-command-id="90" mathquill-block-id="91"><sup class="non-leaf" mathquill-command-id="127" mathquill-block-id="128"><var mathquill-command-id="135">x</var></sup><span mathquill-command-id="130">/</span><sub class="non-leaf" mathquill-command-id="132" mathquill-block-id="133"><var mathquill-command-id="136">y</var></sub></sup><span class="scaled" mathquill-command-id="90"><span class="sqrt-prefix scaled" style="transform: scale(1, 2.4);">√</span><span class="sqrt-stem non-leaf" mathquill-block-id="92"><span class="fraction non-leaf" mathquill-command-id="108"><span class="numerator" mathquill-block-id="109"><var mathquill-command-id="117">y</var><sup class="non-leaf" mathquill-command-id="114" mathquill-block-id="115"><var mathquill-command-id="118">x</var></sup></span><span class="denominator" mathquill-block-id="110"><var mathquill-command-id="125">z</var><sup class="non-leaf" mathquill-command-id="122" mathquill-block-id="123"><var mathquill-command-id="126">y</var></sup></span><span style="display:inline-block;width:0">&nbsp;</span></span></span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function B</div>		
			</div>
		</div>	
	</div>


stattb日更新与新用户驻点注册的并发问题:
	19号累计 100个用户注册
	比如20号前一刻 A用户注册 19号的用户,
	20号到的那刻 statetb更新 20号 ,显示累计100个用户,
	而 A 注册成功后 19号实际上 是累计 101 个 用户, 但新的20号却漏了A,只统计出100个
	想到的办法有:
		比如 设计 0点 到0点15分,禁止用户注册, 在 3分到 10分处才开始更新statetb!
 	或者,0点时,键 20号数据时,不统计累计用户数,
		0点一刻时才统计累计用户数!!

??点星需要新表, 
	hdty 自身需要添加一个唯一识别串
	然后添加一张点赞表,保存 每条 hdty 的点赞数!!!
	hdty内容更改,点赞数数据重置 !!! 

??修要重构通过显示框架,显示发展过程中变化的结构!!1
	比如说,为了点星,突然添加 数据条需要增加新内容,跟旧版内容格式就冲突了!!!
	需要构思通用架构 满足 内容演变!!
	
??建立 浏览和编辑两区域!!
	编辑区默认显示1000行,并可以扩展到 5000行!!!
	浏览区一般不显示,除非拉伸到了,自动补充!!
	一人一生有 30000 X 1000 = 3000 0000 万行经验传世
	一年 有 365 X 1000 = 365000 万行
	超过100 0000行的省略百万行以后数字, 比如 712 3454
	


??,有待加入的功能:
	代码高亮识别!!(以后再说!!)




<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
开发_web_log 重要内容,因为涉及多机上传问题!!,所以未充分测试前不贸然实施
full_stack_note 暂时 通过 hp机 备份到 selfweb 项目上去
20180726
尝试使用第二部电脑 git 备份同一个项目!!
	例如之前再二手thinkpad做的 selfweb,整个文件夹拷贝到现在的 hp 上!!
	这时相当于把整个 git 配置也拷贝过来了,
	所以直接在 selfweb 输入命令:
		git add xxxx
		git commit -m "xxxx"
		git push origin master
		直接成功上传
不过注意!!!!!!!!!!
	注意 由于并没有完全尝试用两部电脑交替上传文件,
	因为,Apc 上传后得到的新节点, Bpc并不知道, bpc又上传时,因为不知情Apc的修改的内容而导致冲突!!!
	所以,只能在 不重要的 selfweb 项目上做好充分的交替上传测试,才允许其他大型项目的实施























