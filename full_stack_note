全栈:
高并发:
负载均衡:  LVS Nginx 应用服务器集群
LAMP  


decops
可用工具有很多，但其中一些环节是组织内部应用DevOps工具链不可或缺的。
诸如Docker（容器化）、Jenkins（持续集成）、Puppet（基础架构构建）、Vagrant（虚拟化平台）等常用、广泛使用的工具都是2016年的DevOps热门工具。




tomcat 


SpringBoot: https://www.cnblogs.com/java1024/p/8570401.html
    JDK8
    Maven3.0+
    Intellij IDEA

前端程序员
    基础
        HTML / CSS
        JavaScript
        DOM
    中级篇
        数据格式（如JSON、XML）
        RESTful API交互（如jQuery Ajax，Fetch API，ReactiveX）
        正则表达式
        HTML语义化
        命令行
        Node.js
        DIV / CSS
        SCSS / SASS
        矢量图形 / 矢量图形动画（如SVG）
        单页面应用
    高级篇
        ES6 / TypeScript
        CSS3
        面向对象编程
        函数式编程
        MVC / MVVM / MV*
        安全性（如跨域）
        授权（如HTTP Basic、JWT等等）
    工程化
        代码质量（如JSLint / ESLint / TSLint / CSLint）
        代码分析（如Code Climate）
        测试覆盖率
        构建系统（gulp、grunt、webpack等等）
        自动构建（脚本）
    兼容性
        跨浏览器测试 （Chrome，IE，Firefox，Safari等等）
        跨平台测试（Windows、GNU/Linux，Mac OS等等）
        跨设备测试（Desktop，Android，iOS，Windows Phone）
        跨版本测试（同一个浏览器的不同版本）
    前端特定
        CSS / CSS3 动画
        JavaScript 动画
        Web字体嵌入
        Icon 字体
        图形和图表
        CSS Sprite（如glue）
        DOM操作（如jQuery、React等等）
        模板引擎（如JSX、Handlebars、JSP、Mustache等等）
    软件工程
        版本管理（如git、svn）
        包管理（如npm、bower）
        依赖管理
        模块化（如CommonJS、WebPack）
    调试
        浏览器调试
        Debug工具
        Wireshark / Charles抓包
        远程设备调试（如Chrome Inspect Devices）
    测试
        单元测试
        服务测试
        UI测试
        集成测试
    性能与优化
        PageSpeed / Yslow 优化
        加载优化（如gzip压缩、缓存等等）
        性能测试（特别是移动Web）
        可用性
        压缩（如Minify、Uglify、CleanCSS等等）
    设计
        切页面
        线框图（Wireframe）
        响应式设计
        网格布局（Grid Layout）
        Flexbox布局
    SEO
        Sitemap（站点地图）
        内部链接建设
        MicroData / MicroFormat
        页面静态内容生成
        H1、H2、H3和strong使用
        Title、Description优化
        页面静态内容生成
后端程序员
    入门
        HTML / CSS
        编程语言：Java / Python / PHP / Ruby等等
        Web框架，如Spring MVC、Flask、Laravel等等
        HTTP协议基础
        CGI基础
    中级篇
        XML和JSON处理
        数据结构与算法
        面向对象编程
        CMS
        API设计
        网络通信协议，如TCP / Socket
    高级篇
        函数式编程
        领域驱动设计
        MVC架构
        运行环境优化，如JVM
        远程调试
    工程化
        版本管理
        单元测试
        依赖管理
        包管理
    基础设施
        虚拟化，如Docker
        自动化部署
        应用包创建、管理、发布
        发布脚本编写
        Web容器，如Jboss
    缓存篇
        应用层缓存
        平台缓存
        数据库端缓存
        分布式缓存
    数据持久化
        SQL
        NoSQL
        ORM
        DBMS
        搜索引擎
    数据库
        查询性能优化
        结构优化
        主从复制、主主复制等等
        伸缩性与高可用性
        备份恢复与容灾
    安全和加密
        认证与会话管理
        加密解密
        数字签名、数字证书
        加密算法
        XSS/CSRF/SQL注入
    监控
        应用性能监控
        异常监控
        日志
        流量监控
    服务
        RESTful
        SOA
        RPC
        MicroServices
    消息
        JMS
        IPC
        MQ
运维开发者
    入门篇
        编写脚本，如Shell、Perl、Rython等等
        编程语言
        Web应用运行基本原理
        HTTP服务器
        应用容器
        命令行，如awk
        CGI
        修复漏洞
    中级篇
        自动化运维
        GNU/Linux操作系统
        编译
        数据库
    高级篇
        分布式文件系统
        分布式存储系统
    云服务
        存储服务，如AWS S3
        计算服务，如AWS Lambda
        托管服务，如AWS EC2
    安全性
    网络
        CCNP / CCNA
    持续集成
        持续集成工具
        自动构建工具
        依赖管理工具
        版本管理工具
    虚拟化
        应用容器虚拟化，如Docker
        环境虚拟化
        操作系统虚拟化
    自动化 (puppet,chef)
        自动化配置
        自动化部署
        进程管理工具，如Supervisor
    监控
        基础设施监控
        日志管理
        监控服务
    负载均衡
        边缘缓存，如（Varnish）
        DNS负载均衡
        CDN










20180726
主要练习部署 和 负载均衡 知识
web 服务器端下游: tomcat、apache httpd、nginx, uwsgi,
	uwsgi，它类似于nginx，通过一个守护进程把不同的http请求转交给子进程并发处理，并且支持多线程的方式，性能较高，
	与其让一个uwsgi服务跑10个进程，不如开10个uwsgi服务，然后用nginx做负载均衡！
	uwsgi本身的负载均衡没有nginx牛逼。所以阉割掉不用。因此uwsgi退化成了wsgi服务器
	nginx 可以一个ip 地址 配置不同端口来实现在 同一台机子上 访问多个不同的网站!!
	nginx 可以集群部署, 同一个网站,但分布多个主机,多个ip,
		https://www.cnblogs.com/lilongsheng1125/p/4978485.html  (nginx 科普)
		https://www.linuxidc.com/Linux/2017-05/143739.htm 	( Keepalived 和 nginx 配合使用 典型集群部署手把手例子)
		https://www.linuxidc.com/Linux/2017-03/141866.htm	( Keepalived 模式方案 )
			Keepalived 管理多个 nginx 节点,分主备节点,主节点死了,备节点顶上!!
			nginx 节点 实现 web服务的负载管理
Keepalived:是一个基于VRRP协议来实现的服务高可用方案，可以利用其来避免IP单点故障，
	类似的工具还有heartbeat、corosync、pacemaker。
	但是它一般不会单独出现，而是与其它负载均衡技术（如lvs、haproxy、nginx）一起工作来达到集群的高可用












20180727
使用 python3 重新开发 django selfweb项目!!
建立独立环境:
	mkvirtualenv django -p python3
	workon django
	pip install django
	pip install uwsgi
	mkdir selfweb_pyth3 && cd selfweb_pyth3
建立项目
	django-admin startproject selfweb_pyth3 /home/william/full_stack/selfweb_pyth3
建立网站
	django-admin startapp web	
尝试运行: 然后刻登录指定链接测试
	python manage.py runserver
	错误:You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): 
		admin, auth, contenttypes, sessions.
		Run 'python manage.py migrate' to apply them
	先不处理
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    path('admin/', admin.site.urls),
		    # by william
		    path('',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
如果要局域网的机子能访问自己
	在settings.py文件中，找到ALLOWED_HOSTS=[ ]，在中括号中加入你在局域网中的IP。如我在局域网中的IP为192.168.10.133
	所以设置ALLOWED_HOSTS = [ '192.168.10.133'] 
	python manage.py runserver 0.0.0.0:8000	//执行网站服务,添加向外开放段端口
设置简单高并发网站:(使用 uwsgi 多进程)
	在settings.py文件中，设置 ALLOWED_HOSTS=[ ]
	建立selfweb_pyth3/uwsgi.ini:
		[uwsgi]
		chdir = /home/william/full_stack/selfweb_pyth3
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb_pyth3.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/william/full_stack/selfweb_pyth3/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb_pyth3/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
如果要局域网的机子能访问自己
	在settings.py文件中，设置 ALLOWED_HOSTS = [ 'xxx.xxx.xxx.xxx']
	selfweb_pyth3/uwsgi.ini: http = 0.0.0.0:8000 
	uwsgi --ini selfweb_pyth3/uwsgi.ini	//启动服务!!
安装数据库:
	sudo apt-get install mysql-server
	sudo apt-get install mysql-client
	mysql 操作教程看 开发_in_linux_log
	还有django用到的python mysqllib 只支持 2.7
	所以需要:
	pip install PyMySQL
	gedit selfweb_pyth3/__init__.py 
	添加:
	import pymysql
	pymysql.install_as_MySQLdb()
添加数据库 mysql:
	数据库,是django网站各种扩展模块的基础,所以,建站之前先要初始化一个数据库
	当migrate过程时,django会给 selfweb/settings.py->INSTALLED_APPS 里提到的模块都建立相应的表单,
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:3***************7
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	配置工程连接这个数据库: 修改 selfweb_pyth3/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb_pyth3',
		        'USER': 'root',
		        'PASSWORD': '3***************7',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错:
	python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
	补充: 
		db_selfweb_pyth3 并不存在与 selweb网站目录里!!,拷贝移植selfweb网站到新机子时,并不带 db_selfweb_pyth3
		关于如何把 db_selfweb也拷贝过去,日后在探究
创建web模块,及建立自定义model模型
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',	//表示 添加 django管理模块 admin
		    'django.contrib.auth',	//表示 添加 django管理模块 admin
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的model 对应的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True,on_delete=models.CASCADE)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		除了web_blogpost 还有一个web_subject,
		web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项 (一对多原理)
		还多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系(多对多原理)
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	要使用admin管理模块: 需要: selfweb/settings.py -> INSTALLED_APPS 含有:
		'django.contrib.admin',	//表示 添加 django管理模块 admin
		'django.contrib.auth',	//表示 添加 django管理模块 admin
	还需要:selfweb/urls.py -> urlpatterns 含有 url(r'^admin/', admin.site.urls)
	python manage.py createsuperuser	//创建管理者:william:3**7q
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
			Django admin后台管理是不支持显示这种many_to_many关系的,因为 'tags' many_to_many关系
			改成 list_display = ('title', 'create_time', 'subject')
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.		
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
			显然 list_display = ('name') 只有name,一项, 不是一个列表,必须加 , 号
			改成 list_display = ('name',)
		System check identified 3 issues (0 silenced).
		错误,不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	关于 admin 进一步定制:https://www.cnblogs.com/zhming26/p/5767158.html
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功










20180731
目前使用 django2.0
	路径分配要使用通配符的话, 需要 import re_path 使用有正则表达式的路径
	view.py 每个def 一般都是定义一个页面的实现方式,如果要像使用print那样调试,可以使用 assert False 主动触发出错页来代替
	例如:
	def hours_ahead(request, offset):
	    try:
	        offset = int(offset)
	    except ValueError:
	        raise Http404()
	    dt = datetime.datetime.now() + datetime.timedelta(hours=offset)
	    assert False
	    html = "<html><body>In %s hour(s), it will be %s.</body></html>" % (offset, dt)
	    return HttpResponse(html)
	django 使用的网页模板 一般使用 .html后缀名, 这个不是一个严格的 html页面文件,里面夹杂着django的一些自家语法.
	利用 Python 的内建函数 locals() 。它返回的字典对所有局部变量的名称与值进行映射
html常用小知识:
	注释符号
	Html
		单行:<!-- -->
		多行:<!-- -->

	javascript
		单行://
		多行:/*  */
		
	Vbscript
		单行:'
		多行:'
		
	ASP <% %>中： 
		单行：' 
		多行：'
	还有跨浏览器管理


















second_brain
初步架构是 
以行号为基础
每行 一条数据指针,每条指针,指向同一条数据 (针对,上十万行后,出现行位转移问题,)
一般来说,一行一段文字
两张数据表, 一个行号表,一个内容表
每一行都有一个属性字节 0位, 换了行位置, 1位, 改变了内容,
由于 行数据指针制度,所以可以一行放置超文本内容(公式,图片,视频链接!!)
按用户分配负载,和database位置空间,而不是按流量
初步发现,使用django应该并不合适.第一版还是用django 吧

任务一:全页文本框
通过建立 html页模板:
	<input> 单行文本框,好像并不合适 
	<br /> 另起一行
	多行文本框 五行、一行50字的文本框，<textarea name="txt" clos=",50" rows="5" warp="virtual"></textarea>
	但是这种多行文本似乎也不理想
	
	参考CKEditor 5 https://ckeditor.com/ckeditor-5/ 的 在线文本编辑框, 这样就建立了一个简单的在线文本编辑.
	<div class="cc" role="textbox" aria-label="Rich Text Editor, main" contenteditable="true">
		<h2>The three greatest thiou learn from traveling</h2>
	这种文本框比较理想
	role 只是识别标记, aria-label只是注释,暂时都未知如何使用
	contenteditable="true" 才表示 当前的这个 div 块,允许编辑!!

回车键监听
	注意js里 跨浏览器的处理方式:
		<div ...onKeyDown="ifenter(event)" >
		function ifenter(e)
		{
			var x
			if(window.event) // IE8 以及更早版本	
			{
				x=e.keyCode;
			}
			else if(e.which) // IE9/Firefox/Chrome/Opera/Safari
			{
				x=e.which;
			}
			......
		}
	通过js 插入html段落: 网上一个 js 片段:
		window.onload = function(){
		var testingText = '<p>hello</p>'
		var rootElement = document.body;
		var newElement = document.createElement("div");
		var newElementHtmlContent = document.createTextNode(testingText);
		rootElement.appendChild(newElement);
		newElement.appendChild(newElementHtmlContent);
		} 
		这段js 是假设放在 <head>段的
		window.onload 表示当<body>加载显示完毕,即html完全显示后 就执行这个function,
		通过 DOM 动态加载一个新段落 <p>hello</p>
		但是 这只能加载 一段 "<p>hello</p>" 字符窜 而不能真的加载一段<p>段落!!
		以下这段才能成功添加一段段落:
			var testingText = "<p>hello william</p>"
			var ccElement = document.body.getElementsByClassName('cc')
			ccElement[0].insertAdjacentHTML("beforeEnd",testingText);	
		原型：insertAdjacentHTML(swhere,stext) 在指定的地方插入html标签语句
		参数：
			swhere:指定插入html标签语句的地方，有四种值可以用：
			1.beforeBegin:插入到标签开始前
			2.afterBegin:插入到标签开始标记后
			3.beforeEnd:插入到标签结束标记前
			4.afterEnd:插入到标签结束标记后
	按键事件  onkeydown、 onkeypress 和 onkeyup这三个事件句柄:
		按键监听句柄书写 可以 onkeydown 也可以 onKeyDown
		onkeydowm 是比较底层的句柄, 不能识别 组合按键和 按键的复用内容,
			比如, g按键 只能传递按键原码,即大写G字符的字符码,不能传递小写g字符码
			shift+1 并不能传递出 感叹号 ! 的字符码
		onkeypress 高级句柄 能识别 组合按键和 按键的复用内容, g按键 可以识别传递 大写字符码或者小写字符码,
			shift+1 能传递出 感叹号 ! 的字符码
		onkeyup 也是底层句柄	
		就是说 onkeydowm / onkeyup 传递的是按键码, 而 onkeypress 传递的是具体的字符码
		当按键一直按住,相当于 连续触发多次 onkeydowm / onkeypress 事件
		暂时只从 firefox 讨论 !!
			按键事件都会传递一个隐含变量 e , 而 e.which 就是传递过来的字符码数字,
			根据事件句柄类型, e.which要么是按键码, 要么是具体的字符码
			还有两个擦差不多的属性变量 e.keycode  e.charcode ,不过都是在跨浏览器上使用的
		通过 fromCharCode 可以把按键码,字符码转换成实际 字符 变量.
		例如: var keychar = String.fromCharCode(e.which)	
	光标控制!!
		'\r'是回车，使光标到行首，return（carriage return）
		'\n'是换行，使光标下移一格，newline（line feed）
		根据 id 跳到 焦点指定的 段落里文本框,光标直接跳到指定段落里的文本框:
			var fui = document.getElementById('dfg')
			fui.focus(); 
			注意,虽然是再<head>写的代码,但不用document.body.getElementById('dfg') 从<body>段寻找
			直接从全页寻找, 而且不像 class标签 得到的不是数组变量,不用使用 fui[xx]指代
		光标 是选区知识的一个部分,必须系统学习 selection 选区内容
		var sel = getSelection()	//选区
		var node = sel.anchorNode	//开始节点, 节点就是<xx>段落
			//鼠标落到的地方所处的段落就是 选区开始作用的段落 (开始节点)
			<div contenteditable="true"...>
			 	<h2>The three greatest</h2>
				<p>hello</p>
				klkkl
				opp
			</div>
			//当鼠标落到 three 这个地方, 那么此刻选取的开始节点是 <h2>段落 中的 #text 文本段落
			//当鼠标落到 hello 这个地方, 那么此刻选取的开始节点是 <p>段落 中的 #text 文本段落
			//当鼠标落到 kikkl或者 opp 这个地方, 那么此刻选取的开始节点是 <div> 段落中的 #text 文本段落
			//一般用户点击时 selection的 anchorNode 只会落在 各个标签段落中的 #text 文本段落
			//所以 node 值一般是 #text
			//如果要 真正落到指定的 tag段落 例如<div> node:div#dfg.cc,一般是 DOM函数获取
			//真正的 tag段落: 每个tag子段落为占一个偏移位置, 每段文本占一个偏移位置
			//tag段落中的#text 文本段落: 每个字符占一个偏移, 注意回车,缩进什么的也算一个字符
		var number = sel.anchorOffset	//开始节点的偏d移
			//当鼠标落到 The 的 h 之后的地方, 此刻开始节点偏移是从<h2>段落里#text 文本段落的第 2 个位置
			//当鼠标落到 hello 的 o 之前的地方, 此刻开始节点偏移是从<p>段落里#text 文本段落的第 4 个位置
			//当鼠标落到 kikkl 的第一个 k 之前的地方, 此刻开始节点偏移是从<div>段落里#text 文本段落第 2 个位置
			//因为 在 <div>段落里<div>段落里#text 文本段落中</P>之后有一个回车和缩进字符才到达位置 kikkl之前
		var fnode = sel.focusNode 	//结束节点  选区最后的段落,
			//一般情况下,开始节点和结束节点是同一个,所以不知道可以怎么用
		var offset = sel.focusOffset	//结束节点偏移, 也是从结束节点的段落里的第 xx 个位置的意思
		var bool = sel.isCollapsed	//选区的开始和结束位置是否重合
			//当开始节点 == 结束节点, 开始节点偏移==结束节点位置, 选区的开始和结束位置就重合, bool==true
			//这个位置点也是光标闪烁的位置点
			//如果是高亮选择的一块区域, 这一次操作选取的区域为 一个 range
			//当 选择高亮 three,时从左到右选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 4, 结束偏移 9
				isCollapsed :false
			//当 选择高亮 three,时从右到左选: 
				开始节点 == 结束节点 == <h2>		
				开始节点偏移 9, 结束偏移 4
				isCollapsed :false			
			//当 选择高亮从 greatest 的第一个 t 到 hello 的第一个l, 即 test hel :
				开始节点 <h2>  结束节点 <p>
				开始节点偏移 14, 结束偏移 3
				isCollapsed :false
				类似这样的跨节点 选择一块分选区能成,是因为 <div contenteditable="true"...>
		var value = sel.rangeCount	//选区的 分选区 个数
			//通过按住 ctrl 我们 多次操作 间断 高亮选择多块区域
			//每一块都作为一个分选区,统计的数字就是 rangcount
			//然而, 开始节点 结束节点 开始节点偏移 结束偏移  都是最新一个分选区区域的对应的内容
			//而之前分选区的这些参数却未知在哪里
		var typ = sel.type	//当前的选区,当前的分选区的类型
			//一个selection 里 可能有很多分选区成员 包括 多个高亮区域,和一般只有一个光标
			//高亮区域的 type是 range 类型
			//光标的 type 是 Caret 类型, 即 collapsed
			//不论是 光标还是 高亮区域 都算入一个 rangeCount 计数
			//但是 高亮区域 和 光标 不能同时存在,
			//某刻,如果有n个 高亮区域 ,那么 selection.rangeCount:n  selection.type= range
			//某刻有光标,那也只能有一个光标, selection.rangeCount:1  selection.type= Caret
		以上光标内容都是 只读 内容,即只能用特定 api 修改, 不能手动修改
		给选区添加一个range
			var ccElement = document.body.getElementsByClassName('cc') //寻找class="cc"的节点 
			var sel = getSelection()  //获取 此刻的 selection 对象 (选区对象)
			if(sel.rangeCount > 0) sel.removeAllRanges(); 
				//如果此刻你见到有光标/高亮区域,说明selection里有分选区成员,这里是都清除他们
			var range = document.createRange();	//新建一个range
  			range.selectNode(ccElement[0]);	//把节点里的所有内容,都放入这个range
			sel.addRange(range);	
				//把这个range 添加到 selection里, 这时,selection 只有一个包含节点内所有内容的高亮区域
				//这时 selection.rangeCount:1  selection.type= range
		光标跳到指定位置:	
			sel.collapse(ccElement[0],1)
				//ccElement[0] 指是 光标要停在的节点, 是tag节点,而不是tag节点里的#text段落
				//1 是 在这节点上对应的偏移地方
				//所以 一个子段落是算 1 个偏移
				//一段字符串算 1 个偏移
				//注意 html 书写为了美观,使用大量缩进键,但是缩进键也算字符串里的字符
				//所以使用这个要非常谨慎
		        sel.collapseToEnd()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最后的那个点.
				//让光标跳到最后的那个逻辑位置
		        sel.collapseToStart()
				//查询 selection 里所有分选区,找到分选区里逻辑位置最前的那个点.
				//让光标跳到最前的那个逻辑位置
		判断指定节点内容是否选上,光标是否在指定节点
			console.log(sel.containsNode(ccElement[0], true))
				//判断 selection对象 比如 光标 落到指定的 节点上,  
				//判断 selection的高亮选区 有没有在 指定节点 选取了部分内容
  			console.log(sel.containsNode(ccElement[0], false))
				//判断 selection的高亮选区 有没有在 指定节点 选取了全部内容
 		删除指定高亮的 文本内容!!
			sel.deleteFromDocument()
		选取扩充至:	
			sel.extend(nodeA, offsetA)	
				//高亮选取一片区域range, 
				//以当前节点,当前偏移位置 (或者某自定义节点,节点偏移)为 开始节点,开始节点偏移, 
				//以 nodeA 为结束节点, offsetA为结束节点偏移
		获选区中其中的一个range
			首先,我们知道,打开的 html 页面,只有一个 selection 对象,而且一直存在, 只不过他的内容不断变换
			selection 里内容,要么是光标,要么是高亮选区range
			如果是光标, 开始节点==结束节点,开始节点偏移==结束节点偏移, rangeCount:1
			Selection { anchorNode: #text, anchorOffset: 17, 
				    focusNode: #text, focusOffset: 17, 
				    isCollapsed: true, rangeCount: 1, 
				    type: "Caret", caretBidiLevel: 0 }
			如果是高亮选区, selection  选中了 多少个高亮选区,就有多少个rangeCount,
			而开始节点,结束节点,开始节点偏移,结束节点偏移 都是最后加入那一个 高亮选区 的参数,
			Selection { anchorNode: #text, anchorOffset: 28, 
				    focusNode: #text, focusOffset: 34, 
				    isCollapsed: false, rangeCount: 4, 
				    type: "Range", caretBidiLevel: 0 }
			然而,如何获得 selection 存着的,靠前的高亮选区 range 呢? 
			range = sel.getRangeAt(index)
				//获得 selection 里 指定序号的 range ,序号0开始 
				//例如 rangeCount:7 表示有7个range ,序号6表示第7个range
		量化移动光标,量化选range
			sel.modify(alter, direction, granularity)
			alter: move 移动光标
			       extend 选range区域
			directtion: forward / right 向前移动/选 (向右)
				    backward / left 向后移动/选 (向左)
			granularity: (量化值)
				"character",按字符
				"word", 按单词
				"sentence", 
				"line", 
				"paragraph", 
				"lineboundary", 
				"sentenceboundary", 
				"paragraphboundary", 
				"documentboundary".
			例如 The three greatest thiou learn from traveling
				sel.modify("move", "forward", "word")
				//点击 greatest 的 a前面时, 光标会出现在最后的t后面
				sel.modify("extend", "backward", "word")
				//点击 thiou 的 o 前面时, thi 被高量选择!			 
		删除 selection 里的 所有 range:  sel.removeAllRanges();
		删除 selection 里的 指定 range:  sel.removeRange(sel.getRangeAt(index))	
		选择节点里的所有内容,包括各种嵌入子节点: sel.selectAllChildren(parentNode)
		通过代码指定一个 selection.
			sel.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)
			例子:
				var one = document.querySelector('.one');
				var two = document.querySelector('.two');
				var aOffset = document.getElementById('aOffset');
				var fOffset = document.getElementById('fOffset');
			    	selection.setBaseAndExtent(one, aOffset.value, two, fOffset.value);
			然后你就看到一段 指定的内容 高亮选中了,此刻 sslection 里也仅有这个range
		sel.toString();
			把 selection 中的文本内容全部转化策成 字符串!!	
	
文本边框消失 CSS !! 
	通过 css实现,例如 <style>#edit{height:500px;width:500px;border:50px none transparent;outline:none}</style>
	首先 boarder:none,表示不显示边框,
	outline:none,也表示 当文本框被点击focus时,边框的显示, 也为none
文本框字体 CSS !!
	大小:	h1 {font-size:3.75em;} /* 60px/16=3.75em */
		h2 {font-size:2.5em;}  /* 40px/16=2.5em */
		p {font-size:0.875em;} /* 14px/16=0.875em */ 	
	颜色:
		直接用 color:#F00;  三原色组合 F00 
背景
	body{background:#001122}
django 外部css 外部script:
	注意没有和nginx一起部署时，DEBUG = True 才能访问django静态资源。
	django 使用 外部css设置简单,但要先理解每一个参数,所以比较耗时间,要引入外部 css 就是相当于引入外部静态资源
	先看 settings.py
	STATIC_URL = '/static/'		//必要,这个是告诉 html可以直接以这个/static为url头,直接获取各静态资源 
					//比如远程客户机浏览器访问
					// http://127.0.0.1:8000/home/william/full_stack/selfweb_pyth3/static/css/base.css
					//可以改为: http://127.0.0.1:8000/tatic/css/base.css 就能访问
					//但似乎 没有也可以实现, 只要有 STATICFILES_DIRS,所以感觉可有可无,可能在真实部署时才有用吧
	STATIC_ROOT = os.path.join(BASE_DIR, 'static')	  //只是声明了一个路径, 没有特殊意义 ,所以非必要 
					//具体线路是:/home/william/full_stack/selfweb_pyth3/static
					//一般也可以这样声明
					//STATIC_ROOT = os.path.join(BASE_DIR, 'static').replace('\\', '/')
	STATICFILES_DIRS = (...)				//必要,这里才是真正定义外部可访问的静态资源链接
	例子一: STATICFILES_DIRS = ( 
			os.path.join(BASE_DIR, 'static'),  //假如 BASE_DIR: /home/william/full_stack/selfweb_pyth3
			)				   //那么 把 BASE_DIR 接上 static 得到一条具体路径:
							   // /home/william/full_stack/selfweb_pyth3/static
							   //这条路径就是 被添加上的一条静态资源路径,假如路径里有文件 body.css yilaao.jpg
							   //浏览器直接访问 http://127.0.0.1:8000/static/yiliao.jpg 就可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/body.css">
							   //就可以加载 对应的 css文件
	例子二:STATICFILES_DIRS = ( 
		     ('css', os.path.join(BASE_DIR, 'static')), //具体线路是:/home/william/full_stack/selfweb_pyth3/static
			)				   //浏览器直接访问 http://127.0.0.1:8000/static/css/yiliao.jpg 可以查看图片
							   //.html文件上 挂 <link rel="stylesheet" href="/static/css/body.css">
							   //就可以加载 对应的 css文件
	例子三:STATICFILES_DIRS = (
	    ('css', os.path.join(STATIC_ROOT, 'css').replace('\\', '/')),  
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/css
							//访问线路 http://127.0.0.1:8000/static/css/
	    ('img', os.path.join(STATIC_ROOT, 'images').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/images
							//访问线路 http://127.0.0.1:8000/static/img/
	    ('fonts', os.path.join(STATIC_ROOT, 'fonts').replace('\\', '/')), 
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/fonts
							//访问线路 http://127.0.0.1:8000/static/fonts/
	    ('js', os.path.join(STATIC_ROOT, 'js').replace('\\', '/')),
							//具体线路是:/home/william/full_stack/selfweb_pyth3/static/js
							//访问线路 http://127.0.0.1:8000/static/js/
	)
	settings.py设定后,(重点设置是STATICFILES_DIRS) 把要用到的文件放到指定 具体地址后,
	编译 django python manage.py migrate. 

	然后就可以再 .html 上使用外部 css 文件
	有两种使用方式: 
	第一种: 使用 django 的 html 语法.
	{% load static %}	// 在 <!DOCTYPE html> 之前加入
	<link rel="stylesheet" href="{% static '/css/index.css' %}">	
	第二种: 使用标准的 html语法
	<link rel="stylesheet" href="/static/css/body.css">	

	在 .html 上使用外部 js 文件
	<script type="text/javascript" src="/static/js/login.js"></script>


<link>标签的一些补充: 1. 定义文档与外部资源的关系；2. 是链接样式表。
	rel各个属性值配置的意思：
              Alternate -- 定义交替出现的链接 
              Stylesheet -- 定义一个外部加载的样式表 
              Start -- 通知搜索引擎,文档的开始 
              Next -- 记录文档的下一页.(浏览器可以提前加载此页) 
              Prev -- 记录文档的上一页.(定义浏览器的后退键) 
              Contents 
              Index -- 当前文档的索引 
              Glossary -- 词汇 
              Copyright -- 当前文档的版权 
              Chapter -- 当前文档的章节 
              Section -- 作为文档的一部分 
              Subsection -- 作为文档的一小部分 
              Appendix -- 定义文档的附加信息 
              Help -- 链接帮助信息 
              Bookmark -- 书签 	
	例如, <link rel="stylesheet" href="css/bootstrap.css">，引入外部的css文件时，一定不能忘记rel属性的配置。

要着重掌握对 contenteditable 里 innertext 的 光标定位问题!! 还有获取光标所在节点
	<div id="dw" contenteditable="true"></div>
	$('#dw')[0].innerHTML
	console.log($('#dw')[0].innerHTML );就是div中的内容 

	数字转换:https://www.jb51.net/article/45331.htm
	javascript自带parseInt(str)函数
	参数：str，为一个包含数字的字符串
	返回值：
	如果str中最前面几个字符是数字，则返回该数字； 如果str第一个字符不是数字，返回NaN。
	例如：
	parseInt("1234"); //返回1234
	parseInt("1234A"); //返回1234
	parseInt("1234A5"); //返回1234
	parseInt("A1234"); //返回NaN 

	字符窜的处理:https://www.cnblogs.com/l1pe1/p/6197371.html
	



代码片段:
回车后插入字符窜再定位事件方法1:
	e.preventDefault();	//阻止回车原来事件 原来回车事件会插入一个 <div><br/></div> 段
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点		
	var range = document.createRange()	//创建一个range
	range.selectNodeContents(o) 		//把节点里的所有内容都选上,即整个文本段选上
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range
	sel.collapseToEnd()			//光标跑到 selection 逻辑最后的那个 range 里的最后一个位置,
						//就是 刚刚添加的 div文本节点的文本段的最后一个位置
回车后插入字符窜再定位事件方法2:
	e.preventDefault();	//阻止回车原来事件
	var htmlcontent = "<div>hello william</div>"	//构造一段 div文本节点
	var IDElement = document.getElementById('editor')	//获取 div 总节点
	IDElement.insertAdjacentHTML("beforeEnd",htmlcontent); 	//添加到 总结点里
	var sel = getSelection()	//获取当前 selection 对象
	var o = document.getElementById('editor').lastChild  //获取 总节点里最后一个子节点,即刚刚添加的 div文本节点	
	var endOffset = o.childNodes.length;	//获取 o 节点 的子节点个数,由于只有一段文本,一段文本作为一个子节点,所以是1 
	var range = document.createRange()	//创建一个range
	range.setEnd(o,endOffset)		// range 开始地方 在o节点里的endOffset位置
	range.setStart(o,endOffset)		// range 结束地方 在o节点里的endOffset位置
	sel.removeAllRanges()			//清空 selection 对象内容
	sel.addRange(range)			//添加刚刚那个range,由于setEnd,setStart 设置同一个地方
						//所以光标处于这个位置中,即 div文本节点的文本段的最后一个位置
中段插入方法1:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode.parentElement  	//得到当前 节点的父节点, 
	//注意 #text的父节点是<div>文本节点, 但是 <div>文本节点 的父节点是 id=editor节点
	//注意 光标在#text时,在 <div></div>中任意字符旁边的位置,
	//注意 光标在<div>文本节点时,在 <div></div>中字符串之前或之后的位置,
	//所以需要做if判断!! 							
	if (El == document.getElementById('editor'))
	{	El.insertAdjacentHTML("beforeEnd",htmlcontent) }
	else
	{	El.insertAdjacentHTML("afterEnd",htmlcontent); 	}
中段插入方法2并定位下一行:
	var htmlcontent = "<div>hello william</div>"
	var sel = getSelection()
	var El = sel.anchorNode
	if (El.parentElement != document.getElementById('editor'))
	{	El = El.parentElement }
	El.insertAdjacentHTML("afterEnd",htmlcontent)	//确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
	var endOffset = o.childNodes.length;
	var range = document.createRange()	
	range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
	range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
	sel.removeAllRanges()
	sel.addRange(range)
中段插入自调整行号定位下一行
	e.preventDefault();	//阻止回车原来事件
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		linenum = linenum + 1	
		var htmlcontent = "<div>" + linenum + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent) //确保当前的节点不是 #text段落,也不是id=edotor节点才插入内容!!
	var El1 = El.nextSibling
	El1 = El1.nextSibling
	for (;El1 != null;)		//自调整行号
	{
	var index = El1.innerText.indexOf(":")	//获取第一个":"字符的位置
	var str = El1.innerText.substring(index)
	linenum = linenum + 1
	El1.innerText = linenum + str	
	El1 = El1.nextSibling
	}
		var o = El.nextSibling    	//当前节点同阶层的 下一个节点,(并不会指向父节点或者子节点)
		var endOffset = o.childNodes.length;
		var range = document.createRange()	
		range.setEnd(o,endOffset)	// range 开始地方 在节点里的位置
		range.setStart(o,endOffset)	// range 结束地方 在节点里的位置
		sel.removeAllRanges()
		sel.addRange(range)	//定位下一行
加上行号对齐,字符串调整!!(基本完成回车按键, 有bug)
	//阻止回车原来事件
		e.preventDefault();	
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length	
	//前方行号对齐	
		var Ell = document.getElementById('editor').lastChild	
		var lastline = parseInt(Ell.innerText)+1	//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 	
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		var cnt3 = El.innerText.indexOf(":")
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'	
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}

		str0 = str0 + linenum

		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling  	//擦入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )	//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					console.log("templine:"+ templine +"cnt5:"+ cnt5 + "cnt6:" + cnt6)			
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段的 cnt4 == 0 导致,
					//不是最后一阶段 cnt4 绝不等于 0 ,所以 cnt5 绝对不会出现 -1.	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转 以及 附加的字符串处理: 回车时,把光标后的字符串放到插入行)
		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,会添加上述字符串处理
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		sel.removeAllRanges()
		sel.addRange(range)	//简单光标跳转
		if( (range2 == "nothing to do") || (range2.startContainer == El) ) //range2.startContainer也是一个节点
		{	//console.log("nothing to do")	}
		else
		{
			var chofst = range2.startOffset		//光标未跳转所在的文本段位置偏移	
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	console.log("nothing to do 2")	}
			else
			{
				//console.log(chofst)
				//console.log(range2.startContainer.length)			
				var fenhao = o.innerText.indexOf(":")		//插入行的第一个分号的位置
				var str1 = El.innerText.substring(chofst)	//未跳转前光标位置后的字符串
				//console.log(range2)
				//console.log(str1)
				o.innerText = o.innerText + str1		//未跳转前光标位置后的字符串添加到擦插入行
				El.innerText = El.innerText.substr(0,chofst)	//原来位置上的删掉
			
			//以下表演如何把光标重新定位到 #text 文本指定位值
				var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
										//o节点的 子节点是我们寻寻觅觅的 #text 节点
				var range1 = document.createRange()
				range1.selectNodeContents(oo) //把 oo 节点里的所有内容都选上
				range1.setEnd(oo,fenhao+1)	// range1 开始地方 #text 分号后的位置
				range1.setStart(oo,fenhao+1)	// range1 结束地方 #text 分号后的位置
				sel.removeAllRanges()
				sel.addRange(range1)		//光标跳转到插入行的分号后位置
								//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
								//所以浏览器知道我们所指向的是哪个 #text节点
			}
		
		}
回车跳转行号对齐字符窜调整,(解除上述bug)
	//阻止回车原来事件
		e.preventDefault();	//阻止回车原来事件
	//准确获取当前行所在节点,获取当前行号,和回车插入行号
		var sel = getSelection()
		var El = sel.anchorNode
		if (El.parentElement != document.getElementById('editor'))
		{	El = El.parentElement }
		var linenum = parseInt(El.innerText)
		var cnt1 = linenum.toString().length	
		linenum = linenum + 1
		var cnt2 = linenum.toString().length
	//获取光标后字符串
		var str1 = null
		if (sel.isCollapsed)	//获得并判断当前选区光标?选区? 若选区则简单跳转,如果是光标,获取光标后字符串
		{	var range2 = sel.getRangeAt(0)	}
		else
		{	var range2 = "nothing to do"	}
		if( (range2 == "nothing to do") || (range2.startContainer == El) )  //判断range在#text节点里,还是<div>节点,
		{	//console.log("nothing to do")	
		}
		else						//range在#text节点里的时候,才继续
		{
			var chofst = range2.startOffset
			if ( chofst == range2.startContainer.length)	//如果 未跳转前位置是文段末尾,什么都不干!!
			{	//console.log("nothing to do 2")	
			}
			else
			{
				str1 = El.innerText.substring(chofst)
			}
		
		}	

	//前方行号对齐
		var Ell = document.getElementById('editor').lastChild
		var lastline = parseInt(Ell.innerText)+1		//获得最终行,最后结果的行号
		var len1 = (parseInt(Ell.innerText)+1).toString().length 
		var cnt3 = El.innerText.indexOf(":")
		//比较最后行号位数A 和 当前行号的位数格式B, A只会等于B 或则比B大1,没有其他情况   
		if (len1 > cnt3)
		{
			El.innerText = '0' + El.innerText
			var El2 = El.previousSibling
			var strp
			for (;El2 != null;)
			{
				strp = El2.innerText
				El2.innerText = '0' + strp
				El2 = El2.previousSibling
			}
		}
	//当前位置后插入一行
		cnt3 = El.innerText.indexOf(":")    //必须重新获取一次,因为当前行号位数格式已经更新
		var temp1 = cnt3 - cnt2
		var str0 = null
		if (temp1>0) 		//这段if 不能少,不然出现null显示错误,因为 null + '0' 不等于字符串"0"
		{
			str0 = '0'
			temp1--
			for (;temp1;)
			{
				str0 = str0 + '0' 
				temp1--
			}
		}
		str0 = str0 + linenum
		var htmlcontent = "<div>" + str0 + ":</div>"
		El.insertAdjacentHTML("afterEnd",htmlcontent)
	//插入行后方的行号对齐
		var El1 = El.nextSibling.nextSibling		//插入行的后一行 的节点
		var El4 = document.getElementById('editor').lastChild
		var lastline = parseInt(El4.innerText) + 1
		var templine
		var index
		var str
		var cnt4 = 0
		var cnt5 = 0
		var cnt6 = 0
		var num0 = null
		var num = null
		for (;El1 != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = El1.innerText.indexOf(":")
			str = El1.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			El1.innerText = num + str
			El1 = El1.nextSibling
		}
	//光标跳转	

		var o = El.nextSibling    
		var endOffset = o.childNodes.length;
		var range = document.createRange()
		range.selectNodeContents(o) //把节点里的所有内容都选上
		range.collapse(false)	//光标在右方, true:光标在左方 
		//光标简单跳转
		sel.removeAllRanges()	
		sel.addRange(range)	
		//如果 回车后有字符串, 则重新光标跳转
		if( str1 != null )
		{
			
			var fenhao = o.innerText.indexOf(":")
			o.innerText = o.innerText + str1		//str1 放到插入行
			El.innerText = El.innerText.substr(0,chofst)  	//原来位置上的删掉
				
			var oo = range.startContainer.childNodes[0] 	//range.startContainer即 <div> o节点,
									//o节点的 子节点是我们寻寻觅觅的 #text 节点
			var range1 = document.createRange()
			range1.selectNodeContents(oo) //把节点里的所有内容都选上
			range1.setEnd(oo,fenhao+1)	// range 开始地方 #text 分号后的位置
			range1.setStart(oo,fenhao+1)	// range 结束地方 #text 分号后的位置
			sel.removeAllRanges()
			sel.addRange(range1)		//光标跳转到插入行的分号后位置
							//html里每个节点都有 #text字节点, 但是 #text子节点都有位置成员
							//所以浏览器知道我们所指向的是哪个 #text节点
		}
TAB基本实现缩进	(但是 未处理缩进显示问题)
	//阻止tab原来事件
		e.preventDefault()
	//实现
		var sel = getSelection()
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))	//在selection在 #text 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer.parentNode
         		console.log(range)
			var str = patN.innerText.substr(0,range.startOffset)
			var str1 = patN.innerText.substring(range.startOffset)
			var offset = str.length +1
			patN.innerText = str + "\t" + str1
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])	//patN.childNodes[0] 指修改后的 #text
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)		
		}
		else if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))	//在selection在 <div> 时
		{
			var range = sel.getRangeAt(0)
			var patN = range.startContainer	
			var str = patN.innerText
			var offset = str.length +1
			patN.innerText = str + "\t"
			var range1 = document.createRange() 
			range1.selectNodeContents(patN.childNodes[0])
			range1.setEnd(patN.childNodes[0],offset)
			range1.setStart(patN.childNodes[0],offset)
			sel.removeAllRanges()
			sel.addRange(range1)
		}	
退格按键 有bug 未实现 缩行操作
	var sel = getSelection()
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer.parentNode
		if( (patN.innerText.indexOf(":"))+1 ==  range.startOffset )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)			
		}
	}
	if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
	{
		var range = sel.getRangeAt(0)
		var patN = range.startContainer
		if( (patN.innerText.indexOf(":"))+1 ==  patN.innerText.length )
		{
			e.preventDefault()	//阻止 退格 原来事件
			var preN = patN.previousSibling
			if(!preN)
			{	return 1	}
			var range1 = document.createRange() 
			range1.selectNodeContents(preN.childNodes[0])
			range1.collapse(false)
			sel.removeAllRanges()
			sel.addRange(range1)
			
		}
	}
退格键,基本完成
	//初始化
		var sel = getSelection()
		var range
		var Nod
		var preN = null
		var range1
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==3))		//#text里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer.parentNode
			if( (Nod.innerText.indexOf(":"))+1 ==  range.startOffset )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if ((sel.isCollapsed) && (sel.anchorNode.nodeType ==1))		//<div>里
		{
			range = sel.getRangeAt(0)
			Nod = range.startContainer
			if( (Nod.innerText.indexOf(":"))+1 ==  Nod.innerText.length )
			{
				e.preventDefault()	//阻止 退格 原来事件
				preN = Nod.previousSibling
			}
		}
		if(!preN)	//如果 检测到退到第 1 行,则退无可退
		{	return 1		}
		else
		{	var creN = preN 	}
		var LaN = document.getElementById('editor').lastChild
		var lastline_bf = parseInt(LaN.innerText)
		var lastline_af = parseInt(LaN.innerText) - 1
	//前行号对齐
		if (lastline_bf.toString().length - lastline_af.toString().length ) //行号位数少1
		{
			var cnt = parseInt(Nod.innerText) - 1 
			for(;cnt;)
			{
				preN.innerText = preN.innerText.substr(1,preN.innerText.length)
				preN = preN.previousSibling
				cnt--
			}
		}
	//后行号对齐 不管 行号位数是否少1		
		var NexN = Nod.nextSibling
		if (NexN != null)
		{	var linenum = parseInt(NexN.innerText) - 2 }	//复用 回车片段对应修改
		var lastline = parseInt(LaN.innerText) - 1
		var cnt5 = 0
		var index
		var str
		var num0 = null
		var num = null
		for (;NexN != null;)		//后方的每一行都与最后行号位数比较,p判断是否加0
		{
			index = NexN.innerText.indexOf(":")
			str = NexN.innerText.substring(index)
			linenum = linenum + 1
			if ( !cnt5 )		//为了减少更多没有必要的for循环,提高效率
			{
				num0 = null
				templine = linenum
				cnt4 = lastline.toString().length - templine.toString().length
				if(cnt4 > 0)
				{
					cnt6 = templine.toString().length
					cnt5 = Math.pow(10,cnt6) - templine
					if (cnt4) 
					{
						num0 = '0'
						cnt4--
						for (;cnt4;)
						{
							num0 = num0 + '0' 
							cnt4--
						}
					}
				}
			}			
			cnt5--		//cnt5出现-1 是因为到了最后一阶段 cnt4 = 0 导致,
					//不然绝对不会出现 -1 ,所以出现-1 就是到了尾声	
			num =  num0 + linenum
			NexN.innerText = num + str
			NexN = NexN.nextSibling
		}	
	//缩行
		Nod.remove()
	//跳转
		range1 = document.createRange() 
		range1.selectNodeContents(creN)
		range1.collapse(false)
		sel.removeAllRanges()
		sel.addRange(range1)
方向左键
if (x == 37 ) //方向左键
	{
		var sel = getSelection()
         		console.log(sel)
		if ( (sel.anchorNode.nodeType == 3) && (sel.anchorNode.parentNode.innerText.indexOf(':') + 1 == sel.anchorOffset ) )
		{	e.preventDefault()	}
		if ( (sel.anchorNode.nodeType == 1) && (sel.anchorNode.innerText.indexOf(':') + 1 == sel.anchorNode.innerText.length ))
		{	e.preventDefault()	}
	}
以上代码片段 仅仅基于 纯文本记录下的操作



html 转义字符: ISO Latin-1字符集: 
&#09; — 制表符Horizontal tab 			&#10; — 换行Line feed 			&#13; — 回车Carriage Return 
&#32; / &nbsp; — Space 				! &#33; — 惊叹号Exclamation mark 	” &#34; &quot; 双引号Quotation mark 
# &#35; — 数字标志Number sign 			$ &#36; — 美元标志Dollar sign 		% &#37; — 百分号Percent sign 
& &#38; &amp; Ampersand 			‘ &#39; — 单引号Apostrophe 		( &#40; — 小括号左边部分Left parenthesis 
) &#41; — 小括号右边部分Right parenthesis 	* &#42; — 星号Asterisk 			+ &#43; — 加号Plus sign 
, &#44; — 逗号Comma 				- &#45; — 连字号Hyphen 			. &#46; — 句号Period (fullstop) 
/ &#47; — 斜杠Solidus (slash) 			0 &#48; — 数字0 Digit 0 		1 &#49; — 数字1 Digit 1
2 &#50; — 数字2 Digit 2 			3 &#51; — 数字3 Digit 3 		4 &#52; — 数字4 Digit 4 
5 &#53; — 数字5 Digit 5 			6 &#54; — 数字6 Digit 6 		7 &#55; — 数字7 Digit 7 
8 &#56; — 数字8 Digit 8 			9 &#57; — 数字9 Digit 9 		: &#58; — 冒号Colon 
; &#59; — 分号Semicolon 			< &#60; &lt; 小于号Less than 		= &#61; — 等于符号Equals sign 
> &#62; &gt; 大于号Greater than 		? &#63; — 问号Question mark 		@ &#64; — Commercial at 
A &#65; — 大写A Capital A 			B &#66; — 大写B Capital B 		C &#67; — 大写C Capital C 
D &#68; — 大写D Capital D 			E &#69; — 大写E Capital E 		F &#70; — 大写F Capital F 
G &#71; — 大写G Capital G 			H &#72; — 大写H Capital H 		I &#73; — 大写J Capital I 
J &#74; — 大写K Capital J 			K &#75; — 大写L Capital K 		L &#76; — 大写K Capital L 
M &#77; — 大写M Capital M 			N &#78; — 大写N Capital N 		O &#79; — 大写O Capital O 
P &#80; — 大写P Capital P 			Q &#81; — 大写Q Capital Q 		R &#82; — 大写R Capital R 
S &#83; — 大写S Capital S 			T &#84; — 大写T Capital T 		U &#85; — 大写U Capital U 
V &#86; — 大写V Capital V 			W &#87; — 大写W Capital W 		X &#88; — 大写X Capital X 
Y &#89; — 大写Y Capital Y 			Z &#90; — 大写Z Capital Z 
[ &#91; --- 中括号左边部分Left square bracket 	\ &#92; --- 反斜杠Reverse solidus (backslash) 
] &#93; — 中括号右边部分Right square bracket 	^ &#94; — Caret 			_ &#95; — 下划线Horizontal bar (underscore) 
` &#96; — 尖重音符Acute accent 			a &#97; — 小写a Small a 
b &#98; — 小写b Small b 			c &#99; — 小写c Small c 		d &#100; — 小写d Small d 
e &#101; — 小写e Small e 			f &#102; — 小写f Small f 		g &#103; — 小写g Small g 
h &#104; — 小写h Small h 			i &#105; — 小写i Small i 		j &#106; — 小写j Small j 
k &#107; — 小写k Small k 			l &#108; — 小写l Small l 		m &#109; — 小写m Small m 
n &#110; — 小写n Small n 			o &#111; — 小写o Small o 		p &#112; — 小写p Small p 
q &#113; — 小写q Small q 			r &#114; — 小写r Small r 		s &#115; — 小写s Small s 
t &#116; — 小写t Small t 			u &#117; — 小写u Small u 		v &#118; — 小写v Small v 
w &#119; — 小写w Small w 			x &#120; — 小写x Small x 		y &#121; — 小写y Small y 
z &#122; — 小写z Small z 			{ &#123; — 大括号左边部分Left curly brace 
| &#124; — 竖线Vertical bar 			} &#125; — 大括号右边部分Right curly brace 
~ &#126; — Tilde 				— &#127; — 未使用Unused 		&#160; &nbsp; 空格Nonbreaking space 
? &#161; &iexcl; Inverted exclamation 		￠ &#162; &cent; 货币分标志Cent sign 	￡ &#163; &pound; 英镑标志Pound sterling 
¤ &#164; &curren; 通用货币标志General currency sign 
￥ &#165; &yen; 日元标志Yen sign 		| &#166; &brvbar; or &brkbar; 断竖线Broken vertical bar 
§ &#167; &sect; 分节号Section sign 		¨ &#168; &uml; or &die; 变音符号Umlaut 
? &#169; &copy; 版权标志Copyright 		a &#170; &ordf; Feminine ordinal 
? &#171; &laquo; Left angle quote, guillemet left 
? &#172; &not Not sign 				? &#173; &shy; Soft hyphen 		? &#174; &reg; 注册商标标志Registered trademark 
ˉ &#175; &macr; or &hibar; 长音符号Macron accent ° &#176; &deg; 度数标志Degree sign 
± &#177; &plusmn; 加或减Plus or minus 		2 &#178; &sup2; 上标2 Superscrīpt two 	3 &#179; &sup3; 上标3 Superscrīpt three 
′ &#180; &acute; 尖重音符Acute accent 		μ &#181; &micro; Micro sign 		? &#182; &para; Paragraph sign 
? &#183; &middot; Middle dot 			? &#184; &cedil; Cedilla 		1 &#185; &sup1; 上标1 Superscrīpt one 
o &#186; &ordm; Masculine ordinal 		? &#187; &raquo; Right angle quote, guillemet right 
? &#188; &frac14; 四分之一Fraction one-fourth 	? &#189; &frac12; 二分之一Fraction one-half 
? &#190; &frac34; 四分之三Fraction three-fourths ? &#191; &iquest; Inverted question mark 
à &#192; &Agrave; Capital A, grave accent 	á &#193; &Aacute; Capital A, acute accent 
? &#194; &Acirc; Capital A, circumflex 		? &#195; &Atilde; Capital A, tilde 	? &#196; &Auml; Capital A, di?esis / umlaut 
? &#197; &Aring; Capital A, ring 		? &#198; &AElig; Capital AE ligature 	? &#199; &Ccedil; Capital C, cedilla 
è &#200; &Egrave; Capital E, grave accent 	é &#201; &Eacute; Capital E, acute accent 
ê &#202; &Ecirc; Capital E, circumflex 		? &#203; &Euml; Capital E, di?esis / umlaut 
ì &#204; &Igrave; Capital I, grave accent 	í &#205; &Iacute; Capital I, acute accent 
? &#206; &Icirc; Capital I, circumflex 		? &#207; &Iuml; Capital I, di?esis / umlaut 
D &#208; &ETH; Capital Eth, Icelandic 		? &#209; &Ntilde; Capital N, tilde 	ò &#210; &Ograve; Capital O, grave accent 
ó &#211; &Oacute; Capital O, acute accent 	? &#212; &Ocirc; Capital O, circumflex 	? &#213; &Otilde; Capital O, tilde 
? &#214; &Ouml; Capital O, di?esis / umlaut 	× &#215; &times; 乘号Multiply sign 	? &#216; &Oslash; Capital O, slash 
ù &#217; &Ugrave; Capital U, grave accent 	ú &#218; &Uacute; Capital U, acute accent 
? &#219; &Ucirc; Capital U, circumflex 		ü &#220; &Uuml; Capital U, di?esis / umlaut 
Y &#221; &Yacute; Capital Y, acute accent 	T &#222; &THORN; Capital Thorn, Icelandic 
? &#223; &szlig; Small sharp s, German sz 	à &#224; &agrave; Small a, grave accent 
á &#225; &aacute; Small a, acute accent 	a &#226; &acirc; Small a, circumflex 
? &#227; &atilde; Small a, tilde 		? &#228; &auml; Small a, di?esis / umlaut 
? &#229; &aring; Small a, ring 			? &#230; &aelig; Small ae ligature 
? &#231; &ccedil; Small c, cedilla 		è &#232; &egrave; Small e, grave accent 
é &#233; &eacute; Small e, acute accent 	ê &#234; &ecirc; Small e, circumflex 
? &#235; &euml; Small e, di?esis / umlaut 	ì &#236; &igrave; Small i, grave accent 
í &#237; &iacute; Small i, acute accent 	? &#238; &icirc; Small i, circumflex 
? &#239; &iuml; Small i, di?esis / umlaut 	e &#240; &eth; Small eth, Icelandic 
? &#241; &ntilde; Small n, tilde 		ò &#242; &ograve; Small o, grave accent 
ó &#243; &oacute; Small o, acute accent 	? &#244; &ocirc; Small o, circumflex 
? &#245; &otilde; Small o, tilde 		? &#246; &ouml; Small o, di?esis / umlaut 
÷ &#247; &divide; 除号Division sign 		? &#248; &oslash; Small o, slash 
ù &#249; &ugrave; Small u, grave accent 	ú &#250; &uacute; Small u, acute accent 
? &#251; &ucirc; Small u, circumflex 		ü &#252; &uuml; Small u, di?esis / umlaut 
y &#253; &yacute; Small y, acute accent 	t &#254; &thorn; Small thorn, Icelandic 
? &#255; &yuml; Small y, umlaut 		symbols, mathematical symbols, and Greek letters 
? &fnof; 	Α &Alpha; 	Β &Beta; 	Γ &Gamma; 	Δ &Delta; 	Ε &Epsilon; 	Ζ &Zeta; 	Η &Eta; 
Θ &Theta; 	Ι &Iota; 	Κ &Kappa; 	Λ &Lambda; 	Μ &Mu; 		Ν &Nu; 		Ξ &Xi; 		Ο &Omicron; 
Π &Pi; 		Ρ &Rho; 	Σ &Sigma; 	Τ &Tau; 	Υ &Upsilon; 	Φ &Phi; 	Χ &Chi; 	Ψ &Psi; 
Ω &Omega; 	α &alpha; 	β &beta; 	γ &gamma; 	δ &delta; 	ε &epsilon; 	ζ &zeta; 	η &eta; 
θ &theta; 	ι &iota; 	κ &kappa; 	λ &lambda; 	μ &mu; 		ν &nu; 		ξ &xi; 		ο &omicron; 
π &pi; 		ρ &rho; 	? &sigmaf; 	σ &sigma; 	τ &tau; 	υ &upsilon; 	φ &phi; 	χ &chi; 
ψ &psi; 	ω &omega; 	? &thetasym; 	? &upsih; 	? &piv; 	? &bull; 	… &hellip; 	′ &prime; 
″ &Prime; 	￣ &oline; 	? &frasl; 	? &weierp; 	? &image; 	? &real; 	? &trade; 	? &alefsym; 	
← &larr; 	↑ &uarr; 	→ &rarr; 	↓ &darr; 	? &harr; 	? &crarr; 	? &lArr; 	? &uArr; 
? &rArr; 	? &dArr; 	? &hArr; 	? &forall; 	? &part; 	?&exist; 	?&empty; 	? &nabla; 
∈ &isin; 	? &notin; 	? &ni; 		∏ &prod; 	∑ &sum; 	? &minus; 	?&lowast; 	√ &radic; 
∝ &prop; 	∞ &infin; 	∠ &ang; 	∧ &and; 	∨ &or; 	∩ &cap; 	∪ &cup; 	∫ &int; 
∴ &there4; 	～ &sim; 	? &cong; 	≈ &asymp; 	≠ &ne; 		≡ &equiv; 	≤ &le; 		≥ &ge; 
? &sub; 	? &sup; 	? &nsub; 	?&sube; 	? &supe; 	⊕ &oplus; 	? &otimes; 	⊥ &perp; 
? &sdot; 	?&lceil; 	? &rceil; 	? &lfloor; 	?&rfloor; 	? &lang; 	? &rang; 	? &loz; 
? &spades; 	? &clubs; 	? &hearts; 	? &diams; 
markup-significant and internationalization characters: 
“ &quot; 	& &amp; 	< &lt; 		> &gt; 		? &OElig; 	? &oelig; 	? &Scaron; 	? &scaron; 
? &Yuml; 	? &circ; 	? &tilde; 	&ensp; 		&emsp; 		&thinsp; 	? &zwnj; 	? &zwj; 	
? &lrm; 	?&rlm; 		– &ndash; 	— &mdash; 	‘ &lsquo; 	’ &rsquo; 	? &sbquo; 	“ &ldquo; 
” &rdquo; 	? &bdquo; 	?&dagger; 	? &Dagger; 	‰ &permil; 	? &lsaquo; 	? &rsaquo; 	€ &euro; 


正则表达式:
((?=[\x21-\x7e]+)[^A-Za-z0-9])
x21-\x7e]+)[^A-Za-z0-9])
这个匹配所有键盘上可见的非字母和数字的符号

var patrn = /[`~!@#$%^&*()_\-+=<>?:"{}|,.\/;'\\[\]·~！@#￥%……&*（）——\-+={}|《》？：“”【】、；‘’，。、]/im;  
     if (!patrn.test(str)) {// 如果包含特殊字符返回false
         return false;
     }
     return true;
这个是输入框防止特殊字符勿输入验证，包括键盘上所有特殊字符的英文和中文状态。需要者可以根据自身需求而定！谢谢！

[^\w\s]+
匹配非空 非字母 非数字 即可

1 数字：^[0-9]*$ 

2 n位的数字：^\d{n}$

3 至少n位的数字：^\d{n,}$ 

4 m-n位的数字：^\d{m,n}$ 

5 零和非零开头的数字：^(0|[1-9][0-9]*)$ 

6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 

7 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 

8 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 

9 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

二、校验字符的表达式

1 汉字：^[\u4e00-\u9fa5]{0,}$ 

2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 

3 长度为3-20的所有字符：^.{3,20}$ 

4 由26个英文字母组成的字符串：^[A-Za-z]+$ 

5 由26个大写英文字母组成的字符串：^[A-Z]+$ 

6 由26个小写英文字母组成的字符串：^[a-z]+$ 

7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 

8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 

9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+

12 禁止输入含有~的字符：[^~\x22]+

三、特殊需求表达式
1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 
a、自定义完美的邮箱验证：（java）
^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$
b、（js或jq）
^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$

2 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 

3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ 

4 手机号码最新：
    ^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\\d{8}$（java）
    ^((13[0-9])|(14[5,7])|(15[0-3,5-9])|(17[0,3,5-8])|(18[0-9])|166|198|199|(147))\d{8}$(js或jq)

5 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$  

6 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 

7 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 

8 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 

9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15 钱的输入格式：

16 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26 中文字符的正则表达式：[\u4e00-\u9fa5]

27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29 HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) 33 IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 

正则表达式可以为空值，不为空则要格式。

格式如下：

^$|^(\d+|\-){7,}$ （"|"后边的是要符合格式。）

如果可以为空的空可以是空格和制表符那就这么写：^\s*$|^(\d+|\-){7,}$

正则表达式不为空用\S匹配，不能有空格可以用[^ ]匹配，[]中^后面是一个空格。

[size=12px]1。^d+$　　//匹配非负整数（正整数 + 0） 
2。^[0-9]*[1-9][0-9]*$　　//匹配正整数 
3。^((-d+)|(0+))$　　//匹配非正整数（负整数 + 0） 
4。^-[0-9]*[1-9][0-9]*$　　//匹配负整数 
5。^-?d+$　　　　//匹配整数 
6。^d+(.d+)?$　　//匹配非负浮点数（正浮点数 + 0） 
7。^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$　　//匹配正浮点数 
8。^((-d+(.d+)?)|(0+(.0+)?))$　　//匹配非正浮点数（负浮点数 + 0） 
9。^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$　　//匹配负浮点数 
10。^(-?d+)(.d+)?$　　//匹配浮点数 
11。^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 
12。^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 
13。^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 
14。^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 
15。^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 
16。^[w-]+(.[w-]+)*@[w-]+(.[w-]+)+$　　　　//匹配email地址 
17。^[a-zA-z]+://匹配(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$　　//匹配url 
18。匹配中文字符的正则表达式： [u4e00-u9fa5]
19。匹配双字节字符(包括汉字在内)：[^x00-xff]
20。应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
String.prototype.len=function(){return this.replace([^x00-xff]/g,"aa").length;}
21。匹配空行的正则表达式：n[s| ]*r
22。匹配HTML标记的正则表达式：/<(.*)>.*</1>|<(.*) />/ 
23。匹配首尾空格的正则表达式：(^s*)|(s*$)

* 正则表达式用例
  * 1、^S+[a-z A-Z]$ 不能为空 不能有空格  只能是英文字母
  * 2、S{6,}         不能为空 六位以上
  * 3、^d+$          不能有空格 不能非数字
  * 4、(.*)(.jpg|.bmp)$ 只能是jpg和bmp格式
  * 5、^d{4}-d{1,2}-d{1,2}$ 只能是2004-10-22格式
  * 6、^0$            至少选一项
  * 7、^0{2,}$        至少选两项
  * 8、^[s|S]{20,}$ 不能为空 二十字以上
  * 9、^+?[a-z0-9](([-+.]|[_]+)?[a-z0-9]+)*@([a-z0-9]+(.|-))+[a-z]{2,6}$邮件
  * 10、w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*([,;]s*w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*)* 输入多个地址用逗号或空格分隔邮件
  * 11、^(([0-9]+))?[0-9]{7,8}$电话号码7位或8位或前面有区号例如（022）87341628
  * 12、^[a-z A-Z 0-9 _]+@[a-z A-Z 0-9 _]+(.[a-z A-Z 0-9 _]+)+(,[a-z A-Z 0-9 _]+@[a-z A-Z 0-9 _]+(.[a-z A-Z 0-9 _]+)+)*$
  *     只能是字母、数字、下划线；必须有@和.同时格式要规范 邮件
  * 13 ^w+@w+(.w+)+(,w+@w+(.w+)+)*$上面表达式也可以写成这样子，更精练。
    14   ^w+((-w+)|(.w+))*@w+((.|-)w+)*.w+$ [/size]



浮窗代码片段:
新闻弹窗: https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  //新闻弹窗
	<head>
	<meta charset="utf-8">
	<title>jquery漂浮广告代码</title>
	<script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
	<style>
	</style>
	</head>
	<body>
	<div id="imgDiv" style="position:absolute;left:50px;top:60px;">
	    <div id="a" style="width:20px;height:20px;position:absolute;left:160px;background:salmon;text-align: center;">×</div>
	    <!-- <img src="01.jpg" border="0" /> -->
	    <div style="width:180px;height:180px;background:red;"></div>
	</div>
	 
	<script>
	var xin = true,
	    yin = true;
	var step = 1;
	var delay = 10;
	var $obj;
	$(function() {
	    $obj = $("#imgDiv");
	    var time = window.setInterval("move()", delay);
	    $obj.mouseover(function() {
	        clearInterval(time)
	    });
	    $obj.mouseout(function() {
	        time = window.setInterval("move()", delay)
	    });
	});
	 
	function move() {
	    var left = $obj.offset().left;
	    var top = $obj.offset().top;
	    var L = T = 0; //左边界和顶部边界
	    var R = $(window).width() - $obj.width(); // 右边界
	    var B = $(window).height() - $obj.height(); //下边界
	 
	    //难点:怎样判断广告的4个边框有没有超出可视化范围!
	    if (left < L) {
	        xin = true; // 水平向右移动
	    }
	    if (left > R) {
	        xin = false;
	    }
	    if (top < T) {
	        yin = true;
	    }
	    if (top > B) {
	        yin = false;
	    }
	    //根据有没有超出范围来确定广告的移动方向
	    left += step * (xin == true ? 1 : -1);
	    top  += step * (yin == true ? 1 : -1);
	    // 给div 元素重新定位
	    $obj.offset({
	        top: top,
	        left: left
	    })
	}
	    //关闭
	$(function() {
	    $("#a").click(function() {
	        var b = $("#a").parent();
	        $(b).remove();
	    })
	})
	</script>
	</body>
浮窗广告: https://blog.csdn.net/Jensen_Yao/article/details/64926666
	<style type=text/css>
	  div#roll {
		width: 100px; color: #fff; position: absolute; height: 100px; background-color: #000
	}
	</style>
	<body>
	<H2>JS全屏漂浮广告，移入光标停止移动</H2>
	<div id="roll">我是广告</div>
	<script type=text/javascript>
	  var ggRoll = {
	    roll: document.getElementById("roll"),
	    speed: 20,
	    statusX: 1,
	    statusY: 1,
	    x: 100,
	    y: 300,
	    winW: document.documentElement.clientWidth - document.getElementById("roll").offsetWidth,
	    winH: document.documentElement.clientHeight - document.getElementById("roll").offsetHeight,
	    Go: function () {
	       this.roll.style.left = this.x + 'px';
	       this.roll.style.top = this.y + 'px';
	 
	       this.x = this.x + (this.statusX ? -1 : 1)
	       if (this.x < 0) { this.statusX = 0 }
	       if (this.x > this.winW) { this.statusX = 1 }
	 
	       this.y = this.y + (this.statusY ? -1 : 1)
	       if (this.y < 0) { this.statusY = 0 }
	       if (this.y > this.winH) { this.statusY = 1 }
	 
	     }
	  };
	    var interval = setInterval("ggRoll.Go()", ggRoll.speed);
	    ggRoll.roll.onmouseover = function () { clearInterval(interval) };
	    ggRoll.roll.onmouseout = function () { interval = setInterval("ggRoll.Go()", ggRoll.speed) };
	</script>
	</body>	
固定浮窗: https://www.jb51.net/article/65211.htm
	<style>
	* { font-size:12px; font-family:Verdana,宋体; }
	html, body { margin:0px; padding:0px; overflow:hidden; }
	.b { margin:0px; padding:0px; overflow:auto; }
	.line0 { line-height:20px; background-color:lightyellow;
	padding:0px 15px; }
	.line1 { line-height:18px; background-color:lightblue;
	padding:0px 10px; }
	.w { position:absolute; right:10px; bottom:10px; width:160px; 
	height:240px; overflow:hidden; border:2px groove #281;
	cursor:default; -moz-user-select:none; }
	.t { line-height:20px; height:20px; width:160px;
	overflow:hidden; background-color:#27C; color:white;
	font-weight:bold; border-bottom:1px outset blue;
	text-align:center; }
	.winBody { height:218px; width:160px; overflow-x:hidden;
	overflow-y:auto; border-top:1px inset blue;
	padding:10px; text-indent:10px; background-color:white;
	}
	</style>
	</head>
	<body>
	<div class="w">
	<div class="t">Demo Win - Fixed</div>
	<div class="winBody">Hello world</div>
	<div>//www.jb51.net/</div>
	</div>
	</body>
	<script>
	//测试用，随机产生一定的内容
	for(var i=0; i<400; i++)document.write("<div class=\"line"+(i%2)+"\">"+(new Array(20)).join((Math.random()*1000000).toString(36)+" ")+"<\/div>");
	//代码如下：
	new function(w,b,c,d,o){
	d=document;b=d.body;o=b.childNodes;c="className";
	b.appendChild(w=d.createElement("div"))[c]= "b";
	for(var i=0; i<o.length-1; i++)if(o[i][c]!="w")w.appendChild(o[i]),i--;
	(window.onresize = function(){
	w.style.width = d.documentElement.clientWidth + "px";
	w.style.height = d.documentElement.clientHeight + "px";
	})();
	}
	</script>		
			
固定<div>: https://blog.csdn.net/qq_26817251/article/details/53648685		
	div id="dg" style="z-index: 9999; position: fixed ! important; right: 0px; top: 0px;">
	<table width=""100% style="position: absolute; width:260px; right: 0px; top: 0px;">
	//table 内部控件代码
	</table>
	</div>	
	div position参数设置为fixed 其相对于浏览器为绝对位置，通过设置right和top将div固定在右上角。
	table position参数设置为absolute,其相对于第一层div绝对定位，通过设置right和top将table固定在div容器的右上角。
		
弹出表单表框层: https://blog.csdn.net/Seety_ST/article/details/49020047
	<style>
	/*灰色遮罩层*/
	.fade{
	    width:100%;
	    height:100%;
	    background:rgba(0, 0, 0, 0.5);
	    position: fixed;
	    left: 0;
	    top: 0;
	    z-index: 99;
	}
	/*弹出层*/ 
	.succ-pop{
	    width: 400px;
	    height: 300px;
	    background: #fff;
	    position: fixed;
	    left: 50%;
	    top: 50%;
	    margin-left: -200px;
	    margin-top: -150px;
	    z-index: 999;
	    border-radius: 5px;
	}   
	.succ-pop h3.title{
	    text-align: center;
	    font-size: 22px;
	    color: #ce002c;
	}
	</style>
	<div class="succ-pop">
	    <h3 class="title">
	        中间填写内容
	    </h3>
		<textarea>options space=20 player=true  tempo=80
		</textarea>
	</div>
	<div class="fade"></div>
通用思路上传文件:
	前端:
		<form enctype="multipart/form-data" action="/uploadFile/" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
	后端:
	views.py
		def upload_file(request):
		    if request.method == "POST":    # 请求方法为POST时，进行处理
		        myFile =request.FILES.get("myfile", None)    # 获取上传的文件，如果没有文件，则默认为None
		        if not myFile:
		            returnHttpResponse("no files for upload!")
		        destination = open(os.path.join("./",myFile.name),'wb+')    # 打开特定的文件进行二进制的写操作
		        for chunk in myFile.chunks():      # 分块写入文件
		            destination.write(chunk)
		        destination.close()
		        return HttpResponse("upload over!")			
	urls.py
		urlpatterns = [
			...
			    re_path('uploadFile',views.upload_file),
			...
		]
	通过通用的 html 标准 <form> <input> 组成的 上传模组实现上传文件
		enctype="multipart/form-data" 表示上传非文本而是文件	
		action="/uploadFile/" 表示要访问的新网址是 http://127.0.0.1:8000/uploadFile
		method="post" 访问新网址时 申请的操作, 这里上传一段数据
		type="file" 表示这个input 是给这个 <form> 载入一个文件,具体选择文件路径
		name="myfile" 很重要 后端通过这个项 来寻找正确的文件位置 
		type="submit"  表示这个input, 把这个form 打包 并并向服务器提交内容 
			先建立握手访问,然后提交post申请,获许后才开始上传数据流, 
			最后获得反馈页面,浏览器新建http://127.0.0.1:8000/uploadFile页面显示反馈页面
	远程服务器网址:http://127.0.0.1:8000/uploadFile 接受链接后,移交 def upload_file(request): 处理 
		if request.method == "POST":    # 查看请求方法是否为POST时
		myFile =request.FILES.get("myfile", None) # 允许上传内容,并开始上传内容
			"myfile" 对应前端的 name="myfile"
			内容上传完,会存在 myFile,然后才开始后续处理工作
		return HttpResponse("upload over!")	#处理工作完了,最后返回一个反馈页面			
	整个过程使用标准 html 方案,所以前端不需要另外使用 js 辅助或实现
通用思路上传文件, 但是浏览器不跳转新页面
	只需要修改前端代码为:
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post">
			<input type="file" name="myfile" />
			<br/>
			<input type="submit" value="upload"/>
		</form>
		<iframe name="frame1" frameborder="0" height="40"></iframe>
	思路是 在原网页 添加一个内嵌页面框, 这样访问 http://127.0.0.1:8000/uploadFile 获得的反馈页内容
	会放入这个内嵌页面框里显示,这样做的好处是 原网页可以直接得到反馈页内容执行交互和信息处理工作
	<form> 添加了 target="frame1",	表示得到的反馈页或内容,不另开新页面显示,而是放到 frame1 里去
	<iframe name="frame1" frameborder="0" height="40"></iframe>	
		<iframe>是标记一个内嵌页面框, 反馈页或者内容会放到这里去
通过 ajax 实现 上传文件
	前端:
		<div>
		        <input type="file" name="file" id="file_upload">
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>
		function FileUpload() {
			var form_data = new FormData();
			var file_info =$( '#file_upload')[0].files[0];
			form_data.append('file',file_info);
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        file_obj = request.FILES.get('file')
	        import os
	        f = open(os.path.join("./",file_obj.name), 'wb+')
	        print(file_obj,type(file_obj))
	        for chunk in file_obj.chunks():
	            f.write(chunk)
	        f.close()
	        print('11111')
	        return HttpResponse('OK')
	urlpatterns = [
	...
	    re_path('upload_ajax',views.upload_ajax),
	...
	]	
	这里通过 jquery 的 ajax 的 实现上传文件,上传工作都通过 js 函数实现
	首先新建填充 一个form数据, 把上传的内容都放入
	然后执行 ajax()函数,实现上传工作 其中填入的数据有
		url:'/upload_ajax/',	要访问的网址链接: http://127.0.0.1:8000/upload_ajax
		type:'POST',		请求类型 post	
		data: form_data,	上传数据
		success: function(callback) {	//成功的回调函数
			console.log(callback)
		}
	执行ajax()时, 浏览器通过子进程访问服务器 并提出 post 上传操作
	服务器后端  def upload_ajax(request): 处理访问, request.FILES.get('file') 允许并开始数据上传
	上传结束,数据存在 file_obj 供 def upload_ajax(request): 继续处理,
	最后返回 反馈页内容, 
	反馈内容被还在执行的 ajax()捕捉,然后返回到当前页面处理, 而不是 浏览器另外开一页面显示!!
通过 ajax 实现 上传 多个文件
	前端:
		<div style="display:block;" >
			<!-- 注意多了multiple,这样可以同时选多个文件, name="file" 为每个选择的文件挂上标签file  -->
		        <input type="file" name="file" id="file_upload" multiple >  
		        <input type="button" value="上传" onclick="FileUpload()">
		</div>	
		function FileUpload() {
			var form_data = new FormData();
			//多文件 依次插入 form_data 队列数据     
			for ( var i=0 ;i < $( '#file_upload')[0].files.length; i++)
			{
				var file_info = $( '#file_upload')[0].files[i];
				form_data.append('file',file_info);
			}
			if(file_info==undefined)	//暂且不许要判断是否有附件
			{	alert('你没有选择任何文件')
				return false
			}
			console.log(form_data)
			console.log(file_info)
			$.ajax({
				url:'/upload_ajax/',
				type:'POST',
				data: form_data,
				processData: false,  // tell jquery not to process the data
				contentType: false, // tell jquery not to set contentType
				success: function(callback) {
					console.log(callback)
				}
			})
		}
	后端:
	views.py
	# 多文件接收
	def upload_ajax(request):
	    if request.method == 'POST':
	        print('2222')
	        files = request.FILES.getlist('file')	# 使用 getlist, 挖出标签 file 的 form_data 成员
	        print(files,type(files))
	        for f in files:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            dest = open(os.path.join("./",f.name),'wb+')
	            for chunk in f.chunks():
	                dest.write(chunk)
	            dest.close()
	        print('11111')
	        return HttpResponse("ok")	
通用思路上传 多个文件
	前端
		<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
			<!-- 注意多了multiple,这样可以同时选多个文件, name="myfile" 为每个选择的文件挂上标签myfile  -->		
			<input type="file" name="myfile" multiple />
			<input type="submit" value="upload"/>
		</form>
	后端
	views.py
	# 多文件
	def upload_file(request):
	    if request.method == "POST":    # 请求方法为POST时，进行处理
	        myFiles =request.FILES.getlist("myfile", None)    # 使用 getlist, 挖出标签 myfile 的 form_data 成员
	        if not myFiles:
	            return HttpResponse("no files for upload!")
	        for f in myFiles:		# 这一个个挖出的成员就是 一个个上传过来的文件
	            print('333')
	            destination = open(os.path.join("./",f.name),'wb+')    # 打开特定的文件进行二进制的写操作
	            for chunk in f.chunks():
	                destination.write(chunk)
	            destination.close()
	        return HttpResponse("upload over!")






	
	
20180824
坑:
	发现,如果 selection, range 所指的 #text文本 被修改了,机制是原来的#text段落会被新的替换,
	所对应的 selection range 指向了 null ,指向#text文本 的节点指针也会指向null
	null + '0' 不等于字符串"0"
	多个空格只显示一个空格,多个tab只显示一个空格的问题!! css 添加 white-space:pre; 处理
	text-indent:2em  css的首行缩进
 	letter-spacing:2px;	css 字符之间间距
	nodeType == 1 //<div>
	nodeType == 3 //<#text>
	图片要居中, 同一div 使用 text-align: center;css属性 然后<img>里  margin: 0 auto; css属性
	可以令 子 div 并排显示 justify-content: center; display:flex;
	<p>和<div>的间距有区别,p 和 div 都是块元素, p和div作为同级元素的情况下会换行显示,但是行距有区别!!
	<img>间距 用 hspace="50"
	<div> 的间距用{margin:top right bottom left }
		如：{margin:10px 20px 30px 40px}表示该元素与上面的元素相距10px，
		与右边的元素相距20px，与下面的元素相距30px，与左边的元素相距40px;
		使用该属性的时候要注意当上面元素的margin-bottom:10px;下面元素margin-top:10px;那么他们的间距将会合并，
			即他们之间的间距变为10px;	
		如果这两个值不一样，那么浏览器将会取较大值。
		但是如果其中有一个元素设置position为absolute时，间距将不会合并。
		使用该属性时一定要注意与它相关的元素的属性，注意观察他们的position和float属性。
		注意使用的时候 是在 子div里使用,不可在父div里使用让子div继承!!
	<audio>起码要这样子标记: <audio src="/static/music/yuxuanji.mp3" controls autoplay="true"></audio>
		不然无法显示
	网页获取 例如:wget -p -np -k -r https://www.52cmajor.com/tab/editor
		wget https://static.52cmajor.com/static/vextab/ -r -c -np -nH --cut-dirs 2 --restrict-file-names=nocontrol
wget -c -r -np -k -L -p -A '*.js*' https://static.52cmajor.com/static/vextab/
	html显示空格:
		连续的空格一般只显示一个
		white-space:pre; 后才显示多个
	现在是制表符号的显示!!!


五线谱: https://www.52cmajor.com/tab/editor 
	https://my.oschina.net/daxia/blog/1590124
	直接下载整个网页分析 wget -p -np -k -r https://www.52cmajor.com/tab/editor 然后点击网页,
	居然发现功能完好!! 而且还有回播功能,可以移植使用
	这三个直接添加了监听处理,而不需要自己主动在<div>标签上设置监听
        	vexTabEditor.keyup(_.throttle(parseAndRender, 250));
   		vexTabEditor.resize(_.throttle(parseAndRender, 250));
   		$(window).resize(_.throttle(parseAndRender, 250));
	使用 vextab相当奇葩, 最稳妥复用几个 div 把 canvas 包涵进去,不然 background 错亂
	还有,使用 vextab 自带 player 时其实是两个canvas重合的,所以 css.position 应当 relative
	值得wget下来参考的网址: 
		https://www.52cmajor.com/doc?doc=vextab
		http://www.vexflow.com/vextab/tutorial.html

数学公式: http://www.html580.com/11952/demo   JMeditor
	显示使用了 	<link rel="stylesheet" href="/static/css/mathquill.css">

js 数组的大坑
	例如:  var vexTabEditor = $('.vex-tab-editor');
	使用了 jquery 的语法 吧 class="vex-tab-editor" 成员都给 vexTabEditor 变量
	vexTabEditor 应该是 一个数组, vexTabEditor[i] 是每一个数组成员的表述
	但是 这里得到的数组成员没有函数, 只有数组有函数方法:
	vexTabEditor.val() 是可执行的,  vexTabEditor[i].val(),却并不存在
	数组有函数方法 一般只是围绕第一个成员.
	比如 vexTabEditor.val() 得到的是 vexTabEditor[i].value 的值
	但是 数组成员是可以有函数方法的!!
	例如 	var artist = new Array()  创建一个新数组
	artist[i] = new Artist(10, 10, 1000, {scale: 0.8});   数组成员被赋予内容
        artist[j].render(renderer[j]); 	数组成员是可以有函数方法的				
浮窗
	https://blog.csdn.net/yongbosong/article/details/4210693	//移动浮窗
	https://blog.csdn.net/kaikaihuiyuan/article/details/79142126  	//新闻弹窗
	重点参数说明 <div style="z-index:100; position:fixed; width:320px; height:320px; background:#aaa; right: 0px; top: 0px">
	z-index 所在显示的层数,高层数遮盖低层数
	position:fixed; 位置方式, 以当前屏幕窗口为准		
	width:320px; height:320px; <div>等控件大小
	right: 0px; top: 0px 具体位置!!
	弹出表单表框层 学会了如何 遮罩的问题!!
	如果在窗口上摆按钮 那么按钮的 位置方式是position:relative: 是相对窗口的摆放 !!
		<div style="float:left; width:160px; height:auto;"></div>
		<div style="float:left; position:relative; width:30px; height:30px; margin-left:-30px"></div>
		设置position:relative;下方的div是相对于上方的div摆放的,float:left 表示 div是 从左到右放
		position:relative; 配对的位置方法是 margin-left
		margin-left:-30px 是根据 relative得到的位置后,往左退30px 

基本DOM 操作:
	更改CSS ,http://www.w3school.com.cn/js/js_htmldom_css.asp
		document.getElementById("p2").style.color="blue";
		注意,一定要字符串,即使是数字 例如
		document.getElementById("p2").style.xxx="233";
		var Y = (233).toString() + "px"
		document.getElementById("p2").style.xxx= Y  ;		
	更改Id
		 $('你的元素').arrt（‘id’,你要的新id）； 
		var obj = document.getElementById("aa");//获取原来的id = aa的div 
		obj.setAttribute("id","bb"); 
	js 的 event 操作:
		onmousedown="contentbar(event)"	这里一定要填写 event 才能传递 event 内容
		function contentbar(e){...}	这里 可以简单用 e 来获得传递过来的event内容
		e.currentTarget.	//重要 因为	getSelection().anchorNode 里都不能很好得到触发事件的 元素!!
	js鼠标样式: 
		<span style="cursor:auto">Auto</span><br />
		<span style="cursor:crosshair">Crosshair</span><br />
		<span style="cursor:default">Default</span><br />
		<span style="cursor:pointer">Pointer</span><br />
		<span style="cursor:move">Move</span><br />
		<span style="cursor:e-resize">e-resize</span><br />
		<span style="cursor:ne-resize">ne-resize</span><br />
		<span style="cursor:nw-resize">nw-resize</span><br />
		<span style="cursor:n-resize">n-resize</span><br />
		<span style="cursor:se-resize">se-resize</span><br />
		<span style="cursor:sw-resize">sw-resize</span><br />
		<span style="cursor:s-resize">s-resize</span><br />
		<span style="cursor:w-resize">w-resize</span><br />
		<span style="cursor:text">text</span><br />
		<span style="cursor:wait">wait</span><br />
		<span style="cursor:help">help</span>
上传预览:
	https://blog.csdn.net/x550392236/article/details/76690927
django 上传到服务器:	
	https://blog.csdn.net/jiangpf1992/article/details/49406879
django 上传到服务器又不跳转页面: 使用 <iframe>
	https://blog.csdn.net/ling926/article/details/72888831
django + jquery(重写的ajax) + 上传文件服务器 重点
	https://www.cnblogs.com/liaojiafa/p/6231382.html
	https://www.cnblogs.com/jishuweiwang/p/6140132.html
	https://www.cnblogs.com/liyqiang/articles/7858523.html  //成功实现,所以从这参考
	上传文件的主要思路 主要是 直接 打包好一段数据 ,然后给某个网址(例如http://127.0.0.1:8000/upload_file 传过去
		相当于访问网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		如果 服务器后端接受 post 请求 , 远程机就可以 把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个页面 表示上传成功, 远程机另开一个页面 显示 访问 网址 http://127.0.0.1:8000/upload_file 得到的页面
	使用 ajax 上传文件的意义在于 此刻 远程机浏览器显示的页面是 http://127.0.0.1:8000/test1 
		浏览器辟出一个子进程访问 网址 http://127.0.0.1:8000/upload_file 并提交一个post请求!!
		服务器后端接受 post 请求 , 远程机把打包的数据分包发到 服务器上,
		最后 服务器后端 返回一个成功页面 表示上传成功, 
		但是 远程机并不会显示这个页面,远程机仍然显示着 http://127.0.0.1:8000/test1 的页面
		返回的成功页面会 转为附加内容 会添加到现在显示的 http://127.0.0.1:8000/test1 的页面中去
以上都是一次上传单个文件的
一次上传多个文件:
	首先 前端: <input type="file" name="file" id="file_upload" multiple >	添加  multiple 可以选多个
	 js 和 后端 都有对应修改,详细看片段
	不论是通用的 还是 ajax 都是建立一个 form 数据队列,然后把独立数据(独立文件),作为一个个成员放入,最后上传
	就是这样完成 文件,数据,多文件,多数据 上传的
	
(django1.10)访问url报错Forbidden (CSRF cookie not set.): xxx
	修改settings.py文件，注释掉
	django.middleware.csrf.CsrfViewMiddleware',

CSS优先级:
	行间>id>class>标签>通配符
		即 stytle="" > #AAA > .BBB >  CCC > * 
	优先级相同,谁后谁优先；优先级不同，优先级高的优先  
	优先级是一种累加的关系，加起来的值越大优先级就越高
		例如  #div3 .dd{...}  这个的优先级是 #div3 和 .dd 累加的优先级
	群组选择器的优先级取决于位置，谁靠后谁的优先级就高，会把前面的样式给覆盖了
		例如以下 必然是 green 
	            div,p,h1{
	                background: red;
	                margin-top: 50px;
	            }
	            div{
	                background: green;
	            }
css推荐模块化,集中化写法:例如
	<div class="uppic">
		<div class="Win" style="">
			<h3 class="title" style="">上传图片</h3>
			<div class="image" style="">
				<img src="/static/img/eye_expression.gif" alt="pleace select a picture " ></img>
			</div>
			<form enctype="multipart/form-data" action="/uploadFile/" target="frame1" method="post" style="text-align:center;">
				<input type="file" name="myfile" multiple />
				<input type="submit" value="upload"/>
			</form>
			<!-- not use -->
			<iframe name="frame1" frameborder="0" height="40" style="display:none;"></iframe>
	
			<div style="display:block;" >
			        <input type="file" name="file" id="file_upload" multiple >
			        <input type="button" value="上传" onclick="FileUpload()">
			</div>
	
		</div>
		<div class="closeW" onmousedown="closeWin(event)"  style=" "></div>
	</div>
	xx.css:
	.uppic{ display:block; width:80%; height:80%; background:#fff; position: fixed; left: 10%; top: 10%;
		margin-left: 0px; margin-top: 0px; z-index: 999; border-radius: 5px; }   
	.uppic div.Win{ float:left; width:100%; height:100%; background:#dddddd; text-align: center;}
	.uppic div.Win div.image{ width:80%;height:70%;overflow:scroll; margin:0 auto; background:#ddddee; text-align: center; }
	.uppic div.Win h3.title{ text-align: center; font-size: 22px; color: #ce002c; }
	.uppic div.closeW{ float:left; position:relative; background:#cc00cc; width:30px; height:30px; margin-left:-30px;  }
CSS class 与 ID 区别:
	id 是 一对一的 ,  class是 一对多的 
	目前的浏览器还都允许用多个相同ID，一般情况下也能正常显示，不过当你需要用JavaScript通过id来控制div时就会出现错误。	


<ing>自身有 width 和 height , 不一定用到 css上的, 当然css上的也起作用
	但是src 没有内容的情况下, 只显示 alt 的文字内容
	css 的background 没有起作用
	width 和 height 不设置,原尺寸显示
要使图片原尺寸显示,显示不到的又可以滚动显示,用div包裹,加 overflow:scroll;
	<div style="width:80%;height:70%;overflow:scroll;text-align:center; background:#ddddee;">
		<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
	</div>
	如果想单滚动条: 例如 overflow-x: hidden; overflow-y: scroll;
	但是滚动条会看到,很讨厌!!
	使滚动条消失,方法一,再包裹一个尺寸小一点div把里面div的滚动条隐藏掉
	<div style="width:800px; height:700px; overflow:hidden; ">
		<div style="width:820px; height:720px;overflow:scroll;text-align:center; background:#ddddee;">
			<img src="/static/img/eye_expression.gif" alt="coded message" ></img>
		</div>
	</div>
	注意: 第一个div width:800px; height:700px; overflow:hidden;
	      第二个div width:820px; height:720px;overflow:scroll;
	方法二:
	改css:
		scrollbar-3dlight-color:#fff; // 3d亮色阴影边框(threedlightshadow)的外观颜色
		scrollbar-highlight-color:#fff; // 滚动条3d高亮边框(threedhighlight)的外观颜色
		scrollbar-arrow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-shadow-color:#fff; // 滚动条方向箭头的颜色
		scrollbar-darkshadow-color:#fff; // 滚动条3d暗色阴影边框(threeddarkshadow)的外观颜色
		scrollbar-base-color:#fff; // 滚动条基准颜色
		scrollbar-track-color:#fff; // 滚动条拖动区域的外观颜色
	滚动条隐藏后操作: 滑轮 y轴；shift+滑轮 x轴;
div 居中与div内容居中: 更多扩展: https://www.thinkcss.com/jiqiao/1460.shtml
	div自身居中：
		使用margin:0 auto
		上下为0，左右自适应的css样式。
	div内容居中:
		1、div内容水平居中CSS： text-align:center
			无论是p还是div都可以对其设置此CSS实现对应对象内的内容水平居中。
		2、div内容垂直居中 行高属性：line-height
			要让div内只有一行的内容垂直居中，通常对div设置的height(高)与line-height(行高)相同，即可实现div内容垂直居中。








20180903
继续填坑:
节点学习:
	<div> XXXXX <span>cccc</span> llll <p>fff</p> kkk </div> oo <div>uu<div>
	对于第一个div来说:
	childNodes: 有 #test( XXXXX ), <span>, #text( llll ), <p>, #test( kkk ), 共 5 个子节点	(算上#text节点)
	children: 有 <span>, <p> 共 2 个子节点		(不算#text节点)
	firstChild 指向 #test( XXXXX ) 子节点		(算上#text节点)
	firstElementChild 指向 <span> 子节点		(不算#text节点)
	innertext 并不好分析,不可信
	lastChild 指向 #test( kkk ) 子节点		(算上#text节点)
	lastElementChild 指向 <p> 子节点		(不算#text节点)
	nextElementSibling 指向 <div>uu<div> 同级节点	(不算#text节点)
	nextSibling 指向 #test( oo ) 同级文本节点	(算上#text节点)
	previousElementSibling,  previousSibling 指向之前的,同理分析可知道具体指向
	parentNode 和 parentElement 一般都直接 指向相同的上级节点,没有据别
插入 html段落内容: insertAdjacentHTML(位置,字符串)
	段落内容写成字符窜 然后使用 insertAdjacentHTML 即可以插入解析
	但是注意 转义字符 的使用
	"&#09;&#09;&#09;<div class=\"spac\">&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;</div>&#10;&#09;&#09;&#09;<div class=\"igdd\">&#10;&#09;&#09;&#09;&#09;<img class=\"imgs\" src=\"" + src[f] + "\"&#32;alt=\"pic error\" ></img>&#10;&#09;&#09;&#09;&#09;<div class=\"imgi\">" + info[f] + "</div>&#10;&#09;&#09;&#09;</div>&#10;"
	例如这样的 使用了 &#09; 一类转义字符串,但是 html解析时会认可并转成相关字符 会构成#text 文本节点
还有注意常常用到的在节点里挖掘 class 子节点的做法:
	var ff = curNode.getElementsByClassName('tabPreviewer'),
	会得到 curNode 里 所有 class= "tabPreviewer" 的子节点
结合现阶段工作小结:
	接下来打算做的事:构思时间保存链,或者 写功能键内容.
	选择构思时间保存链, 学习体验使用参考区块链
另外建立了blockchain 实验:  lsgo技术团队
	git clone https://github.com/bitcoin/bitcoin.git
	cd bitcoin
	git tag		//查看版本
	git checkout v0.16.1	//选择没有 rc 的一个稳定版本
	git status	//查看版本
	//编译安装..... 后,有 bitcoind,bitcoin-cli两个主要命令, 还有自动建立~/..bitcoin 文件夹
	运行Bitcoin Core 客户端, 注意容易与curl冲突导致意外关闭!!
		bitcoind -printtoconsole	//前台执行 bitcoind初步会同步世界数据!!几乎有 130G!!! 草!!
		bitcoind -daemon		//后台执行
		bitcoin-cli stop		//关闭,切勿 ctrl+c  !! bitcoin-cli是辅助工具
	配置bitcoind
	gedit ~/.bitcoin/bitcoin.conf
	//一个完整索引节点的配置
		txindex=1
		rpcuser=bitcoinrpc
		rpcpassward=CHANGE_THIS
	//或者 这样 当设备资源有限时的配置
		maxconnections=15
		prune=5000
		minrelaytxfee=0.0001
		maxmempool=200
		maxreceivebuffer=2500
		maxsendbuffer=500
		rpcuser=bitcoinrpc
		rpcpassword=CHANGE_THIS
	重新运行 bitcoind 客户端 (Bitcoin Core 客户端), 并重建索引
		bitcoind -printtoconsole -reindex
	比特币核心客户端实现了 JSON-RPC 接口，这个接口可以通过命令行帮助程序 bitcoin-cli 访问，也可以通过编程的形式在程序中访问。
btcoin:使用到的密码学:
	hash:
		ripemd160:
		SHA-256: 几乎每个文件都有一个独一无二的 sha256编码,哪怕 文件之间只差几个字符!!都没有可能相同
			 其实说的是,两个完全不同的文件有极低概率sha256相同,但是两个相近的文件的 sha256 绝对不同!!
	密钥对包含了一个私钥和一个（由私钥导出的唯一）公钥。公钥被用来接收款项，私钥被用来签署一笔交易来花费比特币
	btcoin 构成交易的 要素, 私钥,公钥,钱包地址,
	生成一对公私钥的方法: 椭圆曲线乘法, RSA算法
	比特币的公钥是由私钥通过 椭圆曲线乘法 导出的	
	非对称加密: 公钥加密, 私钥解密 ； 私钥加密,公钥解密 ; 公钥无法推导出私钥
		数字签名:应用:
			1.Alice需要使用具体约定的算法（例如RSA）生成私钥和公钥，私钥自己保留，公钥对外公布。
			2.Alice想要发送消息 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。",
			  Alice使用自己的私钥对消息进行加密，例如加密后的密文是 SHG356g3T4+dh4fh，这个密文就是Alice的数字签名。
			3.Alice将消息明文和数字签名打包一起,并发送到网络中:
			 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			4.网络中的所有人接收到消息后，都可以进行如下操作完成验证：
			  收到消息 " Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。| 签名：“SHG356g3T4+dh4fh” "
			  使用提供的公钥 gh3giPGFN2jgh3sF 对数字签名 “SHG356g3T4+dh4fh” 进行解密
			  将解密结果与消息明文 "Alice已向Bob转账1BTC，请查收。| 我的公钥是：“gh3giPGFN2jgh3sF”。" 进行对比
			  如果一致，说明消息是Alice亲自发送的，因为只有Alice本人拥有Alice的密钥
			  如果不一致，则说明消息不是Alice发送的，或者虽然消息是Alice发送的但已遭到他人篡改
			问题: 如果黑客占线 发布同样的内容,但是发送黑客自己的公钥和自己生成的签名,
			那么网络人是分不清消息的来源的,可以把黑客误以为 Alice
		数字证书:
			自己生成的公私钥, 公钥向相关权威机构登记并公开,客户可以公开查询的,公私钥不再是随便生成的
python 的hash 计算:crypt hashlib
时间保存链构思:
	一张 conteid hsah表	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	一个用户, 有 一个行表数据表, 一个cnteid数据表, 一个流媒体文件目录
	一次保存过程, 获取所有变化的 行id数据 和 cnteid数据 再加上时间标签 再加上 10条最近 别人更新的记录(id + hash)刷一次hash值,
	不合理,黑客可以自己随时得到其他人的hash 然后更改自己的时间,然后生成自己的保存块,来欺骗
	构建这个算法要用演绎思维去想,从攻击者手段想如何修改得到合法的时间事件保存块!!!
	算法的核心是保证,保存时间的权威性!

骚操作: 
	ls -lc -t	//查询当前目录下的文件及最后修改时间
	df -hl命令查看磁盘占用情况
	sudo du -sh * 命令查看当前目录下文件的大小
	du -sh .[!.]* 命令查看所有隐藏文件的大小
	频繁利以上两个命令，可追溯想要的文件








20180906
学习了相关 加密算法,发现现阶段构建时间保存链 实在太浪费时间, 还是先优先完成前端基本功能:
	接下来 ,功能按键, 完成媒体文件的修改,提交!!
	还有 批量行处理, 滑轮显示总行数!!
关于 event 的深入
	例如: onmousedown 事件
	e.currentTarget 指的是 设置了 被设置响应事件的 节点 往往一个节点设置了事件, 事件发生时就会显示这个节点
		例如, <span class="newl" onmousedown="cntebar(event)">事件响应时, e.currentTarget一定是 这个设置了事件的span
	e.explicitOriginalTarget 得到的是 具体点击落在的的节点
	e.originalTarget 得到的是 具体点击落在的节点 的 父节点!!
		例如:
<div Id="main" contenteditable="true" onmousedown="point(event)" >
	<div class="vido" cnteid=600 cntety=5 ><span class="svdl" onmousedown="cntebar(event)">&nbsp;</span>15:
		<div class="vidd">
			<video width="320" height="240" controls>
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi">amimal</div>		
		</div>
	</div>
</div>
	设置事件的是 main, 但当鼠标点击落在 animal的 字符串里时, 	explicitOriginalTarget 指的是#text节点, originalTarget指的是 vidi节点
	当鼠标落在 非视频,非animal的字符串时, 即 15 行的空白处时! explicitOriginalTarget 指的是vidd节点, originalTarget也指向 vidd节点
	刚处理完所有按键问题,和 点击问题,发现 还缺一类行数据, 就是 标题行数据
	所以需要规划添加这类行媒体数据格式!! 然后重新调整所有按键操作
	然后就是 媒体行数据的生成页功能,然后ctrl+cv 然后是批量插入,删掉行数据, 
	还有一个就是 方向键操作后的屏幕跟随, 和 滑动显示的 加载行数 !!
	最后是保存上存!!然后就开始做服务器了!!保存到服务器,需要数据回滚操作, 以防保存失败!!!
event 和 this 
	onclick等事件,不仅仅传递event 还可以传递 this, this就是 设置 onlick 的节点!!
	例如 onclick="kkk(this,event)"  function kkk(t,e){}, t和e是自己取的名字,位置对应this,event参数


现在发现 css 关于位置关系的描述非常重要!!需要学习掌握!!










20180913
css位置学习:
CSS 框模型
	---------------------------------------------------------
	|                  外边距 margin (空白透明)              |
	|      ------ 边框 border (线,点,透明)--------------     |
	|      |           内边距 padding (空白透明)       |     |
	|      |      ----------宽 width -----------      |     |
	|      |      |                            |      |     |
	|      |      |                            高     |     |
	|      |      |         element          height   |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      |                            |      |     |
	|      |      ------------------------------      |     |
	|      |                                          |     |
	|      |                                          |     |
	|      --------------------------------------------     |
	|                                                       |
	|                                                       |
        ---------------------------------------------------------
padding 与 margin 的设置方式
	margin: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	margin: 20px			// 统一 20px 的边距
	margin-top: 10px;
	margin-right: 0.25em;
	margin-bottom: 2ex;
	margin-left: 20%;
	padding: 10px 0.25em 2ex 20%;	// 上 右 下 左  尺度还可以cm
	padding: 20px			// 统一 20px 的边距
	padding-top: 10px;
	padding-right: 0.25em;
	padding-bottom: 2ex;
	padding-left: 20%;
	
border设置:
  	border:5px solid red;		//边粗, 边样式, 边颜色
	独立设置:
	border 	简写属性，用于把针对四个边的属性设置在一个声明。
	border-style 	用于设置元素所有边框的样式，或者单独地为各边设置边框样式。
	border-width 	简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。
	border-color 	简写属性，设置元素的所有边框中可见部分的颜色，或为 4 个边分别设置颜色。
	border-bottom 	简写属性，用于把下边框的所有属性设置到一个声明中。
	border-bottom-color 	设置元素的下边框的颜色。
	border-bottom-style 	设置元素的下边框的样式。
	border-bottom-width 	设置元素的下边框的宽度。
	border-left 	简写属性，用于把左边框的所有属性设置到一个声明中。
	border-left-color 	设置元素的左边框的颜色。
	border-left-style 	设置元素的左边框的样式。
	border-left-width 	设置元素的左边框的宽度。
	border-right 	简写属性，用于把右边框的所有属性设置到一个声明中。
	border-right-color 	设置元素的右边框的颜色。
	border-right-style 	设置元素的右边框的样式。
	border-right-width 	设置元素的右边框的宽度。
	border-top 	简写属性，用于把上边框的所有属性设置到一个声明中。
	border-top-color 	设置元素的上边框的颜色。
	border-top-style 	设置元素的上边框的样式。
	border-top-width 	设置元素的上边框的宽度。	
margin 外边框合并!!!
	位置相邻的两个元素,不管是 同阶级关系,还是父子关系, 只要他们都设置了margin 而且是两者的margin相贴合,那么就会发生合并
	保留参数值大的margin,消灭调参数值小的margin 	
块元素,行元素
	div、h1 或 p 元素常常被称为块级元素。这意味着这些元素显示为一块内容，即“块框”。
	与之相反，span 和 strong 等元素称为“行内元素”，这是因为它们的内容显示在行中，即“行内框”
	display 设置为 block，可以让行内元素（比如 <a> 元素）表现得像块级元素一样
	display 设置为 none，让生成的元素根本没有框,即该框及其所有内容就不再显示，不占用文档中的空间。
CSS 有三种基本的定位机制：普通流、浮动和绝对定位	
	除非专门指定，否则所有框都在普通流中定位。
	块级框 从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。
	行内框 在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。
		垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），
		行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。
position : relative 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。
	relative 配合 top,left,right,bottom 方位属性 使用
	position:relative;left:20px;	//表示 元素在原始位置的基础上,从元素的原始左侧位置加上 20px ,相当于向右移动 20px
					//但是原始位置保留, 即下一个元素的原始位置,根据这个元素的原始位置决定
	relative 是 普通流机制的一部分, 原始位置也是 普通流机制的内容`
position : absolute 按绝对坐标定位 它原本所占的空间不保留。	
	absolute 配合 top,left,right,bottom 方位属性 使用
	position:absolute;left:100px;top:150px;		//以页面 左 上 角为原点,水平加100px,垂直加150px
					//即以左上角为原点,向右移动100px,向下移动150px的位置
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
	position:absolute;left:100px;	//以页面 左 上 角为原点,水平加100px,即以左上角为原点,向右移动100px
					//这里只定义了 水平位置的绝对坐标, 垂直位置绝对坐标没有定义.
					//所以垂直位置 按 原始位置的垂直位置排位, 把这个垂直位置作为绝对坐标
					//元素的原始位置不占位保留, 即下一个元素的原始位置,不根据这个元素的原始位置决定
position : fixed 固定定位,这是根据浏览器窗口来定位的, 同样, 与absolute 一样是固定定位,
	不保留原始位置!!, 不对往后的元素的位置有影响. 永远保持显示在最前位置!!
position : static（静态定位）：就是普通流的获得的 原始位置,而且忽略 top, bottom, left, right 或者 z-index 声明的参数!	

overflow: 块元素内容 溢出的显示对策
	visible 默认值。内容不会被修剪，会呈现在元素框之外。
	hidden 	内容会被修剪，并且其余内容是不可见的。
	scroll 	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
	auto 	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
	inherit 规定应该从父元素继承 overflow 属性的值。
clip: 只有 position:absolute 绝对定位的元素, 才可以被clip 裁剪显示元素的展示空间即配合 absolute 使用
	position:absolute;left:100px;clip:rect(0px 50px 200px 0px)	//显示局对定位的元素 50*200 空间 内容
	值:
	shape 	设置元素的形状。唯一合法的形状值是：rect (top, right, bottom, left)
	auto 	默认值。不应用任何剪裁。
	inherit 	规定应该从父元素继承 clip 属性的值。	
vertical-align 属性设置 同阶级 元素间 的垂直对齐方式 ,不是设置在父元素上,而是设置在有需要的子元素上
	baseline 默认。元素放置在父元素的基线上。
	sub 	垂直对齐文本的下标。
	super 	垂直对齐文本的上标
	top 	把元素的顶端与行中最高元素的顶端对齐
	text-top 把元素的顶端与父元素的 #text 的顶端对齐
	middle 	把此元素放置在父元素的中部。
	bottom 	把元素的顶端与行中最低的元素的顶端对齐。
	text-bottom 	把元素的底端与父元素的 #text的底端对齐。
	length 	 例如 20px -10px
	% 	使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。
	inherit 规定应该从父元素继承 vertical-align 属性的值。
text-align: center;对子元素的对齐要求,设置在父元素上
z-index 元素所在的 显示层数, 层数越高元素遮挡层数低的元素
	如果元素不是绝对定位! 层数不管怎样变化,元素的原始位置依然没有改变!!
	所以 z-index 一般是配合 position:absolute 使用的!!

css 浮动:
	html 排布 有 3个次元 普通流 浮动 绝对定位
	普通流
		默认的元素是按照 html 文本流 一个一个相互影响地排列着 ,这是这时普通流的 元素排列
		普通流的方式下, 每个元素都有自己一个对应的原始位置!!
		即使使用了 relative 每个元素的实际所在位置有了偏移, 但是其原始位置是保留下来,对其他元素的位置有影响的!! 
		默认下普通流的 所有元素都 位于 z-index:0 这一层, 但是文本流 往后元素 可以遮盖 往前元素
		除非 往前元素主动设置z-index > 0 或者 > 往后元素的z-index , 往前元素 才有机会遮盖 往后元素 !
	绝对定位	
		如果只是 absolute 但没有水平/垂直坐标, 会先从文本流得到原来应该的原始坐标作为绝对坐标,
		但是并不保留自己的原始坐标,所以下个元素的原始坐标 与这个定义了absolute的元素没有关系!
		拓展例子: 
			<div>普通1</div>
			<div>绝对2</div>
			<div>普通3</div>
			<div>绝对4</div>
			绝对定位的例子只是position:absolute; 并没有设置水平垂直位置. 这时:
			绝对2 的 原始位置 根据 普通1, 普通3 原始位置 也是根据 普通1 而不是绝对2,所以
			<div>绝对2</div>,<div>普通3</div> 的原始位置都是同一个位置上,普通3 遮盖 绝对2,因为普通3元素比绝对2靠后
			绝对4 的位置是 根据 普通3,普通1,的原始位置得到的,与 绝对2 没有任何关系 
		虽然只是坐标关系变化了, 但是显示的先后顺序还是按着文本流 元素出现的先后顺序来,
		默认下绝对定位 的元素 也都 位于 z-index:0 这一层 文本流 往后元素 可以遮盖 往前元素,也是改z-index改变遮盖关系 
	浮动:
		经过实验,发现浮动,是普通流的升级板,例子说明:
		不使用float,普通流: div元素的排布:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------
 			|        |
			|    2   |
			|        |	
			----------
			--------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1使用 float:left 时:
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |
			|          |  |        |
			|          |  ----------
			------------  --------
			              |   3  |
			              |      |
			              --------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素2使用 float:left 时:
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			----------   --------
 			|        |   |   3  |
			|    2   |   |      |
			|        |   --------
			----------   ----------
 			             |        |
			             |    4   |
			             |        |	
			             ----------
		元素1,2使用 float:left 时:
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4)
 		元素 1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4)
			------------  ----------  --------
			|          |  |        |  |   3  |
			|     1    |  |    2   |  |      |
			|          |  |        |  --------
			|          |  ----------  ----------
			------------              |        |
			                          |    4   |
			                          |        |				
			                          ----------
		元素1,2,3使用 float:left 时: (假设页面宽差一点而不能容纳元素4, 元素3高度变得与元素2一样高 )
		元素1,2,3,4使用left时: (假设页面宽差一点而不能容纳元素4,元素3高度变得与元素2一样高 )
			------------  ----------  --------
			|          |  |        |  |      |
			|     1    |  |    2   |  |   3  |
			|          |  |        |  |      |
			|          |  ----------  --------
			------------  ----------
			              |        |
			              |    4   |
			              |        |				
			              ----------
		元素1,2,3使用 float:left 时, (假设页面无限宽)
		元素1,2,3,4使用left时: (假设页面无限宽)
			------------  ----------  --------  ----------
			|          |  |        |  |   3  |  |        |
			|     1    |  |    2   |  |      |  |    4   |
			|          |  |        |  --------  |        |
			|          |  ----------            ----------
			------------          
		元素1 使用 float:right 时,	
			----------             ------------
 			|        |             |          |
			|    2   |             |     1    |
			|        |             |          |
			----------             |          |
			--------               ------------
 			|   3  |
			|      |
			--------
			----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2 使用 float:right 时,
			--------     ----------  ------------
 			|   3  |     |        |  |          |
			|      |     |    2   |  |     1    |
			--------     |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------	
		元素2 使用 float:right 时,
			------------
			|          |
			|     1    |
			|          |
			|          |
			------------
			--------                   ----------
 			|   3  |                   |        |
			|      |                   |   2    |
			--------                   |        |
			----------                 ----------
 			|        |
			|    4   |
			|        |	
			----------
		元素1,2,3 使用 float:right 时, (假设页面宽差一点而不能容纳元素4,)
			   --------  ----------  ------------
 			   |   3  |  |        |  |          |
			   |      |  |    2   |  |     1    |
			   --------  |        |  |          |
			----------   ----------  |          |
			|        |               ------------
			|    4   |
			|        |	
			----------
		也就是说 float 也是 普通流的一种扩展形式, 设置了float的元素, 原始位置也是根据float发生了变化
		影响到 普通流 的其他元素的 原始位置!!
		float还可以配合 clear使用:
		元素1,2,3,4使用left时, 元素3使用了clear:left: (假设页面无限宽)
			------------  ----------
			|          |  |        |
			|     1    |  |    2   |	//其实就是说 3 左边不能紧接着 float:left 的元素  
			|          |  |        |
			|          |  ----------
			------------ 		
			--------  ----------
			|   3  |  |        |
			|      |  |    4   |
			--------  |        |
			          ---------- 		
		同理,  clear:right;  其实就是说 元素 右边不能紧接着 float:right 的元素
		clear:both; 就是 左边不能紧接着 float:left 的元素, 右边不能紧接着 float:right 的元素!!
		clear:both; 就是 左边可以紧接着 float:left 的元素, 右边可以紧接着 float:right 的元素!!
		文字段 #text 与 float元素的的位置关系也是值得 讨论 例如:
			<div id=1>...</div>
			<div id=2>~~~~~~~~~~~~~~~~~~~~..... <img>3</img><div>
			其中 div1 float:right,
			其中 div2 text-align:center; 假装---是文本,最后还有一张图片3,
			就会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
		这样子的话也一样`:
			<div id=2>
			<div id=1>...</div>
			~~~~~~~~~~~~~~~~~~~~..... <img>3</img>
			</div>
			其中 div1 float:right,
			其中 div2 text-align:center;
			div1, 文字段 ~~~~~, 图片3 都是 div1 的子元素
			也会出现 :	
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~   |          |
				~~~~~~~~~~~~~~~  |     1    |
				  ~~~~~~~~~~~    |          |
				~~~~~~~~~~~~~~~  |          |
				~~~~~~~~~~~~~~~  ------------
				 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				                  ------
				                  |    |
				     ~~~~~~~~~~~~~|  3 |
				                  ------
			注意	text-align:center; 都是对于一行内容来说的,
				对于有 float占据空间的 的 行 文字居中不算 float占据空间 例如 第2,4行明显
				如果文字与某些非float元素 同阶级, 元素排版时算作文字中的一员,共同实现居中
				图片3 与 文字共存的一行, 图片决定行高,文字和图片一起居中	
				图片3 是内联元素，如果是<div>,就不会出现最后的居中显示 ！！！而是div另外一行！！
display:
	inline: 相当于 <p>AA</p> <p>BBB</p> 能以 <p>AABBB</p> 显示
		------
		| AA |              ---------
		------       --->   | AABBB |
		-------             ---------
		| BBB |
		-------
		一般 <span> <a> 称为内联元素, 因为他们 即使默认情况下,不用设置 dispaly:inline时,
		 <span>AA</span> <span>BBB</span> 也会以 <span>AABBB</span> 显示 !!
	block: 对于 内联元素<span> <a> 等设置 dispaly:block时,内联元素的排版如 <div> <p> 这些快元素一样 一个元素占一行,
		                      ------
		                      | AA |
		---------             ------
		| AABBB |    --->     -------
		---------             | BBB |
		                      -------
	inline-block: 对于 每一个元素都看作 块元素, 然后把块元素放在 同一行上 !!
		即 <p>AA</p> <p>BBB</p> 不以 <p>AABBB</p> 显示, 而是 <p>AA</p> <p>BBB</p>
		   <span>AA</span> <span>BBB</span> 不以 <span>AABBB</span> 显示, 而是 <p>AA</p> <p>BBB</p>
		------
		| AA |              ------ -------
		------       --->   | AA | | BBB |
		-------             ------ -------
		| BBB |
		-------

		---------           ------ -------
		| AABBB |    --->   | AA | | BBB |
		---------           ------ -------
		注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
			如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
			所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

	none:	元素不会计入页面排版,不占用位置,所以也不就不能显示, 
		对应类似属性: visibility:hidden, 但是这个属性会把元素计入排版,即会占用位置只是不显示
	注意 inline 说的是元素被假装看作字符,所以特别注意两个元素对象中间隔着的换行空格符号,在浏览器里一律以一个空格显示
	这时但你想两个元素对象紧贴时,你会发现两个inline元素对象 死活不贴在一起,不是设计magin的问题,而是中间隔了个空格的问题!!
	
dispay:flex  display新属性!!,弹性布局,是容器属性, 即设置在父元素上的.
	子元素的float、clear和vertical-align属性将失效。
	display:flex 需要配合以下属性,一起使用
		flex-direction　　容器内项目的排列方向(默认横向排列)　　
		flex-wrap　　容器内项目换行方式
		flex-flow　　以上两个属性的简写方式
		justify-content　　项目在主轴上的对齐方式
		align-items　　项目在交叉轴上如何对齐
		align-content　　定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
	详细: https://www.cnblogs.com/xuyuntao/articles/6391728.html
对子内联元素/(文本内容),强制不转行,父元素添加:
		style  white-space:nowrap;
		(默认一般自动转行)自动换行:word-wrap:break-word;  


		
综合使用: margin: auto;
	  width: 50%;
	  text-align: center;
	    display: block;
	    position: absolute;
	    right: 0px;
	    width: 300px;
	    padding: 10px;
	    float: right; 	
	    overflow: auto; 	
	    line-height: 200px;
	    height: 200px;
	    display: inline-block;
	    vertical-align: middle;
	    top: 50%;
	    left: 50%;
	可以实现各种对齐居中,,









20180914
前提
	额外js 保存全局变量
	以下框都允许点击并输入数据 称为合法文本框
		spac edtx hdda hdti imgi mati adoi vidi
	合法文本 imgi mati adoi vidi 复杂 \n\r处理,
		一般加\n 如果文本末加\n必须紧接加上\r
		一般退格 删 连续个\r与最前\r前的一个字符
		具体按键具体分析:
修正点击和按键操作 !!!
	base:mousu(event) , base:mousd(event) , base:mousm(event)配合使用,
	   √	mousd 先行任务: 合法文本 hdda hdti imgi mati adoi vidi 是否空,空则补上 <nothing>
	   √	实现基本鼠标点击动作,
	   √	能避免光标落入禁区,
	   √	点击标记色指定打开 contentbar
	   √	可做简单文本拖选, 
	  hold	一些地方的点击效果未理想{暂时不处理}
	keyboard.js : keypress(event) : 预处理
	   √	弹窗删除媒体行相关预处理
	   √	sel非空,才接下一步工作
	   √	sel是光标,才接下一步工作	
	keyboard.js : keypress(event) : spec优先处理:
	   √	spec只接受 空格和\b, 并优先处理, 方向键不在 keypress 处理, 
	   √	退格处理,永远不能让spac没有内容!!
	keyboard.js : keypress(event) : 简单的 fixl判断处理: 
	   √	keypress 前方讨论 提高输入速度  不谈论 \r \b 等 keypress部分按键, 后面会详细讨论
	   √	spac不处理,spac以外的合法文本框处理
	   √	不是undefine的按键都算字符输入, 需要改 fixl
	   √	onkeypress 似乎不识别 ctrl shift capslock, 而基本功能键为undefined,例如方向键
	keyboard.js : keypress(event) : \r(回车):
	   √	spac hdda hdti不处理
	   √	合法文本 imgi mati adoi vidi 生效:
	   √		复杂 \n\r处理: 文末加\n\r,不是文末加\r 	统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √	edtx 生效: 插入newl, 都不改变 cnteid 和 oid
	   √		\r作用行有机会变 fixl,插入行是newl,
	   √		其他行对齐:svdl,orgl变wrpl,wrpl有机会变回svdl,而newl,fixl不变
	 hold	屏幕跟随光标显示
	keyboard.js : keypress(event) : \b(退格):
	   √	spac不处理,多此一举
	   √	合法文本  hdda hdti imgi mati adoi vidi 同样的处理,
	   √		复杂\n\r处理,循环检查光标前有多少个连续\r,一次过删掉多个连续\r和\r前的一个字符
	   √			\r前是文本起点,则只退到文本起点文本起点
	   √			统一变fixl,或保持newl 不改变 cnteid 和 oid
	   √			由于 hdda hdti 没有 \n 或 \r， 所以会自动绕过 \n\r处理
	   √		当回到尽头不操作,当空标记为空文本 
	   √	最后 edtx...
	   √		尽头时,删除当前行,把余下的文本接入上一行
	   √		遇到媒体行, 光标依然处在文本行,弹窗询问是否删除遇到的媒体行,抬起,再按一次\b实现删除,
	   √			实现这个功能现在不能笼统写成一个模快,各种边沿代码遍布各处,其他地方标明 弹窗删除媒体行相关
	   √			分布:keypress开头预处理, \b段贯穿全部, closeWin部分
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : tab键
	   √	实现 tab 缩进
	keyboard.js : keydowm(event) : 方向左
	   √	合法文本 spac hdda imgi mati adoi vidi: 左到尽头不作为 
	   √	hdti : 左到尽头到 hdda
	   √	edtx : 左到尽头, 跳到再上一个文本行的文本末位置, 最初文本行文本初位置不作为
	   √	合法文本 imgi mati adoi vidi  复杂\n\r处理,
	   √		循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点
	keyboard.js : keydowm(event) : 方向右
	   √	合法文本 spac hdti imgi mati adoi vidi: 右到尽头不作为 				
	   √	hdda: 右到头到 hdti
	   √	edtx : 左到尽头, 跳到再下一个文本行的文本初位置, 最后文本行文本末位置不作为
	   √	所有都有 复杂\n\r处理,循环检查光标前有多少个连续\r,一次跨过多个连续\r和\r前的一个字符组成的字符串,
	   √		\r前是文本起点,则只跨到文本起点		
	keyboard.js : keydowm(event) : 方向上
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再上一个文本行同样的文本偏移位置, 溢出跳到文本末, 最初文本行不作为
	 hold	屏幕跟随光标显示
	keyboard.js : keydowm(event) : 方向下
	   √	合法文本 spac hdda hdti imgi mati adoi vidi: 不作为 				
	   √	edtx : 跳到再下一个文本行同样的文本偏移位置, 溢出跳到文本末, 最后文本行不作为
	 hold	屏幕跟随光标显示
修组合键操作操作 !!!	（hold）
	ctrl + cv
特殊操作:	（hold）
	媒体元素上滑鼠,放大显示尺寸
	页面上滑鼠, 显示已加载的起始行~结束行







20180918
完整修正媒体生成
前提：
	base:mousu(event) 已经讨论，
	   √	点击标记色指定打开 contentbar
	base.js : closeWin(e)	弹窗关闭 处理
	   √	检查并关闭 媒体删除弹窗 
	   √	检查并关闭 各类媒体生成弹窗
	base.js : upmed(e) 
	   √	打开指定媒体生成弹窗
	base.js : mmedial(event) :
	 doing	媒体生成弹窗 加载好的内容插入行
	...
继续学习css h3 
	注意 width height 关于% 的层次关系, %是相对父元素的!!
	默认margin-top/bottom > 0 ！
	font-size:6vh;  //vh vw 是字体大小等于浏览器screen的 width height 的%比例例如 6%height
	text-align: center; 只对父元素内的 内联元素和#text起作用，对于块元素不起作用
		例如 文本 + <audio> <img> 会显示在一行并居中
		     文本 + <div> + <p>  <div> 和 <p> 都会另一行显示
		     所以 对于子块元素的居中使用 margin: 0 auto; //上下没有间距，左右间距一样
	关于 form 和 input 的关系:
		input是内联元素,是放入line上的内容. 而 font-size:6vh; line-height:6vh; 是描述 line 和文字的高度的
		内联元素都可以被看成特殊的行文本文字,内联元素的位置 与 父元素的 font-size line-height 设置有紧密关系!!
	就是说 font-size, line-height 可以控制内联元素的位置
	注意使用了 display:inline-block；就是 块被当作了内联元素内容显示,
		如果相邻的两个块元素设置成内联显示, 他们就相当于文本,他们之间隔着的空白字符会成为他们两的间距
		所以要相邻的两个内联块元素没有间隔,要么之间没有空格转行tab字符,要么他们共同的父元素设置 font-size:0;

继续学习js
	iframe relaod:
		window.location.reload(true); 
			//如需刷新iframe，则只需把window替换为响应的iframe的name属性值或ID属性值
			//  https://www.jb51.net/article/65013.htm  
继续学习python:
	python中是没有NULL的，取而代之的是None
	python是把0，空字符串‘’和None都看作False，把其他数值和非空字符串都看作True
		给一个文字串变量里不停加东西!!可以这样子:
		str1 = ""
		for f in files
			str1 += ("helloworld" + str2 + f.name)
这里修正的内容要一个个流程来记录：
	上传插入音频
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入视频:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed	upload 把数据上传服务器!!
	 writed		服务端接收媒体文件 upload_media
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!	
	 writed	ok : mmedial 把 音频数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传插入图片:
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed	文件选择后, 触发onchange事件 choosed(e),把本地文件路径加载到弹窗 !!
	 writed		form 通过 onsubmit 设置监测函数, afterupload
	  hold			监视整个传输过程, 
	 writed			直到传输完毕,返回 iframe数据, 并提取数据(远程文本路径)
	 writed			覆盖本地文件路径,把远程文件路径加载到弹窗!!
	 writed	ok : mmedial 把 pic数据插入行!!
	 writed		关闭页面前,恢复素材添加页面!!
	上传公式:
	   (jmeditor要点:jme.js onok 告诉如何获得和处理公式,不过是通过jqurey 方式!!)
	 writed	upmed 打开媒体生成行弹窗	
	 writed	修正了弹窗样式显示,
	 writed		funcedit 写公式
	 writed		funcview 预览公式
	 writed		- + 添加/减少写好的公式, 可以点击高亮要加删的位置
	 writed		ok 添加到行数据 !!  恢复默认页面(iframe使用reload)
	上传主题:
	 writed	修正主题行:
	 writed		主题行 标题过长隐藏, 使用的 overflow:hidden; 还有 margin-bottom:-0.4em 微调位置
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示,
	 writed		ok 添加到行数据 !!  恢复默认页面 (iframe可以使用reload)
	 writed		主题优先处理 空白内容 按 ok 的 问题!! nullmed 处理
	上传五线谱:
	 writed	upmed 打开媒体生成行弹窗
	 writed	修正了弹窗样式显示, 并排显示效果不理想,还是竖排比较好
	 writed		有教程链接,
	 writed		textarea 按键触发,自动更新乐谱
	 writed		ok 添加到行数据 !!  恢复默认页面  textarea 的 value 值放文本
	添加/缩减行:(当紧邻的行是媒体行时特别有用)
	 writed	+ 后插入一行
	 writed	- 删除当前一行,
	 writed		删除文本行
	 writed		删除媒体行 (借助 \b按键)
			发现了一个大坑:
`				//   sel一直存在的, 但sel的内容可以是null 
				//   当js函数 中 sel.removeAllRanges() 只是把sel的内容设置null
				//   当js函数完毕后 不会默认处理 sel
				//   但是 js 不管是否执行了 e.preventDefault(), js完毕后, sel的内容都不会被另外处理
				//   event 与 sel 是有区别的
				//   特别注意 js 执行了 e.preventDefault(), js完毕后, 之前的获得的 event 没有释放
				//   所以 可以简单重新 触发 同样的 js !!
				//   比如 div id=klj 设置了一个keydown2,当在点击这个div时,sel指向当前div 并生成 event 
				//   按键时会触发keydowm2,例如打开了一个窗口, 而且例如 keydown2 会 把sel指向其他div
				//   如果 keydown2 执行了 e.preventDefault(), 则keydown2结束后, event斌没有自动消除,
				//   下一刻,按键时,即使 sel不指向当前div, 由于event还在,所以会继续触发这个div 的 keydown2
				//   再下一刻, 鼠标点击其他div 这时,keydown2 没有清除的event 会被 鼠标点击默认事件清除
				//   并获得新的 sel 和 event!!!
				//   页面上的逻辑解释 (糊涂做出来的逻辑,狗屎运)
				//	注意 页面上 按键是 main 元素设置的 , 而其他弹窗独立于 main 元素,
				//	点击 标记色时, 传递js 的是 main 的 event, 标记色打开了独立于 main 的 contentbar
				//	标记色js 执行e.preventDefault(), 标记色js结束后 没有清 event
				//	打开了 contentbar 后, 点击+ - 会传递  contentbar 的 event 到 lineadd-js
				//	这时 lineadd-js 也 执行e.preventDefault() 没有清 event
				//	lineadd-js结束后,     现在 event 存在 main-event 和 contentbar-event
				//	这时,我们可以任意继续 触发 注册在 main 的js ,或则	注册在 contentbar 的js	
				//	而不需要关注 sel 是否也指向同样的位置!!	
	closewin 时恢复素材添加页面
	 writed	所有媒体行窗口关闭时都处理
	ok按键 nullmed 处理!!  (主要在 mmedial 添加处理)
	 writed	pic aud pic 未选择,没有名字,未上传 nullmed	(与服务器设计相关,移植别的服务器请修改mmedial)
	 writed	func 没有函数,函数没有名字,nullmed	//已解决 有bug  第二次无法upfuc 其实是 fucitem 问题, mmedial结束前 fucitem = null
 	 writed	tit  有空白框没填 nullmed		//已解决 有bug <nothing> 问题, 
							//已解决 所有非edtx合法文本都有<nothing>问题, 修改 legalTEmpty 赋值解决
							//已解决 tit独有的 bug ,date title 与 方向左右 与 <nothing>
							//已解决 tit 去 \n\r
	 writed	stv 文本没有内容 nullmed
	媒体行 打开 同样的添加页面, 加载已有内容 修改 upmed
	 writed	tit	
	 writed	fuc
	 writed	stv
	skipped 做着做着才发现, 加载已有的 pic aud vid 没有意义!!因为,使用input type=file type=submit 的关系
至此,实现所有基本编辑功能!!! (仅 firefox)
后续发现bug
	非edtx的合法文本去掉所有字符后再加上新字符也会变nothing,只有不清除所有字符的情况下才不会变















20180929
检修,并开始写 后端
	已解决 tab bug: <div><br></div> 无法添加tab  已解决
安装 pycharm
	https://blog.csdn.net/qq_38683692/article/details/79868391
由于是社区板,没有django套件,不过没关系,我就要它的编辑界面,其他都终端编译,
在所在目录新建一个pycharm工程就可以链接整个文件夹,使用 pc 的文本编辑器方便编译,至于其他功能还是 终端实现
取消自动保存,加星号标记 修改未保存

设计一个`独立的页面使用
	loadlast.html
	base1.js	//拷贝复制base的内容,抽出window.onload
	ready.js 	//专门处理 window.onload()
		使用 $.get( "loadfile", fuction(data.status,xhr){readyloadfile(data.status,xhr)} )
		成功回调函数需要 完全定义在 get 里, 然后调用外部函数 readyloadfile() 执行其他操作
	urls.py  views.py 	//添加	loadlast.html , loadfile 请求处理!

每个用户都有自己的数据表,所以,需要动态建表的能力!!
https://blog.csdn.net/siete/article/details/6170755
https://www.cnblogs.com/kimyeee/p/7241754.html
https://blog.csdn.net/weixin_42134789/article/details/80194488

django 添加 .py 文件,跟普通python添加文件一样不需要另外特别注册
	for 文件夹 import py文件
		py文件.函数()
	for 文件夹.py文件 import 函数
		函数()
	for . import XXX    //从 当前文件位置 加入 XXX
	
	sql命令笔记:
		删除table sql语句:
			drop table web_kate_line;
			删表原则,先删子表,再母表
		查看表内容:
			select * from web_kate_line

关于django 动态建立数据表的 问题,非 通过manager migrate 这样静态指令初始化
	经过痛苦的分析过程,高度怀疑是 BaseDatabaseSchemaEditor.create_model(model) 实现动态建表
	但未知 model具体指什么,
	从源码 发现 model 类似构造
    class Migration(models.Model):
        app = models.CharField(max_length=255)
        name = models.CharField(max_length=255)
        applied = models.DateTimeField(default=now)

        class Meta:
            apps = Apps()
            app_label = "migrations"
            db_table = "django_migrations"

        def __str__(self):
            return "Migration %s for %s" % (self.name, self.app) 
	那么 在 models.py 构造的就是可以填入的 model
	那么一个可用的 动态建表的代码像这样:
		class kate_line(models.Model):
		    name = models.CharField(max_length=255,verbose_name='kname')
		    introduce = models.CharField(max_length=255,verbose_name='ksobject')
		from django.db import connection
		with connection.schema_editor() as editor:
		    editor.create_model(kate_line)
		// connection 与 BaseDatabaseSchemaEditor 的关联如上 connection.schema_editor()
		//一定要用 with 因为涉及 __enter__ 和缺参数的问题
		//python __enter__() 问题:https://www.cnblogs.com/DragonFire/p/6764066.html
		//不能直接 connection.schema_editor().create_model(custom_model)
	创建了数据表,添加数据内容:
		base = kate_line(name = 'bilibiliai',
		                 introduce = 'i still love u'
		                 )
		base.save()
		// django 使用 ORM 的方式 访问 数据库
		// 所以 可以这种方式 给 数据表 web_kate_line 写入数据 bilibiliai i still love u
	另外脱离 models.py那种固定方式,可以使用参考dy_model_creat.py 的 create_model 这种自己建立一个class出来!! 
建立一个保存按钮:页面右下角,鼠标移到显示,移开隐藏:
	onmouseover="this.style.opacity=1;" onmouseout="this.style.opacity=0;"
	点击,收集,并上存.json文件!!
新的技术点,自建文件,并上传!!
参考:
	上传显示进度: https://newsn.net/say/jquery_ajax_upload.html
	生成文件: https://www.jianshu.com/p/e7c7a8e4e9dc
	参考:	https://blog.csdn.net/xcymorningsun/article/details/52949848
		https://coderanch.com/t/549940/languages/generate-xml-file-submit-action
		https://stackoverflow.com/questions/6066837/how-to-write-data-from-form-in-html-to-xml-with-javascript
		https://blog.csdn.net/commandboy/article/details/55680654
	frommdata: 重点有即时处理: https://www.javascripture.com/FormData
	blob才是我需要的??:		https://robertnyman.com/2013/02/11/using-formdata-to-send-forms-with-xhr-as-keyvalue-pairs/
	用blob发即时图片,django后端获得:	https://stackoverflow.com/questions/48097297/upload-an-image-blob-from-ajax-to-django
	js blob 大文件分片传输:		https://www.jianshu.com/p/4d014a45aaf7
	filereader 读取file但是读取的 都是从input choose 获得的文件:	 https://www.cnblogs.com/tianma3798/p/5836484.html
	
	非常直观填了新坑 !! https://blog.csdn.net/hsany330/article/details/52575459
	不过还有 new file 的问题 active...
新坑: File、FileReader、Blob、Fromdata 对象
	一般 file对象是来自用户在一个 <input> 元素上选择文件后返回的FileList对象，也可以是来自由拖放操作生成的 DataTransfer对象
		FileList {0: file, 1: file, length: 2 }
			length: 2
			0: file
				lastModified: 130989987997
				LastModifiedDate: Thu May 26 2011 23:59:00 GMT+0800
				name: "aa.jpg" 
				size: 902047
				type: "image/jpeg"
				webkitRelativePath: ""
				__proto__: File
			1: file
			__proto__: FileList
	FileReader 对 file 对象 blob 对象的 处理过程对象 例子
		var reader = new FileReader();
		reader.onload = function() {
		    console.log(this.result);
		}
		reader.readAsDataURL(file);	//这里是 通过FileReader 读出一个 file 对象的 DataURL
	dataurl: 一般用于把小文件 对应小的 file 对象 转换成 包含数据信息的 url 跟普通的url一样的使用方式:
		DataURI 一般是把 file对象 编译成 base64 斌码 的 一条长字符串
		格式为:		
		data:[<MIME type>][;charset=<charset>][;base64],<encoded data>	
		对应例子:
		<img class='obj' src="data:[<MIME type>][;charset=<charset>][;base64],<encoded data>"
	URL:一般是文件的位置,但如果文件读入到 file 对象里, 
		可以通过 URL.createObjectURL() 对 file对象里的文件建立一个临时的 url
		img.src = window.URL.createObjectURL(file);
  		<img class="obj" src="blob:null/34c9b3b5-9ca9-4b18-9798-xxxxxx">
	blob: blob 跟 file 对象是一样的, 不过 file对象一般是 通过 <input>选入的,但是 blob是凭空创建的
		var arr = ['<h1>hello world</h1>'];
		var blob = new Blob(arr, { "type" : "text/xml" }); // the blob
		slice方法生成blob对象
			var newBlob = Blob.slice(startingBytenum, endindBytenum);
		DataURI（base64）对象转blob对象（二进制）
			function dataURItoBlob(dataURI) { 
				var byteString = atob(dataURI.split(',')[1]); 
				var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0]; 
				var ab = new ArrayBuffer(byteString.length); 
				var ia = new Uint8Array(ab); 
				for (var i = 0; i < byteString.length; i++) { 
					ia[i] = byteString.charCodeAt(i); 
				} 
				return new Blob([ab], {type: mimeString}); 
			} 
			// atob() 将base64解码 , btoa() 将字符串转码为base64 
			var str = 'javascript'; 
			window.btoa(str) 		//转码结果 "amF2YXNjcmlwdA==" 
			window.atob("amF2YXNjcmlwdA==") //解码结果 "javascript"
	FormData 用于 ajax 或者 XMLHttpRequest 上传数据到服务器!!
		一般可以值直接把 <form> 内容在初始化时放入
			<form id="uploadForm" enctype="multipart/form-data"> 
				<input id="file" type="file" name="file"/> 
				<button id="upload" type="button">upload</button> 
			</form>
			var fdata = new FormData($('#uploadForm')[0]);
		也可以把数据一条一条放入, 通过 append()
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			append 可以加载 file blob 对象,还可以加载一般表单项
		一般 FormData  例子:
			<form id='test-form'>
			  Input1: <input name='input1'><br>
			  Input2: <input name='input2'><br>
			  <input type='submit'>
			</form>
			..
			  testForm.onsubmit = function(event) {
			    event.preventDefault();
			
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			
			    var formData = new FormData(document.getElementById('test-form')); //添加了 input1 input2 表项
 			
			    formData.append('appendedFile1', new Blob(['foo']));	// 添加了 blob 对象
			    formData.append('appendedFile2', new Blob(['bar']), 'bar.txt'); // 添加了 blob 对象
    			    formData.append('appended1', 'appended value');		// 添加了 一般表单项
			
			    request.send(formData);
			
			    console.log(request.response);
			  }
			formData 内容: 这个表内容格式并不正确 已经误导我了!!1
			{
			  "args": {}, 
			  "data": "", 
			  "files": {			// file blob 对象 会加载到 flies 数组
			    "appendedFile1": "foo",
			    "appendedFile2": "bar"
			  }, 
			  "form": {			// 普通表项会加载到 from 数组
			    "appended1": "appended value", 
			    "input1": "dd", 
			    "input2": "ddd"
			  }, 
			  "headers": {
			    "Accept": "*/*", 
			    "Accept-Encoding": "gzip, deflate, br", 
			    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", 
			    "Connection": "close", 
			    "Content-Length": "648", 
			    "Content-Type": "multipart/form-data; boundary=---------------------------56193008011516604521985403512", 
			    "Host": "httpbin.org", 
			    "Origin": "https://www.javascripture.com", 
			    "Referer": "https://www.javascripture.com/FormData", 
			    "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:62.0) Gecko/20100101 Firefox/62.0"
			  }, 
			  "json": null, 
			  "origin": "149.28.122.195", 
			  "url": "https://httpbin.org/post"
			}
	ajax 与 XMLHttpRequest , ajax 是 jqurey 的方式  XMLHttpRequest是 标准 DOM
		ajax: 例子1
			var fd = new FormData(); // 构造FromData对象
			var blob = dataURItoBlob(dataURI); // 将base64转为二进制blob对象
			fd.append('file', blob);
			$.ajax({ 
				type: 'POST', 
				url: '/upload', 
				data: fd, 
				processData: false, // 不会将 data 参数序列化字符串,必须false 
				contentType: false, // 根据表单 input 提交的数据使用其默认的 contentType，必须false 
				xhr: function() { 
					var xhr = new window.XMLHttpRequest(); 
					xhr.upload.addEventListener("progress", function(evt) { 
						if (evt.lengthComputable) { 
							var percentComplete = evt.loaded / evt.total; 
							console.log('进度', percentComplete); 
						} 
					}, false); 
					return xhr; 
				} 
			}).success(function (res) { 
				// 拿到提交的结果 
			}).error(function (err) { 
				console.error(err); 
			});
		ajax: 例子2
			$.ajax({ 
				url: '/upload', 
				type: 'POST', 
				cache: false, 
				data: new FormData($('#uploadForm')[0]), 
				processData: false, 
				contentType: false 
			}).done(function(res) { 
			}).fail(function(res) {
			});
		XMLHttpRequest 例子1
			    var request = new XMLHttpRequest();
			    // POST to httpbin which returns the POST data as JSON
			    request.open('POST', 'https://httpbin.org/post', /* async = */ false);
			    var formData = new FormData(document.getElementById('test-form'));		
			    request.send(formData);
	file对象 还有一种创建,非 input 输入的方式:
		var objFile=new File(["First Line Text","Second Line Text"],FileName);
		第一个参数是一个字符串数组。数组中的每一个元素对应着文件中一行的内容。
		第二个参数就是文件名字符串。
		var objFile=new File(["First Line Text","Second Line Text"],FileName,{type: "text/plain", lastModified: date});
		如果是用三个参数的形式
		第三个参数可以设定一些文件的属性，比如文件的MIME，最后更新时间等。 
	js 的 file 对象相关 还有一个 ActiveXObject 不过是微软 activeX 内容,所以不考虑!!
		但是这个涉及到完整的浏览器操作本地文件的过程:
		参考:http://www.cnblogs.com/ayan/archive/2013/04/22/3036072.html
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据补充
	//前端js 查看 formdata 内容的 方式
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
FormData补充:
	FormData类型其实是在XMLHttpRequest 2级定义的，它是为序列化表以及创建与表单格式相同的数据（当然是用于XHR传输）提供便利。
	构造函数
		创建一个空对象实例
			var formData = new FormData();
			此时可以调用append()方法来添加数据
		使用已有的表单来初始化一个对象实例
			假如现在页面已经有一个表单
			<form id="myForm" action="" method="post">
			    <input type="text" name="name">名字
			    <input type="password" name="psw">密码
			    <input type="submit" value="提交">
			</form>
			我们可以使用这个表单元素作为初始化参数，来实例化一个formData对象
			// 获取页面已有的一个form表单
			var form = document.getElementById("myForm");
			// 用表单来初始化
			var formData = new FormData(form);
			// 我们可以根据name来访问表单中的字段
			var name = formData.get("name"); // 获取名字
			var psw = formData.get("psw"); // 获取密码
			// 当然也可以在此基础上，添加其他数据
			formData.append("token","kshdfiwi3rh");
	操作方法   首先，我们要明确formData里面存储的数据形式，一对key/value组成一条数据，
		key是唯一的，一个key可能对应多个value。如果是使用表单初始化，每一个表单字段对应一条数据，
		它们的HTML name属性即为key值，它们value属性对应value值。
			key value
			k1 	[v1,v2,v3]
			k2 	v4
		获取值
			我们可以通过get(key)/getAll(key)来获取对应的value，
			formData.get("name"); // 获取key为name的第一个值
			formData.getall("name"); // 返回一个数组，获取key为name的所有值
		添加数据
			我们可以通过append(key, value)来添加数据，如果指定的key不存在则会新增一条数据，如果key存在，则添加到数据的末尾
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.get("k1"); // "v1"
			formData.getAll("k1"); // ["v1","v2","v1"]
		设置修改数据
			我们可以通过set(key, value)来设置修改数据，如果指定的key不存在则会新增一条，如果存在，则会修改对应的value值。
			formData.append("k1", "v1");
			formData.set("k1", "1");
			formData.getAll("k1"); // ["1"]
		判断是否该数据
			我们可以通过has(key)来判断是否对应的key值
			formData.append("k1", "v1");
			formData.append("k2",null);		
			formData.has("k1"); 		// true
			formData.has("k2"); 		// true
			formData.has("k3"); 		// false
		删除数据
			通过delete(key)，来删除数据
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k1", "v1");
			formData.delete("k1");			
			formData.getAll("k1"); 		// []
		遍历
			我们可以通过entries()来获取一个迭代器，然后遍历所有的数据，
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");
			var i = formData.entries();
			i.next(); // {done:false, value:["k1", "v1"]}
			i.next(); // {done:false, value:["k1", "v2"]}
			i.next(); // {done:false, value:["k2", "v1"]}
			i.next(); // {done:true, value:undefined}
			每调用一次next()返回一条数据，数据的顺序由添加的顺序决定
			返回的是一个对象，当其done属性为true时，说明已经遍历完所有的数据，这个也可以作为判断的依据
			返回的对象的value属性以数组形式存储了一对key/value，数组下标0为key，下标1为value，
			如果一个key值对应多个value，会变成多对key/value返回
		我们也可以通过values()方法只获取value值
			formData.append("k1", "v1");
			formData.append("k1", "v2");
			formData.append("k2", "v1");	
			var i = formData.entries();
			i.next(); // {done:false, value:"v1"}
			i.next(); // {done:fase, value:"v2"}
			i.next(); // {done:fase, value:"v1"}
			i.next(); // {done:true, value:undefined}
		发送数据
			我们可以通过xhr来发送数据
			var xhr = new XMLHttpRequest();
			xhr.open("post","login");
			xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
			xhr.send(formData);
			这种方式可以来实现文件的异步上传。
实验: 
	前端 使用 fd.append('file100',savlins) 或多次使用 append file对象 或者字符窜 到 file100
	后端 使用 files = request.FILES.getlist('file100') 或者 file_obj = request.FILES.get('file100')
	才能 获得 挂在 file100 里的 文件对象 数据, 
	也就是 file100 是 一个数组, 而不是 key/value 格式的 key???
	根据formdata补充 知道: 
	也就是 file100 是key 但是一个key可以对应很多 value, 而value的类型可以是单纯字符串,可以是file对象 等等 !!
	//前端js 查看 formdata 内容的 方式1 
	    for (var pair of fd.entries()) {
	        console.log(pair[0]+ ', ' + pair[1]);
	    }
	//查看 formdata 内容的 方式2
	    var i = fd.entries()
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())
	     console.log(i.next())
关于python读写文件 和 按行读取文件:
	按行读取文件参考: https://www.cnblogs.com/xuxn/archive/2011/07/27/read-a-file-with-python.html 
	    if request.method == "POST":  # 请求方法为POST时，进行处理
		//获取文件
	        file_obj = request.FILES.get('file100')
	        import os
	        f = open(os.path.join("./", file_obj.name), 'wb+')
	        print(file_obj, type(file_obj))
	        for chunk in file_obj.chunks():
	            f.write(chunk)
	        f.close()
		//按行读取文件
	        file = open(os.path.join("./", file_obj.name), 'r')
	        while 1:
	            line = file.readline()
	            if not line:
	                break
	            print(line)  # do something
	        file.close()


接下来就是数据库
	详细参考: https://www.cnblogs.com/ccorz/p/5845711.html
		http://www.liujiangblog.com/course/django/100
		同步现存,增删查改: https://blog.csdn.net/vainfanfan/article/details/80556429?utm_source=blogxgwz0
		系统 django https://code.ziqiangxuetang.com/django/django-queryset-api.html
		重点参考!!
		https://www.cnblogs.com/pythonxiaohu/p/5807059.html
		https://www.cnblogs.com/pythonxiaohu/p/5814247.html
详细学习 models class
	models.AutoField　　自增列 = int(11)
		如果没有的话，默认会生成一个名称为 id 的列，
		如果要显示的自定义一个自增列，必须将给列设置为主键 primary_key=True。 models.AutoField(primary_key=True)
	models.CharField　　字符串字段 
		必须 max_length 参数 CharField(max_length=32)
	models.BooleanField　　布尔类型=tinyint(1)
　　		不能为空，Blank=True 
	models.ComaSeparatedIntegerField　　用逗号分割的数字=varchar
		继承CharField，所以必须 max_lenght参数	例如"12,2,3,4,5"
	models.DateField　　日期类型 date
		对于参数，auto_now = True 则每次更新都会更新这个时间；auto_now_add 则只是第一次创建添加，之后的更新不再改变。
	models.DateTimeField　　日期类型 datetime
		同DateField的参数
	models.Decimal　　十进制小数类型 = decimal
		必须指定整数位max_digits和小数位decimal_places
	models.EmailField　　字符串类型（正则表达式邮箱） =varchar
		对字符串进行正则表达式
	models.FloatField　　浮点类型 = double
	models.IntegerField　　整形
	models.BigIntegerField　　长整形
		　　integer_field_ranges = {
		　　　　'SmallIntegerField': (-32768, 32767),
		　　　　'IntegerField': (-2147483648, 2147483647),
		　　　　'BigIntegerField': (-9223372036854775808, 9223372036854775807),
		　　　　'PositiveSmallIntegerField': (0, 32767),
		　　　　'PositiveIntegerField': (0, 2147483647),
		　　}
	models.IPAddressField　　字符串类型（ip4正则表达式）
	models.GenericIPAddressField　　字符串类型（ip4和ip6是可选的）
		参数protocol可以是：both、ipv4、ipv6
		验证时，会根据设置报错
	models.NullBooleanField　　允许为空的布尔类型
	models.PositiveIntegerFiel　　正Integer
	models.PositiveSmallIntegerField　　正smallInteger
	models.SlugField　　减号、下划线、字母、数字
	models.SmallIntegerField　　数字
		数据库中的字段有：tinyint、smallint、int、bigint
	models.TextField　　字符串=longtext
	models.TimeField　　时间 HH:MM[:ss[.uuuuuu]]
	models.URLField　　字符串，地址正则表达式
	models.BinaryField　　二进制
	models.ImageField   图片
	models.FilePathField 文件
连表结构
	一对多:models.ForeignKey(其他表)
	多对多:models.ManyToManyField(其他表)
	一对一:models.ManyToManyField(其他表)
具体操作:建表 读写 修改 使用 连表!!
懂得一个后端调试手段,不需要打开服务器,直接在 终端调试!! python manage.py shell
django mysql 储存 中文 编码问题:
	(1366, "Incorrect string value: '\\xE7\\xAC\\xAC\\xE4\\xB8\\x80...' for column 'cnte' at row 1")
	再 mysql 里 执行命令!!!
	ALTER TABLE web_content MODIFY COLUMN cnte VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;
	参考: https://my.oschina.net/airship/blog/777146
建表:
	    from django.db import connection
	    with connection.schema_editor() as editor:
	        editor.create_model(Content) 	//Content即models.py里定义的,或自己函数定义的class
直接记录连表操作:
区分 子表 母表:
	class Liker (models.Model):
	    nid = models.AutoField(primary_key=True)
	    name = models.CharField(max_length=255,blank=True, null=True)
	
	class Lnum (models.Model):
	    linum = models.CharField(max_length=255,blank=True, null=True)
	
	class Content (models.Model):
	    ctid = models.AutoField(primary_key=True)
	    type = models.CharField(max_length=10)
	    cnte = models.TextField(blank=True, null=True)
	
	class Line(models.Model):
	    lineid = models.AutoField(primary_key=True)
	    content = models.ForeignKey(Content,blank=True,null=True,on_delete=models.CASCADE)
	    liker = models.ManyToManyField(Liker)
	    lnum = models.OneToOneField(Lnum,on_delete=models.CASCADE)
	Line是子表, Liker, Lnum, Content,是母表,
	OneToOneField 建立 一对一 关系
	ForeignKey 建立 一对多 关系
	ManyToManyField 建立 多对多 关系
基本api认识:
	.get 是获得 数据表中符合条件的第一条数据对象
	.filter 是获得 数据表中符合条件 的 一组数据对象 
一对一:	(母表对象可以作为子表对象中的一个字段内容,但是每个母表对象不能重复出现在一个以上的子表对象里)
	查:
		子表原名.objects.get(子表字段=查询数据).母表表名小写.母表字段名   // 获得指定母表指定字段的内容
		例如: 	Line.objects.get(lineid=4).lnum.linum

		母表原名.objects.get(子表名(小写)__子表字段=查询数据).母表字段名	// 反向查找得到  指定母表指定字段的内容
		例如:	Lnum.objects.get(line__lineid=5).linum		//注意到双下滑线在django models里 的独有用法!!

		子表.objects.get(（一对一的子表字段）子表字段__母表字段=查询数据).子表字段	  //反向查询,得到指定子表字段的内容
		例如:	Line.objects.get(lnum__linum='7').lineid
	增:
		先添加母表数据,然后再作为一个对象 赋给新建的子表对象
		
		//方法1 
		母表.objects.create(字段名字=添加的数据)
		子表.objects.create(（定义一对一）外键字段=母表的对象, 子表的字段=添加的数据)
		例如:  	obj1 = a.Lnum.objects.create(linum='233')
			a.Line.objects.create(lnum=obj1)
		
		//方法2
		对象id=母表.objects.create(字段=数据).id
		子表.objects.create(外键_id=对象id,字表字段=数据)
		例如:	id1 = a.Lnum.objects.create(linum='323').id
			a.Line.objects.create(lnum_id=id1)		//注注意到单下滑线在django models里 的独有用法!!
		
		//方法3
		母表对象=母表.objects.create(字段=数据) 
		子表对象=子表(外键=母表对象, 子表字段=数据)
		子表对象.save() 

		//方法4(字典导入)
		母表对象=母表.objects.create(字段=数据)
		dict={'子表字段':"数据"} 
		子表.objects.create(外键=母表对象,**dict)
	改:
		//修改 母表里单个数据,
		母表对象 = 母表.objects.get(字段=数据)    //get()等同于  .filter().first()
		母表对象.字段名=要修改的数据
		母表对象.save()
	
		//修改 多个指定子表对象 里 的母表对象数据,
		子表.objects.filter(字段=数据).update(外键=母表对象, 子表字段=要修改的数据)  //update(), delete()是QuerySet方法
		
		//修改 多个 含母表对象的子表对象 的数据
		子表.objects.filter(外键__母表字段=母表的数据).update(子表字段=要修改的数据)		

		//也可以 通过字典修改
    		dict = {"子表字段":"要修改的数据"}
    		子表.objects.filter(~~~~).update(**dict)
	删:
		子表.objects.get(字段=数据).delete()	//对象和QuerySet都有delete()
		母表.objects.all().delete()	//清空一张表

		母表.objects.filter(字段=数据).delete()
		例如	Lnum.objects.filter(linum='7').delete()

一对多:	(母表对象可以作为子表对象中的一个字段内容, 每个母表对象可以重复出现在一个以上的子表对象里)
	查:
		子表.objects.get(字段=数据).母表.母表字段 	//(找的是母表数据)	
		例如	Line.objects.get(lnum__linum='3').content.cnte
	
		母表.objects.get(子表__字段=数据).母表字段 	//找的是母表数据
		例如	Content.objects.get(line__lineid=4).cnte

		//查询含有指定母表对象的子表对象,方法1
		母表对象 = 母表.objects.get(字段=数据) 
		母表对象.子表_set.all() 	//注意：子表小写_set的写法,它实际上是一个QuerySet,可以用update,delete,all,filter等方法
		例如	obj1 = a.Content.objects.get(ctid=2)
			obj1.line_set.all()

		//方法2
		子表.objects.filter(字段=母表.objects.get(母表字段=数据)) 
		子表.objects.filter(子表外键__母表字段=数据) 	//写法：filter(子表外键字段__母表字段='过滤条件')
		
		//方法3 
		母表对象 = 母表.objects.get(字段=数据).id
		子表.objects.filter(子表外键_id = 母表对象) 	//filter得到QuerySet,写法：filter(子表外键字段_母表主键=母表主键对象) 

		关于 ValueQuerySet 问题:  通过QuerySet的.values()方法，将QuerySet转化为ValuesQuerySet
		子表.objects.filter(子表外键名=母表.objects.get(母表字段=数据)).values('子表外键__母表字段名', '子表字段') 
		子表.objects.filter(子表外键__母表字段=数据).values("子表外键__母表字段", '子表字段')
			获取子表的某一个字段, 和母表的某一个字段，然后构成 ValuesQuerySet
			即获得指定母表字段和对应的子表字段, 构成 字典序列 key:value 输出显示
			获取母表字段写法: 子表外键字段名__母表字段名--适用于values()或filter() 
		如果不加values(),返回的是:
			[<子表: xxx>, <子表: xxx>]这样一个QuerySet集合，
		通过values可以形成一个列表，列表中的每一个元素是一个字典，
		可以通过list()将ValuesQeurySet转化为列表，之后返回给templates
		另外可通过.values_list()将QuerySet转化为ValuesListQuerySet
			返回：[(u'\u7ea2', u'\u7ea2\u889c\u5b50'), (u'\u7ea2', u'\u7ea2\u889c\u5b50')] 
			得到的是一个列表，列表中是多个元组，每个元组是ValuesQuerySet中字典的value，
			常用于从models里将数据取出后动态添加到前端模板中的select选项中
		例如:	Line.objects.filter(content_id=2).values("content__cnte","lnum__linum")
				<QuerySet [{'lnum__linum': '3', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '4', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '5', 'content__cnte': '第1条信息'}, 
					   {'lnum__linum': '6', 'content__cnte': '第1条信息'}]>
		例如:	Line.objects.filter(content_id=2).values_list("content__cnte","lnum__linum")
				<QuerySet [('第1条信息', '3'), 
					   ('第1条信息', '4'), 
					   ('第1条信息', '5'),
					   ('第1条信息', '6')]>

		最后一条数据,第一条数据:
			xxx.objects.last()
			xxx.objects.first()
	增: 
		子表.objects.create(子表外键=母表.objects.get(母表字段=数据).子表字段=需要添加的数据) 
	
		子表.objects.create(子表外键_id=母表.objects.get(母表字段=数据).id, 子表字段=要添加的数据)

		返回对象 = 子表(子表外键=母表.objects.get(母表字段=数据), 子表字段=要添加的数据) 
		返回对象.save()
	改:
		//写法1 
		子表.objects.filter(子表外键__母表字段=数据).update(子表需要更改的字段=改为什么的数据) 
		//写法2
		子表.objects.filter(子表外键_id=母表.objects.get(母表字段=数据).id).update(子表需要更改的字段=改为什么的数据)
		//写法3 (对应母表的子表的id大于等于1的数据全部修改) 
		母表对象 = 母表.objects.get(字段=数据) 
		母表对象.子表_set.filter(id__gte=1).update(子表字段=改为什么数据)
			__gt 大于 
			__gte 大于等于 
			__lt 小于 
			__lte 小于等于
		
	删:
		子表.objects.get(字段=数据).delete() //对象和QuerySet都有delete() 
		母表.objects.filter(字段=数据).delete() 
多对多:	(一个子表对象里 有包含母表对象的字段, 而这个字段可以包含多个母表对象 这些母表对象也可以被其他 子表对象所有共有)
	建立多对多关系后 ,比如 mysql 会多建立一张表 web_line_liker,而不是在原来的 line表 添加一个 liker_id 字段

	查:
		// 查询并获得 子表对象里 含有的 所有对应多对多母表对象
		返回对象 = 子表.objects.get(字段=数据) 	//写法：子表对象.子表多对多字段.过滤条件(all()/filter())
    		返回对象.外键.all()
		例如:	Line.objects.get(lineid=6).liker.all()
		<QuerySet [<Liker: Liker object (1)>, <Liker: Liker object (2)>, <Liker: Liker object (3)>, 
			   <Liker: Liker object (4)>, <Liker: Liker object (5)>, <Liker: Liker object (6)>, 
			   <Liker: Liker object (7)>, <Liker: Liker object (8)>, <Liker: Liker object (9)>, 
			   <Liker: Liker object (10)>, <Liker: Liker object (11)>, <Liker: Liker object (12)>, 
			   <Liker: Liker object (13)>, <Liker: Liker object (14)>, <Liker: Liker object (15)>, 
			   <Liker: Liker object (16)>, <Liker: Liker object (17)>, <Liker: Liker object (18)>, 
			   <Liker: Liker object (19)>, <Liker: Liker object (20)>, '...(remaining elements truncated)...']>
		
		//反向查询 获得 所有对应多对多母表对象
		母表.objects.filter(子表表名小写__子表字段名=数据)  //母表对象.filter(子表表名小写__子表字段名="过滤条件")	
		例如:	Liker.objects.filter(line__lineid=6)
		<QuerySet [<Liker: Liker object (1)>, <Liker: Liker object (2)>, <Liker: Liker object (3)>, 
			   <Liker: Liker object (4)>, <Liker: Liker object (5)>, <Liker: Liker object (6)>, 
			   <Liker: Liker object (7)>, <Liker: Liker object (8)>, <Liker: Liker object (9)>, 
			   <Liker: Liker object (10)>, <Liker: Liker object (11)>, <Liker: Liker object (12)>, 
			   <Liker: Liker object (13)>, <Liker: Liker object (14)>, <Liker: Liker object (15)>, 
			   <Liker: Liker object (16)>, <Liker: Liker object (17)>, <Liker: Liker object (18)>, 
			   <Liker: Liker object (19)>, <Liker: Liker object (20)>, '...(remaining elements truncated)...']>

		//获得包含母表对象 的 子表对象
		返回对象 = 母表.objects.get(字段=数据)
		返回对象.子表_set.all()		
		例如:	Liker.objects.get(nid=3).line_set.all()

		//获得子表对象方法2
		子表.objects.filter(子表外键=母表.objects.get(母表=数据))	
		子表.objects.filter(子表外键__母表字段=数据)

		//获得子表对象方法3
		返回对象 = 母表.objects.get(字段=数据).id 
		子表.objects.filter(子表外键=返回对象) ##filter得到QuerySet,写法：filter(子表外键字段=母表主键对象),
		此处和一对多略有不同，是子表外键字段而不是外键字段_母表主键
		例如:	obj1 = a.Liker.objects.get(nid=3).nid
			a.Line.objects.filter(liker = obj1)	//注意,不是 filter(liker_id = objs)
		因为 Line 和 Liker 是 多对多关系, Line表 没有 liker_id 字段,也没有liker字段, 他们的关系表现在一张新表里

	增与改	(就是添加关系)
		//写法1 
		返回对象一 = 子表.objects.create(字段=数据)	//如果存在可以使用.get() 
		返回对象二 = 母表.objects.all() 		//创建母表的所有数据QuerySet对象 
		返回对象一.子表外键.add(*返回对象二) 		//写法：子表对象.子表多对多字段.add(*QuerySet对象)	

		//写法2 
		子表对象 = 子表.objects.get(字段=数据) 
		母表对象 = 母表.objects.all() 
		子表对象.子表外键=母表对象 		//注意没有用 *
		子表对象.save() 

		//让子表数据对象 添加指定几个母表数据 
		子表对象 = 子表.objects.get(字段=数据) 
		母表对象 = 母表.objects.filter(字段__in = ["数据一"， "数据二"])  //models默认只能用这种方式得到并集，
										//如需更复杂的过滤逻辑，需使用模块Q 
		子表对象.子表外键.add(*母表对象)	//add是追加模式，如果当前子表数据已经存在母表对应数据，
						//那么执行后，子表原有对应关系不变,会额外增加数据对应 
		子表对象.子表外键.clear()	//是清空子表对应的母表数据 

		//添加一个母表数据
		子表对象=子表.objects.get(字段="数据") 
		母表对象=母表.objects.get(字段="数据") 
		子表对象.子表外键.clear() 
		子表对象.子表外键.add(母表对象) 	//此处没有* 

		//反向插入,即从母表插入
		子表对象=子表.objects.get(字段=数据) 
		母表对象=母表.objects.get(字段=数据) 
		母表对象.子表表名小写_set.add(子表对象) 	//从母表插入子表数据，写法：母表对象.子表名小写_set.add(子表对象)。 

		//让子表所有数据 都添加同一个母表数据
		子表对象=子表.objects.all() 
		母表对象=母表.objects.get(字段=数据) 
		母表对象.子表表名小写_set.add(*子表对象) //另外备注一下:
							//母表对象.子表表名小写_set.clear(),是让所有子表数据去掉母表某一个数据对应,即删除关系
							//母表对象.子表表名小写_set.all().delete(),这里不是删除关系,而是删除涉及的子表对象
		关于_set写法，究竟什么时候使用_set,简单记忆，只有子表才有"子表名小写_set"的写法，得到的是一个QuerySet集合，
		后边可以接.add(),.remove(),.update(),.delete(),.clear()
		使用子表_set的接的add(),.remove(),.update(),.delete(),.clear()
		子表.objects.get/filter 接的 add(),.remove(),.update(),.delete(),.clear() 部分函数功能不一样,例如clear.remove	

	删:	(一般是 删除关联,)
		//从子表来删 写法1 
		子表对象=子表.objects.get(字段=数据) 
		母表对象=母表.objects.all() 
		子表对象.子表外键='' 
		子表对象.save() 
	
		//从子表来删 写法2： 
		子表对象=子表.objects.get(n字段="数据") 
		母表对象=母表.objects.all() 
		子表对象.子表外键.remove(*母表对象) 

		//从子表来删 写法3： 
		子表对象=子表.objects.get(字段="数据") 
		子表对象.子表外键.clear() 

		//从母表来删 写法1:
		子表对象=子表.objects.all() 
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.remove(*子表对象) 
		
		//从母表来删 写法2： 
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.clear() 
	
		//以下不是删除关系,而是删除 指定表对象数据
		母表对象=母表.objects.get(字段="数据") 
		母表对象.子表表名小写_set.all().delete() #注意有.all() #删除包含对应母表对象所有子表对象及数据 
		例如	Liker.objects.get(nid=4).line_set.all().delete()
			lineid=6 的子表对象, 含有 nid=4 的母表对象!!
			这句话的意思是 删除 lineid=6 的子表对象, 
			而 lineidlineid=6 的子表对象, 包含 Liker母表的所有母表对象, 
			所以, 这些母表对象也要被删除 !! 

		//删除所有子表数据		
		子表.objects.all().delete()
关于 筛选:
	利用双下划线将字段和对应的操作连接起来,例如:
	# 大于，小于  利用双下划线将字段和对应的操作连接起来 
	# models.Tb1.objects.filter(id__gt=1)              # 获取id大于1的值
	# models.Tb1.objects.filter(id__lt=10)             # 获取id小于10的值
	# models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值
	# models.Tb1.objects.all()[10:20]  #取所有数据的10条到20条，分页的时候用的到,注意不是id 10到20 的!!

	注意,XX.objects.filter(description="黑球") 是筛选出一堆符合条件的的数据条成为数组,
	    XX,objects.get(name="kate") 是选出对应的一个对象.
	    filter选出的 数组有 .update()  .delete() 等方法改变数据,
	    get得到的 单个对象,未知道有没有!!!
	    然后其他函数都是在get 和 filter 后面接上的专门处理数据
	现在改变连表关系时的数据排列问题!!
	被 OneToOneField(Lnum,on_delete=models.CASCADE) 指定的 Lnum 无法使用 create()建立新内容
models class 中的 meta 参数:
	abstract = True 	//这个model就是一个抽象类,抽象类不会具体化,只有被继承后才会
	app_label = 'web' 	//当 model 不是在models里定义,需要添加告诉django 这是那个django项目的表单
	db_table = 'Students'	//定义该model在数据库中的表名称,
	managed			//默认值为True，这意味着Django可以使用syncdb和reset命令来创建或移除对应的数据库。
				//默认值为True,如果你不希望这么做，可以把manage的值设置为False	
	ordering		//这个字段是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。默认使用升序排列
				//ordering=['order_date'] # 按订单升序排列
				//ordering=['-order_date'] # 按订单降序排列，-表示降序
				//ordering=['?order_date'] # 随机排序，？表示随机
				//ordering=['-pub_date','author'] # 以pub_date为降序，在以author升序排列
	verbose_name		//意思很简单，就是给你的模型类起一个更可读的名字一般定义为中文，例如verbose_name = "学校"

关于执行 sql命令 和 检测数据库表是否存在的 django 操作:
	检测数据库表单是否存在:
		from django.db import connection
		table_name in connection.introspection.table_names()	// in运算 返回true false
	两个重点  Migration connection
	https://code.djangoproject.com/wiki/DynamicModels  //Dynamic models 官方动态数据库教程
	https://docs.djangoproject.com/zh-hans/2.1/topics/db/sql/	//执行纯 sql 指令
	注意 raw 并不好用: 最执行纯 sql指令 的函数 是 execute():
		from django.db import connection
		with connection.cursor() as cursor:
		    cursor.execute('ALTER TABLE web_content MODIFY COLUMN cnte VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')		
		//执行这条 纯 sql指令后  content 可以输入 中文!!

关于删的过程中出现的 连带关系的改变
	母表数据,如果与子表数据联系了,就删除会出错,系统不允许删除
	子表数据删除,会连带母表数据也被删除
	如果母表数据被多个 子表对象共享, 未知 删除某个子表对象,会导致母表对象被删除
	最后发现,使用 django orm 方式
	母表对象必须存在即 已经 save 的情况下才可以 写到 子表里
	删除子表时,连表到的母表并没有删掉! 需要自己删掉!!

models 技巧: select_related prefetch_related

python学习补充:		
	__str__ 是 python的内容,	
	lambda表达式可以理解成为匿名函数，其功能就是定义了一个函数，不过这个函数形式非常简单，通常是一行。过于复杂的函数还是正经定义的好。
		例如:	g = lambda x:x+1
			g(1)
		例如:'__str__' : lambda  self : '%s %s %s %s' % (self.type, self.category, self.title, self.answer),
			xx.__str__()






20181024:
	django 的 数据库 摸得差不多了,开始简单数数据库
	建立三张表
	user:
	自动id 用户名  密码+用户名sha 实名 身份证 信息信用表 save_sha表 line表 xontent表 最大contentid 最大lineid 最后修改时间!!
	line表:
	自动id lineid 一对多content 最后修改时间
	content表:
	自动id contentnum type	 content history  count  最后修改时间 
	
	最后修改时间是服务器自己分配的时间,而不是前端用户点击保存传递过来的时间!!
	另外的信用表记录信用事件,未规划如何使用
	save_sha表 计划 每次save 都产生一个sha, 计划用于防止恶意修改数据 未规划如何使用
	刷新数据库前,先处理内容冲突, 发现冲突,不刷新数据,通知用户先 把修改后的数据拷贝到记事本上,重新刷新后,重新修改!!
		比如说数据库上 14行 本来是 contentid 为40 的内容  type 是text
		不知道是什么问题, 前端保存数据时 提交的信息说 原来 14行是contentid为20的内容 type是pic 的内容,

分析每一个要用到是 数据 的类型!!! 顺便测试建模
	https://docs.djangoproject.com/en/2.1/ref/models/fields/	//参考
	用户名: models.CharField(max_length=100),
	密码+用户名sha (64位16进制):  models.CharField(max_length=100), 
		用64个字符保存吧,或者 64位16进制数字 转成32个char字节,再保存!!	//不好实现
	实名: models.CharField(max_length=100), 但是要求中文!!
	身份证 (种类:数字) models.CharField(max_length=100),
	信息信用表 models.CharField(max_length=100),
	save_sha表,line表,xontent表: models.CharField(max_length=100), 表名字
		关于 models.CharField(max_length=xx), 一定要填 max_length, 但是注意 他是按照 asscii 编码来算字符
		但我们 改成utf编码后,是按照utf来数字符的, 比如 max_length=23 表示最多 23 个 utf 字符.
		除了 max_length=xx 一般还使用通用的 blank=True, null=True, 表示可以填入空字符!!
		    
	最大contentid, 最大lineid,大整数, contentid, count: IntegerField(Field)  即可 -2147483648 ～ 2147483647  足以应付1300.0000 行
		关于models.IntegerField(), 一般使用通用参数 blank=True, null=True 就好了
		填入的 是数字内容 	
	最后修改时间: 我们使用 DateTimeField : https://blog.csdn.net/liereli/article/details/79790303 参考:
		关于 models.DateTimeField(blank=True, null=True), 这个本质是继承字符串的一种格式
		一般的格式是这样的: 2018-10-27 15:19:32.175228. 
		我们填写要当成字符串填写: 例如   
			'datetime': models.DateTimeField(blank=True, null=True),
			datetime='2019-10-22 21:49:05.456263'
		此外 DateTimeField 还有自己独有的参数: auto_now_add=True auto_now=True
			auto_now_add=True 表示 但我们xx.save()等方式写入一条新数据记录时, DateTimeField 字段会自己获得系统时间
				并存入到 DateTimeField 字段里, 当下次修改这条记录时,不会自动这个 DateTimeField 字段 的内容
			auto_now=True 表示,不管我们更新还是修改 一条数据记录时, DateTimeField 字段会自己获得系统时间,
				并存入到 DateTimeField 字段里,
		另外, 不使用 auto_now=True 或者 auto_now_add=True 可以通过以下方式获得系统时间
			from datetime import datetime
			from datetime import timezone
			datetime=datetime.now().replace(tzinfo=timezone.utc)
	content, history : textfield
		关于 models.TextField(blank=True, null=True), 一般 使用blank=True, null=True 参数 允许空字符输入就好了
		TextField() 一般就是可以输入不限个字符的 CharField
	使用动态建模,过程: 整体未遇到什么坑
		fields = {
		    'user': models.CharField(max_length=100),
		    'pw_sha': models.CharField(max_length=64),
		    'realname': models.CharField(max_length=100),
		    'pesonalid': models.CharField(max_length=100),
		    'XXXtable': models.CharField(max_length=100),
		    'content': models.TextField(blank=True, null=True),
		    'count': models.IntegerField(blank=True, null=True),
		    'datetime': models.DateTimeField(blank=True, null=True),
		}
		options = {
		    'ordering': ['user', 'count', 'datetime'],
		    'verbose_name': 'william_test',
		}
		admin = {}
		from django.utils.encoding import smart_str  #  convert unicode to string
		
		custom_model = create_model('william',
		                            fields,
		                            options=options,
		                            app_label='web',
		                            module='web',
		                            admin=admin
		                            )
		install(custom_model)		//之前都是定义模型参数,这里就是建立实体mysql库
		with connection.cursor() as cursor:	//这里是 修改指定字段可以输入中文
		    cursor.execute(
		        'ALTER TABLE web_william MODIFY COLUMN user VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
field 主要参数 详解
	https://www.jianshu.com/p/79a418826357		//通用 field 参数讲解
	https://www.cnblogs.com/linxiyue/p/3662535.html	//通用 field 参数讲解
	通用的:
		verbose_name: 这是 字段 在 admin 管理页面显示的通俗名字 一般如 verbose_name='书本名字'
		null	: 允许空字符
		blank	: 也有允许空字符的意思?? 一般和null 一起使用 blank=True, null=True 表示允许空字符
非通用的
	auto_now :使用解释如 DateTimeField 所说
	auto_now_add :使用解释如 DateTimeField 所说
	on_delete: 用于连表字段 models.ForeignKey(其他表) models.ManyToManyField(其他表)  
		多对多(ManyToManyField)没有 on_delete 参数 !!!
		值一般可 =
		models.CASCADE:这就是默认的选项，级联删除，母表数据被删,这边子表的数据也要被删
		models.DO_NOTHING: 母表数据被删,这边子表什么都不做
		models.PROTECT: 保护模式，如果采用该选项，母表数据被删的时候，会抛出ProtectedError错误。
		models.SET_NULL: 置空模式，母表数据被删的时候，子表的这个外键连表字段会被置空,
			前提这个外键连表字段要设置 blank=True, null=True,定义该字段的时候，允许为空。
		models.SET_DEFAULT: 置默认值，母表数据被删的时候，子表的这个外键连表字段设置为默认值，
			所以定义子表的这个外键连表字段的时候注意加上一个默认值。
		models.SET(): 自定义一个值，,母表数据被删的时候，子表的这个外键连表字段设置为某个指定内容!!
			SET()使用例子:
			    user = models.ForeignKey(USER, on_delete=models.SET( USER.objects.get(id=100) )
基本数据库的坑补得差不多了,现在需要 js 和 py 对 xml 的处理问题, 
	考虑到多媒体文件不是单行字符串数据, 对应的content 需要塞入多行内容,所以需要使用xml
	js找来了一个生成 xml 文件的库函数 xmlwriter.js,但是要做补充, 自己写自己的 tofromstring, 具体还是要说明一下!!
	这里主要学习 字符串的 replace 函数 把 & < > " 等字符转成转义字符,避免注入攻击
	然后就是python的了!!有多种方法,优先使用ElementTree 高速!!
		例如 example.xml
		<?xml version="1.0"?>
		<doc>

		<Line><Cndt>1:1:1:256:0</Cndt>
		<Cnte> 这是第一篇文章的开头</Cnte>
		</Line>
			
		<Line><Cndt>1:1:2:257:0</Cndt>
		<Cnte> 床前明月光</Cnte>
		</Line>
		
		</doc>

		import xml.etree.ElementTree as ET
		tree = ET.ElementTree(file='example.xml')
		root = tree.getroot()	
		root[0].tag	//Line
		root[0][0].tag	//Cndt
		root[0][1].tag	//Cnte
		root[0][1].tag	//这是第一篇文章的开头
	python 写 xml 同样 使用 ET 参考 : https://www.cnblogs.com/AlwinXu/p/5483177.html
	js 读 xml,主要使用 原生DOM方式,原生js 使用 window.XMLHttpRequest 或者 window.DOMParser 方式 
		https://blog.csdn.net/u013719339/article/details/73181122
		https://blog.csdn.net/zxyudia/article/details/62891849
		http://www.w3school.com.cn/tiy/t.asp?f=xmle_node_parsertest_1
	还要解决 django的 GET 请求!!其实也就是:
	if request.method == "GET":  # 请求方法为GET时，进行处理
		return render('/static/clients/clie001/example.xml')
	但是,关于,django 这个 request 的详细内容,可以看 http://djangobook.py3k.cn/appendixH/
python 读文件片段 
        file = open(os.path.join("./", file_obj.name), 'r')
        while 1:
            line = file.readline()
            if not line:
                break
            print(line)  # do something
        file.close()
现在搭路 前端写xml 传到后端 后端存数据库 然后后端读取数据库写xml:
	前端写xml,只使用 Kate Bobe spac 三个tag
	然后后端 先检查 <>符号和 tag 然后直接把 Cnte 的全部内容写入 数据库
	检查建立数据库表单出现的问题!!
		textfield 是不能使用: ALTER TABLE web_william MODIFY COLUMN user VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL 来更改 字符编码的
		应该使用: 'ALTER TABLE web_william MODIFY COLUMN user TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL
		mysql 这句话的意思:
			ALTER TABLE web_william 	//选择表
			MODIFY COLUMN user		//更改字段内容
			VARCHAR(100) /TEXT		//如果这个字段是 charfield 那么使用 VARCHAR(100) 限制多少个字符!!
							  字符个数与字符编码有关系,并不是8bit数据为一个字符
							  如果这个字段是 textfield 那么是并不限制字符个数的!!
			CHARACTER SET utf8 COLLATE utf8_general_ci	//表示 字符编码设置为 utf-8
			NOT NULL / NULL  		//表示这个字段 不允许空 或者允许空 状态
	python 补坑:
		python没有 switch !! 最好还是使用 if elif 代替	
		password-sha 格式  用户名<签名>密码 转成的sha256	
		数字转字符串 int(xx) 数字字符窜转数字 str('xxx')
		注意.子表对象不能直接对包含的母表对象内容直接修改:只能通过反向查询获得母表对象然后母表对象对自身内容进行更改
			例如不能 23line.content.count = 1
				 23line.save()
			只能反向查询  cnt = Cnte.objects.get(line0001__linenum=23)
				cnt.count = 1
				cnt.save()
		例如:needyou<i dont like it>123456 -> 574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B
		一定要添加一条 userlist 用户数据 才可以好好模拟接下来的事情!!
		还有 使用 objects.get()不存在的数据条可能会出错,所以适合使用 try: expect: 而不是 if: else:
		python Elementtree 处理 xml 的重点 以及处理 复杂的编码准换关系 :
			ET 不能有 包含子tag的text 但是可以通过tostring和fromstring 转换格式来存储,
			然而也有问题
			参考: https://www.zybuluo.com/Alston/note/778377
			先:cnte = ET.tostring(child[1],encoding='utf-8') 
			使用tostring 只能获取整段子内容字符串格式,但是不是一般的字符串对象,是有很多其他继承内容的 特殊字符串对象
			然后 必须先解码: cnte.decode('utf-8'), 显然这个decode是这个字符串特有的继承函数
			然后才把解码后的字符串写入数据库 写入的内容是 <ss><a>喜欢你</a></ss>
			然后重新读出来后使用 formstring 就可以完美重构 Element对象内容:
			        kk1 = lucy[6].linecnte.content
				xmlcnte = ET.fromstring(kk1)
			如果不decode, 直接把字符串写入数据库,
			那么写入的内容是 b'<ss><a>\54\57\64\</a></ss>'
			重新读出来也是 这个奇怪的字符串内容,
			读出来的这个奇怪字符串是一个普通的字符串对象,没有继承,所以不可以使用 decode
			直接 fromstring 也会出错.
			另外补充: tostring的得到字符串 也是 b'<ss><a>\54\57\64\</a></ss>'
				但是这个tostring的字符串是特殊字符串,所以可以直接 fromstring 回去 不出错!!
			xml 节点换行美化问题:
			节点结构:
			<kate age=12 tall='6feet'> hello all </kate>
			   |    \	 /             |        |    |
			  tag     attrib              text     tag  tail
			注意 tostring 会把 tail 的字符内容也算入
			很多时候我们需要节点换行,其实就是在tail添加 \n 符号  
			关于根节点的的 换行,使用 Elementtree库的话,	直接在 root.text='\n'就好.
			因为.text赋值的内容紧贴着<root> 而不是紧贴</root>,也不会在中间
			注意 tostring 会把 tail 的字符内容也算入字符串,但是 append时会忽略tail的内容
		python 比较 字符串 使用 == 当两个字符串完全相同,true 否则 false
		python 初始化数组有两个类型:
			aa = []
			bb = {}
			使用[]的 无法使用 aa[2] = 90, 给成员赋值,只能 使用 aa.append(90)	
			使用{}的 可以使用 aa[1] = 89, 的方式赋值
    后端接收xml参考片段:
    # 接收 xml 文件
    if request.method == "POST":  # 请求方法为POST时，进行处理
        print('2222')
        file_obj = request.FILES.get('file100')
        import os
        f = open(os.path.join("./", file_obj.name), 'wb+')
        print(file_obj, type(file_obj))
        for chunk in file_obj.chunks():
            f.write(chunk)
        f.close()
        print('xml file get')



        # 检查并生成数据库表单
        from django.db import models
        from django.db import connection
        from web.dy_model_creat import create_model
        from web.dy_model_creat import install
        table_name = 'web_userlist'
        fields = {
            'user': models.CharField(max_length=32),
            'pwsha': models.CharField(max_length=64),
            'realname': models.CharField(max_length=64),
            'pesonid': models.CharField(max_length=100),
            'trusttb': models.CharField(max_length=100),
            'svshatb': models.CharField(max_length=100),
            'linetb': models.CharField(max_length=100),
            'cntetb': models.CharField(max_length=100),
            'blinenum': models.IntegerField(blank=True, null=True),
            'bcntenum': models.IntegerField(blank=True, null=True),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['user', 'datetime'],
            'verbose_name': '用户列表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Userlist = create_model('userlist',
                                fields,
                                options=options,
                                app_label='web',
                                module='web',
                                admin=admin
                                )
        if  table_name in connection.introspection.table_names() :
            pass
        else :
            install(Userlist)
            with connection.cursor() as cursor:
                cursor.execute(
                    'ALTER TABLE web_userlist MODIFY COLUMN user VARCHAR(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
                cursor.execute(
                    'ALTER TABLE web_userlist MODIFY COLUMN realname VARCHAR(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL')
        #添加 用户 使用try expect 而不是 if else 
        try:
            user = Userlist.objects.get(user='needyou', pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B')
            ltb = 'web_' + user.linetb
            ctb = 'web_' + user.cntetb
            biglinenum = user.blinenum
            bigcntenum = user.bcntenum
            print(ltb,ctb,'///////////////////////////////////////////////')
        except:
            Userlist.objects.create(user='needyou',    #needyou<i dont like it>123456
                                pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B',
                                realname='下半世',
                                pesonid='chinaid:33987117809046775',
                                trusttb='trust0001',
                                svshatb='svsha0001',
                                linetb='line0001',
                                cntetb='cnte0001',
                                blinenum=0,
                                bcntenum=255,
                                datetime='2019-10-22 21:49:05.4587')
            ltb = 'web_line0001'
            ctb = 'web_cnte0001'
            biglinenum = 0
            bigcntenum = 255

        #添加 用户相关数据表
        fields = {
            'cntenum': models.IntegerField(blank=True, null=True),
            'type': models.CharField(max_length=10),
            'content': models.TextField(blank=True, null=True),
            'history': models.TextField(blank=True, null=True),
            'count': models.IntegerField(blank=True, null=True),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['cntenum', 'datetime'],
            'verbose_name': '0001内容表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Cnte = create_model('cnte0001',
                            fields,
                            options=options,
                            app_label='web',
                            module='web',
                            admin=admin
                            )
        if  ctb in connection.introspection.table_names() :
            pass
        else :
            install(Cnte)
            with connection.cursor() as cursor:
                cursor.execute(
                    'ALTER TABLE web_cnte0001 MODIFY COLUMN content TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NULL')
                cursor.execute(
                    'ALTER TABLE web_cnte0001 MODIFY COLUMN history TEXT CHARACTER SET utf8 COLLATE utf8_general_ci NULL')
            #创建 空内容行
            Cnte.objects.create(cntenum=0,
                                type='edit',
                                content='<Cnte>&lt;br&gt;</Cnte>\n',
                                count=0
                                )

        fields = {
            'linenum': models.IntegerField(blank=True, null=True),
            'linecnte': models.ForeignKey(Cnte, blank=True, null=True, on_delete=models.CASCADE),
            'datetime': models.DateTimeField(blank=True, null=True),
        }
        options = {
            'ordering': ['linenum', 'linecnte', 'datetime'],
            'verbose_name': '0001行表',
        }
        admin = {}
        # from django.utils.encoding import smart_str  #  convert unicode to string
        Line = create_model('line0001',
                            fields,
                            options=options,
                            app_label='web',
                            module='web',
                            admin=admin
                            )
        if ltb in connection.introspection.table_names():
            pass
        else:
            install(Line)

        #读取xml文件并写入数据到数据库
        from datetime import datetime
        from datetime import timezone
        dt = datetime.now().replace(tzinfo=timezone.utc)

        import xml.etree.ElementTree as ET
        from xml.etree.ElementTree import Element
        from xml.etree.ElementTree import ElementTree
        tree = ET.parse('testfile')
        root = tree.getroot()
        epty = '<Cnte>&lt;br&gt;</Cnte>\n'
        for child in root:
            # print(child[0].text)
            strl = child[0].text
            if 'newl' in strl:
                strl = strl.split(':')
                typ = strl[1]       # 不能使用 type 变量,只能使用typ
                cnte = ET.tostring(child[1],encoding='utf-8')
                cnte = cnte.decode('utf-8')
                # print(cnte.decode('utf-8'))
                # print(lucy[4].linecnte.content, kong, '::::::', cnte == epty)
                if cnte == epty :
                    # print('yes')
                    content = Cnte.objects.get(cntenum=0)
                else:
                    bigcntenum += 1
                    contentnum = bigcntenum
                    content = Cnte.objects.create(cntenum = contentnum,
                                              type = typ,
                                              content = cnte,
                                              count = 0,
                                              datetime = dt)
                numl = int(strl[2])
                if numl > biglinenum :
                    Line.objects.create(linenum = numl,
                                        linecnte = content,
                                        datetime = dt)
                    Tom = Cnte.objects.get(line0001__linenum = numl)    #反向查询
                    Tom.count += 1
                    Tom.save()
                    biglinenum += 1
                else:
                    Tom = Line.objects.get(linenum = numl)
                    Tom.linecnte = content
                    Tom.save()
                    Tom = Cnte.objects.get(line0001__linenum = numl)    #反向查询
                    Tom.count += 1
                    Tom.save()
        user = Userlist.objects.get(user='needyou',
                         pwsha='574087358D1D69F0EACEBEE4C5ED10DE65A6B3FC0DEC680714294284F5847A6B')
        user.blinenum = biglinenum
        user.bcntenum = bigcntenum
        user.datetime = dt
        user.save()


        #读数据库 生成xml文件  注意 node 点不能共用
        parser = ET.XMLParser(encoding="utf-8")
        doc = Element('doc')
        lucy = Line.objects.filter(linenum__lte = user.blinenum )
        kate = lucy.values_list('linenum','linecnte__cntenum','linecnte__type')
        i = 0
        xmlline = {}
        xmlcndt = {}
        xmlcnte = {}
        for baby in lucy :
            kity=baby.linecnte.content
            xmlcndt[i] = Element('Cndt')
            xmlcndt[i].text = str(kate[i][0]) +':'+ str(kate[i][1]) +':'+ kate[i][2]
            xmlcndt[i].tail = '\n'
            xmlcnte[i] = ET.fromstring(kity)
            xmlcnte[i].tail = '\n'
            xmlline[i] = Element("Line")
            xmlline[i].append(xmlcndt[i])
            xmlline[i].append(xmlcnte[i])
            xmlline[i].tail = '\n\n'
            doc.append(xmlline[i])
            i += 1
        doc.text='\n\n'       #这个提交的text内容,紧贴在<doc>后,并不是紧贴在在</doc>前
        creTree = ElementTree(doc)
        creTree.write("Lexicon.xml",encoding="utf-8", xml_declaration=True)
	









20181106
后端读取数据库写xml 传到前端并刷新页面 !!		
	前端的这个请求
	$.get("../loadfile", function(data,status,xhr){ readyloadfile(data,status,xhr) } )
	注意最终只是当前页面获得了一个数据文件或者数据页面,并没有 新建页面 或者 内容覆盖当前页面
	对应的后端只能发 template 里的文件,
	def loadf(request):
	    dy_model_creat_log()
	    if request.method == "GET":  # 请求方法为GET时，进行处理
	        return render(request,'bili.html') 	# template 里的 bili.html
		或者 return render(request,'kk.xml') 	# template 里的 kk.xml
	其他 文件夹里的都显示出错!!
	return render(request,'/static/clients/clie001/bili.html')
	return render(request,'/static/clients/clie001/kk.xml')	

		
	然而,前端使用这段代码:
	    if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
	        xmlhttp=new XMLHttpRequest();
	    } else {// code for IE6, IE5
	        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	    }
	    xmlhttp.open("GET","/static/clients/clie001/kk.xml",false);
	    xmlhttp.send();
	    xmlDoc=xmlhttp.responseXML;     //获取video2里的值：video2.mp4
	    var xmlvar = xmlDoc.getElementsByTagName("Cnte")[1] //.childNodes[0].nodeValue;
	    console.log(xmlvar)
	并不需要通过后端自定义的程序, djanggo 自动提交/static/clients/clie001/kk.xml文件!!
	注意最终只是当前页面获得了一个数据文件或者数据页面,并没有 新建页面 或者 内容覆盖当前页面

	js创建新页面的 并跳转 三种方式
	1.a标签
		a标签:
		<a href="http://www.jb51.net" title="脚本之家">Welcome</a>
		<a href= “javascript:history.go(-1)”>  :上一个页面，就是前一个页面
		<a href= “javascript:history.go(1)”>  :下一个页面，就是后一个页面
		<a href="http://www.jb51.net" title="脚本之家" target="_blank">Welcome</a>
	2 . location对象的href属性：
		window.location.href="http://www.jb51.net";      //当前页面,获得新页面覆盖,没有另外建立新页面
	3.open :
		window.open(“http://www.w3schools.com”,”_blank”);     //在另外新建窗口中打开窗口
		_self 表示当前窗口
		_blank 表示新窗口
		_parent 表示父窗口
		_top 表示顶层窗口
		这里注意 这些 方法都是要提交后端请求,重新获得页面上内容的,
	现在我们尝试实现的的需求是,把当前信息放到新页面显示,不过好像是不可能实现,还是需要访问服务器获取内容!!
	这样就得需要巧妙的设计,这里就先不讨论了
	学到了 foreach
	var arr = ["one","two","three"];

	//只能遍历 这样这种写法只是表面修改 实际上没有改变数组本身内容!
	arr.forEach(function(part){ 
	  part = "four";
	  return "four";
	})	
	//这种写法 就可以修改 数组本身内容!
	arr.forEach(function(part, index, theArray) {
  		theArray[index] = "hello world";
	});
	
	//这种写法可以修改 数组本身内容
	var spac = '3:4:5:6:7'
	spac = spac.split(':')
	spac.forEach(function(a,b,c){
		spacnum = parseInt(a)
		c[b] = 'y'
		for(;spacnum > 1;){
        		c[b] += 'y'
        		spacnum -= 1
        	}
		console.log(c[b])
	})
	spac = spac[0] + ' << ' + spac[3] 
	console.log(spac)
	
以下这段不成熟的片段,实现了从 xml 读取数据到 页面!!
    //更新网页, 假设 xml里 是连续的行!! 不是分散的行!!
    var ff = document.getElementsByClassName('main')
    var flnum = parseInt(ff[0].firstElementChild.children[1].innerText)
    var llnum = parseInt(ff[0].lastElementChild.children[1].innerText)
    var linod = null
    var clnum = null
	var boby = null
	var spac = null
	var spacnum = null
	var kate = []
	var bobe = []
	var rlikn = null
	var flikn = null
	var htmlcnte = null
    var kl = null


    //var root = r.getElementsByTagName('doc')
    //console.log(r)

    var parser = new DOMParser();
    var tree = r.children[0].innerHTML
    tree = '<root>' + tree + '</root>'
    //tree = tree.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")
    //tree = tree.replace(/<br>/g, "<br></br>")
    var xmldom = parser.parseFromString( tree , 'text/xml')
    var root = xmldom.getElementsByTagName('root')
    //root[0].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")

    //var kl = root[0].innerHTML
    //kl =  kl.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")
    console.log(root[0].innerHTML)
    console.log(xmldom)

    //root[0].innerHTML = kl



    var El = root[0].firstElementChild
    while ( El != null) {
        boby = El.children[0].innerHTML.split(':')
        clnum = parseInt(boby[0])
        if (( clnum <= llnum ) && ( clnum >= llnum )) {
            linod = ff[0].children[clnum-flnum]
            switch (boby[2]){
                case "edit" :
                    htmlcnte = '&#10;&#09;<div class="edit" cnteid="' + boby[1] + '" cntety="1"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span><div class="edtx">' + El.children[1].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&") + '</div></div>'
                    break
                case "hdty" :
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    spac = ' '
                    for(;spacnum > 1;){
                        spac += ' '
                        spacnum -= 1
                    }
                    rlikn = (El.children[1].children[3].innerHTML.split(':'))[1]
                    flikn = (El.children[1].children[4].innerHTML.split(':'))[1]
		            htmlcnte = '&#10;&#09;<div class="hdty" cnteid="' + boby[1] + '" cntety="7"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '" style="font-size:0.84em; font-weight:normal;">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="hdda">' + El.children[1].children[1].innerHTML + '</div>&#10;&#09;&#09;<div class="spac">' + spac + '</div>&#10;&#09;&#09;<div class="hdti">' + El.children[1].children[2].innerHTML + '</div>&#10;&#09;&#09;<div class="hdcr" contenteditable="false">&#10;&#09;&#09;&#09;<div class="rlik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="rlikn">' + rlikn + '</div>&#10;&#09;&#09;&#09;<div class="flik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="flikn">' + flikn + '</div>&#10;&#09;&#09;&#09;<div class="othrc">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "imgt" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')                                                     case "edit" :
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="imgt" cnteid="' + boby[1] + '" cntety="2" contenteditable="false"><span class=""orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="imgd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){  //发现了 spac 比 bobe kate 多 一项
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="igdd">&#10;&#09;&#09;&#09;&#09;<img class="imgs" src="' + bobe[i].innerHTML + '" alt="pic error">&#10;&#09;&#09;&#09;&#09;<div class="imgi" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "adio" :
                    htmlcnte = '&#10;&#09;<div class="adio" cnteid="' + boby[1] + '" cntety="4" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="adod">&#10;&#09;&#09;&#09;<audio src="' + El.children[1].children[1].innerHTML + '" controls=""></audio>&#10;&#09;&#09;&#09;<div class="adoi" contenteditable="true">' + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "math" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="math" cnteid="' + boby[1] + '" cntety="3" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="matd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="mtdd">&#10;&#09;&#09;&#09;&#09;<p>' + bobe[i].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")  + '</p>&#10;&#09;&#09;&#09;&#09;<div class="mati" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "vido" :
                    htmlcnte = '&#10;&#09;<div class="vido" cnteid="' + boby[1] + '" cntety="5" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="vidd">&#10;&#09;&#09;&#09;<video controls="" width="320" height="240">&#10;&#09;&#09;&#09;&#09;<source src="' + El.children[1].children[1].innerHTML + '" type="video/mp4">&#10;&#09;&#09;&#09;</video>&#10;&#09;&#09;&#09;<div class="vidi" contenteditable="true">'  + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "stav" :
                    spac = ' '
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    for(;spacnum > 1;){
        	            spac += ' '
        	            spacnum -= 1
                    }
                    htmlcnte = '&#10;&#09;<div class="stav" cnteid="' + boby[1] + '" cntety="6" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + linod.children[1].innerText + '</span>&#10;&#09;&#09;<div class="stad">&#10;&#09;&#09;&#09;<div style="white-space:pre; display:none;">&#10;<textarea class="vex-tab-editor">' + El.children[1].children[1].innerHTML + '</textarea>&#10;&#09;&#09;&#09;&#09;<p id="errorTip" class="text-danger"></p>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + spac + '</div>&#10;&#09;&#09;&#09;<div>&#10;&#09;&#09;&#09;&#09;<div class="tab-preview-container" style="margin-left:50px;">&#10;&#09;&#09;&#09;&#09;&#09;<canvas class="tabPreviewer"></canvas>&#10;&#09;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
		    }

            linod.insertAdjacentHTML("afterEnd",htmlcnte)
            linod.remove()
        }else{
            linod = ff[0].lastElementChild
            switch (boby[2]){
                case "edit" :
                    htmlcnte = '&#10;&#09;<div class="edit" cnteid="' + boby[1] + '" cntety="1"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span><div class="edtx">' + El.children[1].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&") + '</div></div>'
                    break
                case "hdty" :
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    spac = ' '
                    for(;spacnum > 1;){
                        spac += ' '
                        spacnum -= 1
                    }
                    rlikn = (El.children[1].children[3].innerHTML.split(':'))[1]
                    flikn = (El.children[1].children[4].innerHTML.split(':'))[1]
		            htmlcnte = '&#10;&#09;<div class="hdty" cnteid="' + boby[1] + '" cntety="7"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '" style="font-size:0.84em; font-weight:normal;">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="hdda">' + El.children[1].children[1].innerHTML + '</div>&#10;&#09;&#09;<div class="spac">' + spac + '</div>&#10;&#09;&#09;<div class="hdti">' + El.children[1].children[2].innerHTML + '</div>&#10;&#09;&#09;<div class="hdcr" contenteditable="false">&#10;&#09;&#09;&#09;<div class="rlik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="rlikn">' + rlikn + '</div>&#10;&#09;&#09;&#09;<div class="flik">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="flikn">' + flikn + '</div>&#10;&#09;&#09;&#09;<div class="othrc">&#10;&#09;&#09;&#09;&#09;<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "imgt" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    console.log(spac)
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    console.log(spac)
                    console.log(bobe)
                    htmlcnte = '&#10;&#09;<div class="imgt" cnteid="' + boby[1] + '" cntety="2" contenteditable="false"><span class=""orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="imgd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="igdd">&#10;&#09;&#09;&#09;&#09;<img class="imgs" src="' + bobe[i].innerHTML + '" alt="pic error">&#10;&#09;&#09;&#09;&#09;<div class="imgi" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "adio" :
                    htmlcnte = '&#10;&#09;<div class="adio" cnteid="' + boby[1] + '" cntety="4" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="adod">&#10;&#09;&#09;&#09;<audio src="' + El.children[1].children[1].innerHTML + '" controls=""></audio>&#10;&#09;&#09;&#09;<div class="adoi" contenteditable="true">' + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "math" :
                    spac = El.children[1].children[0].innerHTML.split(':')
                    spac.forEach(function(a,b,c){
		                spacnum = parseInt(a)
		                c[b] = ' '
		                for(;spacnum > 1;){
        	                c[b] += ' '
        	                spacnum -= 1
                        }
                    })
                    kate = El.getElementsByTagName('Kate')
                    bobe = El.getElementsByTagName('Bobe')
                    htmlcnte = '&#10;&#09;<div class="math" cnteid="' + boby[1] + '" cntety="3" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="matd">'
                    spac.forEach(function(item,i){
                        if( bobe.length >= i){
                            htmlcnte = htmlcnte + '&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + item + '</div>&#10;&#09;&#09;&#09;<div class="mtdd">&#10;&#09;&#09;&#09;&#09;<p>' + bobe[i].innerHTML.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, "\"").replace(/&amp;/g, "&")  + '</p>&#10;&#09;&#09;&#09;&#09;<div class="mati" contenteditable="true">' + kate[i].innerHTML + '</div>&#10;&#09;&#09;&#09;</div>'
                        }
                    })
                    htmlcnte = htmlcnte + '&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "vido" :
                    htmlcnte = '&#10;&#09;<div class="vido" cnteid="' + boby[1] + '" cntety="5" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="vidd">&#10;&#09;&#09;&#09;<video controls="" width="320" height="240">&#10;&#09;&#09;&#09;&#09;<source src="' + El.children[1].children[1].innerHTML + '" type="video/mp4">&#10;&#09;&#09;&#09;</video>&#10;&#09;&#09;&#09;<div class="vidi" contenteditable="true">'  + El.children[1].children[0].innerHTML + '</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break
                case "stav" :
                    spac = ' '
                    spacnum = parseInt(El.children[1].children[0].innerHTML)
                    for(;spacnum > 1;){
        	            spac += ' '
        	            spacnum -= 1
                    }
                    htmlcnte = '&#10;&#09;<div class="stav" cnteid="' + boby[1] + '" cntety="6" contenteditable="false"><span class="orgl">&nbsp;</span><span class="lid" oid="' + boby[0] + '">' + boby[0] + ':</span>&#10;&#09;&#09;<div class="stad">&#10;&#09;&#09;&#09;<div style="white-space:pre; display:none;">&#10;<textarea class="vex-tab-editor">' + El.children[1].children[1].innerHTML + '</textarea>&#10;&#09;&#09;&#09;&#09;<p id="errorTip" class="text-danger"></p>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;<div class="spac" contenteditable="true">' + spac + '</div>&#10;&#09;&#09;&#09;<div>&#10;&#09;&#09;&#09;&#09;<div class="tab-preview-container" style="margin-left:50px;">&#10;&#09;&#09;&#09;&#09;&#09;<canvas class="tabPreviewer"></canvas>&#10;&#09;&#09;&#09;&#09;</div>&#10;&#09;&#09;&#09;</div>&#10;&#09;&#09;</div>&#10;&#09;</div>'
                    break

            }
            //console.log(linod)
            linod.insertAdjacentHTML("afterEnd",htmlcnte)
        }
        console.log(El)
        El = El.nextElementSibling
    }
    // 统一处理行号格式
    spacnum = ff[0].lastElementChild.children[1].innerText.length
    linod = ff[0].firstElementChild
    while ( linod != null) {
        boby = spacnum - linod.children[1].innerText.length
        for(;boby > 0;){
    	    linod.children[1].innerText = '0' + linod.children[1].innerText
            boby -= 1
        }
        console.log(linod , linod.nextElementSibling)
        linod = linod.nextElementSibling
    }

    onloadlast()

当中遇到了很多设计上的问题, 例如 <spac>10:10:10:</spac>, 应该改为 <spac>10:10:10</spac>
使用 原生js parser 分析 xml 有很多坑, 重点是, 使用parser分析的xml文件必须是一个规范的xml
以下:
	<kate> < </kate>
	<kate> <br> </kate>
	都不是规范的 xml 文件的内容,要分析这样的文件,或者改成这样子, parser都会崩溃
因为 parser 这么严格的特点
那么就要重新考虑,假如 行内容 要显示 禁忌符号 < > & " 的 xml和数据库的内容存放 问题

附加补充:特殊符号:http://w13.loxa.edu.tw/ctjh930220/








20181124
处理了 wrap 
考虑以下情景:
	原来:  	line32 -> cnte47	line55之后没有line
	后来可以出现以下各种情形
	1,	line32_mewl,  line33_wrap-> cnte47
	2,	line32_newl,	没有line -> cnte47
	3,	line32_wrapl-> cnte46,	line33-> cnte47
	4,	line20_wrapl-> cnte47,	line32-> cnte60
	5,	line20_wrapl-> cnte47,	line32_newl
	....
后来想到一个合理的 cnte count 改变策略
	line_newl时, 如果line本存在,先把当前line指向的cnte_count-1,然后line再指向新cnte,并新cnte_count+1
		     如果line新建,line再指向新cnte,并cnte_count+1
	line_wrap时, 当前line指向的cnte_count-1,然后line再指向新cnte,并新cnte_count+1
	line_fxl时, 获得cnte的content 比较讲究,
			如果 xml的数据条是 = <br> 就直接用特定的哦空白cnte
			如果 != <br> xml获得 cntenum != 0 则是新cnte,需要建立另外存储
			否则 就是就就内容,直接从库里取得内容,
				获得的内容需要添加history,并修改当前内容
				还要注意有时候fixl但是cnte 到最后还是没有变化,所以不算修改
				所以不用添加history,什么都不用做
		    然后就是修改line指向
			如果是新行,行号大于现有的 建立新指向
			如果是指向没有变,那么什么都不变
			不过有种例外,如果本来有的行内容变成空白的cnte,并不是在cnte本身修改成空白cnte
			而是让line直接指向特定的空白cnte!!!
然后是整合到一块!
	首先为了跟好测试,原来用于调试而建立的分立系统就是不需要动了,另外建立新的内容来整合测试
原来的分立测试,页面右下角 onclick="savefile(this,event) 然后 整合xml testfile传到服务器 项目根目录
	服务器 views.saveline 处理并写入数据表单 web_cnte0001 web_line0001 然后整洁读出数据到 lexicon.xml存在项目根目录
	手动把 lexicon.xml 拷贝到 clie001 的kkl.xml, 
	还不要 忘了ready.js loadfile 
		$.get("/static/clients/clie001/kk1.xml", function(data,status,xhr){ readyloadfile(data,status,xhr) } )
		还有 onloadlast 通过加载 kkl.xml 来展示内容
	首先, 关闭 $.get 加载 loadtest_new 来测试 数据库新建立数据条
	然后打开 $.get 加载loadtedt_空白来检测
		由于历史原因, new 需要多次 saveline 才行,不然不能接着做wrap测试
	如此类推,loadtest_wrap 调试 wrap后 刷写数据库
		loadtest_build_for_fix 为 fix建立调试环境
		loadtest_fix1 调试 fix
		loadtest_fix2 调试 带 wrap的fix
	注意 在 base1.js 的多媒体内容上传都在 clie001 了,先不管
	
整合测试,直接使用新的数据表单和函数 不要与分立测试共用,另外这里我都使用加 2 的命令方式
	另外 django的 架构很有问题,我使用views.saveline2,他还是跳回到分立测试的 views.saveline函数,
	就是 onclick="savefile(this,event) 收集变化内容 上传服务器 然后 saline 存数据库,然后重获 xml返回,
	最后更新页面!!! 
	记录未完
	接下来还没有实现 httpresponse 返回文件和更新页面的问题
	网上看到了一个 download文件的例程函数: http://www.cnblogs.com/crystaltu/p/9228454.html
def download(request):  
    """                                                                           
    Send a file through Django without loading the whole file into                
    memory at once. The FileWrapper will turn the file object into an             
    iterator for chunks of 8KB.                                                   
    """   
      
    #读取mongodb的文件到临时文件中  
    fileid_=request.GET["fileid"]  
    filepath_ = ('%s/%s'%(MEDIA_ROOT, fileid_)) #文件全路径  
    file_=TFiles.objects.get(fileid=int(fileid_))  
    filename_=file_.filename  
    filetype_=file_.filetype  
  
    if os.path.isfile(filepath_):  
        pass  
    else:  
        mongoLoad(fileid_)  
      
    #下载文件  
    def readFile(fn, buf_size=262144):#大文件下载，设定缓存大小  
        f = open(fn, "rb")  
        while True:#循环读取  
            c = f.read(buf_size)  
            if c:  
                yield c  
            else:  
                break  
        f.close()  
    response = HttpResponse(readFile(filepath_), content_type='APPLICATION/OCTET-STREAM') #设定文件头，这种设定可以让任意文件都能正确下载，而且已知文本文件不是本地打开  
    response['Content-Disposition'] = 'attachment; filename='+filename_.encode('utf-8') + filetype_.encode('utf-8')#设定传输给客户端的文件名称  
    response['Content-Length'] = os.path.getsize(filepath_)#传输给客户端的文件大小  
    return response
	
	尝试修改迎合自己需求!!			













20181106
后端读取数据库写xml 传到前端并刷新页面 !!
重点问题:
	django  save1() save2()	自动纠错? save1()函数错误,执行save2()?
	firefox 缓存问题 shift+crtl+delect 删缓存 ,
		关闭缓存 about:config 页面
			browser.cache.disk.enable = false
			browser.cache.memory.enable = false
			browser.cache.offline.enable = false
	jquery $.get() $.post() django 可以处理为 静态资源路径STATICFILES_DIRS的内容, 
		也可以是urlpatterns,自己注册的内容
		





20181205
建立登录界面:
	使用模板, 模板中 第3方登录图标 使用diaplay:flex 出现了不必要的下滑线,需要使用bootstrap框架的css 来解决
	但是发现使用 bootstrap 框架会绑架了 body 标签
	自己 body 设计的参数不再起作用!	
	关于使用 span 放置 特殊符号,比如 密码图案还有 ::before ::after 的使用
	改变 inpput 预填充文字的颜色例如:
		input::-webkit-input-placeholder { /* WebKit, Blink, Edge */
		    color:    #909;
		}
		input:-moz-placeholder { /* Mozilla Firefox 4 to 18 */
		   color:    #909;
		}
		input::-moz-placeholder { /* Mozilla Firefox 19+ */
		   color:    #909;
		}
		input:-ms-input-placeholder { /* Internet Explorer 10-11 */
		   color:    #909;
		}
js 补习:
	一般的 js 数组 array 和 html 的DOM 数组对象还是有所区别的
	例如 array 可以使用 pop() 获得最后一个成员, 但是 DOM对象数组咩没有这样的函数
	例如 classList 一个 典型的 Dom对象数组:
		<div id="demo" class="wrap-login100 p-l-55 p-r-55 p-t-65 p-b-54 login-log">
		获得
		var demo=document.getElementById("demo").classList;
		添加add()  
		demo.add("style");
		删除remove()
		demo.remove("style");
		包含contains()
		var is=demo.contains("style");
		console.log(is);//返回false
		其他属性：
		demo.length;//获取class的个数-1
		demo.item(0);//获取第一个类名
		原生通过正则对class的操作 










20181213
对于表单内容的验证,使用 login 例子本身自带的 Validate js 模板,再补上 正则表达式子来判断!!
在一个页面上画一个按钮，有四种办法：
    <input type="button" /> 这就是一个按钮。如果你不写javascript 的话，按下去什么也不会发生。
    <input type="submit" /> 这样的按钮用户点击之后会自动提交 form，除非你写了javascript 阻止它。
    <button> 这个按钮放在 form 中也会点击自动提交， (即<form> 里的 button 会默认点击触发 submmit 事件!!)
	比前两个的优点是按钮的内容不光可以有文字，还可以有图片等多媒体内容。（当然，前两个用图片背景也可以做到）。它的缺点是不同的浏览器得到的 	value 值不同；可能还有其他的浏览器兼容问题（葛亮）。
    其他标签，例如 a, img, span, div，然后用图片把它伪装成一个按钮。
对于 form submit的 加强学习:
例子!
<form>
    标题：<input type="text" name="title" /><br />
    内容：<textarea name="content"><textarea/><br />
    <button>提交</button>
</form>
方法1
$('button').on('click', function() {

    $('form').on('submit', function() {
        var title = $('inpur[name=title]').val(),
            content = $('textarea').val();

        $(this).ajaxSubmit({
            type: 'post', // 提交方式 get/post
            url: 'your url', // 需要提交的 url
            data: {
                'title': title,
                'content': content
            },
            success: function(data) { // data 保存提交后返回的数据，一般为 json 数据
                // 此处可对 data 作相关处理
                alert('提交成功！');
            }
            $(this).resetForm(); // 提交后重置表单
        });
        return false; // 阻止表单自动提交事件
    });
});
方法2
    $('form').on('submit', function() {
        var title = $('inpur[name=title]').val(),
            content = $('textarea').val();

        $(this).ajaxSubmit({
            type: 'post', // 提交方式 get/post
            url: 'your url', // 需要提交的 url
            data: {
                'title': title,
                'content': content
            },
            success: function(data) { // data 保存提交后返回的数据，一般为 json 数据
                // 此处可对 data 作相关处理
                alert('提交成功！');
            }
            $(this).resetForm(); // 提交后重置表单
        });
        return false; // 阻止表单自动提交事件
    });
首先form 里的 button 默认触发 form submit事件,如果我们选择了方法2,
	jquery 会给submit事件注册一个行为, 
	这样每当submit事件触发时先预处理(就是 on('submit', function() {}) 的function 内容),然后再执行默认的表单submit事件
	注意如果 这个预处理function return false 时, 预处理function后,不会继续执行默认的 submit 操作!!
如果我们选择了方法1,
	我们要知道, 点击button时,触发 submit事件的同时,也触发了 onclick, 不过似乎先执行onclick事件,后执行submit
	jquery 会给onclick事件注册一个行为,
	而这个onclick事件又会重新注册一个 submit前预处理行为
	即每一次 onclick时,都会 重新注册一个 submit前预处理行为
	onclick后轮到 submit事件执行时,会按着最新注册的预处理 执行一次,然后在submit表单内容到服务器
	当然 如果 最新注册的预处理function 也遇到return false 时,不会继续执行默认的 submit 操作!!
HTML <form> 标签的 enctype 属性
	application/x-www-form-urlencoded 	在发送前编码所有字符（默认）
	multipart/form-data 	不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
	text/plain 	空格转换为 "+" 加号，但不对特殊字符编码。
form submit 但不跳转 例子
	 <html>    
	  <body>    
	      
	  <form action="/api/user/register" method="post" id="registSubmit" >    
	      <input type="text" id="id_input_text" name="nm_input_text" />    
	      <input type="submit" id="id_submit" name="nm_submit" value="提交" />    
	  </form>         
	  </body>    
	  </html> 
	
	$('#registSubmit').on('submit', function(event){
	      registPost()
	     event.preventDefault() //阻止form表单默认提交
	})
	
	function registPost () {     
	   $.ajax({
	       type: "POST",
	       url: "/api/user/register",
	       data: $('#registSubmit').serialize(),
	       success: function(message) {
	     			console.log(message)
	   		},
	       fail: function(err){
				console.log(err)
		   	},
	    /*
	     或者用jquery.form.min.js提交
	     $('#registSubmit').ajaxSubmit(function(message){
	        console.log(message);
	     })
	     */
	}
form submit 后 django后端获取数据和处理:
html:input设置:
	<input class="input100" type="text" name="username" placeholder="请输入用户名" autocomplete="off">
	<input class="input100" type="password" name="pass" placeholder="请输入密码">
	print(request)
		<WSGIRequest: POST '/login/'>
	print(request.POST)
		<QueryDict: {'pass': ['12345678Qq'], 'username': ['ss']}>
	print(request.path)
		/login/
	print(request.method)
		POST
	print(request.session)
		<django.contrib.sessions.backends.db.SessionStore object at 0x7f0e8a597ac8>
        print(request.COOKIES)
		{}
	print(request.raw_post_data)  // django 1.6以后 是request.body
		b'username=ss&pass=12345678Qq'
        print(request.POST.get('username'))
		ss
        print(request.POST['username'])
		ss
        print(request.POST.getlist('username'))
		['ss']
需要 前后端都要检测 表单的输入内容,使用正则表达式匹配
	前端 js
	    //正则判断 密码至少包含大写字母，小写字母，数字，且不小于于8位,不大于16!!
	    var re = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[^]{8,16}$/
	    //正则判断 正确的邮箱格式 !!
	    var re1 = /^([a-zA-Z0-9_\-\.]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{1,5}|[0-9]{1,3})(\]?)$/
	    //正则判断  正确 11位 手机号码
	    var re2 = /^1\d{10}$/
	    //正则判断 含有标点符号
	    var re3 = /^((?=[\x21-\x7e]+)[^A-Za-z0-9])$/
	    //正则判断 密码至少包含大写字母，小写字母，数字，且不小于于8位,不大于16,且不含特殊符号除了'_'
	    var re4 = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z0-9_]{8,16}$/
	    //正则判断 只能 字母数字下划线 汉字 至少大于5个字符
	    var re5 = /[A-Za-z0-9_\u4e00-\u9fa5]{5,}$/
	    // 只要含有 @  因为username 可以 phone email name 所以 验证邮箱要附加条件
	    var re6 = /^(?=.*[@])[^]{1,}$/
		然后
		    var loginput = $('.validate-loginput .input100');
		    var reginput = $('.validate-reginput .input100');
		for(...){
			if( re4.test( $(loginput[i]).val().trim() ) ) ..	//正则匹配, 这个test()是原生js正则表达式自带的
			if( $(reginput[i]).val().trim().match(re1) ) ..		//或者这样正则匹配
		}
	后端 python 
		import re
		注意 python re 不接受这样的写法:
			    // 只要含有 @  因为username 可以 phone email name 所以 验证邮箱要附加条件
			    ^(?=.*[@])[^]{1,}$
			中的 [^] ,这个表示没有不该出现的,即,所有字符都可以出现
			但是python 不允许, 这样, ^ 就得必须带内容 比如[^a],表示不允许a出现
			如果要表示所有字符都可以出现 ,可以使用. 即
			    ^(?=.*[@]).{1,}$
后端用户密码加密解密验证过程!!
	使用 django 自带的框架好了:
	django的密码加密验证  安装加密算法 的使用教程
		https://django.readthedocs.io/en/2.1.x/topics/auth/passwords.html 
	setting.py 添加:
		PASSWORD_HASHERS = (
		    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
		    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
		    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
		    'django.contrib.auth.hashers.BCryptPasswordHasher',
		    'django.contrib.auth.hashers.SHA1PasswordHasher',
		    'django.contrib.auth.hashers.MD5PasswordHasher',
		    'django.contrib.auth.hashers.UnsaltedMD5PasswordHasher',
		    'django.contrib.auth.hashers.CryptPasswordHasher',
		    'django.contrib.auth.hashers.Argon2PasswordHasher',
		)
        表示密码的编码加密算法有: md5 unsalted_md5 pbkdf2_sha256 pbkdf2_sha1 bcrypt_sha256 aargon2 等
        bcrypt_sha256 需要另外安装库 pip install django[bcpt]
        argon2 需要另外安装库 pip install django[argon2]
	要使用的地方添加:
	from django.contrib.auth.hashers import make_password, check_password
        sha_pwd = make_password('needyou2<i dont like it>1234567', None, 'argon2')
        print(check_password('needyou2<i dont like it>1234567', '919c77acf44af0773fbe493d335e374f'))
	make_password: 根据密码生成加密串,数据库保存加密串而不是密码,减低帐号风险
		参数1:是要加密的密码串,例如这里 needyou2<i dont like it>1234567
		参数2: None 表示 每次生成的加密串都可以不一样,这个根据加密算法的性质看
		参数3: 选择一种加密算法
		结果是一条长长的加密字符串,例如 argon2$argon2i$v=19$m=512,t=2,p=2$dlVScVpodzVUTjRm$s9/1A8TEW3fpV0nslRUUkA
	check_password:
		直接检查秘密是否对上
		参数1:是密码串
		参数2:是加密串
		枚举,把 密码串重新加密后得到 加密串, 再跟已有的加密串比对!
		注意有些算法, 同一个密码串可以加密出多个不一样的加密串,
		但是由于是枚举比对的,所以只要 加密串曾经是这个密码串加密出来的,就可以匹配!!!
		而且不用告诉是什么算法加密的,函数会根据 加密串自动分析!!
django中render()与render_to_response()区别
	render()与render_to_response()均是django中用来显示模板页面的，但是在django1.3之后，render()便比render_to_response()更加招人待见！
	最明显的就是前者会自动使用RequestContext，而后者需要coding进去，例如：
		render(request,'share.html', {'registAdd': registAdd})
		render_to_response('share.html',{'registAdd':registAdd},context_instance = RequestContext(request)


做图片验证码:captcha
	https://blog.csdn.net/teavamc/article/details/77566781
	https://baijiahao.baidu.com/s?id=1592206104048546399&wfr=spider&for=pc
	https://blog.csdn.net/hejunw/article/details/80158473
	https://blog.csdn.net/u014745194/article/details/73997737
	https://stackoverflow.com/questions/34471102/python-nameerror-name-include-is-not-defined 关于 include 找不到
	https://django-simple-captcha.readthedocs.io/en/latest/usage.html#example-usage-for-ajax-form
	http://www.cnblogs.com/zhaijunming5/p/7570180.html
这个 captcha 非常棘手!!
	主要不知道如何单单揪出来 结合自定义的表格!!!!,也不知道如何处理样式!!
	整理captcha 的使用过程!!!
	安装: pip install django-simple-captcha
	settings.py 配置:
		INSTALLED_APPS = [
			....
			'captcha',
		]
		# django_simple_captcha 验证码配置其他配置项查看文档
		# 默认格式
		CAPTCHA_OUTPUT_FORMAT = '%(image)s %(text_field)s %(hidden_field)s '
		CAPTCHA_NOISE_FUNCTIONS = ('captcha.helpers.noise_null', # 没有样式
		    # 'captcha.helpers.noise_arcs', # 线
		    # 'captcha.helpers.noise_dots', # 点
		)
		# 图片中的文字为随机英文字母，如 mdsh
		# CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.random_char_challenge'
		 # 图片中的文字为数字表达式，如2+2=
		CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.math_challenge'
		# 超时(minutes)
		CAPTCHA_TIMEOUT = 1
	urls.py 配置:
		from django.conf.urls import url, include
		urlpatterns = [
		    .......
		    url(r'^captcha/', include('captcha.urls')),
		    url('load_test22',userctrl.some_view),	//专门 为检验 captcha建立的链接!!,例子一般写在views.py里.
		}						//这里自定义 到 userctrl.py里
	建立forms.py:
		from django import forms
		from captcha.fields import CaptchaField
		class LoginForms(forms.Form):
		    email = forms.CharField(label="邮箱", max_length=128)
		    password = forms.CharField(label="密码", max_length=128, widget=forms.PasswordInput)
		    captcha = CaptchaField()
	自定义的 userctl.py:
		from web.forms import LoginForms
		def some_view(request):
		    if request.POST:
		        form = LoginForms(request.POST)
		
		        # Validate the form: the captcha field will automatically
		        # check the input
		        if form.is_valid():
		            human = True
		            return HttpResponse('hahah')
		        else:
		            return HttpResponseRedirect('/load_test22/')
		    else:
		        form = LoginForms()

		    #return render_to_response('loadtest.html',{'login_form':form},context_instance =RequestContext(request))
		    return render(request, 'loadtest.html', {'login_form':form})
	loadtest.html 在合适的地方加上:
		<form action='.' method='POST' style="display:none">
		    {% csrf_token %}
		    {{ login_form }}
		<input type="submit" value='submit' />
		</form>
		-->
	这样,当我们`登录 127.0..../load_test22/ 传递userctl.some_view 内容`
		就会打开 loadtest.html
		login_form 会被自动替代!!
		其中 login_form.captcha 对应的内容是
	<input type="hidden" name="csrfmiddlewaretoken" value="dE16z9Ppx5aMrpGPdouOr6g2R9yO02X2seIiFKaqaPkiXYqjnMDkRMIIBQcqQzV5">
	<img src="/captcha/image/2924b20cacc3a722fd0a9b6685c46ca9fe73a799/" alt="captcha" class="captcha">
	<input autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" id="id_captcha_1" name="captcha_1" type="text">
	<input id="id_captcha_0" name="captcha_0" type="hidden" value="2924b20cacc3a722fd0a9b6685c46ca9fe73a799">
	由于 form action='.' 所以 submit后, 会重新的登录 127.0..../load_test22/ -> userctl.some_view
		form = LoginForms(request.POST)
		form.is_valid()
		直接 验证套装 captcha 的容,判断内容是否正确!!
	这种处理看着简单,但是用起来起来非但复杂,而且不好2次修改,只适合很模式化的登录注册页面设计! 也不通用!!!!!!,所以推荐自己写!!!
	特别是 对于 captcha 的 css 设计非常困难, 单独拆出来使用也麻烦
	单独拆出来使用的 思路 html里 {{ login_form.captcha }}
		或者 class LoginForms(forms.Form) 只有 captcha = CaptchaField()
自己做 验证码图片
	https://www.cnblogs.com/cq146637/p/7831387.html
	https://github.com/happy-python/check_code/blob/master/core/tools.py
	双方都有些错误,最后组合成功!!!
	urls.py 配置:
	urlpatterns = [
	    re_path(r'check_code',userctrl.check_code),
	    .......
	}
	userctl.py 添加!!:
		import random
		from PIL import Image, ImageDraw, ImageFont, ImageFilter
		from io import BytesIO
		
		def check_code(request):
		    stream = BytesIO()          #开辟一块内存空间，不用写在外存，减少读写操作
		    img, code = create_validate_code()
		    img.save(stream,'PNG')
		    img.save('idencode.png')  # 保存验证码图片 到项目根目录!!
		    print(code)
		    request.session['CheckCode'] = code
		    return HttpResponse(stream.getvalue())
		
		_letter_cases = "abcdefghjkmnpqrstuvwxy"  # 小写字母，去除可能干扰的i，l，o，z
		_upper_cases = _letter_cases.upper()  # 大写字母
		_numbers = ''.join(map(str, range(3, 10)))  # 数字
		init_chars = _letter_cases + _upper_cases + _numbers
		
		
		def create_validate_code(size=(120, 30),
		                         chars=init_chars,
		                         img_type="GIF",
		                         mode="RGB",
		                         bg_color=(255, 255, 255),
		                         fg_color=(0, 0, 255),
		                         font_size=18,
		                         font_type="Monaco.ttf",
		                         length=4,
		                         draw_lines=True,
		                         n_line=(1, 2),
		                         draw_points=True,
		                         point_chance = 2):
		
		    '''
		    生成验证码图片
		    @param size: 图片的大小，格式（宽，高），默认为(120, 30)
		    @param chars: 允许的字符集合，格式字符串
		    @param img_type: 图片保存的格式，默认为GIF，可选的为GIF，JPEG，TIFF，PNG
		    @param mode: 图片模式，默认为RGB
		    @param bg_color: 背景颜色，默认为白色
		    @param fg_color: 前景色，验证码字符颜色，默认为蓝色#0000FF
		    @param font_size: 验证码字体大小
		    @param font_type: 验证码字体
		    @param length: 验证码字符个数
		    @param draw_lines: 是否划干扰线
		    @param n_lines: 干扰线的条数范围，格式元组，默认为(1, 2)，只有draw_lines为True时有效
		    @param draw_points: 是否画干扰点
		    @param point_chance: 干扰点出现的概率，大小范围[0, 100]
		    @return: [0]: PIL Image实例
		    @return: [1]: 验证码图片中的字符串
		    '''
		    width, height = size  # 宽， 高
		    img = Image.new(mode, size, bg_color)  # 创建图形
		    draw = ImageDraw.Draw(img)  # 创建画笔
		
		    def get_chars():
		        '''生成给定长度的字符串，返回列表格式'''
		        return random.sample(chars, length)
		
		    def create_lines():
		        '''绘制干扰线'''
		        line_num = random.randint(*n_line)  # 干扰线条数
		        for i in range(line_num):
		            # 起始点
		            begin = (random.randint(0, size[0]), random.randint(0, size[1]))
		            # 结束点
		            end = (random.randint(0, size[0]), random.randint(0, size[1]))
		            draw.line([begin, end], fill=(0, 0, 0))
		
		    def create_points():
		        '''绘制干扰点'''
		        chance = min(100, max(0, int(point_chance)))  # 大小限制在[0, 100]
		        for w in range(width):
		            for h in range(height):
		                tmp = random.randint(0, 100)
		                if tmp > 100 - chance:
		                    draw.point((w, h), fill=(0, 0, 0))
		
		    def create_strs():
		        '''绘制验证码字符'''
		        c_chars = get_chars()
		        strs = ' '.join(c_chars)  # 字符前后以空格隔开
		        font = ImageFont.truetype(font_type, font_size)
		        font_width, font_height = font.getsize(strs)
		        draw.text(((width - font_width) / 3, (height - font_height) / 3),
		                    strs, font=font, fill=fg_color)
		        return ''.join(c_chars)
			
		    if draw_lines:
		        create_lines()
		    if draw_points:
		        create_points()
		    strs = create_strs()
		
		    # 图形扭曲参数
		    params = [1 - float(random.randint(1, 2)) / 100,
		              0,
		              0,
		              0,
		              1 - float(random.randint(1, 10)) / 100,
		              float(random.randint(1, 2)) / 500,
		              0.001,
		              float(random.randint(1, 2)) / 500
		              ]
		    img = img.transform(size, Image.PERSPECTIVE, params)  # 创建扭曲
		
		    img = img.filter(ImageFilter.EDGE_ENHANCE_MORE)  # 滤镜，边界加强（阈值更大）
		
		    return img, strs

	userctl.py 修改!!:		
		def login(request):
			...
		        code = request.POST.get('check_code')
		        if code.upper() == request.session['CheckCode'].upper():
		            print('验证码正确')
		        else:
		            print('验证码错误')	
	然后 作为测试的 我们使用 127.0...../load_test,所以 loadtest.html 添加
		<form...>
			<div>
                    		<input type="text" class="form-control" placeholder="请输入验证码" name="check_code">
			        <img src="/check_code" onclick="changeCheckCode(this);">
			</div>
		</form>
	<img src="/check_code"就是会访问  def check_code(request): 获得图片数据	
	form submit 提交后会在 	def login(request): 的
		        code = request.POST.get('check_code')
		        if code.upper() == request.session['CheckCode'].upper():
		进行验证码的检测!!
cookie 操作问题!!!
`	http://www.yihaomen.com/article/python/277.htm
	http://www.cnblogs.com/skying555/p/4964112.html	

	每个HttpRequest对象都对应一个COOKIES对象,该对象是字典形式.!!
	例如  对于 127.0.0.1:8000/load_test,
		和 127.0.0.1:8000/load_test33, 是两个不一样的对象,所以 两个不一样的cookie 
	session 的概念有点区别, 是浏览器没有,但是 服务器后端会生成并存储的, 是数据加密串!!
		用来区别,每一个浏览器机器登录状态
		比如 A 远程电脑 登录 127.0.0.1:8000/load_test, 或者 127.0.0.1:8000/load_test33, 他们都共用一个 session 
		比如 用户A和用户B 的登录 127.0.0.1:8000/load_test 都修改 使用同一个 session
		用户 A使用时 ,这个session记录 用户A 的状态, 轮到用户B登录时,session会发现不是用户A在使用,会根据操作变成用户B的状态
		而用 B 远程电脑登录时, 服务器会新建 一个 session 数据 专门为 电脑B服务
		session 存在服务器上的是加密内容,从远程电脑登录时 会获得内容(cookie)和机器码(ip,电脑识别id等)加密后,
		与存在电脑的加密内容匹配 识别身份!!!
	实验:
	userctl.py 添加:
		from django.template import loader ,Context
		from django.http import HttpResponse
		def check_cookiesession(request):
		    # response = HttpResponse("hello world")	# 也可以这样!
		    response = render_to_response('loadtest.html', {}), #给 django 架构的request 设置 返回数据
		    cookie_v = 'user=12345&session=yutuusjis'
		    response.set_cookie('my_cookie1', cookie_v)	 #给 request 设置cookies ,即这个设定的cookies 会传给远程客户端浏览器保存
		    return response
	urls.py 添加:
		urlpatterns = [
		    url('load_test33', userctrl.check_cookiesession),
		    ...
		}
	这样 登录 127.0.0.1:8000/load_test33 服务端会 执行  check_cookiesession  然后设置cookie添加内容,最后传回浏览器,
	浏览器就得到关于这个页面的 cookie
	上面介绍了 服务端 即 django 设置cookie 的api
		response.set_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=None, httponly=False, samesite=None)
		expires: 有效期 格式: 例如字符串:  "Wdy, DD-Mon-YY HH:MM:SS GMT" or a datetime.datetime object in UTC
	        max_age默认:None ,cookie需要延续的时间（以秒为单位） 如果参数是\ None`` ，这个cookie会延续到浏览器关闭为止。
		path 默认是"/" ,cookie生效的路径前缀。 浏览器只会把cookie回传给带有该路径的页面，
			这样你可以避免将cookie传给站点中的其他的应用,当你不是控制你的站点的顶层时，这样做是特别有用的。
		domain 默认None,这个cookie有效的站点。 你可以使用这个参数设置一个跨站点（cross-domain）的cookie。 
			比如，\ domain=".example.com" 可以设置一个在\ www.example.com 、\ www2.example.com 
			以及\ an.other.sub.domain.example.com 站点下都可读到的cookie。
			如果这个参数被设成\ None ，cookie将只能在设置它的站点下可以读到。
		False 默认False ,如果设置为 True ，浏览器将通过HTTPS来回传cookie。
		我们说的 set_cookie 是添加一条cookie数据条, 每条数据条都有效期, 所有关于当前页面的 cookie数据条 都放入一个文件里,
	那么用户如何获得当前页面的cookies? 使用js:
		function getCookie(c_name)
		{
		if (document.cookie.length>0)
		  {
		  c_start=document.cookie.indexOf(c_name + "=")
		  if (c_start!=-1)
		    {
		    c_start=c_start + c_name.length+1
		    c_end=document.cookie.indexOf(";",c_start)
		    if (c_end==-1) c_end=document.cookie.length
		    console.log(document.cookie.substring(c_start,c_end))
		    return unescape(document.cookie.substring(c_start,c_end))
		    }
		  }
		return ""
		}
	例如 cookie 中有一项内容是 my_cookie1 = user=12345&session=yutuusjis
	getCookie('my_cookies1') 就得到 user=12345&session=yutuusjis 的内容
	如果 服务器 需要 获得远程客户端页面 的cookies,
		实时上 http 给服务器提交 request 时,会附带浏览器当前页附带的cookies
		远程服务器 只要:
			value = request.COOKIES["my_cookie1"] 
			也可以i:
			value = request.COOKIES.get('sessionid', None)	
		就可以获得 user=12345&session=yutuusjis 的cookie内容!!
	上面介绍 创建cookie 是 服务器自己创建了传回 远程客户端,但是也可以页面自己生成
		function setCookie(c_name,value,expiredays)
		{
			var exdate=new Date()
			exdate.setDate(exdate.getDate()+expiredays)
			document.cookie=c_name+ "=" +escape(value)+
			((expiredays==null) ? "" : ";expires="+exdate.toGMTString())
		}
		expiredays 是有效 日期 !!
	然后 分析 session!!
		上面说过 session 是服务器保存 运城登录用户的状态信息
		让django项目支持session,则必须在settings.py中指定
		INSTALLED_APPS = [
		....	
		    'django.contrib.sessions',
		]

		MIDDLEWARE = [
		    'django.contrib.sessions.middleware.SessionMiddleware',
		    #'django.middleware.csrf.CsrfViewMiddleware',  #禁用跨站请求伪造的中间件
		......
		]
		还有一点，在django处理请求的过程中，需要经过中间件的过滤，涉及到跨站请求伪造时，django会把请求阻止过滤掉，
		所以我们要在setting.py中禁用跨站请求伪造的中间件，如果不禁用，
		默认情况django使用 django.contrib.sessions.models.Session将session存储在你的数据库中
		mysql 查看 session表:
			mysql -u root -p		
			mysql> use db_selfweb_pyth3
			mysql> select * from django_session;
			可以看到
			每条数据哟有 三个内容 
			session_key session_data expire_date
			而 session_key session_data 都是加密的内容  expire_date 是有效时间
			注意 这里 一条数据 就是 一个session文件, 对应一台登录远程客户端的 状态信息
			注意 这里的 expire_date 与 cookie 的 expire_date 不一样,这里对应着整个session文件,
			而 cookie 的 expire_date 仅仅是cookie文件的一条cookie数据!
		服务器会生成session 但是申生成的 session数据 但并不会 回传到运程客户端!
			#get 从数据库获得 对应远程客户端的 session 数据条 fav_color 的内容! 
			# 注意根据 request 据可以区别是那个 远程端发来的请求
				fav_color = request.session['fav_color']     
			#set 为对应对应远程客户端 添加 一条 fav_color=blue session数据条,并加密存入数据库
				request.session['fav_color'] = 'blue'           #set
			# 判断 对应远程客户端的session 文件 是否 有fav_color session数据条!! 
			'fav_color' in request.session
			# 获得 session数据条
				fav_color = request.session.get('fav_color', 'red')
		
		安全匹配
			用户登录了网站后,一直处于登录状态的做法!!!
			登录成功后, 服务器 会建立 session数据条: 比如 user=william,加密存入数据库,
			也生成 cookie user=william 返回 运程客户端!!
			当 远程客户端执行下一步访问 数据内容时, 会返回 含有  cookie user=william 的请求
			服务器检查 发现 跟 session 的 user=william 一致,于是允许继续访问!! 实现一直处于登录状态
			注意:
				cookie是明文, 容易获取拷贝!!
				服务端匹配 cookie 和 session 要用 专门api, 不要用以下蠢方法:
					A = requwst.COOKIE['user']
					B = requwst.session['user']
					if A == B .....
				因为这样就没有用上session 的加密 抗安全的风险!!,因为这是明文比对,
				人家只要搞到cookie 就可以骗过 服务器 黑入账户!!
				很遗憾, 我发现网上都是 这样子的明文比对, django的例程好像也是这样子!!
				只能自己干了!!
				根据 request.META 结合 cookies 使用!!
		从 django shell 处理 查看 session内容		
			python manage.py shell
			>>> from django.contrib.sessions.models import Session
			>>> s=Session.objects.all()
			>>> for i in s:
			...     i.get_decoded()
			... 
			{'williamcolor': 'blue', 'CheckCode': 'QNYy'}
			{'_auth_user_id': '1', '_auth_user_backend': 'django.contrib.auth.backends.ModelBackend', '_auth_user_hash': '95cf94e3674d7a5ef33a4eabf0d8f3bd18442be2'}
			{'williamcolor': 'blue', 'CheckCode': 'awqp'}
			>>> 
input 输入提示 的方式:https://blog.csdn.net/qq_41573860/article/details/82750116

email:使用邮箱发送验证消息!!
	settings.py
		# email_for_sending check
		EMAIL_HOST = "smtp.163.com"   # 服务器
		EMAIL_PORT = 25               # 一般情况下都为25
		EMAIL_HOST_USER = "xxxxxxm@163.com"   # 账号
		EMAIL_HOST_PASSWORD = "AAAAAAAAAaa"  # 密码
		EMAIL_USE_TLS = False             # 一般都为False
		EMAIL_FROM = "xxxxxxxm@163.com"        # 邮箱来自
	userctl.py
		from random import Random # 用于生成随机码
		from django.core.mail import send_mail # 发送邮件模块
		from selfweb_pyth3.settings import EMAIL_FROM  # setting.py添加的的配置信息		

		# 生成随机字符串
		def random_str(randomlength=8):
		    str = ''
		    chars = 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0123456789'
		    length = len(chars) - 1
		    random = Random()
		    for i in range(randomlength):
		        str+=chars[random.randint(0, length)]
		    return str
		
		# 利用  xxxxxxm@163.com 给 dddd@qq.com ssssss@qq.com 发邮件 的例子
		code = random_str(16)
		receiver = 'dddd@qq.com'
		receiver2 = 'ssssss@qq.com'
		email_title = "注册激活链接"
		email_body = "请点击下面的链接激活你的账号:http://127.0.0.1:8000/active/{0}".format(code)
		send_status = send_mail(email_title, email_body, EMAIL_FROM, [receiver,receiver2])
		print(send_status)
解决了 svg 标签 的 问题!!
	登录页面用到的符号是 svg 矢量图, 而我们用到的库是 iconic : http://zavoloklom.github.io/material-design-iconic-font/icons.html
	注意 原来有很多这样的 icon 库, 不如 font-awsome: http://fontawesome.dashgame.com/
	注意,不同库 ,图标与对应的 unicode标识码不一样!!!!
	注意,一般用法是
		下载了库:
		然后库里面的整合 css 包含!!
		<link rel="stylesheet" type="text/css" href="/static/css/logincss/fonts/iconic/css/material-design-iconic-font.min.css">
		<i class="fa fa-shield"></i>
	但是这里,我们这样用: 通过使用 标识码,需要类似这样设置!
		<span class="focus-input100" data-symbol="&#xf2c8;/&#xf15a;"></span>
		.focus-input100 {
		  position: absolute;
		  display: block;
		  width: 100%;
		  height: 100%;
		  top: -10px;
		  left: 0;
		  pointer-events: none;
		}
		
		.focus-input100::after {
		  content: attr(data-symbol);
		  font-family: Material-Design-Iconic-Font;
		  color: #adadad;
		  font-size: 30px;
		
		  display: -webkit-box;
		  display: -webkit-flex;
		  display: -moz-box;
		  display: -ms-flexbox;
		  display: flex;
		  align-items: center;
		  justify-content: center;
		  position: absolute;
		  height: calc(100% - 20px);
		  bottom: 0;
		  left: 0;
		  padding-left: 13px;
		  padding-top: 3px;
		}
		
		.focus-input100::before {
		  content: "";
		  display: block;
		  position: absolute;
		  bottom: -2px;
		  left: 0;
		  width: 0;
		  height: 2px;
		  background: #7f7f7f;
		  -webkit-transition: all 0.4s;
		  -o-transition: all 0.4s;
		  -moz-transition: all 0.4s;
		  transition: all 0.4s;
		}
根本上解决 数据库支持中文问题!!:
1、创建数据库 （注意设置 数据的字符编码）
由于Django自带的orm是data_first类型的ORM，使用前必须先创建数据库
create database day70 default character set utf8 collate utf8_general_ci;
2、修改project中的settings.py文件中设置  连接 MySQL数据库（Django默认使用的是sqllite数据库）

注意到 models.py 的表单类,其中一个项目要改变属性时,需要 重性 make migrations 和 migrate
	注意,属性migrate改变不一定成功!!例如 本身存char数据的 改变成存 int, 如果char数据已存在的数据有abc 而不是123,migrate失败
	数据表单不会接受改变
	如果char 已存在的数据 都是 123这里数字字符串, 那么转成int时, 以int的123重新存储! 所以 migrate会成功,表单会改变!!

django 并发问题 数据库锁
考虑 stateb 的并发修改访问问题!!
	使用django 的锁功能!! select for update
	使用 select for update 数据库查询
	select ... for update 是数据库层面上专门用来解决并发取数据后再修改的场景的，
	主流的关系数据库 比如mysql、postgresql都支持这个功能， 新版的Django ORM甚至直接提供了这个功能的shortcut 。 
	关于它的更多介绍，你可以搜索你使用的数据库的介绍文档。
	使用 select for update 后，我们的代码可能会变成这样：

from django.db import transaction
class NotificationController(object):

    ... ...

    def mark_as_readed(self, notification_id):
        # 手动让select for update和update语句发生在一个完整的事务里面
        with transaction.commit_on_success():
            # 使用select_for_update来保证并发请求同时只有一个请求在处理，其他的请求
            # 等待锁释放
            notification = Notification.objects.select_for_update().get(pk=notification_id)
            # 没有必要重复标记一个已经读过的通知
            if notication.has_readed:
                return

            notification.has_readed = True
            notification.save()
            # 在这里更新我们的计数器，嗯，我感觉好极了
            self.update_unread_count(-1)
注意: transaction.commit_on_success() 不再支持使用:
	使用 transaction.atomic()
	还有 django 的这个锁的原理是,其实是,建立了一个沙箱,
	select_for_update() 是数据库底层级别的加锁,就是说是数据库本身自带的!
	这里只不过是 django 做了个通用封装!!
	还有 select_for_update() 只能在  with transaction.atomic(): 下生效
	出了 django的沙箱是不允许使用的!
	django的transaction沙箱就是一套原子操作框架! 
		先挂起要使用的资源,允许其他访问但不允许更改,然后划了一个内存空间,做好了一些系列的操作后,
		刷写挂起了的资源.最后解放资源,允许其他访问去修改!
	注意 在沙箱 select_for_update().get() 会 完全锁住了表单的某行数据, 当沙箱过程没有结束!!!!
		当 另外的 使用 with transaction.atomic(): select_for_update().get() 请求同一行数据时,这个get就被阻塞等待!
		而其他 普通.get 请求同一行数据时,不会被阻塞还是可以获得访问的,但那是修改数据使用 .save()时会被被阻塞等待了!
	比如
		A 请求:
	        with transaction.atomic():
	            kk = williamtest.objects.select_for_update().get(text = 'buk')
	            print('uuui')
	            kk.text ='opt4'
	            kk.save()
	            time.sleep(60)
		B请求:
	        trydd = williamtest.objects.get(text='buk')
	        trydd.text  = 'tre'
	        print('78')
	        trydd.save()
	        print('90')
	A使用沙箱获取了 buk的那行数据, 并把改成 opt4, 并.save(),然后再沙箱空等60S,沙箱过程未结束,所以 数据库里还是buk,还没变成opt4
	B在A处于沙箱过程未结束时 普通地 get同一条数据,可以获得! ,但是改成 tre 后 .save 被阻塞了!
	最后沙箱空等结束,退出了 transaction.atomic() 沙箱, 数据库buk变成了 opt4
	然后B请求的 .save也不再阻塞了,最后 opt4 又变成了 tre  !!!









20190101:
一些坑:
关于 datetime 格式和使用片段!
	from datetime import datetime
        ####
        dt = datetime.today()
        # statetb.objects.create(date=dt,usernum=0,flag='1')
        dt2=statetb.objects.get(date="2018-12-29" )
        dt2.flag= '67'
        dt2.save()
        print(dt2.flag)
关于 数据库锁 和并发问题的 测试片段:
class williamtest(models.Model):
    text = models.CharField(max_length=100,blank=True,null=True)
    number = models.IntegerField(blank=True,null=True)
def william_test(str=None,num=None):
    try:
        trydd = williamtest.objects.get(text='buk')
        print('iiiu')
        with transaction.atomic():
            kk = williamtest.objects.select_for_update().get(text = 'buk')
            print('uuui')
            kk.text ='opt4'
            kk.save()
            time.sleep(60)
    except williamtest.DoesNotExist:
        with transaction.atomic():
            kk = williamtest.objects.select_for_update().get(text = 'Tom')
            print('atomic')
            kk.text ='lio'
            time.sleep(10)
            kk.save()
    #williamtest.objects.create(text='super',number=90,)

def william_test2():
    try:
        trydd = williamtest.objects.get(text='buk')
        trydd.text  = 'tre'
        print('78')
        trydd.save()
        print('90')
    except:
        print('fail')

transaction.atomic()下,不能执行动态生成表单的功能,那么就不知道如何解决 可能同时生成相同表单的并发问题,
幸亏,生成表单这个操作,从mysql底层看来就自己加入了并发处理!!,所以不需要 transaction.atomic()下 操作!
from django.db.utils import InternalError
    try:
        install(UserList)
        with connection.cursor() as cursor:
            cursor.execute(order_1[0]+listtbn+order_1[1])
            cursor.execute(order_1[0]+listtbn+order_1[2])
    except InternalError:	# 已有表单的情况下,生成相同表单会出错!! 属于 InternalError
        print('create userlist error')


mysql: 数据执行命令
	insert into web_statetb values(5,'2019-01-08',0,'1');	# 插入一条数据
	delete from web_mailcheckcode where mail = '418128064@qq.com';	# 删一条数据
	update web_statetb set flag='1' where id=2; # 修改一条数据
	#批量drop 表
		select concat('drop table ',table_name,';') from information_schema.tables where table_name like 'web_cntex%';
		结果集合粘出来




继续实现,
	password 比对正确后, 生成uid和分配动态密码的cookies,和session,还要测试session的时效性
	注意不能把用户密码写入cookies,风险太大!!
	通过再通过获得的用户cookies, 加载内容和修改刷新内容!!
	之前就测试过,不通过默认静态方式获得 xml 文件,而是通过传统的 httpresponse获得! 查看 postget 函数!!


测试帐号:
	你好大家_
	1234567Ww
	1234567Ww
	418128064@qq.com
	p8WW91
后续才加上的功能和处理!
	忘记密码,通过动态页面设置!
	由于只有 uid 和 email 唯一!!, 而username phone可以多个, 所以要处理多个同名处理
	跨页面的coskies 和 session 传递 处理的问题!!比如搜索页面我们要使用新页面的!!
动态生成数据表单的出现的冲突问题:
def william_tbtest(request):
    fields = {
        'cntenum': models.IntegerField(blank=True, null=True),
        'type': models.CharField(max_length=10),
        'content': models.TextField(blank=True, null=True),
        'count': models.IntegerField(blank=True, null=True),
        'datetime': models.DateTimeField(blank=True, null=True),
    }
    options = {
        'ordering': ['cntenum', 'datetime'],
        'verbose_name': '并发表',
    }
    admin = {}
    tb1 = create_model('tbtest1',
                    fields,
                    options=options,
                    app_label='web',
                    module='web',
                    admin=admin
                    )
    #install(tb1)
    #tb1.objects.create(cntenum=22,
    #                   type= 'person',
    #                   content = 'Tom',
    #                   count = 50
    #                   )
    print(tb1.objects.get(type='person'))

    tb2 = create_model('tbtest2',
                    fields,
                    options=options,
                    app_label='web',
                    module='web',
                    admin=admin
                    )
    #install(tb2)
    #tb2.objects.create(cntenum=13,
    #                   type= 'animal',
    #                   content = 'rabbit',
    #                   count = 20
    #                   )

    print(tb2.objects.get(type='animal'))	#当执行到这里,(1054, "Unknown column 'web_tbtest1.cntenum' in 'field list'")
    return  HttpResponse('done')
	(1054, "Unknown column 'web_tbtest1.cntenum' in 'field list'")
	https://dynamic-models.readthedocs.io/en/latest/pdfindex.html#synchronising-processes	#链接
	清除后台缓存:https://codeday.me/bug/20180507/162192.html (没用)
	不管是 migration cache 什么的都找不到方法,
	然后后面发现:
		之所以发生这种情况,就是因为 第一次  create_model 时,会修改了共用的 fields 变量
		然后 第二次 create_model 时, 会使用被修改的共用变量,然后会嵌入附加错误!
		注意,动态model 生成后,用到的fields也就不再使用了,删除了也没有关系!
		所以共用的全局变量 fields 不能直接使用,而是深度复制出的副本,
		import copy
		f1 = copy.deepcopy(fields)
还有时区问题!
	django setting.py
	TIME_ZONE = 'UTC'  # 'UTC'(标准时区,格林彼治时间) 'Asia/Shanghai'(东八区) 
	USE_TZ = True
	表示使用 UTC 标准时间, 这时
	from datetime import datetime
	datetime.now() 得到的是 TIME_ZONE 设置的时区的时间 与  USE_TZ = True 没有关系!
	datetime.utcnow() 得到的是 标准时区的时间	
	
	from datetime import timezone
	dt = datetime.now().replace(tzinfo=timezone.utc)	把当前时区的时间变成标准时区时间

	dt = datetime.today()	感觉与 now()没区别
	datetime.now().date() 获取日期部分

	from datetime import timezone
	import pytz
	datetime.today().replace(tzinfo=timezone.utc).astimezone(pytz.timezone('Asia/Shanghai')).date()
	# 使用 datetime 的timezone 把获得的时间转成 utc时间, 又使用 astimezone 和 pytz.timezone,转成东八区时间,最后取日期部分 
	#.replace(tzinfo=timezone.utc) 看似多此一举,但是 now(),utcnow(),today()直接astimezone 换成东八区时间是不可能的,
	#所以需要 replace 这一步!
使用reload 机制!!!
	//document.body.reload()        //没有这样子的reload
	window.location.reload()	
遇到了一个世纪问题,幸亏解决了!!
	http://www.yihaomen.com/article/python/342.htm
	例如
	Tom = cntetb.objects.get(line0002__linenum=numl)  # 反向查询
	line0002__linenum 是不确定的,所以需要替换掉
	line0002__linenum=numl get()函数看来是字典参数!
	所以我们构造字典参数!代入
	所以相当于!!
	kk = {'line0002__linenum':'num'}
	Tom = cntetb.objects.get(**kk)
视频作为背景!
	重点是 position:fixed; 还有 z-index:-11 层数必须负数
	注意 Video 放在 login div 上, 所以, z-index:-11 是相对 同 logindiv 其他子 模块而言的,
	即只放在 login div 的最底图层 显示!!
	还有关于视频拖伸播放问题!!!1
	例子:
	video.vibagrd{
	            margin: 0px;
	            padding: 0px;
	
	            position: fixed;
	            right: 0px;
	            bottom: 0px;
	
	            object-fit:fill;		/*这个是视频填充拉伸整个height width 定义的页面意思*/
	            height: 80%;
	            width: 100%;
	            left: 0%;
	            top: 10%;
	            /*加滤镜*/
	            /*-webkit-filter: grayscale(100%);*/
	            /*filter:grayscale(100%);*/
	            z-index:-11
	}
	video.vibagrd source{
	
	            height: 100%;
	            width: 100%;
	        }
	<div class="login" >
	
		<video class="vibagrd" autoplay loop muted poster="/static/img/bg-01.jpg" id="bgvid">
			<!--<source src="polina.webm" type="video/webm">-->
			<source src="/static/video/qbhn.mp4" type="video/mp4">
		</video>
			
		.....
	</div>

django 定时程序:
	https://www.cnblogs.com/perfe/p/6198213.html		////crontab   海关与定时调用终端执行命令
	https://blog.csdn.net/sinat_21302587/article/details/72831002		/// crontab 可用!!!
	https://crontab.guru/examples.html	//// crontab 定时格式编写

	https://www.cnblogs.com/dengshihuang/p/8258621.html

	https://blog.csdn.net/qq_21570029/article/details/80772561		///apscheduler 
重点讨论 crontab
	crontab 这个第三方本来不是 django 独有的,而是传统的 linux 软件
	使用 crongtab 定时任务,即使 django项目没有 runserver , 定时任务还是会照样执行 !!!!
	使用例子: https://blog.csdn.net/sinat_21302587/article/details/72831002		/// crontab 可用!!!
	安装:
	 pip install django-crontab
	setting.py
		INSTALLED_APPS = [
		    'django_crontab',
			.....
		]
		CRONJOBS = [	# 这里是添加 定时任务!!!
		    ('*/5 * * * *', 'web.cron.test','>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
	
		    ('21 21 * * *', 'web.cron.east8test', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
		    ('31 14 * * *', 'web.cron.utctest', 'TZ=UTC', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),	
		    ('21 23 * * *', 'web.cron.statetbtest', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
		
		]
		至于格式 详细要百度: 常用的
			*/5 * * * *   定时的设置 ,这里的 每隔5分钟, 31 14 * * * 这里是 每天的 14时31分
			注意,这些时间默认是以当地系统时区 为准, 要是以其他时区的话也可以设置,但是未找到可行方法
			目前通过 CRON_TZ=  TZ= 的 都是失败的!!  
			比如这样设置 TZ=UTC 其实并不可行!!
			('31 14 * * *', 'web.cron.utctest', 'TZ=UTC', '>>/home/william/full_stack/selfweb_pyth3/crontabtest.log'),
			web.cron.utctest 等,是要执行的任务!!
			>>/home/william/full_stack/selfweb_pyth3/crontabtest.log 执行过程中print等输出的信息都放入这里!!
	任务:
	跟 views.py 同目录 新建 cron.py 写要执行的任务:
	def statetbtest():
	    print('\n\r///////////////// statetb test /////////////////////')
	    kl = statetb.objects.first().date
	    print(kl)

	最后 :
	 python manage.py crontab add  会把 CRONJOBS 里的所有任务都加载 并定时执行,
		并不需要 django project runserver 下才运行
	 	所以执行相当独立
	显示当前的定时任务  python manage.py crontab show 
	关闭并删除所有正在执行的定时任务 python manage.py crontab remove

	crontab 需要用到的功能不多,重点关注的部分有 
		定时执行只能按当前系统时区为准,如果 与django项目是 UTC 等其他时区为准,要注意变换
		定时的格式写法参考  https://crontab.guru/examples.html
		crontab 执行的任务 是相对 django 项目的runserver 独立的, 
		定时任务可以访问 django 项目 各种资源,例如数据库等


	













20190117
先 总结 docker tmux vim ssh 效率工具的学习 :
ssh: 
	scp root@149.28.122.195:/root note2 /home/william/temp   //从运城服务器下载文件 到 本地目录 /home/william/temp
	scp /home/william/full_stack/selfweb/full_stack_note  root@149.28.122.195:/root/	 //把本地文件上传到远程服务器
	ssh root@149.28.122.195		//登录远程服务器 root用户


tmux:
	ctrl + b  加  %   左右分屏.
	ctrl + b  加  "   上下分屏,
	ctrl + b  加  :  命令行 输入 copy  滚动 log 记录
	ctrl + b  加  方向键 换分屏
	ctrl + b  加  c  新键 session(对话)
	ctrl + b  加  数字 换 session 
		session 与 分屏, 相似,又不一样!!
	ctrl + b  加  &  关闭当前 session
	ctrl + b  加  x  关闭当前 分屏
	ctrl + b  加  z  最大化当前分屏 或 退出最大化

	vim :
	打开文件后 , 处于命令行模式, 
	i 命令 开始 输入模式, 
	esc 回到 命令行模式
	: 添加附加命令 的命令
		:wq  保存并退出
		:q!  不保存然后退出
	
docker:
	参考:
	https://blog.csdn.net/cow66/article/details/80096253
	https://blog.csdn.net/bskfnvjtlyzmv867/article/details/81044217
	docker run -it --name redis-master redis /bin/bash    新建一个名字为

	ps命令在docker容器不存在	
	apt-get update && apt-get install procps

        docker pull ubuntu
        docker pull redis
                (pull 下载的 是 专门的镜像 如 ubuntu 是 ubuntu 的镜像, redis 是 专门用于redis数据库服务 的linux系统镜像 )
        docker images (可以看到都，下载了那些镜像)
                REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
                haproxy             latest              fd5f07592ca9        5 days ago          72.1MB
                redis               latest              5d2989ac9711        3 weeks ago         95MB
                ubuntu              latest              1d9c17228a9e        3 weeks ago         86.7MB
                django              latest              eb40dcf64078        2 years ago         436MB

        docker ps -a    （显示所有容器的情况）
        CONTAINER ID  IMAGE      COMMAND                  CREATED        STATUS                    PORTS                    NAMES
        b6a40392708f  haproxy    "/docker-entrypoint.…"   22 hours ago   Up 22 hours               0.0.0.0:6301->6301/tcp   HAProxy
        edfe38f25c4f  django     "/bin/bash"              22 hours ago   Up 22 hours                                        APP2
        73a540d60130  django     "/bin/bash"              22 hours ago   Up 22 hours                                        APP1
        7db27ac7fc76  redis      "docker-entrypoint.s…"   22 hours ago   Up 22 hours               6379/tcp                 redis-slave2
        73b92aeaf7f9  redis      "docker-entrypoint.s…"   22 hours ago   Exited (0) 14 hours ago                            redis-slave1
        6745d8b53e8d  redis      "docker-entrypoint.s…"   22 hours ago   Up 12 hours               6379/tcp                 redis-master
        9f82795ba41e  ubuntu     "/bin/bash"              36 hours ago   Exited (0) 18 hours ago                            web
                （所谓容器 就是 通过 镜像安装在 docker 小型系统, 一个镜像可以安装多个 容器）
                （比如，通过 同一个镜像redis，在docker 安装了 3个相互独立的容器， redis-master redis-slave1 redis-slave2 ）
                （这3个容器 也就是我们理解的服务器节点，操作系统，或者说是三台相互独立运行的电脑！）
                （STATES 是这些容器当前的状态， Up xx hours 表示这个容器节点已经开机xx个小时，Exited表示 这个容器节点已经关机 ）

        创建一个容器：
        docker run -it --name redis-master redis /bin/bash      （使用redis 镜像 创建一个名字为 redis-master 的容器节点,并启动容器）
                （-it 表示创建运行容器后 并进入容器的命令行终端）
		 (docker ps 显示 Up ,即开机运行状态)
	
	通过 run 进入 容器命令行终端后 , exit命令 , 推出容器终端,容器关机, docker ps 显示 Exited ,即关机状态
	
	再次启动容器:
	docker start redis-master

	启动容器后,才可以 登录 容器终端
	第一种登录方式 :docker exec -it redis-master /bin/bash , 
		输入 exit 时, 容器依然工作,只是退出登录终端而已
	第二种登录方式: docker attach redis-master
		输入 exit 时, 容器也会关机!

	移除一个容器
		docker rm redis-master
	
	注意对容器 的操作 可以 用 自定义的容器 名字, 也可以是 容器的id 
		比如 docker start redis-master  等于  docker start 6745d8b53e8d 

        docker info     （显示docker 的 基本信息！）
	        Containers: 7
	         Running: 5
	         Paused: 0
	         Stopped: 2
	        Images: 4
	        Server Version: 18.09.0
	        Storage Driver: overlay2
	         Backing Filesystem: extfs
	         Supports d_type: true
	         Native Overlay Diff: true
	        Logging Driver: json-file
	        Cgroup Driver: cgroupfs
	        Plugins:
	         Volume: local
	         Network: bridge host macvlan null overlay
	         Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
	        Swarm: inactive
	        Runtimes: runc
	        Default Runtime: runc
	        Init Binary: docker-init
	        containerd version: c4446665cb9c30056f4998ed953e6d4ff22c7c39
	        runc version: 4fc53a81fb7c994640722ac585fa9ca548971871
	        init version: fec3683
	        Security Options:
	         apparmor
	         seccomp
	          Profile: default
	        Kernel Version: 4.4.0-127-generic
	        Operating System: Ubuntu 16.04.4 LTS
	        OSType: linux
	        Architecture: x86_64
	        CPUs: 1
	        Total Memory: 488.1MiB
	        Name: william
	        ID: NIX6:DNXE:T664:QSWG:3WFC:OE46:PQER:2ONA:ZX76:XWCK:PJAL:WI54
	        Docker Root Dir: /var/lib/docker
	        Debug Mode (client): false
	        Debug Mode (server): false
	        Registry: https://index.docker.io/v1/
	        Labels:
	        Experimental: false
	        Insecure Registries:
	         127.0.0.0/8
	        Live Restore Enabled: false
	        Product License: Community Engine
	
	        WARNING: No swap limit support

在重构之前先学习好 集群 和 负载均衡 分布 高并发 的 实际操作应用
	主流是 java + spring框架 +dubbo分布式任务 SOA 
	未来需要 可能用上的有 redis(缓存数据库) elasticsearch(搜索引擎) Celery(分布式) Dubbo(分布式基于java)
先名词解释几个概念
	集群: 多个服务器一起只实现 一项特定服务,这些服务器是一个集群 cluster
	分片: 集群的服务器,每一个服务器是一个节点,负责特定服务的某部分,或则被分配存放部分内容数据,这种行为是分片
	高并发: 指一个服务器可以同时处理的连接数众多
	负载均衡: 指把业务请求分给多个 都是处理相同任务的服务器处理,摊分工作量	
	
	一般 我们用 nginx的服务器 处理 负载均衡, 把接到的业务分配各个业务处理服务器,
	但是这个ngnix服务器的吞吐量可能就是这个网站处理连接请求的天花板了
	使用 uwsgi 提高 单个服务器并发处理 业务请求的 数量
	多个服务器专门用来处理业务请求 是 业务处理服务器集群
	每个业务处理服务器的内容都是一样的,他们分担众多业务请求工作
	多个服务器专门用来保存数据 是 数据库服务器集群
	每个数据库服务器不是都保存相同的数据,数据是分布存在不同的服务器的,这时数据库的分片保存
	整个数据库集群一起实现一个完整的数库, 即所有分片

	
目标千万级pv 和亿级pv (一天有千万次浏览)
案例参考:
	像百度等巨型公司除了会采用常规的mysql及oracle数据库库外，会在性能要求更高的领域，大量的使用nosql数据库（非关系型的数据库），
	然后前端在加DNS，负载均衡，分布式的读写分离，最后依然是拆业务，拆库，。。。逐步细化，然后每个点又可以是一组或多组机器。
	数据库层的硬件好坏也会决定访问量的多少，尤其是要考虑磁盘IO的问题，大公司往往在性价比上做文章，
	比如核心业务采用硬件netapp/emc及san光纤架构，对于资源数据存储，如图片视频，会采用sas或固态ssd盘，
	如果数据超大，可以采取热点分取分存的方法：如：最常访问的10-20%使用ssd存储，中间的20-30%采用sas盘，最后的40-50%可以采用廉价的sata。

一例日千万pv架构说明：
    1,架构中直接引入软件名称的模块，是个人推荐使用的，如Haproxy、Hadoop等；
    2,关于全局负载均衡，看成本投入情况，可以使用商业的产品，如F5-GTM，开源方案便是自搭智能DNS；
    3,本地负载均衡方案，可以考虑F5-LTM或成熟的开源解决方案LVS；
    4,代理层为什么推荐大家使用Haproxy？Haproxy是一个非常优秀的反向代理软件，十分高效、稳定。国内top 10的互联网公司都有在使用；
    5,缓存层可以使用squid或Varnish，个人更倾向Varnish。配置灵活、运行稳定，提供非常便利的管理接口。
	为啥在缓存层前面加一层代理？优点非常多，列举如下：
    	A 根据应用配置URI路由规则，集中热点来提高后端缓存的命中率；
    	B 轻松划分网站频道、版块，更好对应用进步组织、规划；
    	C 对URI进行一般性安全过滤，抵御注入攻击；
    	D 弹性调配硬件资源，应对突发事件产生大流量；
    	E 可回收宝贵的公网ip资源；
    6,应用层开源技术方案非常多且成熟，在此不详细描述；
    7,数据库层主流开源解决方案mysql是首选，主从复制（一主对多从）是目前比较靠谱的模式；
    8,于Nosql，应用场景不多说，可参考“给部门做的Mongodb技术交流PPT”文章，redis、memcached等作为热点数据存储、数据库缓存都非常理想；
    9,网DNS扮演的角色非常重要，一定要消灭code中出现的内网IP地址，很大程度减少因IP变更、服务器故障而修改源码的情况，同时也便于维护；
    10,内网LB适用在内部WEB接口、多台数据库Slave、多台Nosql Slave、公共服务等应用的负载均衡，可以使用LVS、Haproxy来实现，
       可用性要求不高的应用可行直接使用Localhost DNS轮询；
    11,hadoop适合海量数据的存储与处理，如做网站日志分析、用户数据挖掘等；
    12,管理集群，平台的核心，运维的阵地；
    13,以上粗略介绍了架构的几个组成部分，如大家有对哪块有疑问或感兴趣都可以展开来讨论，也可以通过weibo与我交流：http://t.qq.com/yorkoliu

负载均衡技术的详细介绍 https://www.cnblogs.com/chanshuyi/p/how-loadbalance-works.html
	https://www.cnblogs.com/rjzheng/p/10263562.html 
	DNS轮询 比如说就是,百度挂在 电信,还是 联通,还是移动的服务器上,分流 移动 电信 联通 用户的访问
	LVS : 一个网站的最前方,把访问的链接分流转发,
	Nginx : LVS 分流过来的 一般会在 Nginx上再分流,或者直接处理,最后把内容直接返回 远程客户端,或者先回到 lvs,由lvs 返回远程客户端
	三种机制:
	DR: LVS 分配给下级服务器,处理,处理结果,下级服务器自己直接返回到网络!
	NAT,FULL-NAT: LVS 分配给下级服务器,处理,处理结果,下级服务器把结果返回 LVS,LVS再返回到网络!
	Tunnel: 之前的模式都是修改数据包的 IP头,MAC头什么的实现装发, Tunnel是直接外部再封装一个IP头后装,透过外加头转发到下级服务器,
		下级服务器会把额外加上的 IP 头 拆掉,最后处理结果直接返回到网络!
	Nginx相似的软件还有apche、squid、lighttpd等负载均衡软件,综合说 Nginx 比较高效,不容易堵塞,造成压力!!! 
数据库 集群分片处理:
	就是使用多个服务器 组合共同存储数据 !!
	重点 redis 数据库, Mysql 数据库  
	MySql Replication
	Mysql PXC 集群方案（ Percona XtraDB Cluster ）

参考:
	亿级pv与负载均衡:
	https://www.cnblogs.com/rjzheng/p/10263562.html
	https://www.cnblogs.com/chanshuyi/p/how-loadbalance-works.html


	Django并行分布式框架 Celery
	https://blog.csdn.net/huanhuani/article/details/81202480 Django并行分布式框架 Celery
	https://blog.csdn.net/max229max/article/details/51463632

	Django redis
	https://mengkang.net/356.html  ///// redis 数据类型
	https://www.cnblogs.com/fuhuixiang/p/4174896.html 
	http://www.cnblogs.com/zjchao/p/8903552.html
	https://www.cnblogs.com/jiangchunsheng/p/9151257.html
	https://www.cnblogs.com/yuanermen/p/5717885.html   ///redis 集群
	https://www.cnblogs.com/cjsblog/p/9048545.html	  ///redis 集群 分片 重要参考



	Mysql 
	https://blog.csdn.net/annotation_yang/article/details/80860988		/////集群
	https://www.cnblogs.com/robbinluobo/p/8294782.html      ///mysql 高可用方案


	搭建参考例子
	https://blog.csdn.net/cow66/article/details/80096253   /// Docker + Django + Redis 搭建 集群分布负载均衡 很好的启蒙例子 
	https://blog.csdn.net/xun527/article/details/78375735	/// 一 django电商平台的搭建例子
	https://blog.csdn.net/kangshuo2471781030/article/details/79253578	/////千万级PV规模高性能高并发网站架构详解


django 和 redis:
	redis 数据内容格式: key:value value可以:字符串,列表,hash值,set,zset 等等
	安装:
	pip3 install django-redis
	配置:settings.py
		# redis 缓存服务器 
			CACHES = {
			    'default': {
			        'BACKEND': 'redis_cache.cache.RedisCache',
			        'LOCATION': '127.0.0.1:6379',
			        "OPTIONS": {
			            "CLIENT_CLASS": "redis_cache.client.DefaultClient",
			        },
			    },
			}
			REDIS_TIMEOUT=7*24*60*60
			CUBES_REDIS_TIMEOUT=60*60
			NEVER_REDIS_TIMEOUT=365*24*60*60
	代码测试:
		from django.core.cache import cache #引入缓存模块 
		from django.conf import settings	# 其实 这个 settings 既有 django 全局设置的内容,
							# 也有本地projrct selfweb的settings内容 
		cache.set('v', '555', 60*60) #写入key为v，值为555的缓存，有效期30分钟 
		cache.has_key('v') #判断key为v是否存在 
		cache.get('v') #获取key为v的缓存
    		cache.set('word', 'helloworld', settings.NEVER_REDIS_TIMEOUT)
	或者:
        	from django_redis import get_redis_connection
        	conn = get_redis_connection("default")
        	conn.hset('n1','k1','v1') 
	或者:
		session 用 redis存储开启方式
		setting.py
	redis 存非cache 的例子!!
		安装pip3 install redis 
		import redis
		conn = redis.Redis(host='10.0.0.10',port=6379)
		conn.set('k1','v1') # 向远程redis中写入了一个键值对
		val = conn.get('k1') # 获取键值对
		print(val)	

			SESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎
        	        SESSION_CACHE_ALIAS = 'default'  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置
	redit 集群,分片 https://www.cnblogs.com/cjsblog/p/9048545.html
		redit 本是独立与django 的模块, django 通过插件接口访问!
		多个节点(服务器),(比如36个节点)一起提供一个数据库的 访问, 是这个 redis数据库的集群
		主从节点, 比如 36个当中有 12个master节点,24个slave节点,即,每个master节点,都有 2个副本节点(slave)
			他们这3个节点数据同步, 外部只访问master节点, master节点挂了,其中一个slave节点会补上充当master节点
		redis 含 16384个 hash slots, 一般平均分摊给12个节点组(1 master 2 slave)
			然后 redis 的 数据条: key:value 会 存入被指定的 hash slots里, 
			相当于 这个redis数据库被分12片,分存数据内容
	redis一般用于 存 session cache celery 等

	redis 集群分片操作例子: *号重点
		https://www.cnblogs.com/cxbhakim/p/9151720.html    // docker 实现 redis 集群搭建
		https://www.cnblogs.com/zhaohuhu/p/9140673.html         //redis 是内存数据库的理解  *
		https://blog.csdn.net/cow66/article/details/80096253	/// Docker + Django + Redis 搭建 集群分布负载均衡  *
									///没有 主从故障切换
			主要思想是 通过宿主机编辑好配置文件 然后传到容器里执行!!
		http://www.cnblogs.com/vipzhou/p/8580495.html		///Docker下redis的主从、持久化配置 哨兵系统     *
									///有 主从故障切换
                https://www.cnblogs.com/linkenpark/p/7841608.html       /// python redis sentinel 实现master故障切换   *
		https://blog.csdn.net/lfgxiaogang/article/details/78020408      
									///redis sentinel 高可用（HA）方案部署，及python应用示例     *

                https://blog.csdn.net/ownfire/article/details/51546543  ///搭建redis-sentinel(哨兵机制)集群
                https://blog.csdn.net/yingxiake/article/details/51671335        ///配置哨兵监控Redis运行情况
                https://www.sunzhongwei.com/test-redis-replication-with-sentinel.html   ///测试 redis replication & sentinel & python
                http://www.cnblogs.com/janehoo/p/6118961.html           ///Redis多机常用架构-sentinel
                        /// 哨兵和 redis数据库  是相互独立， 可以运行在相互独立的节点上！！，不一定要都运行在同个节点上！
                https://www.cnblogs.com/kazihuo/p/9109824.html          /// sentinel + cluster 共同集成 高可用的 数据分片主从故障切换 先cluster 后 sentinel  *
                https://blog.csdn.net/xlnhaha/article/details/80987368  /// sentinel + cluster 例子2

		https://www.cnblogs.com/zhanchenjin/p/5379112.html     ///Redis Sentinel + Cluster  *


		https://www.cnblogs.com/lianggp/articles/8136222.html		///docker + redis-cluster
		
		例子实践进程:
			Docker + Django + Redis  实现了 web应用均衡访问, redis主从实现,
			但是 redis master故障模拟切换没有实现
			通过参考 Docker下redis的主从、持久化配置 实现了 主从模拟故障切换,
			但是, redis-master 挂了 web应用没有 切换到访问新 master !!
			应该说 redis-master 改了, 但是 django还是链接原来的 master 没有转换新的 master !!!  
			所以 应该从 django 的 app 入手
			先 单方面 实现 sentinel，然后单方面实现 cluster 最后在 cluster 上实现 sentinel

在 django redis 简单主从数据库 基础上 实现 sentinel ( 单方面 实现 sentinel，)
	( https://blog.csdn.net/cow66/article/details/80096253 ) 基础上 添加 sentinel
        首先，关闭所有 容器！！
        docker stop HAProxy APP1 APP2 redis-master redis-slave1 redis-slave2
        打开所有容器
        docker start redis-master redis-slave1 redis-slave2 APP1 APP2 HAProxy   //开机注意顺序
        在tmux 建立7个终端方便操作：
        先新建 7个 docker所在的宿主机终端，然后 有6个进入容器终端，剩下一个宿主终端
        进入 redis-master容器终端 ：  docker exec -it redis-master /bin/bash
        进入 redis-slave1容器终端 ：  docker exec -it redis-slave1 /bin/bash
        进入 redis-slave2容器终端 ：  docker exec -it redis-slave2 /bin/bash
        进入 APP1 容器终端 ：  docker exec -it APP1 /bin/bash
        进入 APP2 容器终端 ：  docker exec -it APP2 /bin/bash
        进入 HAProxy 容器终端 ：  docker exec -it HAProxy /bin/bash

        进入各个redis服务器终端， 删除 所有原来的sentinel.conf
        重新修改 sentinel 配置
                在宿主机操作：
                        vim sentinel.conf  ：
                                /////////////
                                port 10011                                              // 哨兵的 端口用 10011
                                sentinel monitor mymaster 172.17.0.2 6379 1             // 1 表示 至少有1个 哨兵节点 支持，才能当master
                                sentinel down-after-milliseconds mymaster 60000
                                sentinel failover-timeout mymaster 180000
                                sentinel parallel-syncs mymaster 1
                                //////////
                        放到 redis 容器：
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-master | awk '{print $3}')
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-slave1 | awk '{print $3}')
                                cp sentinel.conf $(docker inspect -f '{{ .Mounts }}' redis-slave2 | awk '{print $3}')
                redis 容器终端操作：
                        cp /data/sentinel.conf /usr/local/bin/sentinel.conf
        修改 django webapp 节点程序：
                都在宿主机上操作：
                        docker inspect HAProxy APP1 APP2 redis-master redis-slave1 redis-slave2 |grep IPAddress      //查看 redis节点 的 ip
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.7",
                                    "IPAddress": "172.17.0.7",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.5",
                                    "IPAddress": "172.17.0.5",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.6",
                                    "IPAddress": "172.17.0.6",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.2",
                                    "IPAddress": "172.17.0.2",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.3",
                                    "IPAddress": "172.17.0.3",
                            "SecondaryIPAddresses": null,
                            "IPAddress": "172.17.0.4",
                                    "IPAddress": "172.17.0.4",
                        可以发现 redis-master redis-slave1 redis-slave2 分别为 172.17.0.2， 172.17.0.3， 172.17.0.4
                        这次实验默认使用 redis-master redis-slave1 redis-slave2 分别为 172.17.0.2， 172.17.0.3， 172.17.0.4 这个初始参数
                        （新建容器的时候就应该使用静态分配的ip，减少很多不必要麻烦处理）
                        由于 建立容器时的不谨慎， 容器都是开机后获得 动态 IP 所以要知道 redis 节点的 ip
                        修改APP内容：
                                # APP 1
                                cd ~/Projects/Django/App1/dockerweb/redisweb/
                                vim helloworld/views.py
                                # APP 2
                                cd ~/Projects/Django/App2/dockerweb/redisweb/
                                vim helloworld/views.py
//////////////////

from django.shortcuts import render

# Create your views here
from django.http import HttpResponse
import redis
from redis.sentinel import Sentinel
def hello(requset):
    # 加载 哨兵的节点， 注意 之前设置 哨兵节点的 端口是 10011
    sentinel = Sentinel([('172.17.0.2', 10011),('172.17.0.3', 10011),('172.17.0.4', 10011)], socket_timeout=0.2)
    print(sentinel.discover_master('mymaster'))         # 通过 哨兵节点 获得 redis数据库master节点的 ip和端口
    print(sentinel.discover_slaves('mymaster'))         # 通过 哨兵节点 获得 redis数据库slaves节点的 ip和端口
    slave = sentinel.slave_for('mymaster', socket_timeout=0.1)          # 获得一个 redis数据库slave节点 接口
    print('stu_num: ',slave.get('stu_num'))             # 获得数据库数据并打印数据
    master = sentinel.master_for('mymaster', socket_timeout=0.1)        # 获得一个 redis数据库master节点 接口
    master.set('app_info', 'HelloWorld-APP1')           # 给数据库写入一个数据  # 在APP2节点修改为HelloWorld-APP2
    print('app_info: ',master.get('app_info'))
    app_info = bytes.decode(slave.get('app_info'))
    stu_num_info = int(master.get('stu_num'))
    info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    return HttpResponse(info)

    #r = redis.Redis(host='db', port=6379, db=0)
    # 在APP2节点修改为HelloWorld-APP2
    #r.set('app_info', 'HelloWorld-APP1')
    #app_info = bytes.decode(r.get('app_info'))
    #stu_num_info = int(r.get('stu_num'))
    #info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    #return HttpResponse(info)

def hello__dsdsds (request):
    return HttpResponse('helloworld')

////////////

        在所有redis容器 启动 redis数据库 节点
                cd /usr/local/bin/

                # master:
                //注意曾经的哨兵系统工作时会修改 redis.conf 里的内容，所以重新启动数据库需要先更新回初始设置
                cp /data/redis-master.conf /usr/local/bin/redis.conf
                redis-server redis.conf

                # slave1 slave2
                //注意曾经的哨兵系统工作时会修改 redis.conf 里的内容，所以重新启动数据库需要先更新回初始设置
                cp /data/redis-slave.conf /usr/local/bin/redis.conf
                redis-server redis.conf

        同在 redis容器终端下 启动 sentinel 节点服务
                redis-sentinel sentinel.conf
                //// 也可以这样？？？  redis-server sentinel.conf --sentinel
                sentinel 和 redis数据库 是相互独立的，
                实际部署 sentinel 和 redis数据库 应该 放在不同的服务器物理机子 独立运行
                即放在不同的容器上执行
                这次图方便 sentinel 和 redis数据库 放同一容器上了

        APP容器终端下启动  App
                cd /usr/src/app/dockerweb/redisweb
                python manage.py migrate

                # APP1:
                python manage.py runserver 0.0.0.0:8001

                # APP2:
                python manage.py runserver 0.0.0.0:8002
        HAProxy 容器终端下：
                启动HAProxy程序
                cd /usr/local/sbin
                haproxy -f haproxy.cfg

        浏览器登陆： 149.28.122.195:6301 成功
        然后 kill掉 master服务， 登陆时出错，那是因为哨兵还没完成同步处理
        过会 登陆， 又好了，
        把原来的master服务 重新加入，会被降级为 slave！


ssh自动断开问题: https://www.cnblogs.com/aoyihuashao/p/3298950.html
	


redis 单方面实现 cluster实验  (这里cluster 指的是 分片集群 shrding cluster)
	(https://blog.csdn.net/qq_22211217/article/details/80436996)
	(https://redis.io/topics/cluster-tutorial/)
	停止所有容器 ,不管以前的容器, 使用新建的容器测试!!!
	需要 ruby 参与 分片: 添加 ruby 镜像: docker pull ruby
	创建测试用的 网段(局域网): docker network create redis-net
	#查看网段信息
		docker network ls
		docker network inspect  redis-net  | grep "Gateway" |  grep --color=auto -P '(\d{1,3}.){3}\d{1,3}' -o
		172.18.0.1 (查到这个网段的网关IP)
	创建配置文件模版
		pwd
		/root
		mkdir ./redis-cluster ##在home 目录下创建 集群配置文件加
		cd ./redis-cluster    ##在创建目录中
		vim redis-cluster.tmpl  ##创建模版件
/////////////
port ${PORT}                        ##节点端口
cluster-enabled yes                 ##cluster集群模式
cluster-config-file nodes.conf      ##集群配置名
cluster-node-timeout 5000           ##超时时间  
cluster-announce-ip 172.18.0.1      ##实际为各节点网卡分配ip  先用上网关ip代替
cluster-announce-port ${PORT}       ##节点映射端口
cluster-announce-bus-port 1${PORT}  ##节点总线端
appendonly yes                      ##持久化模式
////////////
	终端命令  批量创建节点配置文件
		for port in `seq 7010 7015`; do \
		  mkdir -p ./${port}/conf \
		  && PORT=${port} envsubst < ./redis-cluster.tmpl > ./${port}/conf/redis.conf \
		  && mkdir -p ./${port}/data; \
		done
	还要批量修改 /root/redis-cluster/${port}/conf/redis.conf 的 cluster-announce-ip 
		分别为 六个将要建立的节点 的 ip 172.18.0.2/3/4/5/6/7
	然后,检查:
		在 /root/redis-cluster # tree
			.
			├── 7010
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7011
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7012
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7013
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7014
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			├── 7015
			│   ├── conf
			│   │   └── redis.conf
			│   └── data
			│       ├── appendonly.aof
			│       ├── dump.rdb
			│       └── nodes.conf
			└── redis-cluster.tmpl
			
			18 directories, 25 files
		在 /root/redis-cluster # cat 701*/conf/redis.conf
			port 7010
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.2
			cluster-announce-port 7010
			cluster-announce-bus-port 17010
			appendonly yes

			port 7011
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.3
			cluster-announce-port 7011
			cluster-announce-bus-port 17011
			appendonly yes
			
			port 7012
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.4
			cluster-announce-port 7012
			cluster-announce-bus-port 17012
			appendonly yes
			
			port 7013
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.5
			cluster-announce-port 7013
			cluster-announce-bus-port 17013
			appendonly yes
			
			port 7014
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.6
			cluster-announce-port 7014
			cluster-announce-bus-port 17014
			appendonly yes
			
			port 7015
			cluster-enabled yes
			cluster-config-file nodes.conf
			cluster-node-timeout 5000
			cluster-announce-ip 172.18.0.7
			cluster-announce-port 7015
			cluster-announce-bus-port 17015
			appendonly yes
			
	宿主机终端批量新建启动容器 并 启动redis 服务
		for port in `seq 7010 7015`; do \
		  docker run -d -ti -p ${port}:${port} -p 1${port}:1${port} \
		  --privileged=true -v /root/redis-cluster/${port}/conf/redis.conf:/usr/local/etc/redis/redis.conf \
		  --privileged=true -v /root/redis-cluster/${port}/data:/data \
		  --restart always --name redis-${port} --net redis-net \
		  --sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf; \
		done
		备注：命令译为  循环7010 - 7015  运行redis 容器 并运行 redis服务
		docker  run            运行
		-d                          守护进程模式
		--restart always     保持容器启动
		--name redis-710* 容器起名
		--net redis-net    容器使用虚拟网卡
		-p                        指定宿主机器与容器端口映射 701*:701*
		-P                        指定宿主机与容器redis总线端口映射 1701*:1701*
		 --privileged=true -v /root/redis-cluster/701*/conf/redis.conf:/usr/local/etc/redis/redis.conf
		    付权将宿主701*节点文件挂载到容器/usr/local/etc/redis/redis.conf 文件中
		--privileged=true -v /root/redis-cluster/${port}/data:/data \
		   付权将宿主701*/data目录挂载到容器/data目录中
		--sysctl net.core.somaxconn=1024 redis redis-server /usr/local/etc/redis/redis.conf;
		   容器根据挂载的配置文件启动 redis服务端
	查看网段ip分配情况: docker network inspect redis-net
		[
		    {
		        "Name": "redis-net",
		        "Id": "738f3ba557ea37f27d3d8ba6839ce962bd76fd2ffc24b8ea5c752ced7c3f6df6",
		        "Created": "2019-01-26T13:36:00.113700469Z",
		        "Scope": "local",
		        "Driver": "bridge",
		        "EnableIPv6": false,
		        "IPAM": {
		            "Driver": "default",
		            "Options": {},
		            "Config": [
		                {
		                    "Subnet": "172.18.0.0/16",
		                    "Gateway": "172.18.0.1"
		                }
		            ]
		        },
		        "Internal": false,
		        "Attachable": false,
		        "Ingress": false,
		        "ConfigFrom": {
		            "Network": ""
		        },
		        "ConfigOnly": false,
		        "Containers": {
		            "07da0eb6dc9be4e38c7d3c8426b1181ad9dd89489bee1a79d4928be05664d9a0": {
		                "Name": "redis-7014",
		                "EndpointID": "156a352401c46f85eb8c04c0bb94b83620541c9a8a9d67364dedba60cde14981",
		                "MacAddress": "02:42:ac:12:00:06",
		                "IPv4Address": "172.18.0.6/16",
		                "IPv6Address": ""
		            },
		            "1640364a670c4eafdef9593bca23b41b923f1182a5e6cac604261ebced77d2eb": {
		                "Name": "redis-7015",
		                "EndpointID": "1eb2db7ace2ff6fbb0cfdfa95eb220ed2d8a73cbca7e457a18de8a5e2015eeda",
		                "MacAddress": "02:42:ac:12:00:07",
		                "IPv4Address": "172.18.0.7/16",
		                "IPv6Address": ""
		            },
		            "4266d49967b191a420413dbc80d35049a8f3b893c8bad7e6ea3757c9f793ef94": {
		                "Name": "redis-7013",
		                "EndpointID": "16cbed49c75e578f939ade3ef06aaf3a52c58f284fd065e5d2c9db5fda0062f5",
		                "MacAddress": "02:42:ac:12:00:05",
		                "IPv4Address": "172.18.0.5/16",
		                "IPv6Address": ""
		            },
		            "88459f13cf11a256c0c9df7aa19c5fb615b9b4eb89911cf9a3335f9a8bf71c07": {
		                "Name": "redis-cluster",
		                "EndpointID": "ac1cc0cc86985d53aa193601868cfe5b9210f00b0cd2409d13244cc6ce19a6ae",
		                "MacAddress": "02:42:ac:12:00:08",
		                "IPv4Address": "172.18.0.8/16",
		                "IPv6Address": ""
		            },
		            "bd57b93856da61535dc83235a19625a1417dbfd0833b88c8b668aa288b8174af": {
		                "Name": "redis-7012",
		                "EndpointID": "7cbf8cef0ff4e9ba6192db08bf539a24ae0f605a669152ff4c2df77ad7eef6b2",
		                "MacAddress": "02:42:ac:12:00:04",
		                "IPv4Address": "172.18.0.4/16",
		                "IPv6Address": ""
		            },
		            "e2d11bc6682bdab96713631b1352b51790ee94c8bd05d854a92f45a9da93ab65": {
		                "Name": "redis-7010",
		                "EndpointID": "60975dd5073934ee28d47e9a0495347ac295e0915ffd7d085713af3d6a742dd2",
		                "MacAddress": "02:42:ac:12:00:02",
		                "IPv4Address": "172.18.0.2/16",
		                "IPv6Address": ""
		            },
		            "f36fc8b2efaa14dcbc2b5c49d641a9f3d7ed501bc5a3891d420902369fd03fee": {
		                "Name": "redis-7011",
		                "EndpointID": "b24ac4af7db62086f457bbfc221330d1a4670864f2e6fdd39b7d879aed288813",
		                "MacAddress": "02:42:ac:12:00:03",
		                "IPv4Address": "172.18.0.3/16",
		                "IPv6Address": ""
		            }
		        },
		        "Options": {},
		        "Labels": {}
		    }
		]
		检查 redis-701* 容器 的 ip 正好 跟 被分配持有的 redis.conf配置文件的 cluster-announce-ip  一致!
		不一致的就要删除容器 好好修改重新建立容器:
		/////补充知识
		#  批量 删除指定容器!!
		for port in `seq 7010 7015`; do \
		  docker stop redis-${port};
		  docker rm redis-${port};
		done
	开始启动redis-cluster集群				
		echo yes | docker run -i --rm --net redis-net ruby sh -c '\
		  gem install redis \
		  && wget http://download.redis.io/redis-stable/src/redis-trib.rb \
		  && ruby redis-trib.rb create --replicas 1 \
		  '"$(for port in `seq 7010 7015`; do \
		    echo -n "$(docker inspect --format '{{ (index .NetworkSettings.Networks "redis-net").IPAddress }}' "redis-${port}")":${port} ' ' ; \
		  done)
		实际上就是 建立并启动 可以执行ruby程序的 容器 :docker run --net redis-net ruby
		然后在这个容器 执行
		gem install redis  //安装 ruby 的 redia 插件
		wget http://download.redis.io/redis-stable/src/redis-trib.rb   // 获得实现 cluster 的 ruby 脚本
		ruby redis-trib.rb create --replicas 1 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 	//开始执行 cluster 集群
		不过遇到了问题:
		WARNING: redis-trib.rb is not longer available!
		You should use redis-cli instead.
		
		All commands and features belonging to redis-trib.rb have been moved
		to redis-cli.
		In order to use them you should call redis-cli with the --cluster
		option followed by the subcommand name, arguments and options.
		
		Use the following syntax:
		redis-cli --cluster SUBCOMMAND [ARGUMENTS] [OPTIONS]
		
		Example:
		redis-cli --cluster create 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 --cluster-replicas 1

		To get help about all subcommands, type:
		redis-cli --cluster help
		问题表示, redis-trib.rb 不再提供cluster 服务, redis 本身redis-cli 已经可以实现:
		也就说 这个ruby 容器白建立的!! 删掉
	建立一个新 redis 容器,用来实现 redis-cluster
		docker run -it --name redls-cluster --net redis-net ruby /bin/bash
		cd /usr/local/bin
		redis-cli --cluster create 172.18.0.2:7010 172.18.0.3:7011 172.18.0.4:7012 172.18.0.5:7013 172.18.0.6:7014 172.18.0.7:7015 --cluster-replicas 1		//执行 cluster, --cluster-replicas 1 的 1 表示 1主1从
			>>> Performing hash slots allocation on 6 nodes...
			Master[0] -> Slots 0 - 5460
			Master[1] -> Slots 5461 - 10922
			Master[2] -> Slots 10923 - 16383
			Adding replica 172.18.0.5:7013 to 172.18.0.2:7010
			Adding replica 172.18.0.6:7014 to 172.18.0.3:7011
			Adding replica 172.18.0.7:7015 to 172.18.0.4:7012
			M: 5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010
			   slots:[0-5460] (5461 slots) master
			M: 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011
			   slots:[5461-10922] (5462 slots) master
			M: e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012
			   slots:[10923-16383] (5461 slots) master
			S: b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013
			   replicates 5d9495381e8ca8a72cd62009053f79745dc485b3
			S: 77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014
			   replicates 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23
			S: 25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015
			   replicates e5cee718cb7a59db06d86255d45714218518e2ba
			Can I set the above configuration? (type 'yes' to accept): yes
			>>> Nodes configuration updated
			>>> Assign a different config epoch to each node
			>>> Sending CLUSTER MEET messages to join the cluster
			Waiting for the cluster to join
			..
			>>> Performing Cluster Check (using node 172.18.0.2:7010)
			M: 5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010
			   slots:[0-5460] (5461 slots) master
			   1 additional replica(s)
			M: e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012
			   slots:[10923-16383] (5461 slots) master
			   1 additional replica(s)
			S: 25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015
			   slots: (0 slots) slave
			   replicates e5cee718cb7a59db06d86255d45714218518e2ba
			S: 77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014
			   slots: (0 slots) slave
			   replicates 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23
			S: b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013
			   slots: (0 slots) slave
			   replicates 5d9495381e8ca8a72cd62009053f79745dc485b3
			M: 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011
			   slots:[5461-10922] (5462 slots) master
			   1 additional replica(s)
			[OK] All nodes agree about slots configuration.
			>>> Check for open slots...
			>>> Check slots coverage...
			[OK] All 16384 slots covered.
	貌似成功cluster了, 接下来就是测试 !!!
		在任一节点/宿主容器上查看信息:
root@88459f13cf11:/usr/local/bin# redis-cli -c -h 172.18.0.2 -p 7010 cluster nodes
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548522635159 3 connected 10923-16383
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548522634000 6 connected
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548522634156 5 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 myself,master - 0 1548522634000 1 connected 0-5460
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 slave 5d9495381e8ca8a72cd62009053f79745dc485b3 0 1548522634557 4 connected
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 master - 0 1548522633000 2 connected 5461-10922
		
		redis-cli -c -h 172.18.0.2 -p 7010	//集群模式登录 节点  get set 实验
		172.18.0.2:7010> get foo
		-> Redirected to slot [12182] located at 172.18.0.4:7012
		(nil)
		172.18.0.4:7012> keys *
		(empty list or set)
		172.18.0.4:7012> get Tom
		-> Redirected to slot [9233] located at 172.18.0.3:7011
		(nil)
		172.18.0.3:7011> keys *
		1) "tom"
		172.18.0.3:7011> set jim age11
		-> Redirected to slot [4115] located at 172.18.0.2:7010
		OK
		172.18.0.2:7010> key *
		(error) ERR unknown command `key`, with args beginning with: `*`, 
		172.18.0.2:7010> keys *
		1) "jim"
		2) "kate"
		172.18.0.2:7010> set bob age15
		-> Redirected to slot [8955] located at 172.18.0.3:7011
		OK
		172.18.0.3:7011> set zeta age10
		OK
		172.18.0.3:7011> set anna age5
		-> Redirected to slot [15278] located at 172.18.0.4:7012
		OK
		172.18.0.4:7012> keys *
		1) "anna"
		172.18.0.4:7012> set fuli age7
		OK
		172.18.0.4:7012> keys *
		1) "anna"
		2) "fuli"
		172.18.0.4:7012> get tom
		-> Redirected to slot [8919] located at 172.18.0.3:7011
		"age12"
		172.18.0.3:7011> 
		可以看到 set get 数据 会自动跳到 所属 hash slot 的节点 进行数据保存!!!
	模拟故障1: 当master挂了, slave 会变成 master!!!
		比如直接 docker stop redis-7010 
		检查 网络 :
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes   //先接入  172.18.0.3:7011 然后检查所有节点网络         
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524513000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524513817 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548524310644 1548524309000 1 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524513516 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524512513 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524512814 3 connected 10923-16383
			注意, 看到了 172.18.0.2:7010@17010 master,fail  172.18.0.5:7013@17013 master
			hash-solt:0-5460 的 master节点挂了, 172.18.0.5:7013 作为 slave 节点 变成了 master 继续工作
			注意 redis-cli -c -h 172.18.0.2 -p 7010 cluster nodes //这是先接入 172.18.0.2:7010 然后检查所有节点网络 
			但是,由于这时, 172.18.0.2:7010不能接入,所以 这条指令也就失败了
		操作:redis-cli -c -h 172.18.0.3 -p 7011
			172.18.0.3:7011> get jim	//获取 存于   hash-slot:0-5460 的数据
			-> Redirected to slot [4115] located at 172.18.0.5:7013
			"age11"
			172.18.0.5:7013>  			
			// 换到了 172.18.0.5:7013 节点了!!!
		重新打开 172.18.0.2:7010 , 这个本来的master节点变成了slave节点
			docker start redis-7010 (注意 创建redis-701*的容器,设置了自动运行redis-server, 所以不用额外打开服务)
						(另外,创建容器时的设置,也不能通过 kill -9 来杀掉这个进程,所以只能通过 docker stop来模拟故障)
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524688000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524690000 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 slave b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 0 1548524690000 7 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524691313 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524690311 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524689307 3 connected 10923-16383
			可以看到  172.18.0.2:7010 变成 slave

	模拟故障2: 某 hash-slot 集群的 master slave 节点都挂了,redis 数据库阻塞停摆
		docker stop redis-7010 redis-7013
		检查 网络 :
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548525099000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548525100000 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548525051488 1548525050000 8 connected 0-5460
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master,fail - 1548524979292 1548524978591 7 connected
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548525100428 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548525099425 3 connected 10923-16383
			可见:
			172.18.0.5:7013@17013 master,fail
			172.18.0.2:7010@17010 master,fail
		操作:redis-cli -c -h 172.18.0.3 -p 7011
			172.18.0.3:7011> get jim	//获取 存于   hash-slot:0-5460 的数据 失败 (即故障的hash-solt集群 )
			(error) CLUSTERDOWN The cluster is down	
			172.18.0.3:7011> get tom	//获取 存于   hash-slott:5461-10922  的数据 (即自己本身 也失败)
			(error) CLUSTERDOWN The cluster is down
			172.18.0.5:7013> 
		重新打开 172.18.0.2:7010, 172.18.0.5:7013 , 
			docker start redis-7010 redis-7013  
				(注意,先打开redis-7010, 因为创建容器时,没有使用静态地址)
				(如果先创建 redis-7013 ,redis-7013会继承172.18.0.2,redis-7010会继承172.18.0.5)
				(跟他们 redis-conf 设置的 不匹配,redis-server启动失败)
			当然只 docker start redis-7010 也可以,
			但是只 docker start redis-7010 就不行,也是因为ip冲突,redis-server启动失败)
			然后
			redis-cli -c -h 172.18.0.3 -p 7011 cluster nodes   //先接入  172.18.0.3:7011 然后检查所有节点网络         
7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 172.18.0.3:7011@17011 myself,master - 0 1548524513000 2 connected 5461-10922
25e6971b5603eb6c199b8e88ae46dcb51822f0f0 172.18.0.7:7015@17015 slave e5cee718cb7a59db06d86255d45714218518e2ba 0 1548524513817 3 connected
5d9495381e8ca8a72cd62009053f79745dc485b3 172.18.0.2:7010@17010 master,fail - 1548524310644 1548524309000 1 connected
b8c6b07b61c1227b97d8d0f4aecf50a7cfda710b 172.18.0.5:7013@17013 master - 0 1548524513516 7 connected 0-5460
77d98daae2683f1325a6aeb149ca4e74839f9d69 172.18.0.6:7014@17014 slave 7f9f0b84095c2fd77ff4fb896f7cbd9e943cde23 0 1548524512513 5 connected
e5cee718cb7a59db06d86255d45714218518e2ba 172.18.0.4:7012@17012 master - 0 1548524512814 3 connected 10923-16383				
			cluster网络又好了!! redis数据可以重新工作!!!
	模拟故障3: 上面的cluster 是通过 redis-cluster容器节点 创建集群的,那么, redis-cluster容器节点挂了呢?
		结果没有影响,  redis-cluster容器节点 创建了集群后,就没有 redis-cluster容器节点 的事情了
		即使所有节点都挂了!!
			docker stop redis-7010 redis-7011 redis-7012 redis-7013 redis-7014 redis-7015 redis-cluster
		重新,启动所有 数据库节点:
			docker start redis-7010 redis-7011 redis-7012 redis-7013 redis-7014 redis-7015
			redis数据库,照样如常工作,不需要重新创建集群
		就是说, redis数据节点 一旦创建好分片集群,就能自我管理并工作, 不需要其他管理节点介入
	尝试加入 sentinel (虽然感觉没有加入的意义!!! 因为cluster本身实现了 故障主从切换!!)
		sentinel 配置文件: sentinel-forcluster.conf
//////////
protected-mode no 
port 10011
daemonize yes
logfile "/var/log/sentinel.log"
sentinel monitor mymaster1 172.18.0.2:7010 1
sentinel monitor mymaster2 172.18.0.3:7011 1
sentinel monitor mymaster3 172.18.0.4:7012 1
sentinel down-after-milliseconds mymaster1 10000
sentinel down-after-milliseconds mymaster2 10000
sentinel down-after-milliseconds mymaster3 10000
sentinel parallel-syncs mymaster1 1
sentinel parallel-syncs mymaster2 1
sentinel parallel-syncs mymaster3 1
sentinel failover-timeout mymaster1 15000
sentinel failover-timeout mymaster2 15000
sentinel failover-timeout mymaster3 15000
//////////
		// 这才是 正确的 宿主机拷贝数据到 容器的 方法!!
		docker cp sentinel-forcluster.conf redis-7010:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7011:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7012:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7013:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7014:/usr/local/bin/sentinel.conf
		docker cp sentinel-forcluster.conf redis-7015:/usr/local/bin/sentinel.conf
		然后在容器开启 sentinel 节点,这里 我们在数据库本身开启打开sentinel服务,就懒得用新的容器实现了!!!
		在 6 个容器里分别执行sentinel  : cd /usr/local/bin/ && redis-sentinel sentinel.conf &
		然后出错:
			*** FATAL CONFIG FILE ERROR ***
			Reading the configuration file, at line 5
			>>> 'sentinel monitor mymaster1 172.18.0.2:7010 1'
			Unrecognized sentinel configuration statement.
		发现不能执行, 然后 我换了 3个独立节点 执行 sentinel
		出现同样错误!!
		看来 sentinel 和 cluster 是冲突的 !!!,cluster本身也实现了 故障主从切换, 
		所以sentinel不知道载在这个基础上如何工作了!!
	接入django 测试：
		修改之前 APP1 APP2 的内容： vim helloworld/views.py 添加
//////////////////////
from rediscluster import StrictRedisCluster

def hello (requset):
    redis_nodes = [
        {'host':'172.18.0.2','port':7010},
        {'host':'172.18.0.3','port':7011},
        {'host':'172.18.0.4','port':7012},
        {'host':'172.18.0.5','port':7013},
        {'host':'172.18.0.6','port':7014},
        {'host':'172.18.0.7','port':7015},
    ]
    try:
        redisconn = StrictRedisCluster(startup_nodes=redis_nodes)
    except Exception:
        print('connect Error')
        return HttpResponse('Connect Error!')

    print(redisconn.get('jim'))
    print(redisconn.get('tom'))
    print(redisconn.get('anna'))
    print(redisconn.get('fuji'))
    redisconn.set('app_info', 'HelloWorld-APP1')	# APP2 改为 APP2
    app_info = bytes.decode(redisconn.get('app_info'))
    stu_num_info = int(redisconn.get('stu_num'))
    info = "Hello, everyone!<br/>Get Hi: {0}<br/>Get stu_num: {1}<br/>".format(app_info, stu_num_info)
    return HttpResponse(info) 
/////////////////////
		由于 APP1 APP2 跟 redis-7010 不是一个网段，所以需要建立连接到 redis-net network
			docker network connect redis-net  APP2
			docker network connect redis-net  APP1
		最后成功启动！！		
	
	putty 下载上传远程文件
		pscp E:\dukto\20190128 root@149.28.1xx.1xx:/root          //上传
		pscp root@149.28.1xx.1xx:root/note2 E:\dukto\      //下载
	

	最后,需要深入处理的有:
		如何操作实现读写分离,貌似所有操作都在master节点上,无法把读任务分摊到slave节点? 
		接入django 测试!!


mysql 集群 PXC (pxc是用于高一致集群的 Mysql 软件版本):
	参考: 
	https://blog.csdn.net/weixin_41141219/article/details/82767832  ///Docker 搭建pxc集群 + haproxy + keepalived 高可用（一）
	https://blog.csdn.net/qq_39409110/article/details/82288953     ////Docker 搭建pxc集群 + haproxy + keepalived 高可用（二）
	https://blog.csdn.net/qq_39409110/article/details/82289621     ////Docker 搭建pxc集群 + haproxy + keepalived 高可用（三）
	https://blog.csdn.net/qq_21108311/article/details/82223269   ////直接使用docker 的pxc 镜像,外挂docker volume备份数据库内容
	https://blog.csdn.net/fuckluy/article/details/80450868	////centos安装pxc, 主要讲解 my.cnf 配置参数!!!
	http://www.cnblogs.com/lyhabc/archive/2017/05/05/6812284.html	///// MySQL集群PXC的搭建   版本旧
	https://www.cnblogs.com/zejin2008/p/5475285.html	/////MySQL PXC 高可用集群搭建     版本旧
	http://www.cnblogs.com/kevingrace/p/5685371.html	/////  MySQL高可用方案－PXC环境部署记录   背景知识丰富    版本旧
				//// 模拟故障 和 恢复   重要
	https://www.percona.com/doc/percona-xtradb-cluster/5.5/howtos/centos_howto.html   ////官网部署教程   版本旧
	https://www.biaodianfu.com/centos-7-2-install-percona.html     //yum源 安装冲突问题,    没什么参考价值
	https://blog.csdn.net/wzhwho/article/details/4179154  //关selinux
	https://www.linuxidc.com/Linux/2017-05/143930.htm      ///PXC5.7(Percona XtraDB Cluster)集群部署	tar安装,参考有限
	https://hacpai.com/article/1536650134710	///centos7安装pxc5.7,  使用xtrabackup-v2数据同步     参考最多!!!!!
	https://www.clevernetsystems.com/running-percona-xtradb-cluster-rhel7/      ///pxc 常用指令
	https://www.cnblogs.com/ivictor/p/4837750.html		/////Docker官方CentOS镜像无法启动mysqld的总结
	https://www.jianshu.com/p/7cccdaa2d177   ///centos7 安装 mysql5.7
	http://blog.51cto.com/11819159/1933718	 /// 认识到 yum 安装的一些细节, 认识 basedir和datadir,本来想解决:
						 /// [ERROR] Can't find error-message file '/usr/local/mysql/share/mysql/errmsg.sys'.
						 /// 最后这个问题通过 清除已生成文件,重新初始化 mysald 解决!!!!
	/// yum 安装的一些细节: 作者的 basedir指定的是/usr/local/mysql/；后面突然想到了basedir指定是数据库的bin，lib之列的文件，
	///但是因为是yum安装的，所有这些文件默认的路径是在/usr/share/mysql下面，所以basedir这个参数可以并不需要指定，
	///或者直接指定到/usr/share/mysql/这个目录下面。
	
	
	知识点				
		PXC+Replication多主多从MySQL集群搭建
		MYCAT轻松实现mysql读写分离
		MySQL5.7.18已经支持基于事务的主从复制和读写分离
		而 pxc 做得更远!! 保持数据库高一致性,和每个节点数据保持相同,均可读写
		通过 docker 提供的傻瓜包镜像不好 参透,还是个实战好理解!
		为了锻炼 部署数据库集群到多个服务器的操作, 不直接使用 docker 提供 预装pxc镜像,
		需要实践 在 centos 部署 pxc57 的经验!!!
		需要本机 docker 实验了!!  远程机器资源严重不足 !!! 主要怀疑 pxc 最小的InnoDB_bffer_pool 为 128MB
		而对于 512 mb 内存的远程服务器机子来说就无法玩下去!!
	准备:
		首先在自己的 pc上 安装 docker:  https://blog.csdn.net/bingzhongdehuoyan/article/details/79411479
		docker pull centos  //下载docker上的centos镜像,默认最新最简centos7 镜像
		建立模拟局域网络:
			sudo docker network create pxc-net --subnet=172.22.0.0/16 --ip-range=172.22.0.0/16 --gateway=172.22.0.1      
			//16 是掩码范围的意思即：255.255.0.0
			网络查看: sudo docker network inspect pxc-net
		新建启动5个容器点 指定 pxc-net网络里的静态IP
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.2 -itd --name=pxc-node1 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.3 -itd --name=pxc-node2 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.4 -itd --name=pxc-node3 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.5 -itd --name=pxc-node4 centos /usr/sbin/init
			sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.6 -itd --name=pxc-node5 centos /usr/sbin/init
			(由于 docker 使用 centos建立的容器 执行 systemctl 会出错：Failed to get D-Bus connection: Operation not permitted
			 所以 docker run 的时候 加上 --privileged=true /usr/sbin/init)
			容器内查看centos 版本信息
				cat /etc/redhat-release
				CentOS Linux release 7.6.1810 (Core)	
		容器内centos 关闭 防火墙 和 行为监督 selinux！
			iptable： https://blog.csdn.net/wailaizhu/article/details/53488954
			selinux： https://www.cnblogs.com/activiti/p/7552677.html
			然而 精简 centos 镜像 并没有安装 iptable 和 selinux可以不理会！！
		登陆 5个node 准备 安装同样内容
			docker exec -it pxc-node_XXX bash		//登陆 node1/2/3/4/5	
	部署安装 pxc57( 也叫 pxc5.7)
		目前最通用的是 pxc57 版本, 网上很多使用参考都太旧了,参考价值有限, 
		旧版本 pxc 都需要自己手动安装必要的依赖包,比如:
			yum -y groupinstall Base Compatibility libraries Debugging Tools Dial-up Networking suppport Hardware monitoring utilities Performance Tools Development tools
		或者: 		
			rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
			yum install perl-IO-Socket-SSL perl-DBD-MySQL perl-Time-HiRes socat nc -y
		或者:
			yum install -y git scons gcc gcc-c++ openssl check cmake bison boost-devel asio-devel libaio-devel ncurses-devel readline-devel pam-devel socat
		实际上,虽然我的centos精简,缺少很多东西,但是如果是安装最新的的 pxc 不需要自己主动去添加依赖包!!
		pxc57 安装过程自我添加 依赖包!!!!
		所以以上安装依赖包的操作  不需要 !!!
		主要部署安装参考:  https://hacpai.com/article/1536650134710   //////centos7 部署安装 pxc57
	完整已经填好所有坑的部署安装方法:  假设我们部署5个节点 pxc-node1/2/3/4/5
		所有容器机子都安装:
			yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm //安装源
			yum install Percona-XtraDB-Cluster-57 -y	//直接安装 pxc57
		pxc的配置文件除了 传统的 my.cnf 还有他所包含的子文件,
		所有机子的 my.cnf都添加以下配置内容:
	[client]
	default-character-set = utf8mb4
	[mysqld]
	user=mysql
	skip_ssl
	sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'
	slow_query_log=ON
	slow_query_log_file=/var/lib/mysql/mysql-slow.log
	general_log=ON
	general_log_file=/var/lib/mysql/log-mysql.log
	long_query_time = 1
	explicit_defaults_for_timestamp = 1
	innodb_buffer_pool_instances = 1		//教程说8 不合适,因为注意>1  表示缓存大于1G  ?? 不知道那看到的  
	innodb_buffer_pool_dump_at_shutdown = 1
	log_timestamps=system
	character-set-server = utf8mb4
	collation-server = utf8mb4_unicode_ci
	max_connections=10000

		然后 第一台机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
	
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://					//wsrep已有,不用写上
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.2				//第一台机子的 ip
	# Cluster name
	wsrep_cluster_name=pxc-cluster
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc1					//需要修改!!
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc_user:123456"			//需要修改!!

		其他机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
		
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://172.22.0.2,172.22.0.3,172.22.0.4,172.22.0.5,172.22.0.6	//需要改
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.2/3/4/5/6				//node2,3,4,5 各自 ip地址
	# Cluster name
	wsrep_cluster_name=pxc-cluster
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc2/3/4/5					//需要修改!!node2,3,4,5 各自定义
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc_user:123456"			//需要修改!!
		然后 首次启动第一台机子 node1:
			systemctl start mysql@bootstrap.service
			grep 'temporary password' /var/log/mysqld.log	//获得暂时密码
			mysql -uroot -p		//登录 输入 暂时密码
			ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';  //修改root 密码
			CREATE USER 'pxc_user'@'localhost' IDENTIFIED BY '123456';	//创建热备份账户!!
			GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456';	//提权!!!!
			GRANT ALL PRIVILEGES ON *.* TO 'pxc_user'@'%' IDENTIFIED BY '123456';
			GRANT ALL PRIVILEGES ON *.* TO 'pxc_user'@'localhost' IDENTIFIED BY '123456';
			至此 第一台机子就部署好了,
		然后第二台机子 node2:
			直接 systemctl start mysql 就好了, 机子会加入到集群里,如果加入集群失败,会直接初始化失败
			成功后 mysql -uroot -p  输入同步过来的密码 123456 就可以登录!!
			这里 添加的表单,数据, 直接就开始同步到 第一台机子了!!!,
			可以直接在第一机子登录查看
		然后的三四五台机子.
			跟第二台操作一样,  systemctl start mysql 便可自动加入集群!!
		然后数据库关闭操作:
			一般: 其他节点 systemctl stop mysql 直接关闭!!!
			      第一节点 最后,且 通过 systemctl stop mysql@bootstrap.service 关闭!!!!!
			重新启动的话, 第一节点 先打开systemctl start mysql@bootstrap.service 
				其他节点 陆续打开 systemctl start mysql

	模拟故障分析!!
		假设只加入了 node2
			node1 无法  systemctl stop mysql , 我们尝试直接 kill -9 强制删除
			结果 只剩下 node2, 突然的故障无法让剩下的node2, 自举为首节点, 所以不能读写数据库,数据库直接崩溃!!!
			node2 systemctl stop mysql 常规关掉.
			这时 node1 因为是kill 强制删除的, 重新 systemctl stop mysql@bootstrap.service ,错误!!! 
			查看 /var/log/mysqld.log,说不是最后关闭节点,所以丧失首节点地位!!!
			降级为子节点: 这样子整个集群就没了首节点!!了,都是子节点
			
			node1重新强制成为首节点: 
				vi /var/lib/mysql/grastate.dat , safe_to_bootstrap: 1	//置1
				systemctl start mysql@bootstrap.service
		假如加入了 node2 node3
			1,直接 kill -9 强制 关闭 node1
			  突发故障,却剩下了 node2, node3, 两者很快自举出一个首节点(可能是node2,也可能node3)!!
			  这时数据库仍可以正常读写和同步!!
			2,这时 node3  systemctl stop mysql 正常关闭, 程序上推举node2最后节点,成为首节点
			  这时,数据库仍然正常读写.
			  node2虽然作为最后节点,也是首节点,但是关闭时还是 systemctl stop mysql 指令
			  就是说, node2 当初什么指令打开,最后也什么指令关闭	
			3,node2作为新的首节点, 数据库重新打开时,先打开 node2 而且换成指令 systemctl start mysql@bootstrap.service 打开!
			  然后 node1 node3 作为子节点, 需要 systemctl start mysql 打开!
			  这时 node1出错, cat /var/log/mysqld.log 查看日志发现
			  原来node1被创建人默认为永远的首节点, 所以 wsrep_cluster_address=gcomm:// 可以什么都不写
			  如今沦为子节点 wsrep_cluster_address=gcomm:// 如果没有ip 就不可能找到属于自己集群的首节点,加入集群!!
			  所以需要 vi /etc/percona-xtradb-cluster.conf.d/wsrep.cnf:
				wsrep_cluster_address=gcomm://   改回:
				wsrep_cluster_address=gcomm://172.22.0.2,172.22.0.3,172.22.0.4,172.22.0.5,172.22.0.6	
				就是说 作为首节点 wsrep_cluster_address=gcomm:// 填不填ip 都没有关系.
				但是首节点也有可能沦为子节点 ,所以统一填上更合理!!
			  然后 通过 systemctl start mysql 假如集群
			4,这时 node2 第一个想正常关闭,通过指令 systemctl stop mysql@bootstrap.service
			  而不是 systemctl stop mysql,
			  因为 node2 是 systemctl start mysql@bootstrap.service 打开的, 
			  不管他是不是最后正常关闭都要通过指令 systemctl stop mysql@bootstrap.service
			  首节点变成 node1 node3 其中一个,
			5,如果想 node1 变回 首节点, node3就得先正常关闭 systemctl stop mysql
			  最后 node1 也 通过 systemctl stop mysql 正常关闭
			6,总结的 重点就是说,数据库不完全崩溃的情况下!!!!!, 最后正常关闭的节点,就是下次数据开启的首节点
			  (像第一种讨论的情况只有两个节点, 一个不正常关闭,整个数据库就完全崩溃!!,
			   最后一个节点正常关闭也不会成为下次数据库开启的首节点)
			  节点当初是什么指令打开,就同样指令关闭!!!
		三个节点以上情况,参考3个节点情况同样讨论!!!

	部署安装集群 填坑 分析 :
		不管安装 旧pxc,还是新的pxc57 第一次启动时时都会遇到这个大坑,这个坑问题并不在于漏装依赖包的问题!!
		我们从分析入手:
			第一次启动直接出错: Job for mysqld.service failed because the control process exited with error code. See "systemctl status mysqld.service" and "journalctl -xe" for details.
			我们可以透过 systemctl status mysqld.service  或者 journalctl -xe 查看日志,发现爱呢问题:
			systemctl status mysqld.service 是针对 mysql 第一次启动的日志,
			journalctl -xe 却是 容器启动到此刻系统发布的所有记录的日志
		我们从中查看 ERROR 问题
			发现什么mysql: Can't create directory '/var/lib/mysql/' (Errcode: 17 - File exists) 
			但似乎不是重点.继续发现 [ERROR] InnoDB: Operating system error number 13 in a file operation.			
			错误 !!!! 即访问拒绝错误!!
			网上都没有关闭 seliunx ,但是本来就是没有安装 selinux
			然而,已经是root权限运行centos 了,  针对 pxc 出现的这个问题, 我们可以验证仅仅安装mysql也出现
			pxc是高级版本的mysql, 如果安装启动mysql出现问题,那么就不是pxc 高级模块部分初始化引起的问题!!
		所以先 关闭,重装 再打开 pxc-node1 容器, 安装测试 mysql5.7:
			参考 https://www.jianshu.com/p/7cccdaa2d177   ///centos7 安装 mysql5.7
			//首次密码修改问题
			ERROR 1819 (HY000): Your password does not satisfy the current policy requirements
			参考: https://blog.csdn.net/hello_world_qwp/article/details/79551789
			果然,安装了,也发现同样的问题 InnoDB 权限问题!!!
		一开始 怀疑是 用户权限问题!! 经学习mysql 不能从属 root 用户下工作,不然会出现很多问题
			mysal初始化启动时,应该添加 --user=mysql,即 msqld --uer=mysql
			就是说 使 mysql 的工作文件从属到 一个 mysql 的用户名下,
			虽然假定永远处于 root 下操作,不明白为啥还要分到 mysql 下,
			问题仍然处在
		尝试dmesg,会发现最新的像这样子的错误!!
			audit: type=1400 audit(1548838487.195:1022): apparmor="DENIED" operation="open" profile="/usr/sbin/mysqld" name="/proc/2821/status" pid=12504 comm="mysqld" requested_mask="r" denied_mask="r" fsuid=0 ouid=0
			谷歌 发现是是一个 apparmor 的程序引起
			然而,渐渐精简的centos 并没有,原来是 宿主的,虽然在容器里执行dmesg, 但是得到的却是宿主机开机到现在的日志记录!!!
			怀疑 宿主的 apparmor 阻碍了 容器 的 mysqld 初始化
			apparmor(监督强制软件访问行为的软件,跟 selinux 一样作用) 阻碍的 docker
			apparmor监督注册程序的访问内容, 当程序访问管辖外的内容时,会禁止行为
			主要指通过 路径分析实现监督:
			宿主机 安装了 mysql, 执行程序路径 /usr/sbin/mysqld
			容器 也安装了 mysql, 执行程序路径也是 /usr/sbin/mysqld
			一个是宿主机里的路径,一个数容器里的路径,但是apparmor只辨认 /usr/sbin/mysqld 不管实际位置
			这里 apparmor 只允许 /usr/sbin/mysqld 这个路径执行文件,访问指定的文件目录,
			但是 挂在 docker里的目录的路径显然超出了管辖范围外,所以禁止操作,
			变相 导致 容器 的InnoDB 没有访问权限
			所以禁用apparmor 关于mysql配置文件,参考: https://www.helplib.com/MySQL/article_176
			//查看监督
			sudo aa-status
			//取消监督某某
			sudo ln -s /etc/apparmor.d/usr.sbin.mysqld /etc/apparmor.d/disable
			sudo apparmor_parser -R  /etc/apparmor.d/usr.sbin.mysqld
			sudo /etc/init.d/apparmor   ///重新启动
			//恢复监督某某
			sudo rm /etc/apparmor.d/disable/usr.sbin.mysqld
			sudo /etc/init.d/apparmor   ///重新启动
			删除各种冲突内容!! 最后重新 start mysqld 注意 不是 mysql
			service mysqld start  
			成功!!!!
		查到是宿主 apparmor 的行为, 与mysql无关,我们重新开始部署安装 pxc57
			不需要 依赖包,!!
			直接安装源,然后安装pxc57,
			配置 my.cnf 加上
			[mysqld]
			user=mysql
			然后第一次运行:service mysql start
			也没问题了!!
		然后开始部署: 
			部署开始,启动第一台机子的时候需要  systemctl start mysql@bootstrap.service
			出错!! 分析,由于 机子已经经历了首次启动,所以 使用这个部署启动的时候会出现莫名奇妙的错误
			其实就是初始化冲突问题, 一般
			重装, 配置好 my.cnf 所有内容后 才 systemctl start mysql@bootstrap.service 执行第一次启动
			也可以,删除以下文件夹后 重新执行 systemctl start mysql@bootstrap.service
			rm -rf /var/run/mysqld/ && rm -rf /var/lib/mysql/ && rm -rf /var/log/mysqld.log
			其实就是 删除 .cnf 配置的: pid-file,  datadir,  log-error 
			然后再就可以相当于重新执行 首启动
			成功!!!
		然后加入节点 出错:
			出现了 xtrabackup 运行失败的 信息
			既然 xtrabackup 也开始工作,就是说集群开始了,那么寻找错误就不能只从子节点分析
			子节点 只是 说 xtrabackup 运行错误, 怎样错误,并没有说!!
			而且也会出现:
			Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock'
			ERROR! mysqld_safe with PID 5737 has already exited: FAILURE
			这样的迷惑信息!! 
			实际上,因为 xtrabackup 工作失败后,一系列初始化就停了,于是会出现很多后续错误迷惑而找不到真正的出错点!!
			热备份 高可用关键 xtrabackup
			xtrabackup 出错,可能不仅仅是子节点的问题,也有可能是第一节点的问题!!
			xtrabackup 是节点之间实现热备份同步的程序!! 其实就是共同使用一个统一用户帐号实现,
			节点间自动使用嗯这个帐号登录更新数据!
			然后从 第一节点发现, 原来并第一节点还没有建立这个 统一账户,grant没有建立新帐号,只是给帐号提权
		建立帐号后,继续出错!!
			Error: failed to execute query LOCK TABLES FOR BACKUP: Access denied; you need (at least one of) the RELOAD privilege(s) for this operation
			这个是 帐号建立了,但还没有提权,,,,提权后
			就成功了

	pxc/mysql填坑思路:
		https://www.cnblogs.com/ivictor/p/5146247.html		//填坑思路
		先尝试发现问题!!
		systemctl status mysqld.service
		journalctl -xe
		demesg
		vi /var/log/mysqld.log
		一般mysql 启动时第一时间启动日志系统,即 生成并输出/var/log/mysqld.log
		如果出错在于 生成mysqld.log 之前,就系统问题,重要关注systemctl status mysqld.service,journalctl -xe 内容
		特别关注 dmesg 内容!! 
		这里注意 dmesg 从来是是宿主开机以来的日志记录, 不管这条指令是在容器还是宿主机运行!!
		如果生成了 mysqld.log ,一般就是 my.cnf 即文件配置配置问题,
			或者没有进入 mysql 初始化某些指令的问题, 当然也有可能还是系统问题!!
		重点,不要先考虑 是 安装出撮问题,因为安装时 complete 表示成功安装,一般是内部外部的配置问题导致不能启动!!
		journalctl -xe 把日志从开始位置开始列出, 并不合适,应该 journalctl -n 直接从最后的日志显示内容!!!!
 
		
	附加----使用过的指令:
		yum provide ls		//缺 所以安装 ls 工具
		yum install initscripts		//centos 没有 service 命令 只有 systemctl,如果要使用需要自己添加 
		yum install wget	//添加 wget
		vi /var/log/mysqld.log   或者  cat /var/log/mysqld.log      //查看 运行日志文件
		mysqld --initialize && mysqld install	// mysql 的初始化!! (pxc不建议使用!!)
	 	////  关闭,重装 再打开 pxc-node1/2/3/4/5 容器  ////
		sudo docker stop pxc-node1 && sudo docker rm pxc-node1 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.2 -itd --name=pxc-node1 centos /usr/sbin/init && sudo docker exec -it pxc-node1 bash

		sudo docker stop pxc-node2 && sudo docker rm pxc-node2 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.3 -itd --name=pxc-node2 centos /usr/sbin/init && sudo docker exec -it pxc-node2 bash

		sudo docker stop pxc-node3 && sudo docker rm pxc-node3 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.4 -itd --name=pxc-node3 centos /usr/sbin/init && sudo docker exec -it pxc-node3 bash

		sudo docker stop pxc-node4 && sudo docker rm pxc-node4 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.5 -itd --name=pxc-node4 centos /usr/sbin/init && sudo docker exec -it pxc-node4 bash

		sudo docker stop pxc-node5 && sudo docker rm pxc-node5 && sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.6 -itd --name=pxc-node5 centos /usr/sbin/init && sudo docker exec -it pxc-node5 bash
		
		yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm	///安装最新的pxc 官方源
		////// pxc 常用指令
		service mysql start to start this cluster’s node
		service mysql bootstrap-pxc to start this node as the first node of the cluster
		service mysql status to check the status of this cluster’s node
		service mysql stop to stop this cluster’s node
 		///// selinux 常用指令
		查看SELinux状态：1、
		/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态
			SELinux status:                 enabled
		getenforce                 ##也可以用这个命令检查
		关闭SELinux：
			临时关闭（不用重启机器）：
			setenforce 0                  ##设置SELinux 成为permissive模式
                        setenforce 1 			设置SELinux 成为enforcing模式
		修改配置文件需要重启机器：
			修改/etc/selinux/config 文件
			将SELINUX=enforcing改为SELINUX=disabled
			重启机器即可

建立在 pxc 集群之上的 分片集群!!! (即分布式集群)
实现 Mycat + pcx 的 分片集群
再建立一个 pxc 集群
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.12 -itd --name=pxc2-node1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.13 -itd --name=pxc2-node2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.14 -itd --name=pxc2-node3 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.15 -itd --name=pxc2-node4 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.16 -itd --name=pxc2-node5 centos /usr/sbin/init
		
		sudo docker exec -it pxc2-node1 /bin/bash 	//pxc2-node1/2/3/4/5
		//都按装 pxc57
		yum install http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm //安装源
		yum install Percona-XtraDB-Cluster-57 -y	//直接安装 pxc57
	所有机子的 /etc/my.cnf
	[client]
	default-character-set = utf8mb4
	[mysqld]
	user=mysql
	skip_ssl
	sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'
	slow_query_log=ON
	slow_query_log_file=/var/lib/mysql/mysql-slow.log
	general_log=ON
	general_log_file=/var/lib/mysql/log-mysql.log
	long_query_time = 1
	explicit_defaults_for_timestamp = 1
	innodb_buffer_pool_instances = 1		//教程说8 不合适,因为注意>1  表示缓存大于1G  ?? 不知道那看到的  
	innodb_buffer_pool_dump_at_shutdown = 1
	log_timestamps=system
	character-set-server = utf8mb4
	collation-server = utf8mb4_unicode_ci
	max_connections=10000

	然后 所有机子的 /etc/percona-xtradb-cluster.conf.d/wsrep.cnf 如下
	# Path to Galera library
	wsrep_provider=/usr/lib64/galera3/libgalera_smm.so		//不用改
	
	# Cluster connection URL contains IPs of nodes
	#If no IP is found, this implies that a new cluster needs to be created,
	#in order to do that you need to bootstrap this node
	wsrep_cluster_address=gcomm://172.22.0.12,172.22.0.13,172.22.0.14,172.22.0.15,172.22.0.16	//需要改
	
	# In order for Galera to work correctly binlog format should be ROW
	binlog_format=ROW						//wsrep已有,不用写上
	
	# MyISAM storage engine has only experimental support
	default_storage_engine=InnoDB					//wsrep已有,不用写上
	
	# Slave thread to use
	wsrep_slave_threads= 8						//wsrep已有,不用写上
	
	wsrep_log_conflicts						//wsrep已有,不用写上
	
	# This changes how InnoDB autoincrement locks are managed and is a requirement for Galera
	innodb_autoinc_lock_mode=2					//wsrep已有,不用写上
	
	# Node IP address
	wsrep_node_address=172.22.0.12/13/14/15/16				//每一台机子的 ip
	# Cluster name
	wsrep_cluster_name=pxc2-cluster					//第二个独立的 pxc 集群
	
	#If wsrep_node_name is not specified,  then system hostname will be used
	wsrep_node_name=pxc2-1/2/3/4/5					//每一台机子的名字 需要修改!!
	
	#pxc_strict_mode allowed values: DISABLED,PERMISSIVE,ENFORCING,MASTER
	pxc_strict_mode=DISABLED				//需要修改!!
	
	# SST method
	wsrep_sst_method=xtrabackup-v2
	
	#Authentication for SST method
	wsrep_sst_auth="pxc2_user:123456"			//需要修改!!

		然后 首次启动第一台机子 node1:
			systemctl start mysql@bootstrap.service
			grep 'temporary password' /var/log/mysqld.log	//获得暂时密码
			mysql -uroot -p		//登录 输入 暂时密码
			ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';  //修改root 密码
			CREATE USER 'pxc2_user'@'localhost' IDENTIFIED BY '123456';	//创建热备份账户!!
			GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456';	//提权!!!!
			GRANT ALL PRIVILEGES ON *.* TO 'pxc2_user'@'%' IDENTIFIED BY '123456';
			GRANT ALL PRIVILEGES ON *.* TO 'pxc2_user'@'localhost' IDENTIFIED BY '123456';
			至此 第一台机子就部署好了,
		然后第二台机子 node2:
			直接 systemctl start mysql 就好了, 机子会加入到集群里,如果加入集群失败,会直接初始化失败
			成功后 mysql -uroot -p  输入同步过来的密码 123456 就可以登录!!
			这里 添加的表单,数据, 直接就开始同步到 第一台机子了!!!,
			可以直接在第一机子登录查看
		然后的三四五台机子.
			跟第二台操作一样,  systemctl start mysql 便可自动加入集群!!
		然后数据库关闭操作:
			一般: 其他节点 systemctl stop mysql 直接关闭!!!
			      第一节点 最后,且 通过 systemctl stop mysql@bootstrap.service 关闭!!!!!
			重新启动的话, 第一节点 先打开systemctl start mysql@bootstrap.service 
				其他节点 陆续打开 systemctl start mysql
	最后,注意关机后若重新启动数据库, 需要查看上次关闭最后关闭的节点,所以要
	cat /var/lib/mysql/grastate.dat	1
	查看 safe_to_bootstrap: 1 则是最后关闭的节点,必须第一打开这个节点!! systemctl start mysql@bootstrap.service 
 	然后, 这个pxc2 集群和 之前的pxc集群 成功相互独立共存!!
	后面为 建立 mycat 分片集群准备!!

安装数据库可视化工具,辅助数据库搭建部署测试!!:
	MysqlWorkbench: https://blog.csdn.net/qq_34256348/article/details/78342897
	navicat: (未安装使用,不合适,只有win版本)
	
	由于 docker 把容器的 局域网映射出来了, 所以可以用 可视化工具假装链接远程数据库那样那样子查看操作节点所以的数据库


maycat 分片 集群 部署:
	再建立3个 mycat 节点
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.101 -itd --name=mycat-node1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.102 -itd --name=mycat-node2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.103 -itd --name=mycat-node3 centos /usr/sbin/init
	然后进入每个 节点 命令行窗口操作 !!!
	需要安装java
		登录官网:https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html
		下载最新的 jdk11 : jdk-11.0.2_linux-x64_bin.tar.gz  (手动安装的方法放弃,因为更需要麻烦的配置)
		yum 装 java
		先 java -version 查看已安装的,如果有安装的,如果版本太低就选择卸载:
		yum -y remove java-1.7.0-openjdk*  //卸载旧的 jdk
		yum -y list java*  //查看软件库的 java版本更新 情况
		yum -y install java-11-openjdk*	   //安装查看到的新的 jdk
	安装其他辅助工具:
		yum -y install tree
		yum -y install wget
		//还是缺乏一些常用的命令: ifconfig 等
		寻找 ifconfig 所在 软件包
			yum provides ifconfig			
			yum whatprovides ifconfig	//或者这条
		yum -y install net-tools	//安装
		寻找 netstat 所在 软件包
	安装mycat:
		安装包的位置: 	http://dl.mycat.io/
		获取,解压安装包
			cd /root
			wget http://dl.mycat.io/1.6.5/Mycat-server-1.6.5-release-20180122220033-linux.tar.gz
			tar -zxvf Mycat-server-1.6.5-release-20180122220033-linux.tar.gz
		环境变量添加 mycat 位置!!
			vi /etc/profile 添加:
			export MYCAT_HOME=/root/mycat
			使环境变量生效 source /etc/profile
		改变mycat用户和组
			groupadd mycat
			adduser -r -g mycat mycat
			chown -R mycat.mycat /root/mycat  //修改mycat目录所属mycat用户
		对以下三个重要配置文件备份!!
			cp /root/mycat/conf/schema.xml /root/mycat/conf/schema.xmlbackup
			cp /root/mycat/conf/rule.xml /root/mycat/conf/rule.xmlbackup
			cp /root/mycat/conf/server.xml /root/mycat/conf/server.xmlbackup
	测试mycat:(仅仅第一个mycat节点做的测试,熟悉上手mycat)
		修改 schema.xml !!! 使得只设置 一个 合法 的 datahoat  
			(注意,一个datahost 是一个存储集群,可以是一个pxc集群,然后只存储分片内容!!)
////////////////////////
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

        <schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
                <!-- auto sharding by id (long) -->
                <table name="travelrecord" dataNode="dn1,dn2,dn3" rule="auto-sharding-long" />

                <!-- global table is auto cloned to all defined data nodes ,so can join
                        with any table whose sharding node is in the same data node -->
                <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                <table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2" />

                <!-- random sharding using mod sharind rule -->
                <table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2,dn3"
                           rule="mod-long" />
                <table name="employee" primaryKey="ID" dataNode="dn1,dn2"
                           rule="sharding-by-intfile" />
                <table name="customer" primaryKey="ID" dataNode="dn1,dn2"
                           rule="sharding-by-intfile">
                        <childTable name="orders" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id">
                                <childTable name="order_items" joinKey="order_id"
                                                        parentKey="id" />
                        </childTable>
                        <childTable name="customer_addr" primaryKey="ID" joinKey="customer_id"
                                                parentKey="id" />
                </table>
        </schema>

        <dataNode name="dn1" dataHost="localhost1" database="db1" />
        <dataNode name="dn2" dataHost="localhost1" database="db2" />
        <dataNode name="dn3" dataHost="localhost1" database="db3" /> 

        <dataHost name="localhost1" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="hostM1" url="localhost:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="hostS2" url="localhost:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="hostS1" url="localhost:3316" user="root" password="123456" />
        </dataHost>

</mycat:schema>
////////////////////////
			简单分析下 mycat 登记了 TESTDB 这个数据库!
			这个也登记了在 mycat 之下的多个 tables 而这些表的数据都会参与分片操作!!
			比如: rule="auto-sharding-long" ,这时表的分片规则,这里每5000000条数据分到一个节点分片来存储
			dataNode="dn1,dn2,dn3" 表示登记的这个表有3个分片节点. 所以最多也只有 15000000 条,超出会出错.
			<dataNode name="dn1" dataHost="localhost1" database="db1" /> 描述一个分片节点的参数
				name="dn1" 分片节点的名字, 随便起
				dataHost="localhost1" 分片节点所在的物理服务器机集群名字,随便起
				database="db1" 分片节点所在的物理服务器机集群的真实数据库的真实名字db1,
				就是说 travelrecord数据表,应该属于TESTDB数据库的,
				但是实际是分开保存在 db1,db2,db3数据库里!! 
			关于 dataHost 物理服务器机集群 的定义!!
			maxCon="1000" minCon="10" 最多允许并发1000次连接,最小并发10次连接, balance暂时不清楚
			<writeHost host="hostM1" 定义的是第一组读写分离操作,
			<writeHost host="hostS1" 定义的是第二组读写分离操作,
				当中都包含登录实际数据库的帐号密码信息
			一般按默认来执行第一组读写分离操作 当服务器集群中相关节点出现故障时才转向其他组读写分离操作	
		启动mycat :  /root/mycat/bin/mycat start
			注意 实际数据库 db1,db2,db3 必须先建立好!!!!!! 不然在后面连接数据库的过程中会出错
			登录mycat 使用 mysql 命令, 意味着maycat节点还需要额外安装一个 mysql 数据库 
			当然,不安装数据库的可以使用其他安装了mysql数据库 节点来远程访问 这个 mycat!!
			登录 mycat :  mysql -uroot -p123456 -h127.0.0.1 -P8066
			或者 : mysql -uroot -p123456 -h127.0.0.1 -P8066
			注意: 登录 ip:8066 使用的root帐号, 与实际mysql的root 不是同一个帐号!!
				比如 mysql 帐号是 root:aaabbb, mycat帐号是:root:111222
				那么 mysql -uroot -paaabbb    登录mysql
				     mysql -uroot -p111222 -P8066 -h127.0.0.1 登录mycat
				     mysql -uroot -p111222    错误, 因为登录mysql 却用了mycat的帐号
				     mysql -uroot -paaabbb -P8066 -h127.0.0.1  错误, 因为登录mycat 却用了mysql的帐号
			这时进入的不是真正的 mysql ,而是虚拟的mysql 即mycat
			使用 原来的sql命令在这里操作,最终会被mycat 分配到真正的 mysql 数据库节点上!!
			例如上述 schema.xml 设置的 分片节点,设置到同 172.22.0.101 节点下的 mysql 数据库 的 db1,db2,db3数据库
			所以使用mycat前, 必须先在mysql建立好 数据库 db1,db2,db3
		测试:(再mycat输入 sql命令)
			CREATE TABLE travelrecord (
			  id BIGINT(20) NOT NULL,
			  title VARCHAR(100) NOT NULL,
			  PRIMARY KEY (id)
			) ENGINE=INNODB DEFAULT CHARSET=utf8
				//虽然在mycat 看到了TESTDB数据库 存在 travelrecord 表, 但是实体mysql数据库上并没有
				//所以,这条命令会 在 db1,db2,db3 实体数据库上 建立起 travelrecord 表
			插入数据:
			INSERT INTO travelrecord(ID,TITLE) VALUES(1,'goods1');
			INSERT INTO travelrecord(ID,TITLE) VALUES(2,'goods2'); 
			INSERT INTO travelrecord(ID,TITLE) VALUES(3,'goods3');
				//根据分片rule 这三条会存在 db1.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(5000001,'goods5000001');
				//根据分片rule 这一条会存在 db2.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(10000001,'goods10000001');
				//根据分片rule 这一条会存在 db3.travelrecord 里 
			INSERT INTO travelrecord(ID,TITLE) VALUES(15000001,'goods15000001');
				//根据分片rule,每个分片最多只有5000000条数据, 这一条会出错,因为没有 db4.travelrecord 来承载

	配置mycat节点1 与多个 pxc 集群的连接 !!!
		pxc 和 pxc2 集群 分别建立 shard1 shard2 数据库 作为两个即将被使用的节点!! 
		mycat节点1: 修改 schema.xml
///////////////
<?xml version="1.0"?>
<!DOCTYPE mycat:schema SYSTEM "schema.dtd">
<mycat:schema xmlns:mycat="http://io.mycat/">

        <schema name="WILLIAM" checkSQLschema="false" sqlMaxLimit="100">
                <!-- auto sharding by id (long) -->
                <table name="lover" dataNode="dn1,dn2" rule="auto-sharding-long" />
        </schema>

        <dataNode name="dn1" dataHost="pxc_1" database="shard1" />
        <dataNode name="dn2" dataHost="pxc_2" database="shard2" />

        <dataHost name="pxc_1" maxCon="1000" minCon="10" balance="2"
                          writeType="1" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="w1" url="172.22.0.2:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="r11" url="172.22.0.4:3306" user="root" password="123456" />
			<readHost host="r12" url="172.22.0.5:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="w2" url="172.22.0.3:3316" user="root" password="123456" >
                        <readHost host="r21" url="172.22.0.5:3306" user="root" password="123456" />
			<readHost host="r22" url="172.22.0.6:3306" user="root" password="123456" />
                </writeHost>
        </dataHost>

        <dataHost name="pxc_2" maxCon="1000" minCon="10" balance="2"
                          writeType="1" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <!-- can have multi write hosts -->
                <writeHost host="w1" url="172.22.0.12:3306" user="root" password="123456">
                        <!-- can have multi read hosts -->
                        <readHost host="r11" url="172.22.0.14:3306" user="root" password="123456" />
			<readHost host="r12" url="172.22.0.15:3306" user="root" password="123456" />
                </writeHost>
                <writeHost host="w2" url="172.22.0.13:3316" user="root" password="123456" >
                        <readHost host="r21" url="172.22.0.15:3306" user="root" password="123456" />
			<readHost host="r22" url="172.22.0.16:3306" user="root" password="123456" />
                </writeHost>
        </dataHost>

</mycat:schema>
///////////////
		然后 server.xml需要修改:
///////////////
        <user name="root" defaultAccount="true">
                <property name="password">123456</property>
                <property name="schemas">WILLIAM</property>		//改这里

                <!-- 表级 DML 权限设置 -->
                <!-- 
                <privileges check="false">
                        <schema name="TESTDB" dml="0110" >
                                <table name="tb01" dml="0000"></table>
                                <table name="tb02" dml="1111"></table>
                        </schema>
                </privileges>
                 -->
        </user>

        <user name="user">
                <property name="password">user</property>
                <property name="schemas">WILLIAM</property>		//改这里
                <property name="readOnly">true</property>
        </user>
///////////////
		然后启动发现失败:
		mycat console 看到了问题:
jvm 1    | Caused by: io.mycat.config.util.ConfigException: Illegal table conf : table [ LOVER ] rule function [ rang-long ] partition size : 3 > table datanode size : 2, please make sure table datanode size = function partition size
		就是说 rule="auto-sharding-long" 要求起码有3个节点,,但是,我们只建立了两个pxc集群,没有第三个集群承担第三个节点
		产看 rule.xml,最后 知道要修改 autopartition-long.txt,把第三节点屏蔽掉!
		然后重启 mycat 成功 !!!
		mycat节点1:执行:
			CREATE TABLE lover (
			  id BIGINT(20) NOT NULL,
			  title VARCHAR(100) NOT NULL,
			  PRIMARY KEY (id)
			) ENGINE=INNODB DEFAULT CHARSET=utf8
			INSERT INTO lover(ID,TITLE) VALUES(1,'misa_1');
			INSERT INTO lover(ID,TITLE) VALUES(2,'alita_2'); 
			INSERT INTO lover(ID,TITLE) VALUES(3,'cuter_3'); 
			INSERT INTO lover(ID,TITLE) VALUES(5000001,'marina_5000001'); 
			INSERT INTO lover(ID,TITLE) VALUES(5000002,'alsa_5000002');
		查看对应的 pxc集群 的数据情况!! 测试分片均衡成功
		
	mycat节点 集群预备:
		按照 配置mycat节点 与多个 pxc 集群的连接 
		重复配置 mycat 的节点2 节点3
		注意,这两个节点可以只安装了 jdk11 和 mycat, 不再需要安装 mysql,
		因为最终都是从远程登录 所有 mycat 节点的
		这些节点都可以 独立 访问 pxc集群,
		测试:
		mycat节点2:执行:
			INSERT INTO lover(ID,TITLE) VALUES(4,'luna_4');
		mycat节点3:执行:
			INSERT INTO lover(ID,TITLE) VALUES(5000003,'ayumi_5000003');
			查看pxc集群数据的存储情况
			都不需要再次执行 create lover 表的操作, 因为已经存在,这三个节点都指向操作同一个 WILLIAM 数据库
			而3者是相互独立的, 所以就进一步建立集群,可以实现数据访问流的分流减压
	mycat节点 安装使用 xinetd 网络微服务,方便 haproxy 节点 对 mycat服务状况监控
		yum -y install xinetd
		检查/etc/xinetd.conf的末尾是否有 includedir /etc/xinetd.d
			cat /etc/xinetd.conf
		检查是否有 /etc/xinetd.d 文件夹 : ls /etc/xinetd.d
		添加 mycat 状态检测服务: 
			vi /etc/xinetd.d/mycat_status  
//////////////////  
service mycat_status
{
        flags = REUSE
        socket_type = stream
        port = 48700
        wait = no
        user = root
        server = /usr/local/bin/mycat_status
        log_on_failure += USERID
        disable = no
}
//////////////////
			解释:
			        socket_type = stream 
					## 封包处理方式，Stream为TCP数据包
					## 使用该标记的socket_type为stream，需要设置wait为no
			        port = 48700 ## 服务监听端口 
			        wait = no ## 表示不需等待，即服务将以多线程的方式运行 
			        user = root ## 执行此服务进程的用户 
			        server = /usr/local/bin/mycat_status ## 需要启动的服务脚本 
			        log_on_failure += USERID ## 登录失败记录的内容 
			        disable = no ## 要启动服务，将此参数设置为no 
		添加 /usr/local/bin/mycat_status 服务脚本: vi /usr/local/bin/mycat_status
/////////////////
#!/bin/bash
#/usr/local/mycat/bin/mycat_status
# This script checks if a mycat server is healthy running on localhost. It will
# return:
#
# "HTTP/1.x 200 OK\r" (if mycat is running smoothly)
#
# "HTTP/1.x 503 Internal Server Error\r" (else)
mycat=`/root/mycat/bin/mycat status | grep 'not running' | wc -l`
if [ "$mycat" = "0" ];
then
/bin/echo -e "HTTP/1.1 200 OK\r\n"
else
/bin/echo -e "HTTP/1.1 503 Service Unavailable\r\n"
fi
/////////////////
		给脚本添加执行权限: chmod a+x /usr/local/bin/mycat_status
		/etc/services 中加入 mycat_status 服务: vi /etc/services 添加
			mycat_status    48700/tcp               # mycat_status
		重启 xinetd: systemctl restart xinetd
		验证mycat_status服务是否成功启动: netstat -antup|grep 48700
		脚本测试,直接输入命令: /usr/local/bin/mycat_status 		
	
	创建节点 安装 HAProxy
		添加两个 节点 为haproxy 服务 
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.111 -itd --name=hapro1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=pxc-net --ip=172.22.0.112 -itd --name=hapro2 centos /usr/sbin/init
		进入节点 使用 yum 安装 haproxy 参考: 
			https://blog.csdn.net/aboutmn/article/details/87180266 //这里是haproxy1.8
			https://blog.csdn.net/weixin_42859280/article/details/83796029 //这里是centos7自带的haproxy1.5
		使用通用的	haproxy1.5 就好了
		yum list |grep haproxy
			haproxy.x86_64                            1.5.18-8.el7                   base   
			pcp-pmda-haproxy.x86_64                   4.1.0-5.el7_6                  updates
		yum -y install haproxy
	测试 haproxy 建立 mycat集群: 
		由于使用 电脑资源不够, 直接配置 haproxy + mycat + pxc 会容易崩溃!!所以简化操作!!
		mycat不接 pxc 集群 ,相对地都接到 172.22.0.101 的mysql 的db1 db2 两个分片数据库,简单模拟分片均衡
		配置 haproxy: vi /etc/haproxy/haproxy.cfg
		添加三组配置,和其他信息
/////////////  注意,写到文件时,不要 把 ## 标注的注释也写上
## golbal下添加节点信息
    node        hap_node1
    description haproxy_node1_for_mycat_clusters


listen admin_status
    bind :48800  ## 只绑端口
    stats uri /admin_status ##统计页面
    stats auth admin:admin ## 设置统计页面认证的用户和密码 
    mode http
    option httplog ## 启用日志记录HTTP请求

listen mycat_servers
    bind :3307	
    mode tcp
    option tcplog  ## 记录TCP请求日志
    option tcpka ## 是否允许向server和client发送keepalive
    option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测
    balance roundrobin ## 定义负载均衡算法，可用于"defaults"、"listen"和"backend"中,默认为轮询方式
    server mycat_01 172.22.0.101:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_02 172.22.0.102:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_03 172.22.0.103:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    timeout server 20000

listen mycat_admin
    bind :3308	
    mode tcp
    option tcplog  ## 记录TCP请求日志
    option tcpka ## 是否允许向server和client发送keepalive
    option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测
    balance roundrobin ## 定义负载均衡算法，可用于"defaults"、"listen"和"backend"中,默认为轮询方式
    server mycat_01 172.22.0.101:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_02 172.22.0.102:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    server mycat_03 172.22.0.103:9066 check port 48700 inter 2000ms rise 2 fall 3 weight 10
    timeout server 20000
/////////////
		根据/etc/haproxy/haproxy.cfg 配置:
		添加haproxy用户组和用户	(yum按装后似乎可以跳过这步)
			groupadd haproxy
			useradd -g haproxy haproxy
		创建chroot运行的路径	(yum按装后似乎可以跳过这步)
			mkdir /var/lib/haproxy
		启动 haproxy
			systemctl start haproxy
		测试,
			mysql -uroot -p123456 -h172.22.0.111 -P3307
			插入一条数据:
				use WILLIAM; 
				INSERT INTO lover(ID,TITLE) VALUES(5000003,'fiya_5000003');
			( 注意使用命令行的 mysql端,不要使用 mysql workbench ,发现
			  mysql workbench 除了 直接连mysql外 链接到mysql中间件都不稳定!! )
			然后自己浏览器输入 http://172.22.0.111:48800/admin_status
			可以查看到 haproxy 的状态信息!!
			分析一个流程:
				当 mysql -uroot -p123456 -h172.22.0.111 -P3307
				haproxy 会选出一个 mycat节点 连接,然后 haproxy也建立起这次连接对话 session,并维持
				然后 我们接下来的
					use WILLIAM; 
					INSERT INTO lover(ID,TITLE) VALUES(5000003,'fiya_5000003');
				都算入到这次对话的数据传输内容!!
				然而当我们一段时间步操作, 然后再操作时,比如 select * from lover
				ERROR 2013 (HY000): Lost connection to MySQL server during query
				随表示出错,其实就是 haproxy 维护的这次对话表示已经超时,所以就断开了!!!
				当我们再 select * from lover, haproxy会重新建立起新的对话, 选择新的 mycat节点成功继续操作!!!
				关于超时问题, 还是因为不太熟悉设置 haproxy 的超时机制!!!
		继续配置haproxy节点2
			跟 haproxy节点1 同理配置, 只是 haproxy.cfg golbal的 node description 信息设置成节点2的!!		
			    node        hap_node2
			    description haproxy_node2_for_mycat_clusters
		这下子其实 haproxy 节点1 节点2 都分别独立实现了 对 mycat的集群了!!
	接下来,加入keepalived, 实现 haproxy 的双机热备!!
		再 haproxy 节点上 直接yum安装(centos7 自带 1.3.5,版本) :yum -y install keepalived
		先备份 keepalived 配置文件: cp /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.confbackup
			因为值得后面参考学习!!
		配置 keepalived : vi /etc/keepalived/keepalived.conf
			参考:https://blog.csdn.net/l1028386804/article/details/76397064	
//////////////////// haproxy节点1的
! Configuration File for keepalived

global_defs {
   router_id khnode_in111
}

vrrp_script chk_haproxy {
	script "/etc/keepalived/haproxy_check.sh"
	interval 2
	weight 2
}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 120
    nopreempt
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        chk_haproxy
    }
    virtual_ipaddress {
        172.22.0.120
    }
}
////////////////////

//////////////////// haproxy节点2的
! Configuration File for keepalived

global_defs {
   router_id khnode_in112
}

vrrp_script chk_haproxy {
	script "/etc/keepalived/haproxy_check.sh"
	interval 2
	weight 2
}

vrrp_instance VI_1 {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 110
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    track_script {
        chk_haproxy
    }
    virtual_ipaddress {
        172.22.0.120
    }
}

////////////////////
		添加对应的 检查脚本: 
			mkdir -p /usr/local/keepalived/log
			vi /etc/keepalived/haproxy_check.sh
///////////////////
#!/bin/bash
START_HAPROXY="systemctl start haproxy"
STOP_HAPROXY="systemctl stop haproxy"
LOG_FILE="/usr/local/keepalived/log/haproxy-check.log"
HAPS=`ps -C haproxy --no-header |wc -l`

date "+%Y-%m-%d %H:%M:%S" >> $LOG_FILE
echo "check haproxy status" >> $LOG_FILE
if [ $HAPS -eq 0 ];then
    echo $START_HAPROXY >> $LOG_FILE
    $START_HAPROXY >> $LOG_FILE 2>&1
    sleep 3 
    if [ `ps -C haproxy --no-header |wc -l` -eq 0 ];then
        echo "start haproxy failed, killall keepalived" >> $LOG_FILE
        killall keepalived 
    fi 
fi
///////////////////
		给脚本赋执行权限： chmod +x /etc/keepalived/haproxy_check.sh
		打开 keepalived: systemctl start keepalived
		然而并没有启动成功 : 查看安装配置 cat /etc/sysconfig/keepalived 找出记录日志地方,寻问题!!
		后来发现,服务器启动死在 keepalived -D 这一步上,似乎需要补上 rsyslog 日志系统才能正常工作
		当然,直接跳过 直接使用 keepalived -P 也可以得到我们期望 成功启动 的结果
			不过就要 透过 kill -9 xxx 来 关闭!!!
		补全日志系统 rsyslog:
			yum install -y rsyslog
		然后直接 systemctl start rsyslog 
		然后重新启动 keepalived : systemctl start keepalived //还是启动失败,
		这时 tail -f /var/log/messages 便可以看到 keepalived 启动错误的日志信息 
			Feb 16 12:30:08 3daaa8cfd4f7 Keepalived_healthcheckers[4667]: IPVS: Can't initialize ipvs: Protocol not available
			Feb 16 12:30:08 3daaa8cfd4f7 Keepalived_healthcheckers[4667]: Stopped
		这涉及到kernel内核级别的ipvs 模块!!!!
		解决办法: (参考:http://www.mamicode.com/info-detail-2128337.html) 
			宿主机安装 sudo apt-get install ipvsadm
		然后 宿主机执行 ipvsadm 
			IP Virtual Server version 1.2.1 (size=4096)
			Prot LocalAddress:Port Scheduler Flags
			  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
		然后宿主机检查: lsmod | grep ip_vs                        
			ip_vs                 151552  0
			nf_conntrack          131072  9 	xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ipv4,nf_nat,ipt_MASQUERADE,nf_nat_ipv4,xt_nat,nf_conntrack_netlink,ip_vs
			libcrc32c              16384  3 nf_conntrack,nf_nat,ip_vs
			表示已经正常启动 ip_vs 模块了
		然后 keepalived 常规启动 systemctl start keepalived 便不再出错了!!!
	关于keepalived + haproxy + mycat + pxc 的方案就先不继续下去了,因为机子貌似撑不起
		现在是  keepalived + haproxy + mycat + mysql 方案, 只是末端的数据库是 mysql 而不是pxc集群!!
		有机会再完整实现 keepalived + haproxy + mycat + pxc 方案
		整个集群框架理应改应该是这样子的: (keepalived + haproxy + mycat + pxc)
						      

                                       keepalived make a VIP as enter IP							
                                      -----------(172.22.0.120)----------
                                      |                                 |
                              ----------------                    ----------------         
                              | keepalived1  |   <------------>   | keepalived2  |
                              | haproxy1     |                    | haproxy2     |
                              | 172.22.0.111 |                    | 172.22.0.112 |
                              | p:3307->8066 |                    | p:3307->8066 |
                              | p:3308->9066 |                    | p:3308->9066 |
                              ----------------                    ----------------
                                 /       \   \                     /    /    \
                                /         \   \                   /    /      \
                  ----------------              ----------------             ----------------
                  | mycat1       |              | mycat2       |             | mycat3       |
                  | 172.22.0.101 |              | 172.22.0.102 |             | 172.22.0.103 |
		  |p:8066        |              |p:8066        |             |p:8066        |
                  | for databases|              | for databases|             | for databases|
                  |p:9066        |              |p:9066        |             |p:9066        |
                  | manage mycat |              | manage mycat |             | manage mycat |
                  ----------------              ----------------             ----------------
                          /      \                   /    \                   /       \
                         /                          /      \                           \
  -----------------------------------------------------   -----------------------------------------------------
  |                  pxc  as  shard1                  |   |                 pxc2  as  shard2                  |
  |                                                   |   |                                                   |
  |       ----------------     ----------------       |   |       ----------------     ----------------       |
  |       |  pxc-node1   |     |  pxc-node2   |       |   |       |  pxc2-node1  |     |  pxc2-node2  |       | 
  |       |  172.22.0.2  |     |  172.22.0.3  |       |   |       | 172.22.0.12  |     | 172.22.0.13  |       |
  |       | write1_node  |     | write2_node  |       |   |       | write1_node  |     | write2_node  |       |
  |       | p:3306       |     | p:3306       |       |   |       | p:3306       |     | p:3306       |       |
  |       ----------------     ----------------       |   |       ----------------     ----------------       |
  |          /         \         /          \         |   |          /         \         /          \         |
  | ---------------  ---------------  --------------- |   | ---------------  ---------------  --------------- |
  | | pxc-node3   |  | pxc-node4   |  | pxc-node5   | |   | | pxc2-node3  |  | pxc2-node4  |  | pxc2-node5  | |
  | | 172.22.0.4  |  | 172.22.0.5  |  | 172.22.0.6  | |   | | 172.22.0.14 |  | 172.22.0.15 |  | 172.22.0.16 | |
  | | read1_node1 |  | read1_node2 |  | read2_node2 | |   | | read1_node1 |  | read1_node2 |  | read2_node2 | |
  | | p:3306      |  | read2_node1 |  | p:3306      | |   | | p:3306      |  | read2_node1 |  | p:3306      | |
  | |             |  | p:3306      |  |             | |   | |             |  | p:3306      |  |             | |
  | ---------------  ---------------  --------------- |   | ---------------  ---------------  --------------- |
  -----------------------------------------------------   -----------------------------------------------------
	参考:
		mycat安装参考: https://blog.csdn.net/promise2017/article/details/79326535
			      https://www.cnblogs.com/linjiqin/p/7879903.html
		mycat实现mysql分片集群:https://www.uol123.com/2018/01/16/mycat-mysql.html
				      https://blog.csdn.net/weixin_42582592/article/details/82919039
		mycat+pxc分片集群参考: https://www.cnblogs.com/reblue520/p/10338496.html
		HAProxy实现 mycat集群: https://blog.csdn.net/l1028386804/article/details/75331934
				       https://blog.csdn.net/u012758088/article/details/78654628
		keepalived + haproxy + mycat + pxc : https://blog.csdn.net/l1028386804/article/details/76397064
					https://blog.csdn.net/qq_36586867/article/details/81508032
			这种集群方案针对的是 短连接方案,恰恰访问数据库的确算短连接!!
			如果是关于 维护长连接(长时间),考虑使用 zookeeper 而不是 keepalived

		Mycat配置文件schema.xml: https://blog.csdn.net/l1028386804/article/details/53385637
		mycat配置简单介绍 : http://www.cnblogs.com/wang-meng/p/5861301.html
		mycat自身集群使用 HAProxy : https://blog.csdn.net/l1028386804/article/details/75331934
		mycat1.6.5 问题排错参考(我安装的是这个): https://rorschachchan.github.io/2018/07/05/Mycat%E7%9A%84%E9%83%A8%E7%BD%B2%E4%B8%8E%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/
		mycat管理端口9066: https://blog.csdn.net/zhouchang3/article/details/54382550
		mycat连接管理数据库，操作表时报ERROR 3009 (HY000): java.lang.IllegalArgumentException: Invalid DataSource:0
			https://blog.csdn.net/jaryle/article/details/76830202
		haproxy 超时机制: https://blog.csdn.net/zhaoyangjian724/article/details/51145045 
附加:
vi 常用命令:
	全选:	 	ggvG或者ggVG
	全部复制:	ggyG
	全部删除:	ggvGd
	显示行号:	:set number
	跳到第一行:      按两次“g”
	跳到最后一行：	按“G”,即“shift+g”

最后: 启动 pxc 注意 注意先找到第一节点启动 !!!!!














20190201

	Hadoop spark
	分布式计算

	docker:
		不需要他深入,上述已经够用
	mangoDB:
		https://www.cnblogs.com/nulige/p/7613721.html		//副本集 和 sharding cluster 两种集群

	压力测试:
		https://blog.csdn.net/a13124837937/article/details/79628838    /// jmeter
		https://www.cnblogs.com/kazihuo/p/7986681.html  ///压力测试 Nxginl 例子
	HAProxy:
		上述pxc集群已经足够理解了!!
		
	Nginx:



centos7 mongoDB4 sahrding cluster集群
	就是 外围客户 通过 路由器集任意一个节点, 访问 config 集群,获得数据的位置信息,然后访问 shard 集群 获得数据信息
	停止所有容器:
		sudo docker stop $(sudo docker ps -a -q) //  stop停止所有容器
		sudo docker restart $(sudo docker ps -a -q) //  restart所有容器,但是是逐个restart,,, 不是全关再全开
		sudo docker rm $(sudo docker ps -a -q) //补充   remove删除所有容器
	先建立新局域网络!!!
		sudo docker network create mongodb-net --subnet=172.23.0.0/16 --ip-range=172.23.0.0/16 --gateway=172.23.0.1
	网络查看: sudo docker network inspect pxc-net
	新建启动5个容器点 指定 pxc-net网络里的静态IP
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.2 -itd --name=mgdb-shd11 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.3 -itd --name=mgdb-shd12 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.4 -itd --name=mgdb-shd13 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.5 -itd --name=mgdb-shd21 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.6 -itd --name=mgdb-shd22 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.7 -itd --name=mgdb-shd23 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.8 -itd --name=mgdb-shd31 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.9 -itd --name=mgdb-shd32 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.10 -itd --name=mgdb-shd33 centos /usr/sbin/init

		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.11 -itd --name=mgdb-cofg1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.12 -itd --name=mgdb-cofg2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.13 -itd --name=mgdb-cofg3 centos /usr/sbin/init

		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.14 -itd --name=mgdb-mogs1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.15 -itd --name=mgdb-mogs2 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=mongodb-net --ip=172.23.0.16 -itd --name=mgdb-mogs3 centos /usr/sbin/init
		(由于 docker 使用 centos建立的容器 执行 systemctl 会出错：Failed to get D-Bus connection: Operation not permitted
		所以 docker run 的时候 加上 --privileged=true /usr/sbin/init)
		附加,开启所有 节点:
			sudo docker start mgdb-shd11 mgdb-shd12 mgdb-shd13 mgdb-shd21 mgdb-shd22 mgdb-shd23 mgdb-shd31 mgdb-shd32 mgdb-shd33 mgdb-cofg1 mgdb-cofg2 mgdb-cofg3 mgdb-mogs1 mgdb-mogs2 mgdb-mogs3
	容器内查看centos 版本信息
		cat /etc/redhat-release
		CentOS Linux release 7.6.1810 (Core)		      
	每个 centos7 节点都先 yum 安装 mongodb4:
		参考: https://blog.csdn.net/bigtree_3721/article/details/82768056
	vi /etc/yum.repos.d/mongodb-org-4.0.repo	//添加:
		[mongodb-org-4.0]
		name=MongoDB Repository
		baseurl=https://repo.mongodb.org/yum/redhat/7Server/mongodb-org/4.0/x86_64/
		gpgcheck=1
		enabled=1
		gpgkey=https://www.mongodb.org/static/pgp/server-4.0.asc
	yum makecache 
	yum install -y mongodb-org	//安装 mongodb
	rpm -ql mongodb-org-server	//查看安装的路径!!
		/etc/mongod.conf
		/lib/systemd/system/mongod.service
		/usr/bin/mongod
		/usr/share/doc/mongodb-org-server-4.0.5
		/usr/share/doc/mongodb-org-server-4.0.5/LICENSE-Community.txt
		/usr/share/doc/mongodb-org-server-4.0.5/MPL-2
		/usr/share/doc/mongodb-org-server-4.0.5/README
		/usr/share/doc/mongodb-org-server-4.0.5/THIRD-PARTY-NOTICES
		/usr/share/man/man1/mongod.1
		/var/lib/mongo
		/var/log/mongodb
		/var/log/mongodb/mongod.log
		/var/run/mongodb
	其他:
		8.MongoDB操作：
		8.1关闭、启动、重启MongoDB
		# service mongod restart
		Redirecting to /bin/systemctl restart mongod.service
		8.2 设置开启启动：
		# service mongod restart
		Redirecting to /bin/systemctl restart mongod.service
		9.删除mongoDB：
		#sudo service mongod stop
		#sudo yum erase $(rpm -qa | grep mongodb-org)
		#sudo rm -r /var/log/mongodb
		#sudo rm -r /var/lib/mongo
	开始集群配置: 参考:
		https://www.cnblogs.com/hehexiaoxia/p/6061043.html
		http://www.lanceyan.com/tech/arch/mongodb_shard1.html
		http://feed.askmaclean.com/archives/mongdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html
	分片集群组合:
		mongs : 172.23.0.14:20000, 172.23.0.15:20000, 172.23.0.16:20000
		cnfig : 172.23.0.11:20000, 172.23.0.12:20000, 172.23.0.13:20000
		shrd1 : 172.23.0.2:20000, 172.23.0.3:20000, 172.23.0.4:20000
		shrd2 : 172.23.0.5:20000, 172.23.0.6:20000, 172.23.0.7:20000
		shrd3 : 172.23.0.8:20000, 172.23.0.9:20000, 172.23.0.10:20000
	shard1 节点 都这样 启动节点服务!!!
		mkdir -p /data/shard1/data
		mkdir -p /data/shard1/log
		/usr/bin/mongod --shardsvr --replSet shard1 --port 20000 --dbpath /data/shard1/data  --logpath /data/shard1/log/shard1.log  --oplogSize 10 --fork --bind_ip_all
			--shardsvr 指定作为  分片集群的节点
			--replSet  指定集群名字
			--port     端口是 20000
			--dbpath   数据放置路径
			--logpath  记录日志位置
			--oplogSize 把整体缓存设置变小, 因为只是测试,没有必要用大缓存
			--fork     以新的进程运作
			必须加上--bind_ip_all 不然其他节点不能访问,经踩坑,发现 不加, mongo服务不能 通过 ip 地址登录,只能本地登录
			即, 不能 mongo 172.23.0.xx:20000 登录,只能 mongo 127.0.0.1:20000登录	
	shard2 节点 启动节点服务
		mkdir -p /data/shard2/data
		mkdir -p /data/shard2/log
		/usr/bin/mongod --shardsvr --replSet shard2 --port 20000 --dbpath /data/shard2/data  --logpath /data/shard2/log/shard2.log  --oplogSize 10 --fork --bind_ip_all	
	shard3 节点 启动节点服务
		mkdir -p /data/shard3/data
		mkdir -p /data/shard3/log
		/usr/bin/mongod --shardsvr --replSet shard3 --port 20000 --dbpath /data/shard3/data  --logpath /data/shard3/log/shard3.log  --oplogSize 10 --fork --bind_ip_all
	config 节点 启动节点服务
		mkdir -p /data/config/data
		mkdir -p /data/config/log
		/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork --bind_ip_all
			--configsvr 指定作为  config集群的节点
 	然后开始配置 shard 和 config 集群 !!
	选择 config 集群的 其中一个节点执行配置即可,配置自动贯穿整个集群:
	比如 cofg1 节点,登录 cofg1 节点再登录 172.23.0.11:20000 mongo命令端
	当然从其他 容器节点 登录 172.23.0.11:20000 mongo命令端 也是可以的, 172.23.0.11:20000,
		mongo 172.23.0.11:20000
		> use admin
		switched to db admin
		> config = { _id:"cfgReplSet", configsvr:true, members:[
		... {_id:0,host:"172.23.0.11:20000"},
		... {_id:1,host:"172.23.0.12:20000"},
		... {_id:2,host:"172.23.0.13:20000"}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
			.....
		}

		配置插曲: (出错,无法 连接  172.23.0.13:20000  等等!!)
		> rs.initiate(config);		
		{
		        "operationTime" : Timestamp(0, 0),
		        "ok" : 0,
		        "errmsg" : "replSetInitiate quorum check failed because not all proposed set members responded affirmatively: 172.23.0.12:20000 failed with Error connecting to 172.23.0.12:20000 :: caused by :: Connection refused, 172.23.0.13:20000 failed with Error connecting to 172.23.0.13:20000 :: caused by :: Connection refused",
		        "code" : 74,
		        "codeName" : "NodeNotFound",
		        "$gleStats" : {
		                "lastOpTime" : Timestamp(0, 0),
		                "electionId" : ObjectId("000000000000000000000000")
		        },
		        "lastCommittedOpTime" : Timestamp(0, 0),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(0, 0),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		查看log 发现!!!!!!
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] ** WARNING: This server is bound to localhost.
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          Remote systems will be unable to connect to this server.
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          Start the server with --bind_ip <address> to specify	which IP
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          addresses it should serve responses from, or with --bind_ip_all to
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          bind to all interfaces. If this behavior is desired, start the
		2019-02-04T15:23:37.982+0000 I CONTROL  [initandlisten] **          server with --bind_ip 127.0.0.1 to disable this warning.

		/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork 
		不够,需要添加 --bind_ip_all (就是这里发现需要补上 --bind_ip_all 的 坑)
		所有节点服务重新加上这个启动!!
		然后重新设置 成功
		
	shard1集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样 添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd11 节点配置:
		mongo 172.23.0.2:20000
		> use admin
		switched to db admin
		> config = { _id:"shard1", members:[
		... {_id:0,host:"172.23.0.2:20000"},
		... {_id:1,host:"172.23.0.3:20000"},
		... {_id:2,host:"172.23.0.4:20000",arbiterOnly:true}
		... ]}
			//arbiter 是仲裁的意思,这里的分片集群使用 副本集 的方式
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549301987, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549301987, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard1:SECONDARY>
		配置插曲:
		配置错{_id:2,host:"172.23.0.4:20000"},应该是 {_id:2,host:"172.23.0.4:20000",arbiterOnly:true}才对,
		需要重新配置,通过指令重新配置  Replica set 相当麻烦, 
		还不如节点重新处理安装mongo 服务 !!,然后重新 rs.initiate()

	shard2集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd21 节点配置:
		mongo 172.23.0.5:20000
		> use admin
		switched to db admin
		> config = { _id:"shard2", members:[
		... {_id:0,host:"172.23.0.5:20000"},
		... {_id:1,host:"172.23.0.6:20000"},
		... {_id:2,host:"172.23.0.7:20000",arbiterOnly:true}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549299260, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549299260, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard2:SECONDARY>	
	shard3集群,其中一个节点执行配置即可,配置自动贯穿整个集群 同样添加 --bind_ip_all 重新启动服务!!
		在 mgdb-shd31 节点配置:
		mongo 172.23.0.8:20000
		> use admin
		switched to db admin
		> config = { _id:"shard3", members:[
		... {_id:0,host:"172.23.0.8:20000"},
		... {_id:1,host:"172.23.0.9:20000"},
		... {_id:2,host:"172.23.0.10:20000",arbiterOnly:true}
		... ]}
		> rs.initiate(config);
		{
		        "ok" : 1,
		        "operationTime" : Timestamp(1549302444, 1),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549302444, 1),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		shard3:SECONDARY> 

	然后 开始 创建和匹配 mongos 节点 (路由器节点)
	mongos 所有节点 启动节点服务
		mkdir -p /data/mongos/data
		mkdir -p /data/mongos/log
		/usr/bin/mongos --configdb cfgReplSet/172.23.0.11:20000,172.23.0.12:20000,172.23.0.13:20000 --port 20000  --logpath /data/mongos/log/mongos.log --fork --bind_ip_all
	这时 shard1/2/3  副本集方式做好集群, config 以主从方式也做了集群!! mongs 都各自地挂上了 config集群		
	mongos 之间不分主从,各自独立工作,就是像是并联的节点,充当路由作用
	这时配置路由器,添加分片配置,其实就是 链接 config集群 和 shard1/2/3 集群,实现分片集群
	选择其中一个mongos节点 配置即可,配置自动贯穿整个集群
		mongo 172.23.0.14:20000
		mong0s> use admin
		mong0s> sh.addShard("shard1/172.23.0.2:20000,172.23.0.3:20000,172.23.0.4:20000");
		mong0s> sh.addShard("shard2/172.23.0.5:20000,172.23.0.6:20000,172.23.0.7:20000");
		mong0s> sh.addShard("shard3/172.23.0.8:20000,172.23.0.9:20000,172.23.0.10:20000");
		mong0s> sh.status();	//查看mongs 的状态
		--- Sharding Status --- 
		  sharding version: {
		        "_id" : 1,
		        "minCompatibleVersion" : 5,
		        "currentVersion" : 6,
		        "clusterId" : ObjectId("5c586218e6d1cfea52eda72a")
		  }
		  shards:
		        {  "_id" : "shard1",  "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",  "state" : 1 }
		        {  "_id" : "shard2",  "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",  "state" : 1 }
		        {  "_id" : "shard3",  "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",  "state" : 1 }
		  active mongoses:
		        "4.0.5" : 3
		  autosplit:
		        Currently enabled: yes
		  balancer:
		        Currently enabled:  yes
		        Currently running:  no
		        Failed balancer rounds in last 5 attempts:  0
		        Migration Results for the last 24 hours: 
		                No recent migrations
		  databases:
		        {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
		                config.system.sessions
		                        shard key: { "_id" : 1 }
		                        unique: false
		                        balancing: true
		                        chunks:
		                                shard1  1
		                        { "_id" : { "$minKey" : 1 } } -->> { "_id" : { "$maxKey" : 1 } } on : shard1 Timestamp(1, 0) 
		mong0s> db.runCommand({listShards:1});	//检查，显示shard配置：
		{
		        "shards" : [
		                {
		                        "_id" : "shard1",
		                        "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",
		                        "state" : 1
		                },
		                {
		                        "_id" : "shard2",
		                        "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",
		                        "state" : 1
		                },
		                {
		                        "_id" : "shard3",
		                        "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",
		                        "state" : 1
		                }
		        ],
		        "ok" : 1,
		        "operationTime" : Timestamp(1549381266, 2),
		        "$clusterTime" : {
		                "clusterTime" : Timestamp(1549381266, 2),
		                "signature" : {
		                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
		                        "keyId" : NumberLong(0)
		                }
		        }
		}
		登出 172.23.0.14 mongos容器节点, 然后登入172.23.0.15 mongos容器节点, 然后登录172.23.0.15 的命令界面
		mongos> sh.status();	//查看mongs 的状态
		mongos> db.runCommand({listShards:1});	//检查，显示shard配置：
		发现 其实  172.23.0.15 的 mongs节点也关联上, 也就说 一个mongos节点 添加分片配置后,所有mongos节点都好了!!
		实质是透过, mongos 配置了 config 节点集群的shard1/2/3数据分片信息,而不是配置 mongos 节点本身!!!!!
	至此所有配置 完毕!!!
	数据库可实现 分片集群!!
	实现开机自启动:(集群的节点在这已经配置好了,以后集群节点直接打开后,集群数据库就可以直接工作)
	首先 centos7 支持两种 自启动方式:
		systemctl 和 chkconfig
	参考:
		https://blog.csdn.net/lfgxiaogang/article/details/78924308	//cent7,systemctl方式自启动!!	
		https://www.cnblogs.com/dongling/p/6232730.html		// chkconfig 开机启动!!
		https://www.cnblogs.com/niocai/archive/2012/07/12/2587780.html // chkconfig 开机启动追加问题
	yum 安装 mongodb 时候,都默认设置了 systemctl的自启动,所以要所有节点都要先关闭!!
		systemctl disable mongod.service 
	然后,我选择并开始使用  chkconfig 实现自定义的开机自启动
	shard1 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard1	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard1 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard1 --port 20000 --dbpath /data/shard1/data  --logpath /data/shard1/log/shard1.log  --oplogSize 10 --fork --bind_ip_all
		
		chown root.root /etc/rc.d/init.d/mongod_shard1 && chmod 755 /etc/rc.d/init.d/mongod_shard1 && chkconfig --add mongod_shard1 && chkconfig --levels 245 mongod_shard1 off
		插曲:附加笔记:
		# chkconfig: 2345 90 10   中:
			其中2345是默认启动级别，级别有0-6共7个级别。
				等级0表示：表示关机 　　
				等级1表示：单用户模式 　　
				等级2表示：无网络连接的多用户命令行模式 　　
				等级3表示：有网络连接的多用户命令行模式 　　
				等级4表示：不可用 　　
				等级5表示：带图形界面的多用户模式 　　
				等级6表示：重新启动
			90指启动优先级别 级别分0-100,数字越大,优先级别越低
			10指关闭优先级别 级别分0-100,数字越大,优先级别越低
		# description:    就是随意的自己写的描述信息!!
			如果出现 service myservice does not support chkconfig 的错误
			是因为脚本文件没有 # chkconfig和 # description 这些项
		chown root.root /etc/rc.d/init.d/mongod_shard1		//改变权限
		chmod 755 /etc/rc.d/init.d/mongod_shard1		//所有用户都可以执行，单只有root可以修改
		chkconfig --add mongod_shard1				//将mysqld 放入linux启动管理体系中
		chkconfig --list mongod_shard1				//查看全部服务在各运行级状态
		chkconfig --levels 245 mongod_shard1 off		//只要运行级别3启动，其他都关闭,并不改变 mongod_shard1内容!!
	shard2 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard2	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard2 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard2 --port 20000 --dbpath /data/shard2/data  --logpath /data/shard2/log/shard2.log  --oplogSize 10 --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_shard2 && chmod 755 /etc/rc.d/init.d/mongod_shard2 && chkconfig --add mongod_shard2 && chkconfig --levels 245 mongod_shard2 off
	shard3 集群的节点:
		vi /etc/rc.d/init.d/mongod_shard3	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_shard3 node1/2/3 start on 
			/usr/bin/mongod --shardsvr --replSet shard3 --port 20000 --dbpath /data/shard3/data  --logpath /data/shard3/log/shard3.log  --oplogSize 10 --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_shard3 && chmod 755 /etc/rc.d/init.d/mongod_shard3 && chkconfig --add mongod_shard3 && chkconfig --levels 245 mongod_shard3 off
	config集群的节点:
		vi /etc/rc.d/init.d/mongod_cofg	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_confg node1 start on 
			/usr/bin/mongod --configsvr --replSet cfgReplSet --dbpath /data/config/data --port 20000 --logpath /data/config/log/config.log --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_cofg && chmod 755 /etc/rc.d/init.d/mongod_cofg && chkconfig --add mongod_cofg && chkconfig --levels 245 mongod_cofg off
	mongos 集群的节点:
		vi /etc/rc.d/init.d/mongod_mogs	//添加
			#!/bin/bash
			# chkconfig: 2345 90 10 
			# description: mongodb_confg node1/2/3 start on 
			/usr/bin/mongos --configdb cfgReplSet/172.23.0.11:20000,172.23.0.12:20000,172.23.0.13:20000 --port 20000  --logpath /data/mongos/log/mongos.log --fork --bind_ip_all

		chown root.root /etc/rc.d/init.d/mongod_mogs && chmod 755 /etc/rc.d/init.d/mongod_mogs && chkconfig --add mongod_mogs && chkconfig --levels 245 mongod_mogs off

	至此,自启动的配置也做好了,
	最后便是读写测试:
	mongo 数据库基本操作:
		==> 数据操作：
			插入数据：db.collection.insert
			查询数据：db.collection.find()
			更新数据：db.collection.update()
			删除数据：db.collection.remove()
		==> collection操作：
			新建collection：
			sh.shardCollection("xxx.yyy",{col1: 1, col2: 1})
			删除collection：
			db.yyy.drop()
		==> db操作：
			新建db
				sh.enableSharding("xxx")
			删除db：
				use xxx
				db.dropDatabase();

	批量数据测试:
	登录任意 一个mongos节点命令窗:
	新建数据库 williamblog 并设置允许使用分片均衡
	mongos>sh.enableSharding("williamblog");
	{
	        "ok" : 1,
	        "operationTime" : Timestamp(1549383200, 2),
	        "$clusterTime" : {
	                "clusterTime" : Timestamp(1549383200, 2),
	                "signature" : {
	                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
	                        "keyId" : NumberLong(0)
	                }
	        }
	}
	在 williamblog 数据库 声明一个数据表 testtab,他的 age name项都是 这个表的数据实现分片均衡的 处理标识
	mongos>sh.shardCollection("williamblog.testtab2",{age: 1, name: 1});	
	{
	        "collectionsharded" : "williamblog.testtab",
	        "collectionUUID" : UUID("967dab62-2d2f-4e44-b121-6b79ba425eb7"),
	        "ok" : 1,
	        "operationTime" : Timestamp(1549383349, 8),
	        "$clusterTime" : {
	                "clusterTime" : Timestamp(1549383349, 8),
	                "signature" : {
	                        "hash" : BinData(0,"AAAAAAAAAAAAAAAAAAAAAAAAAAA="),
	                        "keyId" : NumberLong(0)
	                }
	        }
	}
	批量写入一段数据
	mongos>use williamblog	//必须!!! 不然不是在 williamblog.testtab 添加内容!!
				//而是在其他不知道是什么地方新建一个不分片均衡数据表 testtab的添加数据!!
	mongos>for (i=1;i<=10000;i++) db.testtab.insert({name: "user"+i, age: (i%150)});   
	WriteResult({ "nInserted" : 1 })
	检查状态
	mongos> sh.status();
	--- Sharding Status --- 
	  sharding version: {
	        "_id" : 1,
	        "minCompatibleVersion" : 5,
	        "currentVersion" : 6,
	        "clusterId" : ObjectId("5c586218e6d1cfea52eda72a")
	  }
	  shards:
	        {  "_id" : "shard1",  "host" : "shard1/172.23.0.2:20000,172.23.0.3:20000",  "state" : 1 }
	        {  "_id" : "shard2",  "host" : "shard2/172.23.0.5:20000,172.23.0.6:20000",  "state" : 1 }
	        {  "_id" : "shard3",  "host" : "shard3/172.23.0.8:20000,172.23.0.9:20000",  "state" : 1 }
	  active mongoses:
	        "4.0.5" : 3
	  autosplit:
	        Currently enabled: yes
	  balancer:
	        Currently enabled:  yes
	        Currently running:  no
	        Failed balancer rounds in last 5 attempts:  0
	        Migration Results for the last 24 hours: 
	                No recent migrations
	  databases:
	        {  "_id" : "config",  "primary" : "config",  "partitioned" : true }
	                config.system.sessions
	                        shard key: { "_id" : 1 }
	                        unique: false
	                        balancing: true
	                        chunks:
	                                shard1  1
	                        { "_id" : { "$minKey" : 1 } } -->> { "_id" : { "$maxKey" : 1 } } on : shard1 Timestamp(1, 0) 
	        {  "_id" : "williamblog",  "primary" : "shard3",  "partitioned" : true,  "version" : {  "uuid" : UUID("85c6a65a-dbfe-4ce3-b61a-d636f60df1a7"),  "lastMod" : 1 } }
	                williamblog.testtab
	                        shard key: { "age" : 1, "name" : 1 }
	                        unique: false
	                        balancing: true
	                        chunks:
	                                shard3  1
	                        { "age" : { "$minKey" : 1 }, "name" : { "$minKey" : 1 } } -->> { "age" : { "$maxKey" : 1 }, "name" : 	{ "$maxKey" : 1 } } on : shard3 Timestamp(1, 0) 
	可以看到, chunks 只有 shard3  1 一个分片,这就奇怪了,感觉就是没有实现分片均衡的样子,所有数据都放到 shard3 里
		多鞋机次批量数据也这样,后来飞发现可能是 chunks 数据块大小问题, mongo默认数据块大小是 64mb
		而我们的批量数据还是没有超过 64mb,所以就都放在同一个数据块上面.
		所以尝试 修改 chunks 的数据块大小
		use config
		db.settings.save( { _id:"chunksize", value: 20 } )	//块大小是 变成20mb
		然后后再重新批量写次数据,就发现分片了!!
                williamblog.testtab
                        shard key: { "age" : 1, "name" : 1 }
                        unique: false
                        balancing: true
                        chunks:
                                shard1  41
                                shard2  41
                                shard3  41
                        too many chunks to print, use verbose if you want to force print
		每个数据表 williamblog.testtab 数据 分布在三个shard集群上, 每个shard集群都有41个数据块,
		每个数据块都有一部分williamblog.testtab 数据表的内容!!
	balancing 功能是开启着的吗就是说mongo每隔一段时间都会检查 数据的集群分布,务求做到分片均衡!!
		在这里, shard key: { "age" : 1, "name" : 1 } 表示数据 是按照平分数据到 shard集群的方式存数据的!!
		balancing 也按照这种规律监管数据库,
		假如某刻,shard1 有1个数据块,shard2 有2个, shard3 有120个
		那么一段时间后被 balancing 监管发现, balancing会试图 搬迁平分数据, 务求最后 每个shard 都分得41个数据块的方向努力!!
	所以 其实分片设置是成功的,mongoDB 会根据数据实际情况自动分片,我一直以为没有分片,是设置上什么错误,
		其实只不过是各种原因,数据库未选择执行分片而已!! 这里是写入数据还不足以超过(数据块的大小导致)
	
	至此,monodb 分偏集群完成!!
	最后附加上 mogodb 分片股管理的深入参考:
		https://www.cnblogs.com/zhoujinyi/p/4668218.html	//分片管理!!	
		https://www.cnblogs.com/chenmh/p/8954584.html   //数据分片策略研究
		https://blog.csdn.net/wellschen/article/details/82499429 //测试时发现 数据不分块分片的问题!
		https://blog.csdn.net/wellschen/article/details/82499429 //补充的数据分片不成功的问题探

		









	
	

20190217
	未学习 的主流 工具
	nginx
	hoodloop
	electicsearch
学习 electicsearch 先不考录集群安装,先考虑使用!!
	直接使用docker版本:
		sudo docker pull docker.elastic.co/elasticsearch/elasticsearch:6.6.0
		sudo docker run -p 9200:9200 -p 9300:9300 --name=ES -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:6.6.0
		后面实验使用的是 6.1.1 版本,所以 把 6.6.0 版本删除,没必要存在多不同版本的镜像,够用就可以!!!
		sudo docker images 	//查看镜像的 ID	
		sudo docker rmi xxxxx	//根据ID:xxxxx 删除镜像 
	建立一个 docker 程序栈!!
		补充安装 docker-compose 插件:
			sudo curl -L "https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose		//直接下载 bin 文件
			sudo chmod +x /usr/local/bin/docker-compose   //配置执行权限
		建立一个 项目目录..full_stack/electicsearch_test,包含程序栈运行的所有内容!!!
		.
		├── books
		│   ├── 10007.txt
		│   ├── 10007.txt.rsrc
		│   ├── 103.txt
		│   ....
		│
		├── docker-compose.yml
		├── Dockerfile
		├── package.json
		├── public
		│   ├── app.js
		│   ├── index.html
		│   └── styles.css
		└── server
		    ├── app.js
		    ├── connection.js
		    ├── load_data.js
		    └── search.js
		/public - 目录保存是前端 Vue.js Web应用js代码 
		/server - 目录保存服务器后端 Node.js 源代码	
		docker-compose.yml 文件定义全部的应用程序栈,每个被定义的容器都将端口转发到宿主机系统（localhost）上，
		    以便于我们在宿主机上去访问和调试 Node API、Elasticsearch 实例和前端 Web 应用程序
		    gs-api - 后端应用程序逻辑使用的 Node.js 容器
		    gs-frontend - 前端 Web 应用程序使用的 Ngnix 容器。
		    gs-search - 保存和搜索数据的 Elasticsearch 容器。
		Dockerfile  由于 gs-frontend gs-search 是使用下载现成的镜像,gs-api却是使用自己定义配置内容的nodejs镜像,
			所以 需要 这个文件来 告诉生成自定义 nodejs 镜像的步骤!!!
		.dockerignore  生成自定义镜像 是从一个现成的镜像,配置和拷贝内容得到的
			这个文件中记录了 那些内容是不需要的,所以不用拷贝到自定义镜像里
		然后 cd 到 项目文件夹 里 操作: 
文件分析:
/////// docker-compose.yml /////////
version: '3'

services:			# 定义一个程序栈
  api: # Node.js App
    container_name: gs-api	# gs-api 容器
    build: .			# 需要使用重新生成的自定义镜像
    ports:			# 容器端口 映射到 宿主端口
      - "3000:3000" # Expose API port	
      - "9229:9229" # Expose Node process debug port (disable in production)
    environment: # Set ENV vars  设置环境变量
     - NODE_ENV=local
     - ES_HOST=elasticsearch
     - PORT=3000
    volumes: # Attach local book data directory 宿主机的指定文件夹 映射 容器的 /usr/src/app/books, 即数据存到宿主机
     - ./books:/usr/src/app/books

  frontend: # Nginx Server For Frontend App
    container_name: gs-frontend
    image: nginx			# 使用网络下载的现成镜像
    volumes: # Serve local "public" dir
      - ./public:/usr/share/nginx/html	# 宿主机的指定文件夹 映射 容器 这里是映射放 网页文件的地方!!!
    ports:				# 容器端口 映射到 宿主端口
      - "8080:80" # Forward site to localhost:8080

  elasticsearch: # Elasticsearch Instance
    container_name: gs-search
    image: docker.elastic.co/elasticsearch/elasticsearch:6.1.1
    volumes: # Persist ES data in seperate "esdata" volume
      - esdata:/usr/share/elasticsearch/data	#本来是 想宿主机的指定文件夹映射到容器, 即想在宿主机存放ES 的索引数据库,
    environment:
      - bootstrap.memory_lock=true
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - discovery.type=single-node
    ports: # Expose Elasticsearch ports
      - "9300:9300"
      - "9200:9200"

volumes: # Define seperate volume for Elasticsearch data
  esdata:			# 由于没有 指定定义 esdata, 所以 外部文档映射容器并没有实现
////////////////////////////////////

/////// Dockerfile /////////
# Use Node v8.9.0 LTS
FROM node:carbon		# 自定义镜像 基于网上下载的 node:carbon 镜像

# Setup app working directory
WORKDIR /usr/src/app		# 在自定义镜像上建立一个工作文档

# Copy package.json and package-lock.json
COPY package*.json ./		# 其实只把当前 项目目录 的 package.json,拷贝到 自定义镜像建立的工作文档

# Install app dependencies
RUN npm install			# 自定义镜像建立的工作文档里 执行npm 安装,即根据 package.json 安装 软件 
				# 由于安装过程中会检测到 所要安装软件的版本变化问题,所以npm会自生成 package-lock.json
				# package-lock.json 记录 npm 最终安装的软件 信息
# Copy sourcecode
COPY . .			# 把 项目目录 的所有内容 都 拷贝到 自定义镜像建立的工作文档 
				# 会去鉴别 .dockerignore 提供的黑名单,并不拷贝黑名单上的内容
				# 其实实际上,重点是拷贝了 server 文件夹 到 自定义镜像里

# Start app
CMD [ "npm", "start" ]		# 给自定义镜像 添加 开机执行的命令, 
				# 这里npm start 是指根据 package.json 配置 运行已经安装的软件!!!
////////////////////////////
	
////////// package.json /////////////
{
  "name": "guttenberg-search",
  "version": "0.0.1",
  "description": "Source code for Elasticsearch tutorial using 100 classic open source books.",
  "scripts": {
    "start": "node --inspect=0.0.0.0:9229 server/app.js"	# npm start 实际就是启动了这个node后端服务,不断监听连接 
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/triestpa/guttenberg-search.git"
  },
  "author": "patrick.triest@gmail.com",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/triestpa/guttenberg-search/issues"
  },
  "homepage": "https://github.com/triestpa/guttenberg-search#readme",
  "dependencies": {
    "elasticsearch": "13.3.1",
    "joi": "13.0.1",
    "koa": "2.4.1",
    "koa-joi-validate": "0.5.1",
    "koa-router": "7.2.1"
  }
}
/////////////////////////////////////

//////// .dockerignore /////////
node_modules/		# 这是避免拷贝任何 node_modules 名字的文件夹, 不限路径 
npm-debug.log		
books/
public/
////////////////////////////////
		到此为止, 基本分析完 一个docker-compose如何 构造 程序栈
		接下来, 继续完成整个整个程序栈
		添加 public/index.html 文件,并添加如下测试页面内容。
			<html><body>Hello World From The Frontend Container</body></html>
			注意, public 是以映射到 gs-frontend 容器的 !!
		添加 server/app.js 文件,并添加 Node.js 执行的 连接监听后端代码
			const Koa = require('koa')
			const app = new Koa()
			
			app.use(async (ctx, next) => {
			  ctx.body = 'Hello World From the Backend Container'
			})
			
			const port = process.env.PORT || 3000
			
			app.listen(port, err => {
			  if (err) console.error(err)
			  console.log(`App Listening on Port ${port}`)
			})
			注意, server 并不是映射的方式到 gs-api,而是通过构建自定义镜像时拷贝入镜像的 !!!
		然后开始 构建程序栈, sudo docker-compose build 
			其实就是扫一便相关文件 (docker-compose.yml Dockerfile .dockerignore) 
			如果发现需要自建键像,就自建镜像!!!
//////////////// 执行log ////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker-compose build

frontend uses an image, skipping
elasticsearch uses an image, skipping
Building api
Step 1/6 : FROM node:carbon
carbon: Pulling from library/node
741437d97401: Pull complete
34d8874714d7: Pull complete
0a108aa26679: Pull complete
7f0334c36886: Pull complete
65c95cb8b3be: Pull complete
a36b708560f8: Pull complete
81a7e69fab67: Pull complete
a88b577be604: Pull complete
Digest: sha256:a8a9d8eaab36bbd188612375a54fb7f57418458812dabd50769ddd3598bc24fc
Status: Downloaded newer image for node:carbon
 ---> 4f01e5319662
Step 2/6 : WORKDIR /usr/src/app
Removing intermediate container 304ae5a57d51
 ---> 85e1dc7a8b13
Step 3/6 : COPY package*.json ./
 ---> 94c248e69c79
Step 4/6 : RUN npm install
 ---> Running in 7a492633d063
npm WARN deprecated joi@10.6.0: This version is no longer maintained. Please upgrade to the latest version.
npm WARN deprecated hoek@5.0.4: This version is no longer maintained. Please upgrade to the latest version.
npm notice created a lockfile as package-lock.json. You should commit this file.
added 71 packages from 32 contributors and audited 93 packages in 15.887s
found 2 vulnerabilities (1 low, 1 moderate)
  run `npm audit fix` to fix them, or `npm audit` for details
Removing intermediate container 7a492633d063
 ---> c419ec45a179
Step 5/6 : COPY . .
 ---> 27d81e48e490
Step 6/6 : CMD [ "npm", "start" ]
 ---> Running in cc5522c616a7
Removing intermediate container cc5522c616a7
 ---> 1e3b367c4e6d
Successfully built 1e3b367c4e6d
Successfully tagged electicsearch_test_api:latest			
/////////////////////////////////////////////////
		然后执行 docker-compose up 去启动整个应用程序栈,
			也是根据相关文件 (docker-compose.yml Dockerfile .dockerignore)
			在这里才开始构建容器 和 启动容器!!!
//////////////// 执行log ////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker-compose up 
Creating network "electicsearch_test_default" with the default driver
Creating volume "electicsearch_test_esdata" with default driver
Pulling frontend (nginx:)...
latest: Pulling from library/nginx
6ae821421a7d: Pull complete
da4474e5966c: Pull complete
eb2aec2b9c9f: Pull complete
Pulling elasticsearch (docker.elastic.co/elasticsearch/elasticsearch:6.1.1)...
85432449fd0f: Pull complete
ed29febfeb5c: Pull complete
3a63b77751ff: Pull complete
c564c50fb69d: Pull complete
b1a7ef0a5528: Pull complete
9af7b1014a51: Pull complete
Creating gs-api      ... done
Creating gs-search   ... done
Creating gs-frontend ... done
Attaching to gs-frontend, gs-api, gs-search
gs-api           | 
gs-api           | > guttenberg-search@0.0.1 start /usr/src/app
gs-api           | > node --inspect=0.0.0.0:9229 server/app.js
gs-api           | 
gs-api           | Debugger listening on ws://0.0.0.0:9229/d8f7cfca-e9a8-46e4-b34a-da148c130373
gs-api           | For help see https://nodejs.org/en/docs/inspector
gs-api           | App Listening on Port 3000
gs-search        | [2019-02-19T09:51:59,796][WARN ][o.e.b.JNANatives         ] Unable to lock JVM Memory: error=12, reason=Cannot allocate memory
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] This can result in part of the JVM being swapped out.
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] Increase RLIMIT_MEMLOCK, soft limit: 65536, hard limit: 65536
gs-search        | [2019-02-19T09:51:59,798][WARN ][o.e.b.JNANatives         ] These can be adjusted by modifying /etc/security/limits.conf, for example: 
gs-search        |      # allow user 'elasticsearch' mlockall
gs-search        |      elasticsearch soft memlock unlimited
gs-search        |      elasticsearch hard memlock unlimited
gs-search        | [2019-02-19T09:51:59,799][WARN ][o.e.b.JNANatives         ] If you are logged in interactively, you will have to re-login for the new limits to take effect.
gs-search        | [2019-02-19T09:51:59,933][INFO ][o.e.n.Node               ] [] initializing ...
gs-search        | [2019-02-19T09:52:00,076][INFO ][o.e.e.NodeEnvironment    ] [4TpwwJi] using [1] data paths, mounts [[/usr/share/elasticsearch/data (/dev/sda1)]], net usable_space [147.7gb], net total_space [428.2gb], types [ext4]
gs-search        | [2019-02-19T09:52:00,076][INFO ][o.e.e.NodeEnvironment    ] [4TpwwJi] heap size [494.9mb], compressed ordinary object pointers [true]
gs-search        | [2019-02-19T09:52:00,078][INFO ][o.e.n.Node               ] node name [4TpwwJi] derived from node ID [4TpwwJiLQ0Sw4BQGQX99aQ]; set [node.name] to override
gs-search        | [2019-02-19T09:52:00,079][INFO ][o.e.n.Node               ] version[6.1.1], pid[1], build[bd92e7f/2017-12-17T20:23:25.338Z], OS[Linux/4.15.0-45-generic/amd64], JVM[Oracle Corporation/OpenJDK 64-Bit Server VM/1.8.0_151/25.151-b12]
gs-search        | [2019-02-19T09:52:00,079][INFO ][o.e.n.Node               ] JVM arguments [-Xms1g, -Xmx1g, -XX:+UseConcMarkSweepGC, -XX:CMSInitiatingOccupancyFraction=75, -XX:+UseCMSInitiatingOccupancyOnly, -XX:+AlwaysPreTouch, -Xss1m, -Djava.awt.headless=true, -Dfile.encoding=UTF-8, -Djna.nosys=true, -XX:-OmitStackTraceInFastThrow, -Dio.netty.noUnsafe=true, -Dio.netty.noKeySetOptimization=true, -Dio.netty.recycler.maxCapacityPerThread=0, -Dlog4j.shutdownHookEnabled=false, -Dlog4j2.disable.jmx=true, -XX:+HeapDumpOnOutOfMemoryError, -Des.cgroups.hierarchy.override=/, -Xms512m, -Xmx512m, -Des.path.home=/usr/share/elasticsearch, -Des.path.conf=/usr/share/elasticsearch/config]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [aggs-matrix-stats]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [analysis-common]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [ingest-common]
gs-search        | [2019-02-19T09:52:01,647][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-expression]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-mustache]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [lang-painless]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [mapper-extras]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [parent-join]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [percolator]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [reindex]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [repository-url]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [transport-netty4]
gs-search        | [2019-02-19T09:52:01,648][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded module [tribe]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [ingest-geoip]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [ingest-user-agent]
gs-search        | [2019-02-19T09:52:01,649][INFO ][o.e.p.PluginsService     ] [4TpwwJi] loaded plugin [x-pack]
gs-search        | [2019-02-19T09:52:04,149][INFO ][o.e.x.m.j.p.l.CppLogMessageHandler] [controller/120] [Main.cc@128] controller (64 bit): Version 6.1.1 (Build c508cf991ee61c) Copyright (c) 2017 Elasticsearch BV
gs-search        | [2019-02-19T09:52:04,524][INFO ][o.e.d.DiscoveryModule    ] [4TpwwJi] using discovery type [single-node]
gs-search        | [2019-02-19T09:52:05,113][INFO ][o.e.n.Node               ] initialized
gs-search        | [2019-02-19T09:52:05,113][INFO ][o.e.n.Node               ] [4TpwwJi] starting ...
gs-search        | [2019-02-19T09:52:05,237][INFO ][o.e.t.TransportService   ] [4TpwwJi] publish_address {172.18.0.4:9300}, bound_addresses {0.0.0.0:9300}
gs-search        | [2019-02-19T09:52:05,256][WARN ][o.e.b.BootstrapChecks    ] [4TpwwJi] memory locking requested for elasticsearch process but memory is not locked
gs-search        | [2019-02-19T09:52:05,256][WARN ][o.e.b.BootstrapChecks    ] [4TpwwJi] max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
gs-search        | [2019-02-19T09:52:05,349][INFO ][o.e.x.s.t.n.SecurityNetty4HttpServerTransport] [4TpwwJi] publish_address {172.18.0.4:9200}, bound_addresses {0.0.0.0:9200}
gs-search        | [2019-02-19T09:52:05,349][INFO ][o.e.n.Node               ] [4TpwwJi] started
gs-search        | [2019-02-19T09:52:05,475][INFO ][o.e.g.GatewayService     ] [4TpwwJi] recovered [0] indices into cluster_state
gs-search        | [2019-02-19T09:52:06,281][INFO ][o.e.l.LicenseService     ] [4TpwwJi] license [0c6db8a3-2495-4956-ae4f-645d4b64eaa9] mode [basic] - valid
gs-search        | [2019-02-19T09:52:15,253][INFO ][o.e.c.m.MetaDataCreateIndexService] [4TpwwJi] [.monitoring-es-6-2019.02.19] creating index, cause [auto(bulk api)], templates [.monitoring-es], shards [1]/[1], mappings [doc]
gs-frontend      | 172.18.0.1 - - [19/Feb/2019:09:53:08 +0000] "GET / HTTP/1.1" 200 66 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0" "-"
gs-frontend      | 172.18.0.1 - - [19/Feb/2019:09:53:08 +0000] "GET /favicon.ico HTTP/1.1" 404 153 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0" "-"
gs-frontend      | 2019/02/19 09:53:08 [error] 7#7: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 172.18.0.1, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "localhost:8080"
/////////////////////////////////////////////////
		宿主机浏览器 登录 localhost:8080  localhost:3000  localhost:9200 
		分别 访问了 gs-frontend, gs-api, gs-search, 三个节点,都可以成功看到相关内容!!!
		最后,我们可以 登录 gs-api 容器 查看 /usr/src/app 的内容来 分析根据 Dockerfile 建立镜像的情况

	接下来就是在这个 程序栈,实验 electicsearch
		我们的实验是建立一个电子书信息内容搜索服务!!!
		首先是建立电子书数据( 有100本明著,来自古登堡项目 ),在项目目录下执行
			wget https://cdn.patricktriest.com/data/books.zip
			unar books.zip
		得到 books/文件夹 而这个文件夹及其内容根据程序栈设置,会映射到 gs-api 的/usr/src/app/books
		书本都有统一的格式,可供机器分析: 
		假设打开的是 219-0.txt,
		你将注意到它开头是一个公开访问的协议，接下来是一些标识这本书的书名、作者、发行日期、语言和字符编码的行。
			Title: Heart of Darkness

			Author: Joseph Conrad
			
			Release Date: February 1995 [EBook #219]
			Last Updated: September 7, 2016
			
			Language: English
			
			Character set encoding: UTF-8
		在 *** START OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 后，
		在 *** END OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 前,是这本书的正式内容。
		而 *** END OF THIS PROJECT GUTENBERG EBOOK HEART OF DARKNESS *** 后,是这本书更详细的协议版本。
		然后,测试 后端服务器 访问 search 服务器的情况!!!
			添加 server/connection.js 文件,添加内容:
////////////////
const elasticsearch = require('elasticsearch')		//自建镜像添加了ES的 js 的接口,所以可以被node.js使用

// Core ES variables for this project
const index = 'library'
const type = 'novel'
const port = 9200
const host = process.env.ES_HOST || 'localhost'
const client = new elasticsearch.Client({ host: { host, port } })	//建立一个到 gs-search 的连接

/** Check the ES connection status */
async function checkConnection () {
  let isConnected = false
  while (!isConnected) {
    console.log('Connecting to ES')
    try {
      const health = await client.cluster.health({})
      console.log(health)
      isConnected = true
    } catch (err) {
      console.log('Connection Failed, Retrying...', err)
    }
  }
}
////////////////
			由于 server 内容改变了, 需要重建镜像!! sudo docker-compose build 
			重建重开容器,这次选择后台执行程序栈 docker-compose up -d
			程序栈起来后执行: sudo docker exec gs-api "node" "server/connection.js" 会有以下信息
				{ cluster_name: 'docker-cluster',
				  status: 'yellow',
				  timed_out: false,
				  number_of_nodes: 1,
				  number_of_data_nodes: 1,
				  active_primary_shards: 1,
				  active_shards: 1,
				  relocating_shards: 0,
				  initializing_shards: 0,
				  unassigned_shards: 1,
				  delayed_unassigned_shards: 0,
				  number_of_pending_tasks: 0,
				  number_of_in_flight_fetch: 0,
				  task_max_waiting_in_queue_millis: 0,
				  active_shards_percent_as_number: 50 }
				表示 gs-api 连接 gs-search 成功 !!!
			(注意,重建镜像后,之前的旧自建镜像会保留,所以需要手动去清理,
			为了避免麻烦为啥 不把 server 作为映射目录到 镜像? 
			是为了执行安全,因为,node正在执行server的监听js,而你又在此刻更新js, node执行会出错吧)
		server/connection.js 是 gs-api 连接 gs-search 的 接口, 接下来完善这个接口js文件
///////////// server/connection.js /////////////////
const elasticsearch = require('elasticsearch')		//使用 ES 的 javascript api接口

// Core ES variables for this project
const index = 'library'
const type = 'novel'
const port = 9200
const host = process.env.ES_HOST || 'localhost'
const client = new elasticsearch.Client({ host: { host, port } })	//建立一个到 gs-search 的连接

/** Check the ES connection status */
async function checkConnection () {
  let isConnected = false
  while (!isConnected) {
    console.log('Connecting to ES')
    try {
      const health = await client.cluster.health({})	//查看集群的 运行情况
      console.log(health)
      isConnected = true
    } catch (err) {
      console.log('Connection Failed, Retrying...', err)
    }
  }
}

/** Clear the index, recreate it, and add mappings */
async function resetIndex (index) {			//重置 索引
  if (await client.indices.exists({ index })) {			
    await client.indices.delete({ index })	
  }

  await client.indices.create({ index })	//创建一个索引
  await putBookMapping()			//为索引定义一个映射, 相当于给sql数据库定义一个table
}

/** Add book section schema mapping to ES */	
async function putBookMapping () {		//为 索引定义了一个映射。
  const schema = {
    title: { type: 'keyword' },
    author: { type: 'keyword' },
    location: { type: 'integer' },
    text: { type: 'text' }
  }

  return client.indices.putMapping({ index, type, body: { properties: schema } })
}


module.exports = {
  client, index, type, checkConnection, resetIndex	//导出对外发布的属性和函数，这样其它模块就可以访问
}

//checkConnection()
////////////////////////////////////////////////////
		接下来是读取图书的数据, 生成用于能被 ES 实际执行搜索的合法文档,放入 electiicearch 服务器的索引里,
			添加 server/load_data.js 文件
///////////////// server/load_data.js //////////////
const fs = require('fs')
const path = require('path')
const esConnection = require('./connection')		//引用刚刚写的 connection 接口

/** Clear ES index, parse and index all files from the books directory */
async function readAndInsertBooks () {
  try {
    // Clear previous ES index				//重置索引
    await esConnection.resetIndex(esConnection.index)	//原教程出现的bug, 必须加上 esConnection.index
							//如果重置索引失败,会引起后续的众多问题!!!
  } catch (err) {
    console.error(err)
  }

  try {							//读取 电子书数据, 建立 ES 映射文件
    // Read books directory
    let files = fs.readdirSync('./books').filter(file => file.slice(-4) === '.txt')
    console.log(`Found ${files.length} Files`)

    // Read each book file, and index each paragraph in elasticsearch
    for (let file of files) {
      console.log(`Reading File - ${file}`)
      const filePath = path.join('./books', file)
      const { title, author, paragraphs } = parseBookFile(filePath)	//分析 一本电子数内容 并分割段落建立映射内容
      await insertBookData(title, author, paragraphs)			//递交内容到 ES 索引 形成映射文件
    }
  } catch (err) {
    console.error(err)
  }
}


/** Read an individual book text file, and extract the title, author, and paragraphs */
function parseBookFile (filePath) {
  // Read text file
  const book = fs.readFileSync(filePath, 'utf8')		//从文件系统中读取书的文本

  // Find book title and author					//使用正则表达式 解析书名,作者
  const title = book.match(/^Title:\s(.+)$/m)[1]		
  const authorMatch = book.match(/^Author:\s(.+)$/m)
  const author = (!authorMatch || authorMatch[1].trim() === '') ? 'Unknown Author' : authorMatch[1]

  console.log(`Reading Book - ${title} By ${author}`)

  // Find Guttenberg metadata header and footer		//通过匹配 “古登堡项目” 的头部和尾部，识别书的正文内容。
  const startOfBookMatch = book.match(/^\*{3}\s*START OF (THIS|THE) PROJECT GUTENBERG EBOOK.+\*{3}$/m)
  const startOfBookIndex = startOfBookMatch.index + startOfBookMatch[0].length
  const endOfBookIndex = book.match(/^\*{3}\s*END OF (THIS|THE) PROJECT GUTENBERG EBOOK.+\*{3}$/m).index

  // Clean book text and split into array of paragraphs	//提取书的内容文本,分割每个段落到它的数组中,清理文本并删除空白行
  const paragraphs = book
    .slice(startOfBookIndex, endOfBookIndex) // Remove Guttenberg header and footer
    .split(/\n\s+\n/g) // Split each paragraph into it's own array entry
    .map(line => line.replace(/\r\n/g, ' ').trim()) // Remove paragraph line breaks and whitespace
    .map(line => line.replace(/_/g, '')) // Guttenberg uses "_" to signify italics.  We'll remove it, since it makes the raw text look messy.
    .filter((line) => (line && line.length !== '')) // Remove empty lines

  console.log(`Parsed ${paragraphs.length} Paragraphs\n`)
  return { title, author, paragraphs }	//返回构建的对象，这个对象包含书名、作者、以及书中各段落的数组 paragraphs
}


//这个函数将使用书名、作者和附加元数据的段落位置来索引书中的每个段落。我们通过批量操作来插入段落，它比逐个段落插入要快的多。
/** Bulk index the book data in Elasticsearch */
async function insertBookData (title, author, paragraphs) {
  let bulkOps = [] // Array to store bulk operations

  // Add an index operation for each section in the book
  for (let i = 0; i < paragraphs.length; i++) {
    // Describe action
    bulkOps.push({ index: { _index: esConnection.index, _type: esConnection.type } })

    // Add document
    bulkOps.push({
      author,
      title,
      location: i,
      text: paragraphs[i]
    })

    if (i > 0 && i % 500 === 0) { // Do bulk insert in 500 paragraph batches
      await esConnection.client.bulk({ body: bulkOps })
      bulkOps = []
      console.log(`Indexed Paragraphs ${i - 499} - ${i}`)
    }
  }

  // Insert remainder of bulk ops array
  await esConnection.client.bulk({ body: bulkOps })
  console.log(`Indexed Paragraphs ${paragraphs.length - (bulkOps.length / 2)} - ${paragraphs.length}\n\n\n`)
}

readAndInsertBooks()
////////////////////////////////////////////////////	
			然后 重建重启程序栈,快捷命令: sudo docker-compose up -d --build
				相当于sudo docker-compose build  加 sudo docker-compose up -d 
				(注意 手动删除多余的旧镜像)
				docker-compose logs -f api   //从 Node 应用程序中查看实时日志
			然后执行 sudo docker exec gs-api "node" "server/load_data.js"
				gs-api 读取电子书数据文件并生成映射内容 上传到 gs-search 的 book 索引
////////////////////// 部分执行log ///////////////////////////
william@william-HP:~/full_stack/electicsearch_test$ sudo docker exec gs-api "node" "server/load_data.js"
Found 100 Files
Reading File - 10.txt
Reading Book - The King James Bible By Unknown Author
Parsed 24609 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 1000
Indexed Paragraphs 1001 - 1500
Indexed Paragraphs 1501 - 2000
Indexed Paragraphs 2001 - 2500
.........



Reading File - 10007.txt
Reading Book - Carmilla By J. Sheridan LeFanu
Parsed 681 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 681



Reading File - 103.txt
Reading Book - Around the World in 80 Days By Jules Verne
Parsed 1720 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 1000
Indexed Paragraphs 1001 - 1500
Indexed Paragraphs 1501 - 1720



Reading File - 1080.txt
Reading Book - A Modest Proposal By Jonathan Swift
Parsed 39 Paragraphs

Indexed Paragraphs 0 - 39



Reading File - 11-0.txt
Reading Book - Alice’s Adventures in Wonderland By Lewis Carroll
Parsed 820 Paragraphs

Indexed Paragraphs 1 - 500
Indexed Paragraphs 501 - 820

...........

/////////////////////////////////////////////////////////////
		然后,我们就可以执行搜索了测试了
		浏览器执行:
			http://localhost:9200/library/_search?q=text:Java&pretty
			这是直接访问 gs-search 节点执行的极其简单的 搜索操作.
			浏览器会看到一堆json内容返回.
			而且只是从 ES 索引中找到合适的 映射文件
			然后返回映射文件 而已!!! 不是真正意义上的搜索功能!!
		真实的搜索的一种常规场景应该是这样子的!!!
			后端服务器,对数据库 执行的分析 生成映射文件 存入  ES服务器
			映射文件包含了 数据片段外,还包含了真是数据的位置信息 !!!!
			
			[client] <---> [gs-frontend] <----> [gs-api]
			                                        ^ 
								|
                                                                v
			                                   [gs-search]
			client只能访问 前端服务器即web应用服务器, 搜索请求由 前端传递到后端,后端传递到ES服务器
			ES 返回,合适的 映射文件内容.给后端,后端再返回 前端
			client看到许多结果,其实 都是 ES 的映射文件而已,当 client点击其中一个 结果
			就是 请求打开 这个映射文件的指向的数据真实位置, 请求从client传到前端传到后端,
			后端把 指定位置的数据库信息 读出 返回前端再返回client
			当然也有直接 从 前端 直接访问 ES 获取搜索的 映射文件,(可能安全性会差些吧)
		接下来我们的实验是.
			client 搜索请求,经 前端,后端到 ES
			结果映射文件经 ES, 后端, 前端, 到 client 
			client 点击一个结果, 依然是 经 前端,后端到 ES
			ES收集这个结果对应的映射文件附近的映射文件,经 ES, 后端, 前端, 到 client
			与一般场景有所区别,是因为仅仅这个例子映射文本就记录了全部所需要的信息,
			不需要通过映射文本寻找读取后端的 电子书数据!!
	开始 ES 实验:
		gs-api 容易 添加 使用 ES 搜索的功能模块
///////////// server/search.js //////////////
const { client, index, type } = require('./connection')		//使用 server/connection.js 接口

module.exports = {
  /** Query ES index for the provided term */
  queryTerm (term, offset = 0) {	//搜索 关键字 得到 结果
    const body = {
      from: offset,		//from - 允许我们分页查询结果。默认每个查询返回 10 个结果，from: 10 将允许我们取回 10-20 的结果。
      query: { match: {		
        text: {		
          query: term,		//query - 这里我们指定要查询的词。
          operator: 'and',	//operator - 搜索行为；本例中，我们使用 and 操作去对查询中包含所有字元（要查询的词）的结果来确定优先顺序。
          fuzziness: 'auto'	//fuzziness - 对拼写错误的容错调整，auto 的默认为 fuzziness: 2。模糊值越高，结果越需要更多校正。
        } } },
      highlight: { fields: { text: {} } }	//highlights - 结果返回一个额外的字段包含 HTML，以显示精确的文本字集和查询中匹配的关键词。
    }

    return client.search({ index, type, body })		
  },		// 一定要添加 , 号

  /** Get the specified range of paragraphs from a book */
  getParagraphs (bookTitle, startLocation, endLocation) {	//根据当前选择的搜索结果(映射文件),获得其前后各5片映射文件
    const filter = [						//目的是后面取其段落文本片段组成 结果文章 显示!! 
      { term: { title: bookTitle } },
      { range: { location: { gte: startLocation, lte: endLocation } } }
    ]

    const body = {
      size: endLocation - startLocation,
      sort: { location: 'asc' },
      query: { bool: { filter } }
    }

    return client.search({ index, type, body })
  }

}
/////////////////////////////////////////////		
		更新 server/app.js 内容, 使 gs-api 成为一个简单完整的后端服务器
		这些代码将为 Koa.js Node API 服务器导入服务器依赖，设置简单的日志，以及错误处理。 
////////////////////// server/app.js ///////////////////////

const Koa = require('koa')
const Router = require('koa-router')
const joi = require('joi')
const validate = require('koa-joi-validate')
const search = require('./search')

const app = new Koa()
const router = new Router()

// Log each request to the console
app.use(async (ctx, next) => {
  const start = Date.now()
  await next()
  const ms = Date.now() - start
  console.log('${ctx.method} ${ctx.url} - ${ms}')
})

// Log percolated errors to the console
app.on('error', err => {
  console.error('Server Error', err)
})

// Set permissive CORS header
app.use(async (ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', '*')
  return next()
})

// ADD ENDPOINTS HERE
/**
 * GET /search
 * Search for a term in the library
 * Query Params -
 * term: string under 60 characters
 * offset: positive integer
 */				
router.get('/search',			//根据 前端 获得/search请求, 后端向es获取搜索数据
  validate({				//http://localhost:3000/search,,, 就是执行到后端服务器的这个地方 获取搜索功能
    query: {
      term: joi.string().max(60).required(),		//添加一些使用 Joi 和 Koa-Joi-Validate 库的中间件，以对输入做校验
      offset: joi.number().integer().min(0).default(0)
    }
  }),
  async (ctx, next) => {
    const { term, offset } = ctx.request.query
    ctx.body = await search.queryTerm(term, offset)	//后端向es获取搜索数据
  }
)
/**
 * GET /paragraphs
 * Get a range of paragraphs from the specified book
 * Query Params -
 * bookTitle: string under 256 characters
 * start: positive integer
 * end: positive integer greater than start
 */
router.get('/paragraphs',	//根据 前端 获得 /paragraphs请求, 后端向es获取结果附近的文本段落
  validate({
    query: {
      bookTitle: joi.string().max(256).required(),	//添加一些使用 Joi 和 Koa-Joi-Validate 库的中间件，以对输入做校验
      start: joi.number().integer().min(0).default(0),
      end: joi.number().integer().greater(joi.ref('start')).default(10)
    }
  }),
  async (ctx, next) => {
    const { bookTitle, start, end } = ctx.request.query
    ctx.body = await search.getParagraphs(bookTitle, start, end)	//后端向es获取结果附近的文本段落

  }
)

const port = process.env.PORT || 3000

app					//建立监听程序
  .use(router.routes())
  .use(router.allowedMethods())
  .listen(port, err => {
    if (err) throw err
    console.log('App Listening on Port ${port}')
  })
////////////////////////////////////////////////////////////
		接着 我们给前端服务 添加 web 应用 ,允许其与 客户端交互
		添加 /public/app.js
		这是 一个 基于 vue 的简单 js 程序!!
		只定义了一些共享的数据属性，以及添加了检索和分页搜索结果的方法。
		为防止每次按键一次都调用 API，搜索输入有一个 100 毫秒的除颤功能 
/////////////////// /public/app.js /////////////////////
const vm = new Vue ({
  el: '#vue-instance',
  data () {
    return {
      baseUrl: 'http://localhost:3000', // API url  后端gs-api 访问接口
      searchTerm: 'Hello World', // Default search term
      searchDebounce: null, // Timeout for search bar debounce
      searchResults: [], // Displayed search results
      numHits: null, // Total search results found
      searchOffset: 0, // Search result pagination offset

      selectedParagraph: null, // Selected paragraph object
      bookOffset: 0, // Offset for book paragraphs being displayed
      paragraphs: [] // Paragraphs being displayed in book preview window
    }
  },
  async created () {
    this.searchResults = await this.search() // Search for default term
  },
  methods: {
    /** Debounce search input by 100 ms */
    onSearchInput () {
      clearTimeout(this.searchDebounce)
      this.searchDebounce = setTimeout(async () => {
        this.searchOffset = 0
        this.searchResults = await this.search()
      }, 100)
    },
    /** Call API to search for inputted term */
    async search () {				// 搜索请求
      const response = await axios.get(`${this.baseUrl}/search`, { params: { term: this.searchTerm, offset: this.searchOffset } })
      this.numHits = response.data.hits.total	//
      return response.data.hits.hits
    },
    /** Get next page of search results */
    async nextResultsPage () {
      if (this.numHits > 10) {
        this.searchOffset += 10
        if (this.searchOffset + 10 > this.numHits) { this.searchOffset = this.numHits - 10}
        this.searchResults = await this.search()
        document.documentElement.scrollTop = 0
      }
    },
    /** Get previous page of search results */
    async prevResultsPage () {
      this.searchOffset -= 10
      if (this.searchOffset < 0) { this.searchOffset = 0 }
      this.searchResults = await this.search()
      document.documentElement.scrollTop = 0
    },

    /** Call the API to get current page of paragraphs */
    async getParagraphs (bookTitle, offset) {	// 获取结果所在文章
      try {
        this.bookOffset = offset
        const start = this.bookOffset
        const end = this.bookOffset + 10
        const response = await axios.get(`${this.baseUrl}/paragraphs`, { params: { bookTitle, start, end } })
        console.log(response.data)
        return response.data.hits.hits
      } catch (err) {
        console.error(err)
      }
    },
    /** Get next page (next 10 paragraphs) of selected book */
    async nextBookPage () {
      this.$refs.bookModal.scrollTop = 0
      this.paragraphs = await this.getParagraphs(this.selectedParagraph._source.title, this.bookOffset + 10)
    },
    /** Get previous page (previous 10 paragraphs) of selected book */
    async prevBookPage () {
      this.$refs.bookModal.scrollTop = 0
      this.paragraphs = await this.getParagraphs(this.selectedParagraph._source.title, this.bookOffset - 10)
    },
    /** Display paragraphs from selected book in modal window */
    async showBookModal (searchHit) {		//显示结果文本, 这里会经历一个 获取 围绕结果上下文段落的 get过程
      try {
        document.body.style.overflow = 'hidden'
        this.selectedParagraph = searchHit
        this.paragraphs = await this.getParagraphs(searchHit._source.title, searchHit._source.location - 5)
        console.log(searchHit._source.title, ' ', searchHit._source.location)
      } catch (err) {
        console.error(err)
      }
    },
    /** Close the book detail modal */
    closeBookModal () {
      //console.log('wiliam/n/r')
      document.body.style.overflow = 'auto'
      this.selectedParagraph = null
    }
  }
})
////////////////////////////////////////////////////////
		完善前端 web应用的 页面样板
		还有 css ui 样式
/////////////////// /public/index.html /////////////////
<!--
<html><body>Hello World From The Frontend Container</body></html>
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Elastic Library</title>
  <meta name="description" content="Literary Classic Search Engine.">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" rel="stylesheet" type="text/css" />
  <link href="https://cdn.muicss.com/mui-0.9.20/css/mui.min.css" rel="stylesheet" type="text/css" />
  <link href="https://fonts.googleapis.com/css?family=EB+Garamond:400,700|Open+Sans" rel="stylesheet">
  <link href="styles.css" rel="stylesheet" />
</head>
<body>
<div class="app-container" id="vue-instance">
    <!-- Search Bar Header -->
    <div class="mui-panel">
      <div class="mui-textfield">
        <input v-model="searchTerm" type="text" v-on:keyup="onSearchInput()">
        <label>Search</label>
      </div>
    </div>

    <!-- Search Metadata Card -->
    <div class="mui-panel">
      <div class="mui--text-headline">{{ numHits }} Hits</div>
      <div class="mui--text-subhead">Displaying Results {{ searchOffset }} - {{ searchOffset + 9 }}</div>
    </div>

    <!-- Top Pagination Card -->
    <div class="mui-panel pagination-panel">
        <button class="mui-btn mui-btn--flat" v-on:click="prevResultsPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextResultsPage()">Next Page</button>
    </div>

    <!-- Search Results Card List -->
    <div class="search-results" ref="searchResults">
      <div class="mui-panel" v-for="hit in searchResults" v-on:click="showBookModal(hit)">
        <div class="mui--text-title" v-html="hit.highlight.text[0]"></div>
        <div class="mui-divider"></div>
        <div class="mui--text-subhead">{{ hit._source.title }} - {{ hit._source.author }}</div>
        <div class="mui--text-body2">Location {{ hit._source.location }}</div>
      </div>
    </div>

    <!-- Bottom Pagination Card -->
    <div class="mui-panel pagination-panel">
        <button class="mui-btn mui-btn--flat" v-on:click="prevResultsPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextResultsPage()">Next Page</button>
    </div>

    <!-- INSERT BOOK MODAL HERE -->
    <!-- Book Paragraphs Modal Window -->
    <div v-if="selectedParagraph" ref="bookModal" class="book-modal">
      <div class="paragraphs-container">
        <!-- Book Section Metadata -->
        <div class="title-row">
          <div class="mui--text-display2 all-caps">{{ selectedParagraph._source.title }}</div>
          <div class="mui--text-display1">{{ selectedParagraph._source.author }}</div>
        </div>
        <br>
        <div class="mui-divider"></div>
        <div class="mui--text-subhead locations-label">Locations {{ bookOffset - 5 }} to {{ bookOffset + 5 }}</div>
        <div class="mui-divider"></div>
        <br>

        <!-- Book Paragraphs -->
        <div v-for="paragraph in paragraphs">	//这里显然轮选显示 paragraphs段落数组的 每个段落 paragraph
          <div v-if="paragraph._source.location === selectedParagraph._source.location" class="mui--text-body2">
            <strong>{{ paragraph._source.text }}</strong>
          </div>
          <div v-else class="mui--text-body1">
            {{ paragraph._source.text }}	
          </div>
          <br>
        </div>
      </div>

      <!-- Book Pagination Footer -->
      <div class="modal-footer">
        <button class="mui-btn mui-btn--flat" v-on:click="prevBookPage()">Prev Page</button>
        <button class="mui-btn mui-btn--flat" v-on:click="closeBookModal()">Close</button>
        <button class="mui-btn mui-btn--flat" v-on:click="nextBookPage()">Next Page</button>
      </div>
    </div>


</div>
<script src="https://cdn.muicss.com/mui-0.9.28/js/mui.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.3/vue.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.17.0/axios.min.js"></script>
<script src="app.js"></script>
</body>
</html>
////////////////////////////////////////////////////////
////////////////// public/styles.css//////////////////
body { font-family: 'EB Garamond', serif; }

.mui-textfield > input, .mui-btn, .mui--text-subhead, .mui-panel > .mui--text-headline {
  font-family: 'Open Sans', sans-serif;
}

.all-caps { text-transform: uppercase; }
.app-container { padding: 16px; }
.search-results em { font-weight: bold; }
.book-modal > button { width: 100%; }
.search-results .mui-divider { margin: 14px 0; }

.search-results {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: space-around;
}

.search-results > div {
  flex-basis: 45%;
  box-sizing: border-box;
  cursor: pointer;
}

@media (max-width: 600px) {
  .search-results > div { flex-basis: 100%; }
}

.paragraphs-container {
  max-width: 800px;
  margin: 0 auto;
  margin-bottom: 48px;
}

.paragraphs-container .mui--text-body1, .paragraphs-container .mui--text-body2 {
  font-size: 1.8rem;
  line-height: 35px;
}

.book-modal {
  width: 100%;
  height: 100%;
  padding: 40px 10%;
  box-sizing: border-box;
  margin: 0 auto;
  background-color: white;
  overflow-y: scroll;
  position: fixed;
  top: 0;
  left: 0;
}

.pagination-panel {
  display: flex;
  justify-content: space-between;
}

.title-row {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

@media (max-width: 600px) {
  .title-row{ 
    flex-direction: column; 
    text-align: center;
    align-items: center
  }
}

.locations-label {
  text-align: center;
  margin: 8px;
}

.modal-footer {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: space-around;
  background: white;
}
//////////////////////////////////////////////////////
		最后 重建重启程序栈: sudo docker-compose up -d --build     (注意 手动删除多余的旧镜像)
		登录 http://localhost:8080/ 就可以体验到效果!!!!
	最后在项目文件夹里:
		sudo docker-compose stop	//停止整个 service ,就是关闭容器!
		sudo docker-compose up -d	//重新开启整个 service	 或者 sudo docker-compose stop

	
	参考:
		Docker 和 Elasticsearch 构建一个全文搜索应用程序 (上述例子参考尝试了):
			教程相当有启发性,还开拓的不小其他技能点!!!!,当然也有几个漏洞
			https://www.zcfy.cc/article/building-a-full-text-search-app-using-docker-and-elasticsearch
		docker简易搭建ElasticSearch集群: (未尝试集群)
			https://blog.csdn.net/belonghuang157405/article/details/83301937
	首先想学习到如何 实现 一个 docker 程序栈:
		即通过把需要使用的资源整合,然后通过脚本,自动创建运行容器集群,提供特定的服务!!
		一般我们模拟搭建一个网站会 使用多个docker容器来模拟多个服务器,然后集群生成服务!!
		一般手动过程繁琐复杂,但是通过 docker-compose 插件, 可以把手动过程简单集成到脚本文本,
		通过运行脚本即可 一键实现!
	










20190220
补全分布式任务计算运行系统主要 hadoop + spark:
hadoop 是一个分布式计算系统 主要包含 
	分布式存储的文件系统 HDFS
	节点管理辅助系统 yarn
	分布式计算单元架构 mapreduce
一个分布分布式系统意味着 可以通过 集群的的力量 实现庞大的数据分析处理
spark 是一个 成熟的分布式计算架构软件, 一般用于单纯的分布式计算,自身本来就是带有节点管理,
	使用 spark自身的节点管理执行分布式计算, 属于 standalone模式,
	而使用 hadoop 的 yarn 作为节点管理执行分布式计算是 另外的一种模式!!
	组合到 hadoop 使用 ,替代 mapreduce 分布计算架构,应用在特定的场景,工作效率更加高效,
		因为配合 hadoop 的 HDFS 等资源, 所以能实现更多复杂的 分布任务
Hbase 是运行再 HDFS 上的 非sql数据库 (key-value数据库)

接下来是 真实 hadoop 生产环境的集群搭建: (使用 docker 模拟)
准备环境(每个节点都有):
	建立一个新的局域网:
		sudo docker network create hadoop-spark-net --subnet=172.19.0.0/16 --ip-range=172.19.0.0/16 --gateway=172.19.0.1  
	查看目前为止的局域网络分配:
		sudo docker network ls
		NETWORK ID          NAME                         DRIVER              SCOPE
		c0855bb6075c        bridge                       bridge              local	"Subnet": "172.17.0.0/16"
		aec052958d73        electicsearch_test_default   bridge              local	"Subnet": "172.18.0.0/16"
		e9823d19d9bc        hadoop-spark-net             bridge              local	"Subnet": "172.19.0.0/16"
		ffcc34d472a4        host                         host                local	null
		5010361fce5e        mongodb-net                  bridge              local	"Subnet": "172.23.0.0/16"
		4a6c0cd999bd        none                         null                local	null
		c3c65c6eed73        pxc-net                      bridge              local	"Subnet": "172.22.0.0/16
	创建 3个 容器节点 hdsp_m hdsp_w1 hdsp_w2
		sudo docker run -d --privileged=true --network=hadoop-spark-net --ip=172.19.0.2 -itd -h hadoopsparkmaster --add-host=hadoopsparkworker1:172.19.0.3 --add-host=hadoopsparkworker2:172.19.0.4 --name=hdsp_m centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=hadoop-spark-net --ip=172.19.0.3 -itd -h hadoopsparkworker1 --add-host=hadoopsparkmaster:172.19.0.2 --add-host=hadoopsparkworker2:172.19.0.4 --name=hdsp_w1 centos /usr/sbin/init
		sudo docker run -d --privileged=true --network=hadoop-spark-net --ip=172.19.0.4 -itd -h hadoopsparkworker2 --add-host=hadoopsparkmaster:172.19.0.2 --add-host=hadoopsparkworker1:172.19.0.3 --name=hdsp_w2 centos /usr/sbin/init 
			(-h 是定义一个hostname,不然一个乱码代替, 注意建立的容器不能修改 hostname
			[root@b39d369b1b11 /]# 	//未定义hostname 是一个乱码
			[root@hadoopspark_master /]# 	//定义hostname 后  
			三个节点组成的集群网络需要 互相认识对方的 IP , 
			--add-host 是添加对方机子的 IP 映射, 到容器的 /etc/hosts 文件里
			建立好的 /etc/hosts 是不能修改,所以只能 docker run 时候 设置好!!
			)
	查看容器的 hosts 可以看到: vi /etc/hosts
		172.19.0.2      hadoopspark_master
		172,19.0.3      hadoopspark_worker1
		172.19.0.4      hadoopsaprk_worker2
	需要安装 ssh 并实现三节点 无密登录 (方便后面的集群配置)
		安装 ssh :yum install openssh-server openssh-clients -y
		开启公钥验证 vi /etc/ssh/sshd_config  添加:   
			PubkeyAuthentication yes	
		容器需要修改 root 密码,用于远程ssh登录: echo 'root:123456'|chpasswd
			容器建立时都被随机建立的 root 密码.需要自己更换回自己知道的密码
		每台节点 生成公钥、私钥: 执行ssh-keygen -t rsa	//一律回车,不需要设置 自身ssh 密码,(注意此密码不是 远程用户登录密码)
//////////////////////////////  ssh-keygen -t rsa  (log) ///////////////////////////
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:EKPDf+4spHKrPxgfbLNXK4AUpW00E+69P+XgS4ykIS4 root@hadoopspark_master
The key's randomart image is:
+---[RSA 2048]----+
|   .*.o          |
|  .* + o         |
|  ..B .          |
|  .o + .         |
| ..oo + S        |
| .o.*+.*o .      |
|E .=.Boo+=       |
| .o * +=+ .      |
|  .=o+ o=o       |
+----[SHA256]-----+
//////////////////////////////  ssh-keygen -t rsa  (log) ///////////////////////////
		实现登录自己免密:
		把自己的公钥id_rsa.pub放入到自己的认证文件中authorized_keys:
			systemctl start sshd	//需要先启动 sshd 服务,
			chmod 700 /root/	//一定要对 以下文件目录 做权限处理,不然免密登录失败 要求输入 远程用户的密码
			chmod 700 /root/.ssh/	//一定要对 以下文件目录 做权限处理,不然免密登录失败 要求输入 远程用户的密码	 
			ssh-copy-id root@localhost	//获得自己的 公钥考到自己的 认证文件authorized_keys
		这时,自己登录自己 ssh root@localhost  第一次需要输入密码, 以后的都不需要了!!	
		实现登录 远程节点 免密:
			ssh-copy-id root@172.19.0.3	//获取运程机子的ssh 公钥!
			ssh root@172.19.0.3	//然后就可以免密登录远程ssh
		以此类推,建立 3个节点 可以互免密登录 !!
	安装 java8 (注意 只能是java8, 因为 hadoop 到目前 20190304,我使用的 3.2 版本依然是基于 java8)
		yum 装 java  (省事)
		先 java -version 查看已安装的,如果有安装的,如果版本太低就选择卸载:
		yum -y remove java-1.7.0-openjdk*  //卸载旧的 jdk
		yum -y list java*  //查看软件库的 java版本更新 情况
		yum -y install java-1.8-openjdk*	   //安装查看到的新的 jdk
		寻找 JAVA_HOME 的集体位置: 
		whereis javac
			javac: /usr/bin/javac /usr/share/man/man1/javac.1.gz
		ll /usr/bin/javac    // 查看 /usr/bin/javac 软链接到啥位置
			lrwxrwxrwx 1 root root 23 Feb 27 02:37 /usr/bin/javac -> /etc/alternatives/javac
		ll  /etc/alternatives/javac
		lrwxrwxrwx 1 root root 63 Feb 27 02:37 /etc/alternatives/javac -> /usr/lib/jvm/java-1.8-openjdk-xxxxxxx.x86_64/bin/javac
		这时,JAVA_HOME 的位置 应该就是 : /usr/lib/jvm/java-1.8-openjdk-xxxxxxxxxx.el7_6.x86_64
	安装其他 工具:
		yum -y install rsync wget
准备hadoop3.2:(一般装master节点,然后配置好, 把整个hadoop打包拷贝到从节点解压,不建议从节点重新安装和重新配置):
	在 root/software 下载: wget http://mirror.cogentco.com/pub/apache/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz
	然后解压得 hadoop-3.2.0 : tar -zxf /root/software/hadoop-3.2.0.tar.gz -C /root
	更改目录名: mv hadoop-3.2.0 hadoop
	添加 系统环境变量: vi /etc/profile
		#hadoop
		HADOOP_HOME=/root/hadoop/
		PATH=$HADOOP_HOME/bin:$PATH
		export PATH HADOOP_HOME
	环境变量生效 :	source /etc/profile
简单配置 hadoop 启动使用:
	正常启动所必须的设置项： hadoop-env.sh slaves、core-site.xml、hdfs-site.xml、mapred-site.xml、yarn-site.xml
	参数参考:
		https://hadoop.apache.org/docs/r2.4.1/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml
		https://hadoop.apache.org/docs/r2.6.0/hadoop-project-dist/hadoop-common/core-default.xml
		https://hadoop.apache.org/docs/r3.2.0/   //左下角 configuration
	master节点(容器):
//////////////////////////  简单启动 hadoop 的配置  (master节点) //////////////////////////////////////////
vi /root/hadoop/etc/hadoop/hadoop-env.sh	//添加 java_home 环境变量
export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/	


vi /root/hadoop/etc/hadoop/core-site.xml
<configuration>
    <property>
        <name>fs.default.name</name>			//hdfs 的根节点入口
        <value>hdfs://172.19.0.2:9000</value>
        <description> uri of HDFS, hdfs://namenode_name:port</description>
    </property>
    <property>
        <name>hadoop.tmp.dir</name>			//hdfs 实际放置数据映射到机子的文件夹位置
        <value>/root/hadoop/tmp</value>
        <description>temp files folder of namenode </description>
    </property>
    <property>
        <name>fs.defaultFS</name>			//还是 hdfs 的根节点入口
        <value>hdfs://172.19.0.2:9000</value>
    </property>
</configuration>


vi /root/hadoop/etc/hadoop/hdfs-site.xml	
<configuration>
    <property>
        <name>dfs.namenode.secondary.http-address</name>
        <value>172.19.0.2:50090</value>			//用户监视 hdfs 的入口
    </property>
    <property>
        <name>dfs.replication</name>			//有的说是数据备份数.有说是分布集群放数据的物理节点数
        <value>3</value>
    </property>
    <property>
        <name>dfs.namenode.name.dir</name>		//主节点的信息的数据的物理节点存放	
        <value>file://${hadoop.tmp.dir}/dfs/name</value>
    </property>
    <property>
        <name>dfs.datanode.data.dir</name>		//数据节点的信息的数据的物理节点存放
        <value>file://${hadoop.tmp.dir}/dfs/data</value>
    </property>
</configuration>
dfs.namenode.name.dir注意与 dfs.name.dir 是有区别的
dfs.datanode.data.dir 和 dfs.data.dir 同理
注意 查看官方 config 文件 斌没有  dfs.data.dir dfs.name.dir 这两项


vi /root/hadoop/etc/hadoop/mapred-site.xml		//map分布计算架构单元配置
<configuration>
    <property>
        <name>mapreduce.framework.name</name>		//使用 yarn 节点管理系统
        <value>yarn</value>
    </property>
    <property>
        <name>mapreduce.jobhistory.address</name>	//查看 计算任务历史信息 的入口
        <value>172.19.0.2:10020</value>
    </property>
    <property>
        <name>mapreduce.jobhistory.webapp.address</name>	//查看 计算任务历史信息 的浏览器管理入口
        <value>172.19.0.2:19888</value>
    </property>
</configuration>
注意 新版本没有 mapred.job.tracker, mapred.local.dir


vi /root/hadoop/etc/hadoop/yarn-site.xml
<configuration>
<!-- Site specific YARN configuration properties -->
    <property>
        <name>yarn.resourcemanager.hostname</name>	//yarn 节点管理服务的 主节点
        <value>172.19.0.2</value>
    </property>
    <property>
        <name>yarn.nodemanager.aux-services</name>	//附加 服务 mapreduce_shuffle,纤细谷歌!!
        <value>mapreduce_shuffle</value>
    </property>
</configuration>


vi /root/hadoop/etc/hadoop/workers	//旧版hadoop是 slaves 文件, 表示那些机子提供 worker 服务!!
172.19.0.2			//注意表示 master 容器下 也提供一个 worker 服务, master 和 worker 服务共存把并不冲突
172.19.0.3			//一般填写 ip 或者 映射ip的 hostname, 一行一个	
172.19.0.4


添加 hadoop自己的环境变量
vi /root/hadoop/etc/hadoop/hadoop-env.sh
export HDFS_NAMENODE_USER=root
export HDFS_DATANODE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export HDFS_JOURNALNODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
export YARN_NODEMANAGER_USER=root
\\\\\\\\\\\\\\\\\\\\\\\\\\  简单启动 hadoop 的配置  (master节点) \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
	worker节点:
		(把配置好的 master 节点 的 hadoop 直接打包拷贝到 我让可燃节点)
		master:
			cd /root
			tar zcf hadoop.tar.gz hadoop
			scp hadoop.tar.gz root@172.19.0.3:/root
			scp hadoop.tar.gz root@172.19.0.4:/root
		worker1 worker2 节点:
			cd /root
			tar -zxf hadoop.tar.gz
		简单启动,并不需要 worker 节点继续深入配置 hadoop
		修改和 master节点同样的 /etc/profile 环境变量!!!
	启动:
		首次启动需要先在 Master 节点执行 NameNode 的格式化
			hdfs namenode -format
		然后继续在 master 节点:
			start-dfs.sh
			start-yarn.sh
			mapred --daemon start historyserver
		成功后: 可以查看:
			[root@hadoopsparkmaster ~]# jps
			22035 NodeManager		//yarn 从服务
			21205 NameNode			//hdfs 主服务
			10716 DataNode			//hdfs 从服务	workers文件也是设置了自己ip得到
			21898 ResourceManager		//yarn 主服务
			22490 JobHistoryServer		//任务历史管理服务 
			21515 SecondaryNameNode		//hdfs 主服务备用
			22559 Jps
			[root@hadoopsparkworker1 ~]# jps
			11002 Jps
			10796 NodeManager		//yarn 从服务
			10716 DataNode			//hdfs 从服务
		继续查看技巧:
			//查看 官方默认configuration  
			//	https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml
			//得知各个监视端口的使用
			网页打开 172.19.0.2:9870 查看	//查看 官方默认configuration得知
			网页打开 172.19.0.2:8088 查看	
			网页打开 172.19.0.2:50070 查看
			网页打开 172.19.0.2:9000 查看
	测试:
		尝试执行一个分布式任务!!
		首先创建 HDFS 上的用户目录：
			hdfs dfs -mkdir -p /user/root     //由于没有创建用户 机子属于 root 用户的 所以 需要这样子
		将 /root/hadoop/etc/hadoop 中的配置文件作为输入文件复制到分布式文件系统中
			hdfs dfs -mkdir input		//如果没有 -mkdir /user/root ,这条不会成功
			hdfs dfs -put /root/hadoop/etc/hadoop/*.xml input
		接着就可以运行 MapReduce 作业了：
		hadoop jar /root/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+'
		出错 ,需要设置 HADOOP_MAPRED_HOME (所有节点都有)
			vi /root/hadoop/etc/hadoop/mapred-site.xml
			    <property>
			        <name>yarn.app.mapreduce.am.env</name>
			        <value>HADOOP_MAPRED_HOME=/root/hadoop/</value>
			    </property>
			    <property>
			        <name>mapreduce.map.env</name>
			        <value>HADOOP_MAPRED_HOME=/root/hadoop/</value>
			    </property>
			    <property>
			        <name>mapreduce.reduce.env</name>
			        <value>HADOOP_MAPRED_HOME=/root/hadoop/</value>
			    </property>
		重新 运行例子程序
		hdfs dfs -rm input/* 			//*/  去掉原来的文件
		hdfs dfs -put /root/hadoop/etc/hadoop/*.xml input			//*/
		hadoop jar /root/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output 'dfs[a-z.]+'
		成功启动 测试 hadoop3.2

spark 替换 mapreduce 作为 hadoop 的分布式计算单元架构
	同样先 master 容器节点安装 spark
		配合 hadopp3.2 应该取哪个版本的 spark 比较 讲究:
			参考:http://dblab.xmu.edu.cn/blog/1307-2/
			究竟选择 in hadoop2.7 还是 without hadoop 的镜像,比较讲究,按道理我们应该选择 without hadoop的版本
			因为我们 安装了 hadoop3.2, 不需要spark安装时添附加的 hadoop 接口,
			但是 这里我们选择 in hadoop2.7 的版本,好像也没有出问题!!!
		获得镜像: wget https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz
		注意,这次尝试使用 spark-2.4.0-bin-hadoop2.7.tgz 自带 scala ,所以不需要自己安装scala 和配置 环境变量 SCALA_HOME
		安装:
			tar -zxf spark-2.4.0-bin-hadoop2.7.tgz -C /root
			cd /root
			mv spark-2.4.0-bin-hadoop2.7 spark
		更改环境变量:
			vi /etc/profile
				#spark
				export SPARK_HOME=/root/spark/
				export PATH=$SPARK_HOME/bin:$PATH
			使生效 source /etc/profile
		配置:
			cp /root/spark/conf/spark-env.sh.template /root/spark/conf/spark-env.sh
			vi /root/spark/conf/spark-env.sh
				export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/
				export SPARK_MASTER_HOST=172.19.0.2
				export HADOOP_CONF_DIR=/root/hadoop/etc/hadoop

			cp /root/spark/conf/slaves.template /root/spark/conf/slaves
			vi /root/spark/conf/slaves
				去掉 localhosts
				172.19.0.3
				172.19.0.4

	打包到 worker节点(slave节点)
		tar zcf spark.tar.gz spark
		scp spark.tar.gz root@172.19.0.3:/root
		scp spark.tar.gz root@172.19.0.4:/root	

	worker节点操作:
		解压 spark :
			cd /root
			tar -zxf spark.tar.gz

		环境变量:也有这样子:
			vi /etc/profile
				#hadoop
				HADOOP_HOME=/root/hadoop/
				PATH=$HADOOP_HOME/bin:$PATH
				export PATH HADOOP_HOME

				#spark
				export SPARK_HOME=/root/spark/
				export PATH=$SPARK_HOME/bin:$PATH
			使生效 source /etc/profile
	启动:
		先启动 hadoop 环境
			master容器:
			/root/hadoop/sbin/start-dfs.sh
			/root/hadoop/sbin/start-yarn.sh
			mapred --daemon start historyserver

		master 容器 启动 spark
			/root/spark/sbin/start-all.sh
			jps 发现 msater节点多了 master  worker节点多了worker 即成功
	测试:
		启动 Spark Shell (默认 standalone 模式)
			/root/spark/bin/spark-shell	//或者直接 spark-shell  因为注册了环境变量
			这样 默认 使用 standalone 模式, 即使用spark 自带的节点管理
			查看http://172.19.0.2:8080
			查看http://172.19.0.2:4040
		如果使用 yarn 节点管理模式 启动 spark shell
			spark-shell --master yarn
		执行 分布式任务!!! satndalone 模式
 			spark-submit --class org.apache.spark.examples.SparkPi --master spark://172.19.0.2:7077 /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar 100 2>&1 | grep "Pi is roughly"
			成功打印: Pi is roughly 3.1421811142181113 
		执行 分布式任务!!!  使用 hadoop的yarn节点管理 的模式
			spark-submit --class org.apache.spark.examples.SparkPi --master yarn-cluster /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar
			//被提醒 新版本 spark 只需要 --master yarn 写 即可
			spark-submit --class org.apache.spark.examples.SparkPi --master yarn /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar
			发现两种写法的 输出log 不太一致, 前者一个post到网端,后者post到 终端 
			中的来说,成功的,未发现异常
			点击 输出结果的网址(其中 URL) ,可以查看 更加详细的执行结果信息例如
				 client token: N/A
				 diagnostics: N/A
				 ApplicationMaster host: hadoopsparkmaster
				 ApplicationMaster RPC port: 39585
				 queue: default
				 start time: 1551345119522
				 final status: SUCCEEDED
				 tracking URL: http://hadoopsparkmaster:8088/proxy/application_1551340373862_0006/
				 user: root
		配合 hadoop HDFS 使用
			# 下面这条命令中，我们把spark安装目录下的README.md文件上传到分布式文件系统HDFS的根目录下
			hadoop fs -put /root/spark/README.md /
			# standalone 模式 进入 spark-shell
			spark-shell --master spark://172.19.0.2:7077	//spark://代表 standalone 模式
			输入代码: (成功, 表示 spark2.4 与 hadoop3.2 的 HDFS 还没有出现冲突!! )
			scala> val textFile = sc.textFile("hdfs://172.19.0.2:9000/README.md")
			textFile: org.apache.spark.rdd.RDD[String] = hdfs://172.19.0.2:9000/README.md MapPartitionsRDD[1] at textFile at <console>:24
			scala> textFile.count()
			res0: Long = 99                                                                 
			scala> textFile.first()
			res1: String = # Apache Spark
	测试可见:  spark2.4 与 hadoop3.2  集群暂时没有冲突问题!!!
	关闭集群:
		关闭 spark 集群:
			/root/spark/sbin/stop-all.sh
		关闭 hadoop 集群:
			mapred --daemon stop historyserver
			/root/hadoop/sbin/stop-yarn.sh
			/root/hadoop/sbin/stop-dfs.sh


zookeeper 实现 spark  standalone模式下的 高可用!!!!
	首先 master容器 安装配置 zookeeper
		获取镜像: wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.12/zookeeper-3.4.12.tar.gz
		安装:
			cd /root
			tar -zxf /root/software/zookeeper-3.4.12.tar.gz -C /root
			mv zookeeper-3.4.12/ zookeeper
		配置:
			mkdir zookeeper/data zookeeper/logs
			echo '0'>zookeeper/data/myid
			cp zookeeper/conf/zoo_sample.cfg zookeeper/conf/zoo.cfg
			vi zookeeper/conf/zoo.cfg
				dataDir=/root/zookeeper/data
				dataLogDir=/root/zookeeper/logs
				server.0= 172.19.0.2:2888:3888
				server.1= 172.19.0.3:2888:3888
				server.2= 172.19.0.4:2888:3888
		拷贝到 worker 节点
			tar zcf zookeeper.tar.gz zookeeper
			scp zookeeper.tar.gz root@172.19.0.3:/root
			scp zookeeper.tar.gz root@172.19.0.4:/root

	worker节点 安装和配置 zookeeper:
		tar -zxf zookeeper.tar.gz
		rm zookeeper/data/myid
		echo '1'>zookeeper/data/myid		//仅 172.19.0.3 (worker1)节点操作
		echo '2'>zookeeper/data/myid		//仅 172.19.0.4 (worker2)节点操作
	配置 spark , (所有容器都要):
		vi /root/spark/conf/spark-env.sh
			#export SPARK_MASTER_HOST=172.19.0.2（因为设置了zookeeper,所以这行不用了，注释掉）
			export SPARK_DAEMON_JAVA_OPTS="-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=172.19.0.2:2181,172.19.0.3:2181,172.19.0.4:2181 -Dspark.deploy.zookeeper.dir=/spark"

	启动:
		先启动zookeeper, 所有容易都要:
			/root/zookeeper/bin/zkServer.sh start
			//成功后 jps 可以看到 QuorumPeerMain
		master 节点启动 hadoop 集群:
			/root/hadoop/sbin/start-dfs.sh
			/root/hadoop/sbin/start-yarn.sh
			mapred --daemon start historyserver
		master 节点启动 spark 集群:
			/root/spark/sbin/start-all.sh
		worker节点都要 启动:
			/root/spark/sbin/start-master.sh	//即 worker节点 登记成为备用 master
	监视查看:
		ip:8080 端口 查看master状态
		ip:8081 端口 查看worker状态
		master 节点启动的master早 所以 查看master状态 Status: ALIVE 
		worker 节点启动的master晚 所以 查看master状态 Status: STANDBY 		
	测试:
		测试1
		172.19.0.3 节点启动 spark-shell  :   spark-shell --master spark://172.19.0.3:7077	
			//出错,不行的,因为 alive 的master是 172.19.0.2, 
			//不会自动转到 172.19.0.3 !!
		测试2
		172.19.0.3 节点启动 spark-shell  :   spark-shell --master spark://172.19.0.2:7077
			//成功
		关闭 172.19.0.2 的 master : /root/spark/sbin/stop-master.sh
			//这时 172.19.0.3 节点启动 spark-shell 出现: 正在 重连接备用master
			//scala> 2019-02-28 14:51:22 WARN  StandaloneAppClient$ClientEndpoint:66 - Connection to hadoopsparkmaster:7077 failed; waiting for master to reconnect...
			//2019-02-28 14:51:22 WARN  StandaloneSchedulerBackend:66 - Disconnected from Spark cluster! Waiting for reconnection...
		查看 0.3 节点 8080 端口 已经自动升为 master alive
		但是 spark-shell 还是没有重新自动转连成功的迹象 
		因为重链成功应该 出现 master has changed，new master is at spark://172.19.0.3:7077
		但是退出 连接 spark-shell --master spark://172.19.0.3:7077 会成功
		初步认为 配置没有到位, 节点可以 主备切换, 但是运行中被打断的任务 直接崩溃!!

		测试3
		现在alive msater是 0.3 节点
		0.2节点执行 : 
			spark-submit --class org.apache.spark.examples.SparkPi --master spark://172.19.0.3:7077 /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar
		同时 0.3节点执行 : /root/spark/sbin/stop-master.sh 关闭master,
		这时 运行中的程序会崩溃!!!!! 并不会切换 alive master 继续执行!! 

		测试4 
		假如 此刻 0.3 节点是 alive master, 
		0.2节点执行: spark-shell --master yarn
		同时 0.3节点执行 : /root/spark/sbin/stop-master.sh 关闭master,
		因为使用 hadoop yarn 节点管理!!!  
		所以 spark 自带的节点管理 崩溃 切换并不会影响到什么 !!!

		测试5
		假如 此刻 0.4 节点是 alive master, 
		0.3节点执行: 
		spark-submit --class org.apache.spark.examples.SparkPi --master yarn-cluster /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar
		同时 0.4节点执行 : /root/spark/sbin/stop-master.sh 关闭master,
		真的, 使用 yarn 后 alive master zookeeper 什么的就没有关系!!!, 程序照样运行!!!

		暂时得到的结果 zookeeper 实现的 standalone 模式高可用, 功能很有限!!!,或许是配置未到位!!!


zookeeper 对 hadoop 实现高可用,
	zookeeper 按上述已经部署好,所以跳过
	master 容器 继续配置 hadoop:
/////////////////////// master 配置 hadoop 配合 zookeeper 实现高可用 //////////////////////////
vi /root/hadoop/etc/hadoop/core-site.xml   添加
    <!-- 指定ZooKeeper集群的地址和端口。注意，数量一定是奇数，且不少于三个节点-->
    <property>
        <name>ha.zookeeper.quorum</name>
        <value>172.19.0.2:2181,172.19.0.3:2181,172.19.0.4:2181</value>
    </property>

vi /root/hadoop/etc/hadoop/hdfs-site.xml  
去掉:
    <property>
        <name>dfs.namenode.secondary.http-address</name>
        <value>172.19.0.2:50090</value>
    </property>
添加
  <!-- 指定副本数，不能超过机器节点数  -->
  <property>
    <name>dfs.replication</name>
    <value>3</value>
  </property>
  <!-- 为namenode集群定义一个services name -->
  <property>
    <name>dfs.nameservices</name>
    <value>whservice</value>
  </property>
  <!-- nameservice 包含哪些namenode，为各个namenode起名 -->
  <property>
    <name>dfs.ha.namenodes.whservice</name>
    <value>masterA,masterB</value>
  </property>
  <!-- 名为masterA的namenode的rpc地址和端口号，rpc用来和datanode通讯 -->
  <property>
    <name>dfs.namenode.rpc-address.whservice.masterA</name>
    <value>172.19.0.2:9000</value>
  </property>
  <!-- 名为masterB的namenode的rpc地址和端口号，rpc用来和datanode通讯 -->
  <property>
    <name>dfs.namenode.rpc-address.whservice.masterB</name>
    <value>172.19.0.3:9000</value>
  </property>
  <!--名为masterA的namenode的http地址和端口号，用来和web客户端通讯 -->
  <property>
    <name>dfs.namenode.http-address.whservice.masterA</name>
    <value>172.19.0.2:50070</value>
  </property>
  <!-- 名为masterB的namenode的http地址和端口号，用来和web客户端通讯 -->
  <property>
    <name>dfs.namenode.http-address.whservice.masterB</name>
    <value>172.19.0.3:50070</value>
  </property>
  <!-- namenode间用于共享编辑日志的journal节点列表 -->
  <property>
    <name>dfs.namenode.shared.edits.dir</name>
    <value>qjournal://172.19.0.2:8485;172.19.0.3:8485;172.19.0.4:8485/whservice</value>
  </property>
  <!-- 指定该集群出现故障时，是否自动切换到另一台namenode -->
  <property>
    <name>dfs.ha.automatic-failover.enabled.whservice</name>
    <value>true</value>
  </property>
  <!-- journalnode 上用于存放edits日志的目录 -->
  <property>
    <name>dfs.journalnode.edits.dir</name>
    <value>/root/hadoop/tmp/data/dfs/journalnode</value>
  </property>
  <!-- 客户端连接可用状态的NameNode所用的代理类 -->
  <property>
    <name>dfs.client.failover.proxy.provider.whservice</name>
    <value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>
  </property>
  <!-- 一旦需要NameNode切换，使用ssh方式进行操作 -->
  <property>
    <name>dfs.ha.fencing.methods</name>
    <value>sshfence</value>
  </property>
  <!-- 如果使用ssh进行故障切换，使用ssh通信时用的密钥存储的位置 -->
  <property>
    <name>dfs.ha.fencing.ssh.private-key-files</name>
    <value>/root/.ssh/id_rsa</value>
  </property>
  <!-- connect-timeout超时时间 -->
  <property>
    <name>dfs.ha.fencing.ssh.connect-timeout</name>
    <value>30000</value>
  </property>


vi /root/hadoop/etc/hadoop/yarn-site.xml
去掉:
    <property>
        <name>yarn.resourcemanager.hostname</name>
        <value>172.19.0.2</value>
    </property>
添加
  <!-- 启用HA高可用性 -->
  <property>
    <name>yarn.resourcemanager.ha.enabled</name>
    <value>true</value>
  </property>
  <!-- 指定resourcemanager的名字 -->
  <property>
    <name>yarn.resourcemanager.cluster-id</name>
    <value>yrm</value>
  </property>
  <!-- 使用了2个resourcemanager,分别指定Resourcemanager的地址 -->
  <property>
    <name>yarn.resourcemanager.ha.rm-ids</name>
    <value>rm1,rm2</value>
  </property>
  <!-- 指定rm1的地址 -->
  <property>
    <name>yarn.resourcemanager.hostname.rm1</name>
    <value>172.19.0.2</value>
  </property>
  <!-- 指定rm2的地址  -->
  <property>
    <name>yarn.resourcemanager.hostname.rm2</name>
    <value>172.19.0.3</value>
  </property>
  <!-- 指定当前机器masterA作为rm1 -->
  <property>
    <name>yarn.resourcemanager.ha.id</name>
    <value>rm1</value>
  </property>
  <!-- 指定zookeeper集群机器 -->
  <property>
    <name>yarn.resourcemanager.zk-address</name>
    <value>172.19.0.2:2181,172.19.0.3:2181,172.19.0.4:2181</value>
  </property>
  <!-- NodeManager上运行的附属服务，默认是mapreduce_shuffle -->
  <property>
    <name>yarn.nodemanager.aux-services</name>
    <value>mapreduce_shuffle</value>
  </property>
\\\\\\\\\\\\\\\\\\\\\\\ master 配置 hadoop 配合 zookeeper 实现高可用 \\\\\\\\\\\\\\\\\\\\\\\\\\

	清空 之前的数据:(所有节点)
		rm -rf /root/hadoop/logs/*			//*/
		rm -rf /root/hadoop/tmp/*			//*/
		合并: rm -rf /root/hadoop/tmp/* /root/hadoop/logs/*       //*/
	重置其他 worker 节点的 hadoop!!!
		master节点:
			cd /root
			rm -rf hadoop.tar.gz
			tar zcf hadoop.tar.gz hadoop
			scp hadoop.tar.gz root@172.19.0.3:/root
			scp hadoop.tar.gz root@172.19.0.4:/root	
		worker节点:
			rm -rf hadoop.tar.gz
			rm -rf hadoop
			tar -zxf hadoop.tar.gz
	worker节点 深入修改配置:
		worker1节点:
		vi /root/hadoop/etc/hadoop/yarn-site.xml
		修改
		  <property>
		    <name>yarn.resourcemanager.ha.id</name>
		    <value>rm2</value>
		  </property>

		worker2节点:
		vi /root/hadoop/etc/hadoop/yarn-site.xml
		删除:
		  <property>
		    <name>yarn.resourcemanager.ha.id</name>
		    <value>rm1</value>
		  </property>

	为了实现 ssh 的故障转移,还需要 fuser (所以节点都要检查!!)
		缺少fuster程序，将在zkfc的日志文件中发现如下错误：
		PATH=$PATH:/sbin:/usr/sbin fuser -v -k -n tcp 9000 via ssh: bash: fuser: 未找到命令
		Unable to fence service by any configured method
		java.lang.RuntimeException: Unable to fence NameNode at master189/192.168.29.189:9000
		Psmisc软件包中包含了fuster 所有节点安装 psmisc
		yum install psmisc
	启动:
		所有节点启动zookeeper:
			/root/zookeeper/bin/zkServer.sh start	
				// /root/zookeeper/bin/zkServer.sh status 可以查看zookeeper节点运行状态!!!
		格式化 同步 集群:
			所有节点启动Journalnode  (格式化namenode时要先启动各个JournalNode机器上的journalnode进程)
				hdfs --daemon start journalnode		
			master (即masterA)节点 格式化 NameNode和ZKFC
				hdfs namenode -format
				hdfs zkfc -formatZK
			worker1(即masterB)备用节点 同步主节点数据, 
				在备用主节点同步主节点的元数据时，主节点的 HDFS 必须已经启动, 即主节点namenode启动
				因为同步需要接到 master的 9000 端口 实现数据同步,
				所以首先 master先运行namenode:	hdfs --daemon start namwnode
				worker1节点 执行同步:		hdfs namenode -bootstrapStandby
				然后 master节点关闭 namenode:	hdfs --daemon stop namwnode
		启动 hadoop 集群:
			master节点启动:
				/root/hadoop/sbin/start-dfs.sh
				/root/hadoop/sbin/start-yarn.sh
				hdfs --daemon start zkfc
			worker1节点启动:
				hdfs --daemon start zkfc 	//不然 namenode 节点不能实现热备转移
	监视检查成功启动后的内容:
		jps 查看成功启动后的进程栈:
			master(masterA):jps
				23282 Jps
				21526 NameNode		// master start-dfs 打开的
				21671 DataNode		// master start-dfs 打开的
				8200 QuorumPeerMain	// master zkServer.sh start 打开的
				22586 NodeManager	// master start-yarn 打开的
				21933 JournalNode	// master start-dfs 重新打开的
				17181 DFSZKFailoverController	//master hdfs --daemon start zkfc
				22446 ResourceManager	// master start-yarn 打开的
			worker1(masterB):jps
				25663 Jps
				24934 DataNode		// master start-dfs 打开的
				25191 ResourceManager	// master start-yarn 打开的
				18055 QuorumPeerMain	// worker1 zkServer.sh start 打开的
				25273 NodeManager	// master start-yarn 打开的
				25037 JournalNode	// master start-dfs 重新打开的
				24845 NameNode		// master start-dfs 打开的
				24270 DFSZKFailoverController	//worker1 hdfs --daemon start zkfc 打开的
			worker2:jps
				16293 Jps
				16016 JournalNode	// master start-dfs 重新打开的
				16130 NodeManager	// master start-yarn 打开的
				13365 QuorumPeerMain	// worker2 zkServer.sh start 打开的
				15913 DataNode		// master start-dfs 打开的
		查看 hadoop状态 信息
			hdfs haadmin -getServiceState masterA		//alive 表示 0.2节点 dfs namenode 活跃态
			yarn rmadmin -getServiceState rm1 		//stanby 表示 0.2节点 yarn ResourceManager 预备态 
			hdfs haadmin -getServiceState masterB		//stanby 表示 0.3节点 dfs namenode 预备态
			yarn rmadmin -getServiceState rm2		//alive 表示 0.3节点 yarn ResourceManage 活跃态	
	测试:(热备转义 高可用重要功能)
		关闭 masterA namenode:
			hdfs --daemon stop namenode
			masterB 的 namenode 变成 alive !!
			//注意到: 当 worker1(masterB)节点 没有启动 hdfs --daemon start zkfc
			//这时, 如果 masterB 的 namenode 是standby态,那 就永远都是 standby 态, 不会进行热备转移!! 
		关闭 masterB resourcemanager:
			yarn --daemon stop resourcemanager
			发现 masterA 的 resourcemanager 变成 alive
		所以 hadoop + zookeeper 高可用集群 成功部署 搭建
	关闭集群:
		masterA:
			/root/hadoop/sbin/stop-yarn.sh
			/root/hadoop/sbin/stop-dfs.sh
		masterA, masterB(worker1) 
			hdfs --daemon stop zkfc
		masterA, masterB(worker1), worker2
			/root/zookeeper/bin/zkServer.sh stop
	(重新)打开集群:(注意,不再需要首先每个节点独立打开JournalNode, start-dfs 自会实现!!)
		masterA, masterB(worker1), worker2
			/root/zookeeper/bin/zkServer.sh start
		masterA:
			/root/hadoop/sbin/start-dfs.sh
			/root/hadoop/sbin/start-yarn.sh
		masterA, masterB(worker1)
			hdfs --daemon start zkfc

zookeeper 实现 集群高可用的分析:
	zookeeper 自身状态 与 zookeeper 监视 的 dfs 和 yarn 的节点状态 是 互不相干的!
	zkServer.sh status 监视 zookeeper自身状态  masterA  masterB 节点都是 follower  worker2 是 leader
	hdfs haadmin -getServiceState ,, 表示 dfs节点管理服务的状态: masterA alive , masterB standby
	yarn rmadmin -getServiceState .. 表示 yarn节点管理服务的状态: masterA standby , masterB alive
	所以所 dfs yarn 热备变换时  跟 zookeeper 自身状态如何,没有关系, 依然masterA,masterB>follower,  worker2>leader
	zookeeper状态变化 除非是自身异常引起,与 dfs yarn 无关
	zookeeper 监视 dfs 和 yarn 又是独立监视的,
		dfs 节点管理服务对应 namenode 进程
		yarn 节点管理服务对应 resourcemanager 进程
		dfs主节点挂了 ,zookeeper会更换 dfs 的主节点, 不会影响 当前的 yarn 状态
		相反同理!!!!


hadoop高可用下 加入 Hbase 数据库
	master节点安装
		hbase是 hadoop 专门数据库, 使用 hbase-2.1.3 
		wget http://www.trieuvan.com/apache/hbase/2.1.3/hbase-2.1.3-bin.tar.gz
		cd /root
		tar -zxf /root/software/hbase-2.1.3-bin.tar.gz -C /root
		mv hbase-2.1.3/  hbase/
		配置:
//////////////////// master 节点 hadoop高可用下 配置 Hbase //////////////////
vi /root/hbase/conf/hbase-env.sh
//配置JDK
export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.191.b12-1.el7_6.x86_64/	
//保存pid文件
export HBASE_PID_DIR=/root/hbase/pids
//修改HBASE_MANAGES_ZK，禁用HBase自带的Zookeeper，因为我们是使用独立的Zookeeper
export HBASE_MANAGES_ZK=false


vi /root/hbase/conf/hbase-site.xml
<configuration>
  <!-- 设置HRegionServers共享目录，请加上端口号 -->
  <property>
    <name>hbase.rootdir</name>
    <value>hdfs://172.19.0.2:9000/hbase</value>
  </property>

  <!-- 指定HMaster主机 -->		//可能出问题的地方
  <property>
    <name>hbase.master</name>
    <value>hdfs://172.19.0.2:60000</value>
  </property>

  <!-- 启用分布式模式 -->
  <property>
    <name>hbase.cluster.distributed</name>
    <value>true</value>
  </property>

  <!-- 指定Zookeeper集群位置 -->
  <property>
    <name>hbase.zookeeper.quorum</name>
    <value>172.19.0.2:2181,172.19.0.3:2181,172.19.0.4:2181</value>
  </property>

  <!-- 指定独立Zookeeper安装路径 -->
  <property>
    <name>hbase.zookeeper.property.dataDir</name>
    <value>/root/zookeeper</value>
  </property>

  <!-- 指定ZooKeeper集群端口 -->
  <property>
    <name>hbase.zookeeper.property.clientPort</name>
    <value>2181</value>
  </property>
</configuration>

vi /root/hbase/conf/regionservers
172.19.0.2
172.19.0.3
172.19.0.4

创建pid文件保存目录
mkdir /root/hbase/pids

\\\\\\\\\\\\\\\\\\\\ master 节点 hadoop高可用下 配置 Hbase \\\\\\\\\\\\\\\\\\
		拷贝到 worker 节点
			tar zcf hbase.tar.gz hbase
			scp hbase.tar.gz root@172.19.0.3:/root
			scp hbase.tar.gz root@172.19.0.4:/root

	worker节点 处理:
		tar -zxf hbase.tar.gz
	启动: 
		注意:在 namenode resourcemanager 均为 active 的节点,且是hbase.master 指定的节点 启动 Hbase !! 
		(即要求此刻 active 主节点 是 masterA, 在masterA 启动 Hbase)
		/root/hbase/bin/start-hbase.sh
		备用主节点也要启动 HMaster 进程，作为备用HMaster： (此刻standby主节点是masterB)
		/root/hbase/bin/hbase-daemon.sh start master

		成功后,jps 
			masterA 多了 HRegionServer Hmaster 
			masterB 多了 HRegionServer Hmaster
			worker2 多了 HRegionServer
	
		最后启动多个集群, 内存消耗特大, 需要 16G 内存 !!!!
	测试:
		测试 Hbase 高可用:
			由于 hadoop 高可用下使用 Hbase,所有 Hbase 默认高可用 : 
			172.19.0.2:16010 可以看到作为 hbase master , 172.19.0.2:16010 可以看到作为 hbase backup master ,
			kill 掉 0.2 的 Hmaster, 0.3 就成了 主master
			注意 : jps 显示 的是 执行java 的进程 和 进程pid ,所以可以通过 kill pid 来关闭进程!!
		打开 Hbase
			/root/hbase/bin/hbase shell	//任意一机都可以 通过客户端 登录 hbase 数据库 !!
		hbase 的 数据库操作命令测试:
			//查看当前HBase有哪些表
			hbase(main):> list
			//创建表t_user，cf1和cf2是列族，列族一般不超过3个
			hbase(main):> create 't_user','cf1','cf2'
			//获得表t_user的描述信息
			hbase(main):> describe 't_user'
			//禁用表
			hbase(main):> disable 't_user'
			//删除表，删除表之前要先把表禁用掉
			hbase(main):> drop 't_user'
			//查询表是否存在
			hbase(main):> exists 't_user'
			//查看全表数据
			hbase(main):> scan 't_user'
			//插入数据，分别是表名、key、列（列族：具体列）、值。HBase是面向列的数据库，列可无限扩充
			hbase(main):> put 't_user' ,'001','cf1:name','chenxj'
			hbase(main):> put 't_user' ,'001','cf1:age','18'
			hbase(main):> put 't_user' ,'001','cf2:sex','man'
			hbase(main):> put 't_user' ,'002','cf1:name','chenxj'
			hbase(main):> put 't_user' ,'002','cf1:address','fuzhou'
			hbase(main):> put 't_user' ,'002','cf2:sex','man'
			//获取数据，可根据key、key和列族等进行查询
			hbase(main):> get 't_user','001'
			hbase(main):> get 't_user','002','cf1'
			hbase(main):> get 't_user','001','cf1:age'
	
hadoop高可用下 使用 spark 分布计算架构
	假设 hadoop hbase 的已经在高可用配置下打开,
	
	启动spark: (其实并不需要.因为启动的不是我们想象中的spark,而是 spark 的自带节点管理系统)
		masterA节点(0.2节点)
			/root/spark/sbin/start-all.sh	
			0.2 多了 master , 0.3,0.4 多了 workeer
		masterB 节点
			/root/spark/sbin/start-master.sh
			0.3 多了master
		这时,其实spark 自身节点管理也被 zookeeper 监视着,能实现高可用
	测试
		masterA节点 启动 spark shell 利用高可用的 yarn节点管理器
			spark-shell --master yarn  (成功) 因为使用 yarn 节点管理,不是使用自身节点管理
			而接上 shell 后 yarn dfs 的active主节点崩溃, 并不会断开 shell ,还可以做简单工作,但是就应该不能做分布计算任务了
		kill 掉 masterA (0,2节点) 的 master (spark的自带节点管理的 master) 然后
			spark-shell --master spark://172.19.0.2:7077	(失败) 因为0.2的spark自带节点管理已被kill, 强制接入会出错
			spark-shell --master spark://172.19.0.3:7077	(成功) 因为spark自身节点管理高可用模式已被zookeeper监视,0.3的spark自带节点管理 alive
			这时, 启动 0.2 的 spark master kill 掉 0.3 的saprk master
			在 热备转变过程中 spark-shell 只是出标示了,但是没有自动断开,还是可以工作,
			但是 我们 也把0.2 的master kill 了后 , spark-shell 依然能工作!!!!!!!(这就比较神奇了)
			可能是 master 未断开前便分配了 计算单元, 即使所有master 挂了 但是计算单元的连接还没有挂!!!
		测试分布计算任务
			spark-submit --class org.apache.spark.examples.SparkPi --master yarn-cluster /root/spark/examples/jars/spark-examples_2.11-2.4.0.jar
			发现实际上的高可用 不能的发生在 分布计算任务正在进行时的状态!!
			就是说 分布计算任务正在进行时,发生主备切换会 计算任务直接失败

		结论: 目前测试 hadoop 实现的高可用能力还是很有限的,主要是正在运行的分布计算,再主节点突然崩溃切换时会直接 死掉,
			不会自动转换链接并继续
		注意 这里 我们会发现 zookeeper 分别独立地管理了 三个高可用节点集群
			dfs 节点集群
			yarn 节点集群
			hbase 节点集群!!
			spark 自带的节点管理集群
		
继续 要了解 hadoop 的其他 可用组件:
	storm 跟 spark 一样都是 分布计算单元 但是内核设计理念不一样,处理不同背景下的计数,各有效率差异!!
	hbase 是一个 在 hdfs文件系统 上的 一个key-value数据库(非关系数据库!!)
	hue 是一个可视化ui 操作 HDFS
	hive 是 把 存在 hdfs文件系统的文件 看作像 sql 数据表上的数据 那样的结构,通过 sql 语言来 管理 hdfs 上 的文件 !!!
		应用场景
			Hive适合用来对一段时间内的数据进行分析查询，
				例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。
			hive表中的数据 就是hdfs目录中的文件。按表名把文件夹分开。
				如果是分区表，则分区值是子文件夹，可以直接在M/R job里使用这些数据.
			hive数据分为真实存储的数据和元数据:
		真实数据存储在hdfs中，元数据存储在mysql中
		metastore 元数据存储数据库
		Hive将元数据存储在数据库中，如MySQL、derby。
		Hive中的元数据包括表的名字，表的列和分区及其属性，表的属性（是否为外部表等），表的数据所在目录等。
		工作方式: 机子A 安装了hive ,输入了获取 hdfs 所有名字有9的文件!!
			于是hive 转换成 mapreduce 程序在hadoop集群执行, 最后得到的数据 返回机子A 的 hive 生成一张数据表
			输入到 机子A的 mysql 数据库里!!
	Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。
	Sqoop：用于传统数据库与HBase数据转移存储，即利用Sqoop可以将传统数据库上的数据转移到Hbase上，反之亦可。
	Flume：可以进行海量数据日志采集，聚合、传输系统
	Mahout：方便机器学习，数据挖掘，提供很多可扩展算法
	Zeppelin: 以笔记本（notebook）的形式组织和管理交互式数据探索任务

重点填坑记录:
	namwnode 自身不能作为 Datanode, 即 namenode和 datanode 不共存??
		最后,怀疑是 etc/hadoop/worker 文件设置问题引起,每个节点的 worker文件设置应该一致
		还有不应该使用 localhost 这个host, 往往会导致集群冲突 而出现这个问题 !!!! 
	还有过多使用 格式化 namenode 导致 hadoop 启动失败
		因为 格式化 只格式化了 master 的 namenode, 并没有 同步到 worker 的Datanode,
		所以失败,办法是清空 worker 节点 数据,例如这里是清空 tmp 文件夹	
	打开 Hbase 失败:Hmaster 自动挂!!
		jps  发现 都多出 HRegionServer
		但是 Hmaster 挂了 !!!!
		check log: vi /root/hbase/logs/....hoopmaster.log 
		发现 HBase Operation category READ is not supported in state standby
		其实就是 没有在 合适的 节点 启动的问题!!!! 配合 active namenode 还有 hbase-site.xml hbase.rootdir hbase.master 才可以成功!!
		https://blog.csdn.net/tiandd12/article/details/53928090
		即 hbase-site.xml hbase.rootdir hbase.master 设置的 是 正在 alive 的 namenode ,这样 Hbase 才可以正常启动
///////////////////////   hadoop + zookeeper  调试 记录     ////////////////////////////

	注意此刻应该 master 和 worker1 都可以 jps 到 namenode!!!!
	因为 同步namenode 时候不成功!! hdfs namenode -bootstrapStandby 中 bootstrapStandby 缺了个d
	所以最后没有同步,导致最后 只 打开了 master 这个namenode, worker1 的没有打开

重新
格式化 先关掉所有,删掉所有产生的数据
rm -rf /root/hadoop/tmp/* /root/hadoop/logs/*		//*/
重新,先全部节点 打开 hdfs --daemon start journalnode
等待 10秒 直到 journalnode 完全打开,才可以格式化节点
0.2 节点格式化: 
	hdfs namenode -format
	hdfs zkfc -formatZK
然后 0.3 节点 同步 0.2 节点的 namenode, 	hdfs namenode -bootstrapStandby
但是出错说 连不上 0.2:9000 端口, 这个端口是 dfs 启动后才提供的 感觉跟说的不一样,
0.2 节点先得启动 dfs: /root/hadoop/sbin/start-dfs.sh, (只启动 0.2的namenode)
0.3 节点然后执行 同步 hdfs namenode -bootstrapStandby
0.2 节点 关闭 dfs 再重新 打开 dfs,
这时,就会 打开 (0.2 和 0.3 的 namenode !!!)


关闭 masterA namenode:
hdfs --daemon stop namenode
masterB 的 namenode 依然是 standby,,,,,
原来 masterB 节点也要 hdfs --daemon start zkfc 

关闭 masterB resourcemanager:
yarn --daemon stop resourcemanager
发现 masterA 的 resourcemanager 变成 alive


集群启动参考(十分重要!!!): https://blog.csdn.net/u014686399/article/details/80774547
\\\\\\\\\\\\\\\\\\\\\\\   hadoop + zookeeper    调试 记录     \\\\\\\\\\\\\\\\\\\\\\\\\\\

参考:
	spark:
		Hadoop、Spark、Hbase、Hive的安装 :	http://www.voidcn.com/article/p-pwgpxeyr-bow.html
		Spark2.1.0入门：Spark的安装和使用 :	http://dblab.xmu.edu.cn/blog/1307-2/			//Spark的安装版本参考
		在集群上运行Spark应用程序:		http://dblab.xmu.edu.cn/blog/1217-2/
		Centos7搭建hadoop spark集群之spark集群搭建:	https://dxysun.com/2018/04/16/centosForSpark/	//安装spark集群重点参考
		官网 spark 下载页:			http://spark.apache.org/downloads.html
		官网 spark 配置页:			https://spark.apache.org/docs/2.3.0/configuration.html
		基于zookeeper的Spark高可用集群配置:	
			https://blog.csdn.net/YQlakers/article/details/72831812		//参考配置zookeeper+saprk
			https://blog.csdn.net/xummgg/article/details/50759913
			https://blog.csdn.net/lishuan182/article/details/52331333

	hadoop:
		Centos7搭建hadoop spark集群之hadoop集群搭建 :	https://dxysun.com/2018/04/16/centosForHadoop/	//安装hadoop集群重点参考
		官网 hadoop 左下角configuraion:			https://hadoop.apache.org/docs/r3.2.0/		//重要参考 配置hadoop
		CentOS 7 上安装Hadoop V 2.8.1集群及配置:	https://blog.wuwii.com/linux-hadoop.html
		centos7.6安装配置hadoop-3.2.0笔记(单机安装、伪分布式安装):	https://blog.csdn.net/u010476739/article/details/86647585
		hadoop安装指南:		http://xiaoxin2009.github.io/hadoop%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97.html
		启动集群start-dfs.sh和start-yarn.sh的脚本错误:	http://mazhiyu.info/hadoop/2017/04/13/%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4start-dfs.sh%E5%92%8Cstart-yarn.sh%E7%9A%84%E8%84%9A%E6%9C%AC%E9%94%99%E8%AF%AF/
		java.lang.IllegalArgumentException: Does not contain a valid host:port authority: eastchina2_ops_exactdata1:8020
			就是说映射IP的hosts 不能带下划线 "_" 
			https://community.hortonworks.com/questions/96359/javalangillegalargumentexception-does-not-contain.html
		nodemanager和resourceManager日志报错:java.lang.NoClassDefFoundError: javax/activation/DataSource
			就是说 hadoop 只能用jdk8 版本!!,jdk9,jdk10,可以勉强用用,jdk11就没戏,不用想!!
			https://bbs.csdn.net/topics/392273321
			https://issues.apache.org/jira/browse/HADOOP-14978
			https://blog.csdn.net/wu_noah/article/details/79434048
			https://cwiki.apache.org/confluence/display/HADOOP/Hadoop+Java+Versions
		tail -f /var/log/hadoop/hdfs/hadoop-hdfs-namenode*.log  查看hadoop logs 方法
			https://community.hortonworks.com/questions/196075/unable-to-start-namenode-1.html
		格式化namenode 太多,弄得与 datanode 的cluster-ID不同步,删掉datanode 的 current文件夹就好了
			https://blog.csdn.net/gis_101/article/details/52679914
		
附加:
vi 无反应 vim 无反应
使用vim时，如果你不小心按了 Ctrl + s后，你会发现不能输入任何东西了，像死掉了一般，其实vim并没有死掉，
这时vim只是停止向终端输出而已，要想退出这种状态，只需按Ctrl + q 即可恢复正常。

命令行 输入 ?woed1  查找 word1, 然后 *下翻 #上翻		













20190308
准备构建2.0
bug1
今天遇到了一件离奇的事情,火狐的 js系统 onkeypress 不再俘获 backspace (退格按键)
弄得我需要 修改 keydown 以支持, 幸亏简单修改后恢复正常,他妈的
修改处 添加了 20190308 的水印

bug2
本来有12行, 如果修改减到小于12行就会保存出错!!
行本存在数据,然后行变成新行,可以存储
行本存在数据,但是 wrap 到 小行,无法存储
反正各种保存bug,并没有做好!!
wrap 和 new 共存 无法保存!!
反正 wrap 就无法 保存 

参考:
https://stackoverflow.com/questions/4843472/javascript-listener-keypress-doesnt-detect-backspace/23256446










20190410
小结 与 2.0
1.0 暂时的功能是 登录 然后 可以写自己的博客内容,但是,存储还是有bug
就是跟 wrap 和 冲突, 当更新后的总行数小于 原来的行数,更新是失败,
bug 先不修复,


## 2.0 主要内容
接下来需要 处理2.0的 主体,滑动blog,
基于需求,由于无法同步处理超过 3000 0000 行 数据,所以,显示内容滑动添加,可更改的内容范围只能1000-2000 行数据
暂时前端测试 2000 行 读写问题
后端测试 3000 0000 行数据 的处理问题

djanggo 单元测试:
写3000 0000 行文本
	在 shelltest 添加一个 makexml 函数 
	专门用来生成测试 xml 行的文件
	150行, 1000行, 5000行, 10000行, 30000行,,,,,30000000行
	最后发现使用 python xml 模块来生成 3000 0000 行太慢
	还是用回基本的 open read write 快速!!
写 3000 0000 行 数据库
	bulk_create()
	100000 起码 29s
	3000 0000 起码 8700s = 145m = 2.5h
	要脱离 django 写数据!!!!  使用 mysql.connector 模块(不过问题是用户密码隐身性能问题)
	https://www.jb51.net/article/133144.htm
	别人做的 100000 行只需要 5s !! 相当厉害了!! 
改 3000 0000 行 数据库
	bulk_update() /或者 with transaction.atomic(): 事务操作
	一种 使用  with transaction.atomic():  事务操作!!!
	 1000 行处理 4.5s
	 10000行要 150s  !!!!
	另一种使用 插件  pip install django-bulk-update
	 500 行处理 1.3 s
	 1000 行处理  3.7s
	 2000 行处理 9s
	 3000 行处理 17s
	 10000 行处理 132s
	太慢!!!!!  操作数据库,不能使用django的 orm了,需要近乎指令级别的操作!!!!
	还要改缓存大小 !!!!!
	https://blog.csdn.net/u014520745/article/details/52416002
	https://blog.csdn.net/number1killer/article/details/77839529
	批量更新的其他操作
批量操作,不能使用 django 的 orm 模块, 直接使用 mysql.connector 直链模块,完全mysql指令操作
	参考:https://www.jb51.net/article/133144.htm
	目前的得到效果: line 加 cnte 表 合计 1000 0000 + 1000 0000 =2000 0000 条数据写入 20分钟!!
	目前每100000 + 100000 = 200000 条数据 需要 12s!!
	现在开始修改 mysql 参数 提高性能!!!
		max_allowed_packet               | 16777216       //原来16MB  单位byte
		max_heap_table_size              | 16777216       //原来16MB  单位byte
			块操作时,处理包的默认大小,参数越大,块就可以越大,减少硬盘请求次数??
			然而, 都从 16MB 设置为 32MB 处理数据 处理 200000 条数据 还是需要大概 24s,性能没有上来
		innodb_log_buffer_size                   | 16777216    //原来16MB 单位byte
		innodb_log_file_size                     | 50331648    //原来48MB 单位byte
		innodb_autoextend_increment              | 64          //原来64MB 单位Mbyte  
			innodb_log_buffer_size配置项作用设定innodb 数据库引擎写日志缓存区；
			将此缓存段增大可以减少数据库写数据文件次数
			innodb_log_file_size配置项作用设定innodb 数据库引擎UNDO日志的大小；从而减少数据库checkpoint操作。
			当tablespace 空间已经满了后，autoextend_increment 需要MySQL系统需要自动扩展多少空间，
			增加自动扩展Size可以减少tablespace自动扩展次数
			分别设置为 48MB 128MB 128MB (不懂动态改,只线下改 my.cnf 重启)
			my.cnf 添加:
				[mysqld]
				innodb_log_file_size=128M
				innodb_log_buffer_size=48M
				innodb_autoextend_increment=128
			最后  处理 200000 条数据 还是需要大概 24s, 还是没有改变!!
			主要是之前 100000条记录一次的块操作 是在一次缓存i/o操作中工作完毕,没有多次log缓存io申请的操作的时间开销
			所以 跟log缓存io申请的操作只有一次, 时间都用刷入处理了!!
			所以 即使扩大了log缓存空间, 可以实现 200000条记录一次的块操作, 但是缓存io申请的操作也只有1次,
			所以 缓存io申请的操作 的开销没有变化
		unique_checks | ON	//唯一性检查,默认开启
			set unique_check 0  //关闭,没强化多少!!!

		innodb_read_io_threads                   | 4         //读操作线程
		innodb_write_io_threads                  | 4         //写操作线程
			都改到 8, 变化还是不明显!!!
		innodb_buffer_pool_size                  | 134217728        //默认128MB 
		innodb_buffer_pool_instances             | 1                //默认1
			buffer_pool_size 缓存表数据，索引数据的地方。增加它的值可以减少 磁盘 io ，提升 读写性能。
			buffer_pool_instances 是 buffer_pool 实例数量，默认为1。增加它的值，
			可以减少数据库内部的资源竞争，增加并发处理能力。
			改到 size 改到 512MB instances 改成 ?
			最后发现 都不明显!!
		
	20 0000 数据平均 24 S, 即每 10000条 1.2s 感觉改参数优化单表数据已经 到头了!!, 需要多表来尝试降低时间开销!!!!
		即分表操作 !!!!

mysql 参数操作:
	查看参数:
		SHOW VARIABLES ;     //查看参数!!! 不过是查看 session参数		    
		SHOW VARIABLES like 'max_%';     //查看参数!!!  不过是查看 session参数
		SHOW GLOBAL VARIABLES ;     //查看GLOBAL参数!!!	
		SHOW GLOBAL VARIABLES like  'innodb_%' ;     //查看GLOBAL参数!!!		    	    
	设置参数: 
		SET GLOBAL read_buffer_size = 2*1024*1024	//设置 GLOBAL 参数
		SET read_buffer_size = 2*1024*1024	//设置 session 参数
	有些参数在 mysql 启动时,不能修改,需要 下线 mysql,再修改 my.cnf 文件 (locate my.cnf 寻找文件位置)
		并重启 mysql : sudo service mysql restart
		
mysql 常用操作指令
	显示表最后的10条记录
	select * from web_linex9014 order by id desc limit 10 ;
	select * from web_cntex9014 order by id desc limit 10 ;
	查看表大小:
	use information_schema;
	select concat(round(sum(DATA_LENGTH/1024/1024),2),'MB') as data  from TABLES where table_schema='db_selfweb_pyth3' and table_name='web_cntex9014' or table_name='web_linex9014';

数据库性能优化 参考: 
	http://www.111cn.net/database/mysql/43315.htm
	http://blog.jobbole.com/107264/
	https://coolshell.cn/articles/1846.html
	https://juejin.im/post/59d83f1651882545eb54fc7e


ubuntu 内存塞满检查命令:
	top -o %MEM

python file open 读写模式的类型有：
	rU 或 Ua 以读方式打开, 同时提供通用换行符支持 (PEP 278)
	w     以写方式打开，
	a     以追加模式打开 (从 EOF 开始, 必要时创建新文件)
	r+     以读写模式打开 (不会清除文件源内容)
	w+     以读写模式打开 (先清除文件内容再读写操作)	
	a+     以读写模式打开 (参见 a )
	rb     以二进制读模式打开
	wb     以二进制写模式打开 (参见 w )
	ab     以二进制追加模式打开 (参见 a )
	rb+    以二进制读写模式打开 (参见 r+ )
	wb+    以二进制读写模式打开 (参见 w+ )
	ab+    以二进制读写模式打开 (参见 a+ )

python 	seek
    offset -- 开始的偏移量，也就是代表需要移动偏移的字节数
    whence：可选，默认值为 0,表示要从哪个位置开始偏移；
	0代表从文件开头开始算起，
	1代表从当前位置开始算起，
	2代表从文件末尾算起。

python readlines 的参数问题:
	hint参数 是字节的总大小，会读取到该文件内对应字节数的当前行。
	第一行如果有5个字符，hint=5，就只读取第一行，(hint<=5时都只会读取第一行的内容)
	第二行如果有5个字符，hint=6，会开始读取第二行内容。(5<=hint<=11时时会读取到前两行的内容)
	注意到 如果 把最后的换行符号也算进 hint参数, readlines 会逼

python 插入一段数据:
    file = open('./static/clients/clie001/linenum.txt', 'r+')
    content = file.read()   # 270MB全部读到内存 0.3-0.5s !!
    post = content.find('22998990\n')
    content = content[:post + 9] + kk + content[post + 9:]
    time_end = time.time()
    print('cost:', time_end - time_start)
    file.seek(0)
    file.write(content)
	#注意,如果是这样直接添加数据并不成功,只不过是覆盖了原来是数据而已!!!
    file.seek(xxxxx)
    file.write(kk)

python break pass continue
	break是终止本次循环，比如你很多个for循环，你在其中一个for循环里写了一个break，满足条件，只会终止这个for里面的循环
	continue：跳出本次循环，执行下一次
	pass:不做任何事情，只起到占位的作用

后端的基本逻辑性能基本 填坑完毕部分代码参考:
#事务操作
'''
insertwrap()  函数片段
#事务操作 方式 实现 批量 save()
    k=0
    #@transaction.commit_manually       #用法废弃
    with transaction.atomic():          #新用法!!
        for i in lnum:
            i.linecnte = content[k]
            k += 1
            i.save()
'''

#修改数据的语法!!
'''
    #sql = "select max(cntenum) from  web_cntex9014 ;"
    #cur.execute(sql)
    #cnteid = cur.fetchall()[0][0]
    #print(cnteid+1000)

    #print(inxeidt)
'''

# 随加生成 不同组合的字符串
'''
    for i in range(256):
        kk =[]
        while 1:
            k = ''.join(random.sample(string.ascii_letters + string.digits, 8))
            if k in kk:
                pass
            else:
                kk.append(k)
                print( "'<Cnte>"+ k +" &lt;br&gt;</Cnte>\\n',  # cnteid:"+str(i)+"     undefined just placeholder!!" )
                break
'''

## 数组 转 字符串
'''
a = ['ss', 'dwdw', 'rrrr']
d = "".join(map(lambda x: str(x), a))
print(d)
print(a[-1])    # rrrr
'''

##块操作
'''
sql = "update web_cntex%s set cntenum=%s,type=%s where id=%s"  # 修改数据的语法!!
value = []
value.append([9014, 257, 'hdty', 2])
value.append([9014, 258, 'vido', 3])
cur.executemany(sql, value)
'''

# 检测 是否系统行
'''
k = '<Cnte>&lt;br&gt;</Cnte>\n'
try:
    kk = qstag.sysline.index(k)
    print(kk)
    pass
except:
    print('no kk')
    pass
'''

# 修改数据
'''
    delsql = "update web_cntex%s set count=0 where cntenum=%s"     #value_eaample [9014, 23330]
    ppp=[9014,3000]
    kkk=[]
    for i in  delsval:
        delsql += " or cntenum=%s"
        ppp.append(i[1])
    kkk.append(ppp)
    cur.executemany(delsql, kkk)
    time_end = time.time()
    print('2cost:', time_end - time_start)
'''

    opq=[]
    for i in range(2000):
        while 1:
            num = random.randint (1000,200000)
            if num in opq:
                pass
            else:
                break
        opq.append(num)
        fixsval.append([n, b'dddd', str(num) ])
        delsval.append([n, str(num)])
        print(num)
    time_end = time.time()
    print('random cost:', time_end - time_start)


    ### 刷 数据库!!!
    time_end = time.time()
    print('cost:', time_end - time_start)
    conn.start_transaction()
    # cur.executemany(delsql, delsval)
    # cur.executemany(fixsql, fixsval)
    cur.executemany(newsql, newsval)
    conn.commit()
    time_end = time.time()
    print('1cost:', time_end - time_start)


    # 插入数据
    #newsql = "insert into web_cntex%s(cntenum, type, content, history, count, datetime) values(%s,%s,%s,%s,%s,%s)"    #value_example [9014,123434,edit,'<Cnte>dsdsds</Cnte>',None,1,'2019-01-02:22:22:22:22' ]
    #newsql = "insert into web_cntex9014(cntenum, type, content, history, count, datetime) values(%s,%s,%s,%s,%s,%s)"
    #kkk=[]
    #kkk.append( (300001, 'ssss','ddddddd', None,1,'2019-04-06 12:50:29.978461' ) )
    #cur.executemany(newsql, kkk)

    # 伪删除数据
    delsqlf = "update web_cntex9014 "
    delsql1 = "set count=case cntenum "
    delsqlw = "where cntenum in ("
    for i in  delsval:
        delsql1 += "when " + str(i[1]) + " then " + "22 "
        delsqlw += str(i[1]) + ", "
    delsql1 += " end "
    delsqlw = delsqlw[:-2]
    delsqlw += " )"
    delsql = delsqlf + delsql1 + delsqlw
    cur.execute(delsql)
    time_end = time.time()
    print('2cost:', time_end - time_start)

    # fix'数据
    fixsqlf = "update web_cntex9014 "
    fixsql1 = "set content=case cntenum "
    fixsqlw = "where cntenum in ("
    for i in  fixsval:
        fixsql1 += "when " + i[2] + " then " + "'<Cnte> new  william cnte-testing-dsadsajfdfdkdasfdfdsfajidwiqnxahikfhufhwqjihoihfieowhefiqowfhiqhiqofhefiqfhihscnksnidfsfsdjfieif</Cnte>'"+ " "
        fixsqlw += i[2] + ", "
    fixsql1 += " end "
    fixsqlw = fixsqlw[:-2]  # 字符串最后两个字符去掉
    fixsqlw += " )"
    fixsql = fixsqlf + fixsql1 + fixsqlw
    cur.execute(fixsql)
    time_end = time.time()
    print('3cost:', time_end - time_start)


    ###刷index文本
    inxmid = "".join(map(lambda x: str(x), inxedit))
    inexbuff = inxfron + inxmid + inxafter
    indexf = open('./static/clients/clie001/linenum.txt', 'w+')
    indexf.write(inexbuff)
    indexf.close()










20190418
前端攻坚:
水平滑动条: 当出现 overflow现象时,希望出现 水平滑动条出现在screen 下方, 而不是 最下面的body 底
	所以最好的做法是 <body overflow-x:-moz-scrollbars-none; >
	而不是 overflow-x:auto, 什么的
关于 overflow  , 要求行内元素不自动换行显示
	父节点添加 white-space:nowrap; 表示子节点,字符串内容都在一行上,直到遇上<br> 才换行
	如果 不加上的话,,例如 <span> <div inline-block> 同一行显示,但是 当div 过长时, div会自动换行显示!!!
关于 文本 显性显示全部空格!!
	节点 加上 white-space:pre;
滚动到光标位置!! (跳到历史保存的位置!!!)
	先 blur 后 focus  ????
	focus 只能一般只能focus没有 contenteditable 的元素,父元素 contenteditable, 子元素不能被成功focus !!
	这个很好处理了 先获得光标位置的 element 元素!!
	然后 获得 对应 的 offsetTop, offsetLeft, offsetParent, 然后转到 scrollTop, scrollLeft 坐标 AA BB
	最后 body.scrollTop = AA body.scrollLeft = BB 成功跳转!
	注意 offsetPrarent 与 offsetTop offsetLeft 的关系: https://blog.csdn.net/Inuyasha1121/article/details/49149725
	之所以,本身的视野无法跳转的问题,在于整体的maintag 设置了 contenteditable, 然后作为 main 的子元素就不能好好被
	focus 了!!!
最后就是 background 的问题, 
	主动改变main 父节点 width 便可以解决 ?? 这样需要处理的函数太复杂!!
























20180425 
系统学习 重点 DOM !!  : https://www.w3schools.com/jsref/prop_document_activeelement.asp
重点的 都 打上了 * 号
首先 DOM 可以看作是 js 在html领域 的标准分支库, 属于 js 
DOM attribute : 比如: conclick, id, class, type, style 等等!!
DOM console 几个重点函数使用: 
	console.log()打印 , 
	console.time()计时开始, console.timeEnd()计时结束
	console.trace() 跟踪 js 的调用!!		
DOM dococument: 一个 html页面内容就是 一个 dicument
	document.activeElement.tagName    当前被 focus 的 节点的 tag名 
	document.addEventLister("click",function(){...})     : 动态给指定节点添加事件 onclick()
	document.removeEventListener("mousemove", myFunction)   :   动态去除 添加的事件 !!
	adoptNode()  : 从别的document 接受一个节点到本地的 document (比如从 iframe 里 加载的html页面 document)
	anchors():  统计 document 有多少个 <a> 对象
	applets:   统计有多少个 <applet>
	baseURI:   获得当前网址
	document.URL  :  当前网址  
	documentURI:  跟 baseURI 一样,感觉
	body:     <body>节点
	document.open /write/close/   :相当于重绘 一次当前的docment了
		open 意味着清空当前 document 所有内容, 然后 写入内容, 然后关闭 document 通道!
		如果不open 前提下直接调用 write,  默认会还是会先执行 open 操作,
		如果没有 close 操作, 多次write 的内容都会紧贴着
	write 写入数据 ,写入的数据接着行写
	writeln 另起一行,写入数据!!
	cookie : 就是cookie
	characterSet  : 编码: 例如 UTF-8
	inputEncoding  :  也是编码
	lastModified   :  最后修改时间
	links  :   document 拥有的链接数
	document.scripts  :   所有的 <script> 节点
	head:  <head> 节点
	images :   document 的所有 <img> 节点
	document.embeds.length  :  <embed> 节点的个数
	forms.length :   <form> 节点的个数 
	document.title  :   <title> 的内容
	createAttribute :  动态添加 attribute 使用比较绕,注意!!
		var att = document.createAttribute("class");       // 动态添加 "class" attribute
		att.value = "democlass"; 
		h1.setAttributeNode(att);
	createComment()   : 创建 <!--  -->  的笔记
	createdocumentfragment()   :	这个是动态建立一些节点片段,然后修改后,可以插入,或者替换原来的!!!
	createElement()  : 新建 节点
	createEvent() :  创建事件, 跟 addEventLister 差不多...
	createTextNode() : 创建了 字符串到节点里, 其实一串字符串的每个字符都可以被看作一个行内元素,(行内节点,没有tag标签那种)
	defaultview: 获得 window object  不知道是啥,,
	designMode:  document 可以编辑, 跟 attri  contenteditable 差不多的效果!! 
	documentElement:  就是cocument的根节点 <HTML>
	doctype: 就是 <!DOCTYPE html> 所说明的 html
	documentMode : IE8+ 的一个特性,不知道表达啥,
	document.domain:  这个页面所在服务器的主域名, 例如 www.baidu.com
	document.fullscreenElement  :  取得正在fullscreen显示的 节点!!
	document.fullscreenEnabled  :  document 是否允许fullscreen显示莫内容
	getElementById()  :  根据 id attri 获得 节点 ,一般获得一个节点,所以 id 应该要唯一!
	getElementsByClassName()  :  根据 class  attri 获得 节点, 获得节点 一般是 一堆节点 
	getElementsByName()  :	根据 name  attri 获得 节点, 获得节点 一般是 一堆节点 
	getElementsByTagName()  :  根据 tag 像<div> 什么的 获得节点  一般是 一堆节点
	document.querySelector(".example").style.backgroundColor = "red"; 根据 example class 获取 第一个 节点
	document.querySelectorAll(".example")  :   根据 class  attri 获得 节点, 获得节点 一般是 一堆节点
	document.hasFocus()  :  页面是否被 focus  还有一个附加知识点: setInterval("myFunction()", 1) 值得注意!!!
	document.readyState  :  获得 document 的加载准状况, 是否 complete
	document.referrer   :  获得 访问当前 document 之前曾访问的 document, 即上一个打开页面的地址
	document.renameNode(p, null, "h1")  :   改变 节点 的 tag名  这里是把节点 p  的tag 改为 和h1
	implementation :  document 的 implementation  不知道是啥,,
	strictErrorChecking   :   不知道是啥
	document.importNode(h, true);   : 插入节点,  插入到 <body>最后的地方!!!
	normalize():   removes empty Text nodes, and joins adjacent Text nodes.
	execCommand() :  执行命令  !!!! 这里的 命令是重点, 有以下命令
		command 	Specifies the name of the command to execute on the selected section.
	
			Legal values:
			"backColor"
			"bold"
			"createLink"
			"copy"
			"cut"
			"defaultParagraphSeparator"
			"delete"
			"fontName"
			"fontSize"
			"foreColor"
			"formatBlock"
			"forwardDelete"
			"insertHorizontalRule"
			"insertHTML"
			"insertImage"
			"insertLineBreak"
			"insertOrderedList"
			"insertParagraph"
			"insertText"
			"insertUnorderedList"
			"justifyCenter"
			"justifyFull"
			"justifyLeft"
			"justifyRight"
			"outdent"
			"paste"
			"redo"
			"selectAll"
			"strikethrough"
			"styleWithCss"
			"superscript"
			"undo"
			"unlink"
			"useCSS"
		showUI 	A Boolean, specifies if the UI should be shown or not
		value 	Some commands need a value to be completed
	  例子:
	  if (event.keyCode == 16) {
		    // Execute command if user presses the SHIFT button:
		    document.execCommand("bold");
		  }
DOM Element: document里的节点 就是element, 这里是对 element 操作的 api, 现在只笔记重点使用的 api
	accessKey :  快捷键
	addEventListener("click", function(){...});	:   给 element 添加 事件
	removeEventListener("mousemove", myFunction)   :   去掉事件
	appendChild() :  给节点插入一个子节点成员
	attributes:   节点的属性   id  class  type style 什么的,,,
	hasAttribute("onclick") :  是否含有  onclick  attri
	hasAttributes()  :  是否含有任何的 attri
	getAttributeNode("class").value:  获得 一个attri.然后得到他的 value
	getAttribute("class") : 直接获得 attri 的 value 
	setAttribute("class", "democlass");  设置 attri
	setAttributeNode() : 设置 attri  用法:
		var h1 = document.getElementsByTagName("H1")[0];   // Get the first <h1> element in the document
		var att = document.createAttribute("class");       // Create a "class" attribute
		att.value = "democlass";                           // Set the value of the class attribute
		h1.setAttributeNode(att);                          // Add the class attribute to <h1>  
	removeAttribute("class"):  去掉 class attri
	removeAttributeNode() :  去掉 attri   用法:
		var elmnt = document.getElementsByTagName("H1")[0];  // Get the first <h1> element in the document
		var attr = elmnt.getAttributeNode("class");          // Get the class attribute node from <h1>
		elmnt.removeAttributeNode(attr);                     // Remove the class attribute node from <h1>  
	blur()  :   指定节点如果已经 focus状态, 这个可以取消focus
	classlist:   一个 节点 可以有多个 class attri,  比如 <div class="a gg kk"..>, 有 a gg kk 3个class, classlist 凑齐了元素的所有
	className:  设置 一个节点 只有一个class , 即使以前是多class 节点, 使用classname后, 覆盖成一个单class节点!! 
	click :  对指定element 执行一次 click 事件
	clientxxx
		client 是 算上内空白padding 的element, client由边界border围着,border之外就是margin !! 
		clientHeight:   height of a <XXX> element, including padding:
		clientWidth:    width of a <XXX> element, including padding:
		clientTop: 相当于 top border 的厚度
		clientLeft:  相当于 left border 的厚度
		getBoundingClientRect()  :   不知道得到什么
	offsetxxx:
		offset 算上padding 和 border边界的厚度
		offsetHeight : height of a <XXX> element, including padding and border 
		offsetWidth : width of a <XXX> element, including padding and border 
*		offsetLeft: 距离参照对象的 左边位移
			一般 相关节点 在 父节点内容,而不是和父节点同阶层,所以 offsetleft 宽度包含以下内容 
    			left position(远处直到margin边界), and margin of the element
    			the left padding, scrollbar and border (and margin) of the offsetParent element
*		offsetTop:  距离参照对象的 顶端位移
			一般 相关节点 在 父节点内容,而不是和父节点同阶层,所以 offsetleft 宽度包含以下内容 
    			top position(远处直到margin边界), and margin of the element
    			the top padding, scrollbar and border (and margin如果没有其他项都是0px,可能就算上这个margin) of the offsetParent element
		offsetparent:  参照对象 没有特别设置,指的就是 <body>
	scrollxxxx: 某些节点,在一些小窗口里难免会显示不出来而需要滑动条
		scrollHeight: 其实就是这个显示不全的节点的 高度 包含这个节点的 height 和 padding
		scrollWidth:  其实就是这个显示不全的节点的 宽度 包含这个节点的 width 和 padding
		scrollIntoView: 在窗口里,一下子滑到要显示的节点所在!!
			以上三者对应的 主角都是 这个显示不全的节点
			例如: <div id="w"> <div id="a">dsds </div></div> w是窗口, a是显示bu全的节点
			        //a节点 的 scrollwidth scrollhight
				var elmnt = document.getElementById("a");
				var y = elmnt.scrollHeight;
				var x = elmnt.scrollWidth; 
				//w窗口一下子滑到 显示 a节点的区域
				var elmnt = document.getElementById("a");
				elmnt.scrollIntoView();
			就是说,即使窗口多个 显示不全的节点.滑动条会变长,是累加了多个显示不全的节点的 scrollheight/width 
			但是针对 a 节点 scrollwidth scrollhight 并不会改变!!
*		scrollTop: 滑动条上偏移
*		scrollLeft: 滑动条下偏移
			以上两者对应的 主角都是 小窗口
			var elmnt = document.getElementById("myDIV");
			var x = elmnt.scrollLeft;
			var y = elmnt.scrollTop; 
			一般来说,scrollLeft scrollTop 的值 都是 子节点所有内容所占的长宽减去窗口的长宽!!
			但显然不是,还有很多不知道来自何处的附加数值
*	child,node,elenment 区分:
		childElementCount :  指定节点下 有多少个子节点!!
		childNodes :    指定节点下 有的子节点都登记到一个数组上来
		firstChild   :  第一个 子节点 不一定是element 可以使字符串
		firstElementChild  :   第一个子节点
		lastChild  :
		lastElementChild  :
		nextSibling :   下个节点??? 
		nextElementSibling :  下个节点??
		parentNode :  父节点 ?? 
			In HTML, the document itself is the parent node of the HTML element, 
			HEAD and BODY are child nodes of the HTML element.
		parentElement:  父节点
		previousSibling: 前一个节点
		previousElementSibling 前一个节点??
		getElementsByClassName  :  获得 含相同class属性 的所有 element
		getElementsByTagName  :   获得 含相同 tag头 的所有 element
		hasChildNodes()	: 是否含有子节点
		removeChild() :  去掉子节点
		replaceChild(): 替换节点
			item.replaceChild(textnode, item.childNodes[0]); 
			// Replace the first child node of <ul> with the newly created text node
		cloneNode() 克隆节点
		compareDocumentPosition():    比较节点的位置:
	 		The possible return values would specify:
			1: No relationship, the two nodes do not belong to the same document.
			2: The first node (p1) is positioned after the second node (p2).
			4: The first node (p1) is positioned before the second node (p2).
			8: The first node (p1) is positioned inside the second node (p2).
			16: The second node (p2) is positioned inside the first node (p1).
			32: No relationship, or the two nodes are two attributes on the same element.
	querySelector(".ooo") : 获得 class="000" 的 所有节点的第一个节点
	querySelectorAll(".ooo") :  获得 class="000" 的 所有节点

	insertAdjacentElement() : 节点 移位  inserts a the specified element into a specified position
		Legal position values are:
			"afterbegin"
			"afterend"
			"beforebegin"
			"beforeend"
		例如:	  var s = document.getElementsByTagName("span")[0];
			  var h = document.getElementById("myH2");
			  h.insertAdjacentElement("afterend", s);  //s 放到 h 之后
	insertAdjacentHTML() :  节点 移位, 把某个html片段放到指定节点的相关位置
		例如:
		  var h = document.getElementById("myH2");
		  h.insertAdjacentHTML("afterend", "<p>My new paragraph</p>");
	insertAdjacentText()  :   把某段 text 字符串 放到指定节点的相关位置
		例如: h.insertAdjacentText("afterend", "My inserted text"); 
	insertBefore()  :    在父节点里操作, 把子节点A 放到 子节点B 之前
		例如: list.insertBefore(newItem, list.childNodes[0])  父节点list , 子节点  newItem 放到 子节点 list.childNodes[0] 之前
	innerHTML :   节点里所有内容,包括节点tag 都统一成字符串内容
	innerText :   仅仅节点内的 字符串内容
	lang :  直接得到节点语言属性 lang attri 值 例如 <div lang="en">  elmnt.lang 就是 en   
	namespaceURI :   ??????  不知道是啥
	nodeName  : 节点 的 tag 头名
	nodeType  : 节点 的类型:
		If the node is an element node, the nodeType property will return 1.
		If the node is an attribute node, the nodeType property will return 2.
		If the node is a text node, the nodeType property will return 3.
		If the node is a comment node, the nodeType property will return 8.
	nodeValue : 节点的内容 如果是element节点,具体是 仅接着的text文本内容
	normalize() : 相邻的 多个text节点 合成一个tezt节点!!
	style  : 设置 css 的!!
	tabIndex    :  不知道是啥
	tagname  :  就是 tagname
	textContent  : 提取节点所有字符内容,不管是不是嵌入到子节点的文本,都提取出来,得到一个文本内容
	title  : 获得  title attri 的内容

DOM event: 事件 节点触发的事件, 就是我们接触的 onclick 什么的事件触发标记:
	流媒体: <video> <audio>
		abort事件: <video onabort="myFunction()"> 流媒体请求被拒绝后是事件 
		ondurationchange :  流媒体事件相关 略
		oncanplay :  视频准备好播放, 可执行的事件
		oncanplaythrough:  不明所以 略
		onended  :  流媒体结束的时候!!
		onloadeddata : 当加载的内容可用时,一般指video 这些流媒体
		onloadedmetadata : 流媒体的 meta数据加载好时候
		onloadstart : 流媒体开始加载时
		onpause :暂停
		onplay : 开始播放
		onplaying: 正在播放
*		onprogress : 正在加载下载视频时候
		onratechange: 播放速度改变
		onseeked  : 拉进度条触发事件
		onseeking  : 正在拉精度条触发事件
		ontimeupdate : 改变进度条发生的事件
		onstalled : 流媒体数据无法获得时候
		onsuspend : 无法得到流媒体数据时候
		onvolumechange : 音量改变事件!!
		onwaiting : 等待时缓存事件
		
	onerror  : 当出现错误的时候
	beforprint  /   afterprint:  略
	animationxxxx事件, 略
		event.animationName  属性: 动画事件的名字
	onbeforeunload  : 如果不想加载时发生的事件, 不知道怎么测试..
	onload : 当所指向的 节点 内容已经加载完毕 通常用在 body 节点
	onunload :不加载内容时候

	onmessage: 配合 eventsource使用的 一旦获得消息就触发的是事件
	onopen : 配合 eventsource使用
	onblur  :  失去focus 发生的事件
	onfocus :  被focus 的时候  
	onfocusin  : 将要得到 focus 的时候?
	onfocusout : 将要推出 focus 的时候.
	onhashchange  : hash 值改变的时候?
	一般 <input> 使用到的
		oninput : 当写入内容的时候!!
		oninvalid : 当input 没有内容时,  例子:
			<form action="/action_page.php" method="get">
			  Name: <input type="text" oninvalid="alert('You must fill out the form!');" name="fname" required>
			  <input type="submit" value="Submit">
			</form>
		onreset: 重置:
			<form onreset="myFunction()">
			  Enter name: <input type="text">
			  <input type="reset">		//这是一个重置按钮
			</form>
		onsearch: 触发搜索
			 <input type="search" onsearch="myFunction()"> 
		onselect: 当文本内容被鼠标 括选时候
		事件属性:
			event.inputType : 输入内容的类型!!例如
				"insertText" 正在输入文本
				"deleteContentBackward"  breakspace 删除内容时  

	change: 节点更改后事件 
	触摸屏事件:
		ontouchcancel : 触摸事件被打断时候
		ontouchend :  触摸结束事件
		ontouchmove : 触摸滑动事件
		ontouchstart : 触摸开始事件
*	鼠标点击操作
		onclick: 点击
		ondblclick 双击
		onmousedown 
		onmouseup
		oncontextmenu 右键事件
		onmouseenter : 当鼠标指向时触发
		onmouseleave: 当鼠标离开时触发 配合 seenter 使用
		onmouseover : 当鼠标指向时触发 (不知道有什么不同)
		onmouseout : 当鼠标离开时候触发 (不知道有啥据别) 配合 over使用
		onmousemove: 当鼠标在指定的 节点内移动时
		onwheel : 滚轮事件
		事件属性:
			event.button: 那个按键:
			  0 = The left mouse button
			  1 = The middle mouse button
			  2 = The right mouse button
			event.buttons: 那个按键, 这里属性包含跟多按键编码??
			event.clientX:
			event.clientY: 鼠标当前的位置坐标!! 根据 窗口 The client area is the current window.
			event.pageY
			event.pageX; 鼠标当前的位置坐标  
					The pageX property returns the horizontal coordinate 
					(according to the document) of the mouse pointer when a mouse event was triggered.
					The document is the web page.
			event.deltaX : 滑轮事件
			event.deltaY : 滑轮事件 普通鼠标就只有 Y 滑轮
			event.deltaZ : 滑轮事件
			event.deltaMode : 滑轮新式, 换页, 换像素点, 还是换行 ???
			event.which : 表示点击了那个 鼠标按键
*	键盘事件:
		onkeydown 
		onkeypress
			Note: The onkeypress event is not fired for all keys (e.g. ALT, CTRL, SHIFT, ESC) in all browsers. 
			To detect only whether the user has pressed a key, 
			use the onkeydown event instead, because it works for all keys
		onkeyup
		事件属性:
			event.which : 使用 unicode 表示按下了那个按键
			event.location :  按键的键盘区域 : 数字小键盘,还是主键盘, 等等
			event.altkey : 按下alt事件 
			event.ctrlkey : 按下alt事件 
			event.shiftKey : 按下shift事件
			event.metaKey  :  meta 按键 ?? 不知道是哪个,,,
			event.code : 按键码  按键的字符
*			event.charCode : 按键码 转成的数字码
				The charCode property returns the Unicode character code of the key that triggered the onkeypress event.
				The Unicode character code is the number of a character (e.g. the number "97" represents the letter "a").
				Tip: For a list of all Unicode characters, please study our Complete Unicode Reference.
				Tip: If you want to convert the Unicode value into a character, use the fromCharCode() method.
				Note: If this property is used on onkeydown or onkeyup events, the returned value is always "0".
				Note: This property is read-only.
				Note: The charCode property is not supported in IE8 and earlier. 
					However, for these browser versions, you can use the keyCode property. Or, 
					for a cross-browser solution, you could use the following code:
					var x = event.charCode || event.keyCode; 
						// Use either charCode or keyCode, depending on browser support
				Tip: You can also use the keyCode property to detect special keys (e.g. "caps lock" or arrow keys).
					However, both the keyCode and charCode property is provided for compatibility only. 
					The latest version of the DOM Events Specification 
					recommend using the key property instead (if available).
				Tip: If you want to find out whether the "ALT", "CTRL", "META" or "SHIFT" key was pressed 
					when a key event occured, use the altKey, ctrlKey, metaKey or shiftKey property.
			event.key 按键码  read-only
				Key identifiers are strings that identify keyboard buttons. 
				The return value of this property can be a string of:
				    A single character (like "a", "W", "4", "+" or "$")
				    A multicharacter (like "F1", "Enter", "HOME" or "CAPS LOCK")
				If you want to find out whether the "ALT", "CTRL", "META" or "SHIFT" key was pressed 
				when a key event occured, use the altKey, ctrlKey, metaKey or shiftKey property.
			event.keyCode  按键码  转成数字的
				The keyCode property returns the Unicode character code of the key that triggered the onkeypress event, 
				or the Unicode key code of the key that triggered the onkeydown or onkeyup event.
				The difference between the two code types:
				    Character codes - A number which represents an ASCII character
				    Key codes - A number which represents an actual key on the keyboard
				These types do not always mean the same thing; for example, 
				a lower case "w" and an upper case "W" have the same keyboard code, 
				because the key that is pressed on the keyboard is the same (just "W" = the number "87"), 
				but a different character code because the resulting character is different 
				(either "w" or "W", which is "119" or "87") - See "More Examples" below to better understand it.
				Tip: To find out if the user is pressing a printable key (e.g. "a" or "5"), 
					it is recommended to use this property on the onkeypress event. 
					To find out if the user is pressing a function key 
					(e.g. "F1", "CAPS LOCK" or "Home") use the onkeydown or onkeyup event.
				Note: In Firefox, the keyCode property does not work on the onkeypress event 
					(will only return 0). For a cross-browser solution, 
					use the which property together with keyCode, e.g:
				var x = event.which || event.keyCode;  
					// Use either which or keyCode, depending on browser support
				Tip: For a list of all Unicode characters, please study our Complete Unicode Reference.
				Tip: If you want to convert the returned Unicode value into a character, use the fromCharCode() method.
				Note: Both the keyCode and which property is provided for compatibility only. 
					The latest version of the DOM Events Specification recommend using the key property 
					instead (if available).
				Tip: If you want to find out whether the "ALT", "CTRL", "META" or "SHIFT" key was pressed 
					when a key event occured, use the altKey, ctrlKey, metaKey or shiftKey property.
			event.getModifierState("CapsLock");  判断某些复合作用的按键状态是否在生效中, (不是判断按下了什么!!)
				The getModifierState() method returns true if the specified modifier key was pressed, or activated.
				Modifier keys that are activated only when they are being pressed down:
				    Alt
				    AltGraph
				    Control
				    Meta
				    Shift
				Modifier keys that are activated when they are clicked, and deactivated when they are clicked again:
				    CapsLock	//大小写
				    NumLock	//数字小键盘
				    ScrollLock	//???
*	drag:拖曳事件:
		拖曳区域:
			ondragenter : 当拖曳对象拖进这个区域时触发的事件
			ondragleave  : 当拖曳对象被拖出这个区域时 触发的事件!!
			ondragover : 正在拖曳对象 曾经经过这个拖曳区域时 区域触发的事件
			ondrop :  拖曳结束, 接受释放的事件
		拖曳对象  必须提添加上这个 attri draggable="true" 定义了一个拖曳对象
			ondrop: 当拖曳对象被拖曳触发的事件
			ondragstart: 表示这是一个可以被拖曳是对象,当拖曳发生时,发生的事件	
			ondragend: 当结束时 发生的事件
		以下是一个例子:
		// 这是 一个拖曳区域
		<div class="droptarget" ondrop="drop(event)" ondragenter="dragEnter(event)" ondragleave="dragLeave(event)" ondragover="allowDrop(event)">
		// 这是一个拖曳对象
		  <p ondragstart="dragStart(event)" ondragend="dragEnd(event)" draggable="true" id="dragtarget">Drag me!</p>
		</div>
		// 这是第二个拖曳区域
		<div class="droptarget" ondragenter="dragEnter(event)" ondragleave="dragLeave(event)" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
		<script>
			function dragStart(event) {
			  event.dataTransfer.setData("Text", event.target.id);
			}
			function dragEnd(event) {
			}
			function dragEnter(event) {
			  if ( event.target.className == "droptarget" ) {
			    document.getElementById("demo").innerHTML = "Entered the dropzone";
			    event.target.style.border = "3px dotted red";
			  }
			}
			
			function dragLeave(event) {
			  if ( event.target.className == "droptarget" ) {
			    document.getElementById("demo").innerHTML = "Left the dropzone";
			    event.target.style.border = "";
			  }
			}
			
			function allowDrop(event) {
			  event.preventDefault();
			}
			
			function drop(event) {
			  event.preventDefault();
			  var data = event.dataTransfer.getData("Text");
			  event.target.appendChild(document.getElementById(data));
			}
		</script>
	oncontextmenu : 唤起菜单时 的事件(右键事件!!)
		可以给常规菜单添加自己 的 菜单命令  例如:
		<div oncontextmenu="myFunction()" contextmenu="mymenu">
		<p>Right-click inside this box to see the context menu!
		<menu type="context" id="mymenu">
		  <menuitem label="Refresh" onclick="window.location.reload();" icon="ico_reload.png"></menuitem>
		  <menu label="Share on...">
		  <menuitem label="Twitter" icon="ico_twitter.png" onclick="window.open('//twitter.com/intent/tweet?text=' + window.location.href);"></menuitem>
		  <menuitem label="Facebook" icon="ico_facebook.png" onclick="window.open('//facebook.com/sharer/sharer.php?u=' + window.location.href);"></menuitem>
		  </menu>
		  <menuitem label="Email This Page" onclick="window.location='mailto:?body='+window.location.href;"></menuitem>
		</menu>
		</div>	
	copy, cut  paste事件:就是执行标准右键菜单 对应按键 的事件
		用法例如, <input type="text" oncopy="myFunction()" value="Try to copy this text">
			 <input type="text" oncut="myFunction()" value="Try to cut this text">
			 <input type="text" onpaste="myFunction()" value="Paste something in here">  
	onshow :一般配合 <menu>使用,当菜单要被显示时候
	onsubmit : 一般配合 <from> 事件,当表格内容要提交时候
	ontoggle : 配合	<detail> 使用, 当显示一个词条详细解析时候	
	transitionend : 变形事件,,,,????			
	onoffline 当 浏览器离线时操作!!
	ononline 浏览器上线时
	onpagehide : 节点隐藏不可视时候
	onpageshow : 节点可视时候
	onresize : 浏览器窗口改变时候
	onscroll : 当滑动条滑动时候
	
	其他事件属性:
		event.bubbles  事件冒泡??
		event.button: 那个按键
		event.cancelable: 可取消的事件
		event.currentTarget : 触发这个事件的 节点
*		event.preventDefault() 阻止当前事件的默认操作事件
		event.detail : 事件发生的统计次数,或者其他信息
		event.elapsedTime :  动画事件运行的时间统计
		event.eventPhase
			A Number, representing which phase of the event flow is currently being evaluated
			Possible values:
				0. NONE
				1. CAPTURING_PHASE - The event flow is in capturing phase
				2. AT_TARGET - The event flow is in target phase
				3. BUBBLING_PHASE - The event flow is in bubbling phase
		event.isTrusted : 判断事件是否真实发生:
			例如,真正的点击事件是 真实的,
			通过调用函数模拟点击事件 是 假的
		event.oldURL  /  event.newURL  : 与 hashchange 有关!! 不知道是啥,,,
		event.persisted 	
			The persisted property returns a Boolean value that indicates if the webpage is loaded directly from the server, 
			or if the page is cached, when an onpageshow or onpagehide event occurs.
		event.propertyName : TransitionEvent 用到的参数!!! 显示变形的参数是哪个
			比如 width 变化了, 就是width在改变!!
		event.relatedTarget : 事件发生的相关节点
		event.target : 发生事件的节点
		event.targetTouches : 多指触控,记录有多少个手指!! 触摸着指定的节点
		event.touches: 多指触控,记录有多少个手指同时触摸 屏幕
		event.screenX : 相对于电脑屏幕 的位置
		event.screenY : 
		event.stopImmediatePropagation(): 同一个事件有多个 事件触发函数时候,后面的触发函数将不会工作!!
		event.stopPropagation() : 某些子节点 和 父节点 有相同的触发事件,所以点击子节点也会继续触发父节点的函数
					  这个函数阻止 父节点函数及以后的触发!!	
		event.timeStamp : 从 January 1, 1970 到现在的 毫秒 数 milliseconds
		event.type : 显示当前什么事件!! 例如 onclick mouseup.....
		event.view : 不知道是啥
	
	操作事件的api	
		createEvent(): 建立事件
			var x = document.createEvent("MouseEvent");
			x.initMouseEvent("mouseover", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
			document.getElementById("myDiv").dispatchEvent(x);
DOM screen:
	screen.availHeight 电脑屏幕不含 win开始菜单烂 有效高度
	screen.availWidth  电脑屏幕不含 win开始菜单烂 有效高度
	screen.colorDepth 颜色深度 红绿蓝
	screen.pixelDepth 像素点深度  24bit 16bit 8bit
	screen.height : 电脑屏幕高度
	screen.width :  电脑屏幕宽度
DOM Window 一般来说浏览器显示页面的的区域就是我们说的 窗口
	窗口的开关:
		myWindow = window.open("", "myWindow", "width=400, height=200");  新建一个窗口
		myWindow.close(); 关闭这个窗口
		myWindow.closed  这个窗口的关闭状态
	console 属于窗口成员,一般不需要 加上 window. 直接 console.log() 使用等等
	window.defaultStatus  //可以自定义描述窗口的状态!!
***	这里值得 讨论下 screen window frame document 的抽象关系
		screen 就是 电脑屏幕, 
		window 窗口是一个抽象概念,是一个数据, 承载窗口的载体 有两种: 浏览器显示页面的区域, html页面中嵌入 的 iframe 节点对象
		document 就是页面内容文本,是 window 的成员.
	window.frameElement: 如果当前 window 搭载在 iframe 上, 就返回这个 iframe 节点
		否则,window是搭在浏览器上,返回null
	window.length: 当前的document 的 iframe 的个数 提取到 window.length 数据里
	window,frames[x] :  窗口数据包含着 document这个分数据, document 嵌入的 <iframe>对象会提取出来
		也称为了窗口的 另外的分数据frames
	window.history: 保存着窗口 岑经加载过的 document 网址
		window.history.go(-2)  window加载曾经加载过的 往前第二个网页 的docment
		window.history.forward() 加载往后的一个网页
		window.history.back() 加载往前的一个网页
	关于尺寸问题:
*		window.innerWidth
		window.innerHeight
			Use the outerWidth and outerHeight properties to get the width/height of the browser window.
			即浏览器的显示页面区域的大小,或者 iframe 节点显示内容区域的大小 (不包括 滑动条等其他!!)!!!
		window.outerWidth;
		window.outerHeight; 
			Use the outerWidth and outerHeight properties to get the width/height of the browser window.
			即浏览器的显示页面区域的大小,或者 iframe 节点显示内容区域的大小 
			(包括浏览器的滑动条,菜单栏工具栏等,,,除了浏览器的顶部窗口控制栏,最大化,关闭,最小化那栏!!)!!!
		window.pageXOffset
		window.pageYOffset
			窗口显示的页面内容有具体尺寸大小, pageoffset 就是 页面内容的偏移位置
			例如 
				window.scrollBy(100, 200);
				此刻显示页面内容的偏移位置 pageXOffset pageYOffset 就是 X:100 y:200 pixl 的像素位置
		window.screenLeft
		window.screenTop
			window outer 区域, 相对于电脑屏幕的偏移!!!
		myWindow.screenX
		myWindow.screenY
		 	window outer 区域, 相对于电脑屏幕的偏移!!! 不知道有什么区别
	window.parent :如果窗口的载体是 iframe, parent就是这个ifrane所在的父窗口 window		
		一般直接  parent 使用,不需要加载 window. 前缀
	window.screen : 就是之前讨论 的  DOM screen 电脑屏幕:
		一般直接  screen 使用,不需要加载 window. 前缀
	window.sessionStorage  会话信息存储
		一般直接  sessionStorage 使用,不需要加载 window. 前缀
	window.localStorage 当前窗口存储的临时数据的地方
		一般直接  localStorage 使用,不需要加载 window. 前缀
	window.Location  位置信息:比如 uri  经纬度等
		一般直接  location 使用,不需要加载 window. 前缀
	window.alert() 窗口通知
		一般直接  alert 使用,不需要加载 window. 前缀
	window.confirm() 也是窗口通知
		一般直接  confirm 使用,不需要加载 window. 前缀
		例如: confirm("Press a button!");
	window.prompt() : 临时参数输入窗口 例如:
		var person = prompt("Please enter your name", "Harry Potter");
	window.name  窗口的名字
	window.navigator 导航信息 例如关于 什么浏览器 浏览器版本之类
		一般直接  navigator 使用,不需要加载 window. 前缀
	window.opener : 窗口打开者 
		myWindow = window.open(...)
		myWindow.opener  指的是 打开 myWindow 窗口 的 父窗口对象
	window.top
		显示在顶层的窗口对象
	window.self
		窗口自己本身对象!!
		window.top != window.self  检查顶层显示的窗口是不是当前窗口本身
	window.status 窗口对象的状态:  用法例如
		window.status = "Some text in the status bar!!";
	window.btoa(str);  string to a base-64 encoded string
	window.atob(enc);  a base-64 encoded string to string
	Window.blur() : 取消 窗口的 focus
	window.focus() : focus 窗口
	window.setInterval() 设置定时事件
	window.clearInterval() 取消定时事件
	window.setTimeout() 设置超时事件
	window.clearTimeout() 取消超时事件
	window.getComputedStyle() 获得指定节点 最终演示的 指定的 css 属性,例如:
		var elem = document.getElementById("test");
		var theCSSprop = window.getComputedStyle(elem, null).getPropertyValue("background-color");
	window.matchMedia() : 判断 window 显示大小是否达到目标
		window.matchMedia("(max-width: 700px)").matches
	window.moveBy(250, 250); 移动多少个像素点
	Window.moveTo(250, 250); 移动到屏幕某处
	window.scrollBy(100, 0): 滑动条滑动多少位置
	window.scrollTo(500, 0); 滑动条滑动到某位置
	window.resizeBy(): 缩放多少个像素点
	window.resizeTo(): 缩放到某尺寸  
	window.print(); 打印当前页面内容	
DOM web stroge: 页面的 临时存储: localStorage sessionStorage
	localStorage.key[x] 页面存储的 key 内容
	localStorage.length : localStorage 内容成员
	getItem(keyname) 	Returns the value of the specified key name
	setItem(keyname, value) 	Adds that key to the storage, or update that key's value if it already exists
		例如: localStorage.setItem("mytime", Date.now()); 
		      sessionStorage.setItem("lastname", "Smith");
	removeItem(keyname) 	Removes that key from the storage
	clear() 	Empty all key out of the storage	
	相关的: localStorage, sessionStorage 是属于 窗口的参数???
	window.localStorage 	Allows to save key/value pairs in a web browser. Stores the data with no expiration date
	window.sessionStorage 	Allows to save key/value pairs in a web browser. Stores the data for one session
DOM style: 通过 dom 修改 css 内容!!!!
	内容太多, 配合 css 一起学习讨论














20190427
javascript jquery vue.js react angular.js 关系:
javascript 原生语言
jquery 简单底层封装的一套 js 库, 也可以认为是 伪原生语言
vue.js, react, angular.js,  针对 大部分 情景特定 而封装的 js应用框架, 降低开发工作量
所以 : javascript  jquery 需要 学习,
框架的话 选流行的就好了, react 复杂适合做大型项目, vue轻量,还在发展, 大家的相当,react易于做移动端,但学习路线陡峭
排除 angular,  react 和 vue 选, 目前认为 vue 合适
bootstrap 是 css 模板,跟多现成的UI模块, 可以配合 js应用框架使用
jquery 学习:
使用jquery 需要加载库:
	<head>	//加载本地的,需要先下载
	<script src="jquery-3.3.1.min.js"></script>
	</head>
	<head>	//从cdn 上加载, 即从内容托管网站加载
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	</head> 
分布加载jquery函数:
	<head>  //注意放置顺序,因为决定了加载顺序
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="my_jquery_functions.js"></script>
	</head> 
语法:
	快速学习例子:
		$(this).hide() - hides the current element.
		$("p").hide() - hides all <p> elements.
		$(".test").hide() - hides all elements with class="test".
		$("#test").hide() - hides the element with id="test".
		$(document).ready(function(){  // jQuery methods go here...   } ); //注册了一个ready函数 当doc加载好,执行 function()
	也可以这样注册一个事件函数:
	 $(  function(){  // jQuery methods go here... }  ); 
	注册一个ready事件函数,doc加载完就执行, ready事件函数的工作是 注册一个点击事件函数,
		$(document).ready(function(){
		  $("button").click(function(){
		    $("p").hide();
		  });
		});
		.ready() //注册 ready 事件函数
		.click() //注册 点击 事件函数
		.hide()  //直接执行的隐藏函数
	选择器:
		$("*") 	Selects all elements 	
		$(this) 	Selects the current HTML element 	
		$("p.intro") 	Selects all <p> elements with class="intro" 	
		$("p:first") 	Selects the first <p> element 	
		$("ul li:first") 	Selects the first <li> element of the first <ul> 	
		$("ul li:first-child") 	Selects the first <li> element of every <ul> 	
		$("[href]") 	Selects all elements with an href attribute 	
		$("a[target='_blank']") 	Selects all <a> elements with a target attribute value equal to "_blank" 	
		$("a[target!='_blank']") 	Selects all <a> elements with a target attribute value NOT equal to "_blank" 	
		$(":button") 	Selects all <button> elements and <input> elements of type="button" 	
		$("tr:even") 	Selects all even <tr> elements 	
		$("tr:odd") 	Selects all odd <tr> elements
		Selector 		Example 			Selects
		* 			$("*") 				All elements
		#id 			$("#lastname") 			The element with id="lastname"
		.class 			$(".intro") 			All elements with class="intro"
		.class,.class 		$(".intro,.demo") 		All elements with the class "intro" or "demo"
		element 		$("p") 				All <p> elements
		el1,el2,el3 		$("h1,div,p") 			All <h1>, <div> and <p> elements
		  	  		 	
		:first 			$("p:first") 			The first <p> element
		:last 			$("p:last") 			The last <p> element
		:even 			$("tr:even") 			All even <tr> elements
		:odd 			$("tr:odd") 			All odd <tr> elements
		  	  		 	
		:first-child 		$("p:first-child") 		All <p> elements that are the first child of their parent
		:first-of-type 		$("p:first-of-type") 		All <p> elements that are the first <p> element of their parent
		:last-child 		$("p:last-child") 		All <p> elements that are the last child of their parent
		:last-of-type 		$("p:last-of-type") 		All <p> elements that are the last <p> element of their parent
		:nth-child(n) 		$("p:nth-child(2)") 		All <p> elements that are the 2nd child of their parent
		:nth-last-child(n) 	$("p:nth-last-child(2)") 	All <p> elements that are the 2nd child of their parent, 
									counting from the last child
		:nth-of-type(n) 	$("p:nth-of-type(2)") 		All <p> elements that are the 2nd <p> element of their parent
		:nth-last-of-type(n) 	$("p:nth-last-of-type(2)") 	All <p> elements that are the 2nd <p> element of their parent,
							 		counting from the last child
		:only-child 		$("p:only-child") 		All <p> elements that are the only child of their parent
		:only-of-type 		$("p:only-of-type") 		All <p> elements that are the only child, 
									of its type, of their parent
		  	  	 
		parent > child 		$("div > p") 			All <p> elements that are a direct child of a <div> element
		parent descendant 	$("div p") 			All <p> elements that are descendants of a <div> element
		element + next 		$("div + p") 			The <p> element that are next to each <div> elements
		element ~ siblings 	$("div ~ p") 			All <p> elements that are siblings of a <div> element
		  	  	 
		:eq(index) 		$("ul li:eq(3)") 		The fourth element in a list (index starts at 0)
		:gt(no) 		$("ul li:gt(3)") 		List elements with an index greater than 3
		:lt(no) 		$("ul li:lt(3)") 		List elements with an index less than 3
		:not(selector) 		$("input:not(:empty)") 		All input elements that are not empty
		  	  		 
		:header 		$(":header") 			All header elements <h1>, <h2> ...
		:animated 		$(":animated") 			All animated elements
		:focus 			$(":focus") 			The element that currently has focus
		:contains(text) 	$(":contains('Hello')") 	All elements which contains the text "Hello"
		:has(selector) 		$("div:has(p)") 		All <div> elements that have a <p> element
		:empty 			$(":empty") 			All elements that are empty
		:parent 		$(":parent") 			All elements that are a parent of another element
		:hidden 		$("p:hidden") 			All hidden <p> elements
		:visible 		$("table:visible") 		All visible tables
		:root 			$(":root") 			The document's root element
		:lang(language) 	$("p:lang(de)") 		All <p> elements with a lang attribute value starting with "de"
		  	  	 
		[attribute] 		$("[href]") 			All elements with a href attribute
		[attribute=value] 	$("[href='default.htm']") 	All elements with a href attribute value equal to "default.htm"
		[attribute!=value] 	$("[href!='default.htm']") 	All elements with a href attribute value 
									not equal to "default.htm"
		[attribute$=value] 	$("[href$='.jpg']") 		All elements with a href attribute value ending with ".jpg"
		[attribute|=value] 	$("[title|='Tomorrow']") 	All elements with a title attribute value 
									equal to 'Tomorrow', or starting with 'Tomorrow' 
									followed by a hyphen
		[attribute^=value] 	$("[title^='Tom']") 		All elements with a title attribute value starting with "Tom"
		[attribute~=value] 	$("[title~='hello']") 		All elements with a title attribute value containing 
									the specific word "hello"
		[attribute*=value] 	$("[title*='hello']") 		All elements with a title attribute value containing 
									the word "hello"		  	  	 
		:input 			$(":input") 			All input elements
		:text 			$(":text") 			All input elements with type="text"
		:password 		$(":password") 			All input elements with type="password"
		:radio 			$(":radio") 			All input elements with type="radio"
		:checkbox 		$(":checkbox") 			All input elements with type="checkbox"
		:submit 		$(":submit") 			All input elements with type="submit"
		:reset 			$(":reset") 			All input elements with type="reset"
		:button 		$(":button") 			All input elements with type="button"
		:image 			$(":image") 			All input elements with type="image"
		:file 			$(":file") 			All input elements with type="file"
		:enabled 		$(":enabled") 			All enabled input elements
		:disabled 		$(":disabled") 			All disabled input elements
		:selected 		$(":selected") 			All selected input elements
		:checked 		$(":checked") 			All checked input elements
					
	注册事件的函数,一般有: 
		Mouse Events 	Keyboard Events 	Form Events 	Document/Window Events
		click 		keypress 		submit 		load
		dblclick 	keydown 		change 		resize
		mouseenter 	keyup 			focus 		scroll
		mouseleave 	  			blur 		unload
		hover()
		mouseup
		mousedown
		
		hover例子: The first function is executed when the mouse enters the HTML element, 
		and the second function is executed when the mouse leaves the HTML element:
			 $("#p1").hover(function(){
			  alert("You entered p1!");
			},
			function(){
			  alert("Bye! You now leave p1!");
			});
		一个普遍通用注册函数  on(): 例如
			$("p").on("click", function(){
			  $(this).hide();
			}); 
 		      再例如,符合注册
			$("p").on({
			  mouseenter: function(){
			    $(this).css("background-color", "lightgray");
			  },
			  mouseleave: function(){
			    $(this).css("background-color", "lightblue");
			  },
			  click: function(){
			    $(this).css("background-color", "yellow");
			  }
			});
		一般注册事件: 
		bind() 			Deprecated in version 3.0. Use the on() method instead. Attaches event handlers to elements
		blur() 			Attaches/Triggers the blur event
		change() 		Attaches/Triggers the change event
		click() 		Attaches/Triggers the click event
		dblclick() 		Attaches/Triggers the double click event
		delegate() 		Deprecated in version 3.0. Use the on() method instead. Attaches a handler to current, 
					or future, specified child elements of the matching elements
		die() 			Removed in version 1.9. Removes all event handlers added with the live() method
		error() 		Removed in version 3.0. Attaches/Triggers the error event
		focus() 		Attaches/Triggers the focus event
		focusin() 		Attaches an event handler to the focusin event
		focusout() 		Attaches an event handler to the focusout event
		hover() 		Attaches two event handlers to the hover event
		keydown() 		Attaches/Triggers the keydown event
		keypress() 		Attaches/Triggers the keypress event
		keyup() 		Attaches/Triggers the keyup event
		live() 			Removed in version 1.9. Adds one or more event handlers to current, or future, selected elements
		load() 			Removed in version 3.0. Attaches an event handler to the load event
		mousedown() 		Attaches/Triggers the mousedown event
		mouseenter() 		Attaches/Triggers the mouseenter event
		mouseleave() 		Attaches/Triggers the mouseleave event
		mousemove() 		Attaches/Triggers the mousemove event
		mouseout() 		Attaches/Triggers the mouseout event
		mouseover() 		Attaches/Triggers the mouseover event
		mouseup() 		Attaches/Triggers the mouseup event
		off() 			Removes event handlers attached with the on() method
		on() 			Attaches event handlers to elements
		one() 			Adds one or more event handlers to selected elements. 
					This handler can only be triggered once per element
		$.proxy() 		Takes an existing function and returns a new one with a particular context
		ready() 		Specifies a function to execute when the DOM is fully loaded
		resize() 		Attaches/Triggers the resize event
		scroll() 		Attaches/Triggers the scroll event
		select() 		Attaches/Triggers the select event
		submit() 		Attaches/Triggers the submit event
		toggle() 		Removed in version 1.9. Attaches two or more functions to toggle between for the click event
		trigger() 		Triggers all events bound to the selected elements
		triggerHandler() 	Triggers all functions bound to a specified event for the selected elements
		unbind() 		Deprecated in version 3.0. Use the off() method instead. 
					Removes an added event handler from selected elements
		undelegate() 		Deprecated in version 3.0. Use the off() method instead. 
					Removes an event handler to selected elements, now or in the future
		unload() 		Removed in version 3.0. Attaches an event handler to the unload event		
		这些是 特殊的事件函数和对象,不是注册函数
		event.currentTarget 	The current DOM element within the event bubbling phase
		event.data 		Contains the optional data passed to an event method when the current executing handler is bound
		event.delegateTarget 	Returns the element where the currently-called jQuery event handler was attached
		event.isDefaultPrevented() 		Returns whether event.preventDefault() was called for the event object
		event.isImmediatePropagationStopped() 	Returns whether event.stopImmediatePropagation() was called for the event object
		event.isPropagationStopped() 		Returns whether event.stopPropagation() was called for the event object
		event.namespace 	Returns the namespace specified when the event was triggered
		event.pageX 		Returns the mouse position relative to the left edge of the document
		event.pageY 		Returns the mouse position relative to the top edge of the document
		event.preventDefault() 	Prevents the default action of the event
		event.relatedTarget 	Returns which element being entered or exited on mouse movement
		event.result 		Contains the last/previous value returned by an event handler triggered by the specified event
		event.stopImmediatePropagation() 	Prevents other event handlers from being called
		event.stopPropagation() 		Prevents the event from bubbling up the DOM tree, 
							preventing any parent handlers from being notified of the event
		event.target 		Returns which DOM element triggered the event
		event.timeStamp 	Returns the number of milliseconds since January 1, 1970, when the event is triggered
		event.type 		Returns which event type was triggered
		event.which 		Returns which keyboard key or mouse button was pressed for the event
	效果函数:
		hide() and show()
		toggle()  //when hiding show, when showing hide
		fadeIn( speed,callback ) //显示	
		fadeOut( speed,callback ) //隐去
		fadeTogglee(speed,callback)// when in out,  when out in  
		fadeTo(speed,opacity,callback)
			//speed:values: "slow", "fast", or milliseconds. 
			//callback function to be executed after the fading completes.
			//opacity: fading to a given opacity 透明程度(value between 0 and 1)
		slideDown(speed,callback);	//下拉抽屉
		slideUp(speed,callback);	//上拉抽屉
		slideToggle(speed,callback);	//when down uo , when up down
			//speed:values: "slow", "fast", or milliseconds. 
			//callback function to be executed after the fading completes.
		animate({params},speed,callback); //动画效果
			//params parameter defines the CSS properties to be animated.
			//speed:values: "slow", "fast", or milliseconds. 
			//callback function to be executed after the fading completes.
			例子:
			$("button").click(function(){
			  $("div").animate({
			    left: '250px',
			    opacity: '0.5',
			    height: '150px',
			    width: '150px'
			  });
			});  
		stop() : 停止动画效果!!
		还有:
		delay() 	Sets a delay for all queued functions on the selected elements
		dequeue() 	Removes the next function from the queue, and then executes the function
		finish() 	Stops, removes and completes all queued animations for the selected elements
		queue() 	Shows the queued functions on the selected elements
		clearQueue() 	Removes all remaining queued functions from the selected elements
	链式执行函数:
		例如:
		 $("#p1").css("color", "red").slideUp(2000).slideDown(2000); //先改css,然后uo,最后dowm
		又例如:
		 $("#p1").css("color", "red")
		  .slideUp(2000)
		  .slideDown(2000); 
	用于 html 函数  set  get:
		text() - Sets or returns the text content of selected elements
		html() - Sets or returns the content of selected elements (including HTML markup)
		val() - Sets or returns the value of form fields
			无参数,获得数据, 有参数设置数据
		例如:
			  $("#test1").text("Hello world!");
			  $("#test2").html("<b>Hello world!</b>");
			  $("#test1").text();
			  $("#test2").html();
		attr() - method is used to get set attribute values.
			 $("#w3s").attr("href")	//get

			 $("#w3s").attr({	//set
			    "href" : "https://www.w3schools.com/jquery/",
			    "title" : "W3Schools jQuery Tutorial"
			  }
		
			  $("#w3s").attr("href", function(i, origValue){   //set
			    return origValue + "/jquery/";
			  })
	用于 html 函数  add remove:	
		append() - Inserts content at the end of the selected elements
		prepend() - Inserts content at the beginning of the selected elements
		after() - Inserts content after the selected elements
		before() - Inserts content before the selected elements
		例子:
			$("p").prepend("Some prepended text."); 
			var txt1 = "<p>Text.</p>";               // Create element with HTML 
			var txt2 = $("<p></p>").text("Text.");   // Create with jQuery
			var txt3 = document.createElement("p");  // Create with DOM
			txt3.innerHTML = "Text.";
			$("body").append(txt1, txt2, txt3);      // Append the new elements 
		remove() - Removes the selected element (and its child elements)
		empty() - Removes the child elements from the selected element
		例子:
			$("#div1").remove(); //removes the selected element(s) and its child elements.
			$("#div1").empty();  //removes the child elements of the selected element(s).
			$("p").remove(".test"); //removes all <p> elements with class="test"
			$("p").remove(".test, .demo");  //removes all <p> elements with class="test" or class="demo"
	用于 html 函数  修改 css:
		addClass() - Adds one or more classes to the selected elements
		removeClass() - Removes one or more classes from the selected elements
		toggleClass() - Toggles between adding/removing classes from the selected elements
		css() - Sets or returns the style attribute			
		例子:
			$("h1, h2, p").addClass("toblue"); // all <h1> <h2> <p> add class toblue
			$("p").css("background-color"); //return   background-color
			$("p").css("background-color", "yellow"); //set  background-color
			$("p").css({"background-color": "yellow", "font-size": "200%"}); //mul set
		一般DOM 和 css api:
		addClass() 	Adds one or more class names to selected elements
		after() 	Inserts content after selected elements
		append() 	Inserts content at the end of selected elements
		appendTo() 	Inserts HTML elements at the end of selected elements
		attr() 	Sets or returns attributes/values of selected elements
		before() 	Inserts content before selected elements
		clone() 	Makes a copy of selected elements
		css() 	Sets or returns one or more style properties for selected elements
		detach() 	Removes selected elements (keeps data and events)
		empty() 	Removes all child nodes and content from selected elements
		hasClass() 	Checks if any of the selected elements have a specified class name
		height() 	Sets or returns the height of selected elements
		html() 	Sets or returns the content of selected elements
		innerHeight() 	Returns the height of an element (includes padding, but not border)
		innerWidth() 	Returns the width of an element (includes padding, but not border)
		insertAfter() 	Inserts HTML elements after selected elements
		insertBefore() 	Inserts HTML elements before selected elements
		offset() 	Sets or returns the offset coordinates for selected elements (relative to the document)
		offsetParent() 	Returns the first positioned parent element
		outerHeight() 	Returns the height of an element (includes padding and border)
		outerWidth() 	Returns the width of an element (includes padding and border)
		position() 	Returns the position (relative to the parent element) of an element
		prepend() 	Inserts content at the beginning of selected elements
		prependTo() 	Inserts HTML elements at the beginning of selected elements
		prop() 		Sets or returns properties/values of selected elements
		remove() 	Removes the selected elements (including data and events)
		removeAttr() 	Removes one or more attributes from selected elements
		removeClass() 	Removes one or more classes from selected elements
		removeProp() 	Removes a property set by the prop() method
		replaceAll() 	Replaces selected elements with new HTML elements
		replaceWith() 	Replaces selected elements with new content
		scrollLeft() 	Sets or returns the horizontal scrollbar position of selected elements
		scrollTop() 	Sets or returns the vertical scrollbar position of selected elements
		text() 	Sets or returns the text content of selected elements
		toggleClass() 	Toggles between adding/removing one or more classes from selected elements
		unwrap() 	Removes the parent element of the selected elements
		val() 	Sets or returns the value attribute of the selected elements (for form elements)
		width() 	Sets or returns the width of selected elements
		wrap() 	Wraps HTML element(s) around each selected element
		wrapAll() 	Wraps HTML element(s) around all selected elements
		wrapInner() 	Wraps HTML element(s) around the content of each selected element
		
 	用于 html 的 Dimensions  : margin border pading elementcontent
		width()		the width of an element (excludes padding, border and margin).
		height()	the height of an element (excludes padding, border and margin)
			除了 element 也可以描述 $(document)  $(window)
		innerWidth()	the width of an element (includes padding).
		innerHeight()	the height of an element (includes padding)
		outerWidth()	the width of an element (includes padding and border)
		outerHeight()	the height of an element (includes padding and border)
		outerWidth(true)	the width of an element (includes padding, border, and margin).
		outerHeight(true)	the height of an element (includes padding, border, and margin).
		另外, 只有 width() height()  添加参数,可以设置 ,
		其他都一般都不建议设置!! 因为不知到参数都分布给 elementcontent ,psdding, border 等多少长度
	用于 HTML DOM Traversing : 就是关于节点的 父子关系和 移动 ??
		(Ancestors)	
		parent()	//返回父节点	(Ancestors)
		parents()	//返回所有扣扣相嵌的父节点们!! 返回是一个数组还是字典  ?? 
		parentsUntil("div")  //返回所有扣扣相嵌的父节点们!!知道遇到div父节点,但不包括这个div父节点 返回是一个数组还是字典  ?? 
		(Descendants)
		children()	// returns all direct children of the selected element.
				//
			 $("div").children("p.first");  // returns all <p> elements with the class name "first", 
							// that are direct children of <div> (不包括子节点的子节点)
		find()		//The find() method returns descendant elements of the selected element, 
				//all the way down to the last descendant. (包括子节点的子节点)
			 $("div").find("span");  //返回所有 <span> 节点 包括搜索 子节点的子节点!!
		(Siblings)
		siblings()  //returns all sibling elements of the selected element
			$("h2").siblings() //返回所有 跟 <h2> 同阶层的节点!!
			$("h2").siblings("p");  //返回所有 跟 <h2> 同阶层的<p>节点!
		next()	// 同阶层的下一个节点
		nextAll() // 同阶层的后面的所有节点
		nextUntil("h6")  //同阶层的后面的所有节点直到第一个 遇到的 <h6>节点(不包括这个<h6>节点)
		prev()		// 同阶层的上一个节点
		prevAll()	// 同阶层的前面的所有节点
		prevUntil("h6")	//同阶层的前面的所有节点直到第一个 遇到的 <h6>节点(不包括这个<h6>节点)
		此外还有:
		add() 	Adds elements to the set of matched elements
		addBack() 	Adds the previous set of elements to the current set
		andSelf() 	Deprecated in version 1.8. An alias for addBack()
		closest() 	Returns the first ancestor of the selected element
		contents() 	Returns all direct children of the selected element (including text and comment nodes)
		each() 		Executes a function for each matched element
		end() 		Ends the most recent filtering operation in the current chain, 
				and return the set of matched elements to its 	previous state
		filter() 	Reduce the set of matched elements to those that match the selector or pass the function's test
			 $(selector).filter(criteria,function(index))
				criteria  筛选条件,
				function(index)  筛选出来的成员每个都得执行一次 这个函数!!
		has() 		Returns all elements that have one or more elements inside of them
		is() 		Checks the set of matched elements against a selector/element/jQuery object, 
				and return true if at least one of these elements matches the given arguments
		map() 		Passes each element in the matched set through a function, 
				producing a new jQuery object containing the return values
		offsetParent() 	Returns the first positioned parent element
		slice() 	Reduces the set of matched elements to a subset specified by a range of indices
	用于 HTML DOM, Filtering 筛选
		$("div").first();  //第一个 <div> 节点
		$("div").last();   //最后一个 <div> 节点
		$("p").eq(1);   // 选取 第二个 <p> 节点 , 参数1代表第二个, 所以从 0 开始, 0代表第一个
		$("p").filter(".intro"); //返回所 所有带有 class=intro 的 <p>节点
		$("p").filter(".intro").eq(0); //返回所 带有 class=intro 的第一个 <p>节点
		$("p").not(".intro"); //返回所 所有不带 class=intro 的 <p>节点
	专门用于 ajax 的 jquery 模块
		$(selector).load(URL,data,callback); 
			url, 加载文本的路径
			data, 加载文本申请所用到的 参数
			callback, 回调函数
			$("#div1").load("demo_test.txt"); //加载 txt文本所有内容到 div1 的节点里
			$("#div1").load("demo_test.txt #p1"); //加载 txt文本的 id=p1 的节点内容到 div1节点里
		$.get(URL,callback); // GET REQUEST
			例如:
			  $.get("demo_test.asp", function(data, status){
			    alert("Data: " + data + "\nStatus: " + status);
			  }); 
		$.post(URL,data,callback); // POST REQUEST
			$("button").click(function(){
			  $.post("demo_test_post.asp",
			  {
			    name: "Donald Duck",
			    city: "Duckburg"
			  },
			  function(data, status){
			    alert("Data: " + data + "\nStatus: " + status);
			  });
			}); 
			//把数据 post 到 server 当成功收到反馈数据时 使用 alert 把反馈显示出来
		此外还有:
		$.ajax() 	Performs an async AJAX request
		$.ajaxPrefilter() 	Handle custom Ajax options or modify existing options 
					before each request is sent and before they are processed by $.ajax()
		$.ajaxSetup() 	Sets the default values for future AJAX requests
		$.ajaxTransport() 	Creates an object that handles the actual transmission of Ajax data
		$.get() 	Loads data from a server using an AJAX HTTP GET request
		$.getJSON() 	Loads JSON-encoded data from a server using a HTTP GET request
		$.parseJSON() 	Deprecated in version 3.0, use JSON.parse() instead. 
				Takes a well-formed JSON string and returns the resulting JavaScript value
		$.getScript() 	Loads (and executes) a JavaScript from a server using an AJAX HTTP GET request
		$.param() 	Creates a serialized representation of an array or object 
				(can be used as URL query string for AJAX requests)
		serialize() 	Encodes a set of form elements as a string for submission
		serializeArray() 	Encodes a set of form elements as an array of names and values
		注册事件函数:
		ajaxComplete() 	Specifies a function to run when the AJAX request completes
		ajaxError() 	Specifies a function to run when the AJAX request completes with an error
		ajaxSend() 	Specifies a function to run before the AJAX request is sent
		ajaxStart() 	Specifies a function to run when the first AJAX request begins
		ajaxStop() 	Specifies a function to run when all AJAX requests have completed
		ajaxSuccess() 	Specifies a function to run when an AJAX request completes successfully
	专门用于 jquery 与 冲突:
		jQuesy 使用 $ 代替 jQuery, 当其他js应用库和框架要使用到 $ 便会冲突,
		这时我们可以这样子, $.noConflict(); 释放 $ 符号的捆绑, 之后要使用jQuery时,只能这样
		例如: jQuery("div").first();
**	关于 filter function的问题
		以下例子, 不知道是如何使用 filter ,和 this 指针的问题!!!
		// $("#myDIV *") 取得了所有内容加入列表
		//.filter(function) 循环取出列表每一个对象 执行一次 filter 里的 function 函数!!
		$(document).ready(function(){
		  $("#myInput").on("keyup", function() {
		    var value = $(this).val().toLowerCase();
		    $("#myDIV *").filter(function() {
		      $("#myInput").toggle($("#myInput").text().toLowerCase().indexOf(value) > -1)
		    });
		  });
		});

		<input id="myInput" type="text" placeholder="Search..">

		<div id="myDIV">
		  <p>I am a paragraph.</p>
		  <div>I am a div element inside div.</div>
		  <button>I am a button</button>
		  <button>Another button</button>
		  <p>Another paragraph.</p>
		</div>
	其他  Miscellaneous Methods
		data() 	Attaches data to, or gets data from, selected elements
		each() 	Execute a function for each matched element
		index() 	Search for a given element from among the matched elements
		$.param() 	Create a serialized representation of an array or object 
				(can be used as URL query string for AJAX requests)
		removeData() 	Removes a previously-stored piece of data
		size() 	Removed in version 3.0. Use the length property instead
		toArray() 	Retrieve all the DOM elements contained in the jQuery set, as an array
	关于 jquery 库的属性,自身信息
		context 	Removed in version 3.0. Contains the original context passed to jQuery()
		jquery 	Contains the jQuery version number
		jQuery.fx.interval 	Change the animation firing rate in milliseconds
		jQuery.fx.off 	Globally disable/enable all animations
		jQuery.support 	A collection of properties representing different browser features or bugs 
				(Intended for jQuery's internal use)
		length 	Contains the number of elements in the jQuery object













20190429
vue.js
在 html xml 文本里: Vue.js uses double braces {{ }} as place-holders for data.
简单例子1:
	<head>
		<meta charset="utf-8">
		<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
		<script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"></script>
	</head>
	<body>
	<div id="vue_det">
	    <h1>site : {{site}}</h1>
	    <h1>url : {{url}}</h1>
	    <h1>{{details()}}</h1>
	</div>
	<script type="text/javascript">
	    var vm = new Vue({
	        el: '#vue_det',
	        data: {
	            site: "菜鸟教程",
	            url: "www.runoob.com",
	            alexa: "10000"
	        },
	        methods: {
	            details: function() {
	                return  this.site + " - 学的不仅是技术，更是梦想！";
	            }
	        }
	    })
	</script>
	</body>
	vm 实例化 内容直接填充指定地方
简单例子2:
	<div id="vue_det">
	    <h1>site : {{site}}</h1>
	    <h1>url : {{url}}</h1>
	    <h1>Alexa : {{alexa}}</h1>
	</div>
	<script type="text/javascript">
	// 我们的数据对象
	var vdata = { site: "菜鸟教程", url: "www.runoob.com", alexa: 10000}
	var vm = new Vue({
	    el: '#vue_det',
	vm.site = "Runoob"
	    data: vdata
	})
	</script>
	这时, vdata链接到 vm, 当 vm.site改变时候,意味着 vdata.site 也改变 因为他们是同个东西,并同时改变 html 的显示
	vm.$data 就是指 vdata 参数
	vm.$el   就是指 <div id="vue_det"> 这个节点 (document.getElementById('vue_det'))!!!
模板语法!!
	注意 要是 v-xxx  {{}} 的生效, 必须对 这些语法所在的 父div 建立一个vue对象, 就是对 <div id="app"> 建立一个 new vue !!
	上述使用的是 文本插值的模板语法 {{ }} , 又更多方便的 模板插值语法!!
	直接在 直接在 {{ }} 文本插值模板上使用 JavaScript 表达式!!! 在 v-XXX上使用js表达式子
		<div id="app">
		    {{5+5}}<br>
		    {{ ok ? 'YES' : 'NO' }}<br>
		    {{ message.split('').reverse().join('') }}
		    <div v-bind:id="'list-' + id">菜鸟教程</div>
		</div>
		.........    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    ok: true,
		    message: 'RUNOOB',
		    id : 1
		  }
		})
		</script>
	html节点插值模板:
		<div id="app">
		    <div v-html="message"></div>
		</div>
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    message: 
		  }
		})
		</script>
		实际得到的显示结果是:
		<div id="app">
		    <div>
			'<h1>菜鸟教程</h1>'
		    </div>
		</div>			
	属性节点插值模板:
		<style>
		.class1{
		  background: #444;
		  color: #eee;
		}
		</style>
		.....
		<div id="app">
		  <label for="r1">修改颜色</label><input type="checkbox" v-model="use" id="r1">
		  <br><br>
		  <div v-bind:class="{'class1': use}">
		    v-bind:class 指令	//点击checkbox 改变这里的颜色!!
		  </div>
		</div>
		..........    
		<script>
		new Vue({
		    el: '#app',
		  data:{
		      use: false
		  }
		});
		</script>
	指令插值模板:  v-if  if判断指令
		<div id="app">
		    <p v-if="seen">现在你看到我了</p>
		</div>
		......    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    seen: true
		  }
		})
		</script>
	参数插值模板:	v-bind 动态更新属性参数 ,例如 class href 什么的
		<div id="app">
		    <pre><a v-bind:href="url">菜鸟教程</a></pre>
		</div>
		    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    url: 'http://www.runoob.com'
		  }
		})
		</script>
		v-bind 缩写:
			<a v-bind:href="url"></a>    等于 <a :href="url"></a>
		例子1:
		<div id="app">
		  <div v-bind:class="classObject"></div>	//相当于 class="active text-danger"
		</div>
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    classObject: {
		      active: true,
		      'text-danger': true
		    }
		  }
		})
		</script>
		例子2:
		<div id="app">
		  <div class="static"		//相当于 class="static active text-danger"
		     v-bind:class="{ active: isActive, 'text-danger': hasError }"> 
		  </div>
		</div>
		
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    isActive: true,
			hasError: true
		  }
		})
		</script>

	用于 实现 静听事件 的 v-on
		<a v-on:click="doSomething">
		<form v-on:submit.prevent="onSubmit"></form>  .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：
		例子:
		<div id="app">
		    <p>{{ message }}</p>
		    <button v-on:click="reverseMessage">反转字符串</button>
		</div>    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    message: 'Runoob!'
		  },
		  methods: {
		    reverseMessage: function () {
		      this.message = this.message.split('').reverse().join('')
		    }
		  }
		})
		</script>
		v-on 缩写 :  <a v-on:click="doSomething"></a>  等于 <a @click="doSomething"></a>
		事件修饰符: 例如:
			<!-- 阻止单击事件冒泡 -->
			<a v-on:click.stop="doThis"></a>
			<!-- 提交事件不再重载页面 -->
			<form v-on:submit.prevent="onSubmit"></form>
			<!-- 修饰符可以串联  -->
			<a v-on:click.stop.prevent="doThat"></a>
			<!-- 只有修饰符 -->
			<form v-on:submit.prevent></form>
			<!-- 添加事件侦听器时使用事件捕获模式 -->
			<div v-on:click.capture="doThis">...</div>
			<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
			<div v-on:click.self="doThat">...</div>
			<!-- click 事件只能点击一次，2.1.4版本新增 -->
			<a v-on:click.once="doThis"></a>
		按键修饰符:  Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：
			<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
			<input v-on:keyup.13="submit">
			记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：
			全部的按键别名：
			    .enter    .tab    .delete (捕获 "删除" 和 "退格" 键)
			    .esc    .space    .up    .down    .left
			    .right    .ctrl    .alt    .shift    .meta

			<!-- 同上 -->
			<input v-on:keyup.enter="submit">
			<!-- 缩写语法 -->
			<input @keyup.enter="submit">
	v-model: v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，
		根据表单上的值，自动更新绑定的元素的值。 和 v-bind 相似,但又不是v-bind
		<div id="app">
		    <p>{{ message }}</p>
		    <input v-model="message">
		</div>    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    message: 'Runoob!'
		  }
		})
		</script>
		关于 v-model 更深入的讨论 : 配合表格讨论!!
		v-model 针对的是 html 特定的模块,不可能是自定义的
		例如  <input type="checkbox" id="checkbox" v-model="checked">
		        <label for="checkbox">{{ checked }}</label>
		v-model只能等于 checked , 不能等于 checkeeeed ,等自定义的量!!!
		因为 checked 才能被 <input type="checkbox"> 识别
		而 checked 本身也可以作为参数 传递到 vue 和 {{}} 里
		更多 v-model 的内容需要深入 关于 vue 的表格控制!!
		v-model 也可以有修饰符号!!!
 
	过滤器 " | " 符号, 凡是 vue 语法的地方都适用,例如:
		{{ message | capitalize }}
		<div v-bind:id="rawId | formatId"></div>
		过滤器本身是一个 js 函数,例如:
		<div id="app">
		  {{ message | capitalize }}
		</div>
		    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    message: 'runoob'
		  },
		  filters: {
		    capitalize: function (value) {
		      if (!value) return ''
		      value = value.toString()
		      return value.charAt(0).toUpperCase() + value.slice(1)
		    }
		  }
		})
		</script>
		过滤器可以串联  	 {{ message | filterA | filterB }}
		过滤器是 JavaScript 函数，因此可以接受参数：  {{ message | filterA('arg1', arg2) }}
	vs-if: 条件语句:
		例如:
		<div id="app">
		    <div v-if="type === 'A'">
		      A
		    </div>
		    <div v-else-if="type === 'B'">
		      B
		    </div>
		    <div v-else-if="type === 'C'">
		      C
		    </div>
		    <div v-else>
		      Not A/B/C
		    </div>
		</div>    
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    type: 'C'
		  }
		})
		</script>
		在text模板上 也可以这样作用,例如:
		<div id= "app">
		  {{#if ok}}
		  <h1>Yes</h1>
		  {{/if}}
		</div>
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    ok: true
		  }
		})
		</script>
	v-show:
		<div id="app">
		    <h1 v-show="ok">Hello!</h1>
		</div>		
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    ok: true
		  }
		})
		</script>
	v-for : 两种主要方式!!, 
		1,循环 template 仅限于 <template>节点
		<ul>
		  <template v-for="site in sites">
		    <li>{{ site.name }}</li>	   //循环的时候, 这两部分<li> 一同循环,
		    <li>--------------</li>
		  </template>
		</ul>
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    sites: [
		      { name: 'Runoob' },
		      { name: 'Google' },
		      { name: 'Taobao' }
		    ]
		  }
		})
		</script>
			结果:
			<ul>
				<li>Runoob</li> 
				<li>--------------</li>
				<li>Google</li> 
				<li>--------------</li>
				<li>Taobao</li> 
				<li>--------------</li>
			</ul>
		2, 其他循环: 
		<div id="app">
		  <ul>
		    <li v-for="(value, key, index) in object">
		     {{ index }}. {{ key }} : {{ value }}	//循环的使用 整个<li> 包括<li>头, 一起循环
		    </li>
		  </ul>
		</div>
		<script>
		new Vue({
		  el: '#app',
		  data: {
		    object: {
		      name: '菜鸟教程',
		      url: 'http://www.runoob.com',
		      slogan: '学的不仅是技术，更是梦想！'
		    }
		  }
		})
			结果:
			<ul>
				<li>0. name : 菜鸟教程</li>
				<li>1. url : http://www.runoob.com</li>
				<li>2. slogan : 学的不仅是技术，更是梦想！</li>
			</ul>
		关于v-for 更多灵活用途,需要实践
	vue 的 computed 和 methods 和 watch
		computed和 medthods都是 定义各种执行函数的地方,但是 computed 把数据都放到魂存里,速度更快..
		watch 是设置监视一个参数,当参数发生改变时候,执行中断函数
	
	vue.component 组件: vue组件 很庞大的概念,需要好好实践
		vue.componet(tagname, {} ) 是全局组件
		vue{ component:{"tagname":ddd}} 是动态组件
		Prop 传递数据
	vue 自定义的指令 即 自定义 节点上的 v-XXXXX attri 很庞大的概念,需要好好实践
		Vue.directive(..)
	Vue.js 路由:是另一个独立的插件模块
	vue 混入,,,实践了解!!
	vue ajax 实践了解
	vue 响应接口 ??
	注意这些需要实践来理解的内容 需要好好实践!!
https://www.jianshu.com/p/89fae6aa143f   // h5 大前端
深入vue:  prop  emit   (state 是 react 的!!)
	就是 把 组件标签 v-bind 的参数, 传回到组件本身执行处理
	还有注意到一点,虽然,最终显示的是 new vue 生成的内容,但是 原始的内容仍然显示着存在着!!
	注意两个典型的例子!!!
	例子1:
		<div id="app">
			<ol>
		    <todo-item v-for="item in sites" v-bind:todo="item"></todo-item>
		  	</ol>
		</div>

		Vue.component('todo-item', {
		  props: ['todo'],
		  template: '<li>{{ todo.text }}</li>'
		})
		new Vue({
		  el: '#app',
		  data: {
		    sites: [
		      { text: 'Runoob' },
		      { text: 'Google' },
		      { text: 'Taobao' }
		    ]
		  }
		})
		首先 new Vue,会使用组件的temple 替换指定标签 <todo-item>
		替换时候, 遇到v-for, 表示其实有多个 <todo-item>标签需要替换
		遇到 v-bind, 表示 把 v-for中的 item 内容 以todo的名字 传递给 组件,
		组件直接或获取 todo的 内容 修改 temple 最后成功替换掉 <todo-item占位>
	例子2:
		<div id="app">
			<div id="counter-event-example">
			  <p>{{ total }}</p>
			  <button-counter v-on:increment="incrementTotal"></button-counter>
			  <button-counter v-on:increment="incrementTotal"></button-counter>
			</div>
		</div>
		
		Vue.component('button-counter', {
		  template: '<button v-on:click="incrementHandler">{{ counter }}</button>',
		  data: function () {
		    return {
		      counter: 0
		    }
		  },
		  methods: {
		    incrementHandler: function () {
		      this.counter += 1
		      this.$emit('increment')
		    }
		  },
		})
		new Vue({
		  el: '#counter-event-example',
		  data: {
		    total: 0
		  },
		  methods: {
		    incrementTotal: function () {
		      this.total += 1
		    }
		  }
		})
		首先 new Vue,会使用组件的temple 替换指定标签 <button-counter>
		然而所谓替换,只是显示上的替换,注意到 button 上有 v-on:click, 注册了点击函数
		而 <button-counter>上有 v-on:increatment 也注册了一个函数,
		而 <buton> 只是 在显示上 替换了 <button-counter>,但  <button-counter> 并没有消失!!! 
		就是说 html从 :
			<div id="counter-event-example">
			  <p>{{ total }}</p>
			  <button-counter v-on:increment="incrementTotal"></button-counter>
			  <button-counter v-on:increment="incrementTotal"></button-counter>
			</div>
		变成了:
			<div id="counter-event-example">
			  <p>{{ total }}</p>
				<button v-on:click="incrementHandler">{{ counter }}</button>
				<button v-on:click="incrementHandler">{{ counter }}</button>
			</div>
		但其实真正的关系是:
			<div id="counter-event-example">
			  <p>{{ total }}</p>
			  <button-counter v-on:increment="incrementTotal">
			      <button v-on:click="incrementHandler">{{ counter }}</button>
			  </button-counter>
			  <button-counter v-on:increment="incrementTotal">
			      <button v-on:click="incrementHandler">{{ counter }}</button>
			  </button-counter>
			</div>
		点击button 触发了 v-on:click,  而 click中的 $emit 又触发了 <button-counter v-on:increment="incrementTotal">
			所以最后total发生了改变
	













20190501
react学习:
	包含
	<head>
		<script src="https://cdn.staticfile.org/react/16.4.0/umd/react.development.js"></script>
		<script src="https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js"></script>
		<script src="https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js"></script>
	</head>
	将元素渲染到 DOM 中 ReactDOM.render
		<script type="text/babel" >
		const element = <h1>Hello, world!</h1>;  //这种在 <script> 里 写出 xml 感觉的内容是 jsx 
		ReactDOM.render(
		    element,
		    document.getElementById('example')   //渲染到 <div id =example>节点里
		);
		</script>
		// ReactDOM.render 直接把 example节点的所有内容 去掉,替换成 element 的内容 
	jsx:  在 <script> 里 写出 xml 感觉的内容是 jsx ,而这些jsx 最终会渲染到 DOM 上成为真正的 html 内容
 		JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中 例如:
			ReactDOM.render(
			    <div>			//这段都是同一个 jsx 段 内容
			      <h1>{1+1}</h1>		//这段都是同一个 jsx 段 内容
			    </div>			//这段都是同一个 jsx 段 内容
			    ,
			    document.getElementById('example')
			);
		JSX 表示样式:			
			var myStyle = {
			    fontSize: 100,
			    color: '#FF0000'
			};
			ReactDOM.render(
			    <h1 style = {myStyle}>菜鸟教程</h1>,	//放到 {} 里
			    document.getElementById('example')
			);
		JSX 注释:
			ReactDOM.render(
			    <div>
			    <h1>菜鸟教程</h1>
			    {/*注释...*/}			//放到 {} 里
			     </div>,
			    document.getElementById('example')
			);
		jsx 数组:
			var arr = [
			  <h1>菜鸟教程</h1>,
			  <h2>学的不仅是技术，更是梦想！</h2>,
			];
			ReactDOM.render(
			  <div>{arr}</div>,			//放到 {} 里
			  document.getElementById('example')
			);
	组件:
		使用函数定义一个组件:
			function HelloMessage(props) {
			    return <h1>Hello World!</h1>;
			}
			 
			const element = <HelloMessage />;
			 
			ReactDOM.render(
			    element,
			    document.getElementById('example')
			);
		也可以使用 ES6 class 来定义一个组件:
			class Welcome extends React.Component {
			  render() {
			    return <h1>Hello World!</h1>;
			  }
			}
			 
			const element = <HelloMessage />;
			 
			ReactDOM.render(
			    element,
			    document.getElementById('example')
			);
		组件的传递参数:
			function HelloMessage(props) {
			    return <h1>Hello {props.name}!</h1>;
			}
			 
			const element = <HelloMessage name="Runoob"/>;	 //传递参数
			 
			ReactDOM.render(
			    element,
			    document.getElementById('example')
			);
		符合组件:
			function Name(props) {				//这里的prop 就是从 父组件传递过来的的数据
			    return <h1>网站名称：{props.name}</h1>;
			}
			function Url(props) {
			    return <h1>网站地址：{props.url}</h1>;
			}
			function Nickname(props) {
			    return <h1>网站小名：{props.nickname}</h1>;
			}
			function App() {
			    return (
			    <div>
			        <Name name="菜鸟教程" />		//组件1
			        <Url url="http://www.runoob.com" />	//组件2
			        <Nickname nickname="Runoob" />		//组件3
			    </div>
			    );
			}
			 
			ReactDOM.render(
			     <App />,
			    document.getElementById('example')
			);
	React State 和 Props  map()  注意要实践学习
		例子1:
		class Clock extends React.Component {		//使用 es6 的 class 标准来建立一个 组件
		  constructor(props) {
		    super(props);
		    this.state = {date: new Date()};		//当前组件的 state, 其实是一个字典列表
		  }
		 
		  render() {
		    return (
		      <div>
		        <h1>Hello, world!</h1>
		        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2>   // 使用当前组件的 state
		      </div>					//当前组件的state,只由当前组件来调用
		    );
		  }
		}
		 
		ReactDOM.render(
		  <Clock />,
		  document.getElementById('example')
		);

		例子2: 
		关于生命周期的问题
		function FormattedDate(props) {		//组件 FormattedDate  接受父组件传递过来的数据 props
		  return <h2>现在是 {props.date.toLocaleTimeString()}.</h2>;
		}
		 
		class Clock extends React.Component {	//组件 clock
		  constructor(props) {
		    super(props);
		    this.state = {date: new Date()};	//给 组件 state 变量组,添加 data 成员
		  }
		 
		  componentDidMount() {			//当 组件被成功 加载,即 <clock/> 成功render后,执行的加载函数 
		    this.timerID = setInterval(		//这里 是设置一个定时函数
		      () => this.tick(),
		      1000
		    );
		  }
		 
		  componentWillUnmount() {		//当组件 即将被卸载时, 执行的卸载函数
		    clearInterval(this.timerID);	//这里是 注销定时函数
		  }
		 
		  tick() {				//定时函数
		    this.setState({
		      date: new Date()
		    });
		  }
		 
		  render() {				//被 render 返回的 jsx
		    return (
		      <div>
		        <h1>Hello, world!</h1>
		        <FormattedDate date={this.state.date} /> //传递参数到 子组件
		      </div>					 //特别注意 定时函数会 周期改变date, 当data变量被改变时, 
		    );						 //会自动更新 页面html显示,不需要手动处理!!
		  }
		}
		 
		function App() {
		  return (
		    <div>
		      <Clock />		//这里表示的是第一个组件
		      <Clock />		//第二个组件
		      <Clock />		//第三个组件
		    </div>
		  );
		}
		
		ReactDOM.render(<App />, document.getElementById('example'));
		首先, 三个 <Clock/> 是分别各自独立建立起,意味他们的行为相互独立!!
		也就是说,他们的 所有参数搜各自独立, 他们的定时函数事件都各顾各的
		React是通过创建虚拟DOM 然后将虚拟DOM生成真实的DOM 最后插入到页面中，
		而React生命周期中render方法的作用就是将虚拟DOM渲染成真实DOM

	state 和 props
		搜是 字典列表方式 来存放数据.	
		组件操作自己的参数 是 state 参数,
		父组件 传递数据到 子组件, 子组件用 props 承接.
	prop是,有数据类型的验证处理!!
		例子:
		var title = "菜鸟教程";
		// var title = 123;
		var MyTitle = React.createClass({
		  propTypes: {
		    title: React.PropTypes.string.isRequired,	//验证 props.title 的数据类型
		  },
		 
		  render: function() {
		     return <h1> {this.props.title} </h1>;
		   }
		});
		ReactDOM.render(
		    <MyTitle title={title} />,			//这里是传递全局数据 title 到 组件 Mytitle 的props.title
		    document.getElementById('example')
		);
		这里首先 传递群居全局数据 title 到 组件 Mytitle, Mytitle会对数据验证格式,
		没有问题,就渲染到 jsx 然后输出到 exampke即节点 下!!! (注意不是替换 example节点 !!!)
	react 触发事件的写法. 	
		在这里有一个 bind(this) 需要讨论!!
		先讨论 This 的含义: This 指向的是当前调用者!!
			const jerry = {
			 sayThis: function () {
			 console.log(this); // `this` 指向什么？
			  },
			
				 exec: function (cb) {
				 cb();
				  },
				
				 render: function () {
				 this.exec(this.sayThis);
				  },

			 exec2: function (cb) {
			 this.sayThis();
			  },

			 render2: function () {
			 this.exec2(this.sayThis);
			  },
		
				 render3: function () {
				 this.exec(this.sayThis.bind(this));
				  },

			}
			
			jerry.sayThis(); // jerry
				首先, 调用者是 jerry, 所以表示为 jerry调用了log,自然This指的就是 jerry
			var1 = jerry.sayThis    var1();  // window
				首先,我们执行的是 var1(),谁调用未知? 所以默认指向是 全局对象即 window 调用
				var1只是执行了 jerry的sayThis函数, 不能说执行了某某的函数,所以调用者就变成是某某
				var1执行的 jerry的sayThis函数, 但是没有表达是谁作为调用者执行,
				所以调用者未知,默认指向 window !!! 所以 log(This)指出是 window全局对象执行的函数 
			jerry.render();  // window
				首先, 调用者是 jerry, 所以可以表示为 jerry调用了reander函数,
				所以 this.xexc 中this指jerry, this.sayThis 中 this 也指jerry
				于是变成了 jerry.exec(jerry.sayThis), 这一步说明了是jerry在调用自己的函数exec(),所以调用者是jerry
				这里传递了一个实参数 jerry.sayThis, 这里是 把jerry的sayThis函数 的指针传递到 exec上! 
				exec 得到了一个函数指针而已, 同时exec的调用者是 jerry
				然而 cb() 只是执行这个 函数指针的函数, 只是知道要执行这个函数,却没有被告知要以那个调用者身份来执行
				cb() 不等于 jerry.sayThis(), 而是等于 jerry的sayThis函数这个函数指针位置的函数被执行了,并没有指出调用者!!
				所以 最后, 执行 jerry的sayThis函数 的调用者未知, 默认指向全局!!
			jerry.render2();  // jerry
				首先, 调用者是 jerry, 所以可以表示为 jerry调用了reander2函数,
				所以 this.xexc 中this指jerry, this.sayThis 中 this 也指jerry
				于是变成了 jerry.exec2(jerry.sayThis), 这一步说明了是jerry在调用自己的函数exec2(),所以调用者是jerry
				这里传递了一个实参数 jerry.sayThis, 这里是 把jerry的sayThis函数 的指针传递到 exec2上! (虽然没有用上)
				exec2 得到了一个函数指针而已, 同时exec2的调用者是 jerry
				所以 exec2 的 this.sayThis(); this 指的就是 jerry
				所以这一步又变成了 jerry.sayThis() 这一步说明了是jerry在调用自己的函数sayThis(),所以调用者是jerry
			jerry.render3();  // jerry
				首先, 调用者是 jerry, 所以表示为 jerry调用了reander3函数,
				所以 this.xexc 中this指jerry, this.sayThis.bind(this) 中 this 也指jerry
				于是变成了 jerry.exec(jerry.sayThis.bind(jerry)), 
					这一步说明了是jerry在调用自己的函数exec(),所以调用者是jerry
					注意到, 我们传递的实参数 jerry.sayThis.bind(jerry),这是一个函数.
					jerry.sayThis.bind(jerry) 得到了一个函数指针, 但是这个函数指针比较特别,明确指定调用者是jerry
					就是说:
					jerry.sayThis 得到的是个通用函数指针,没有指定调用者
					jerry.sayThis.bind(jerry) 得到一个特殊的函数指针, 指定了函数调用者!!
					于是 cb() 就等于 jerry.sayThis() 表示调用者 jerry 执行了 jerry的sayThis函数 
			总的来说,XX()里的参数只是传递一个地址,并没有附加传递调用者的信息,
				即() 内的 .点运算符号 并不会也不是传递调用者信息的,例如, XX(A.kk)
				并没有 A 并不是调用者, A不过是告知 kk 函数的位置!!
				而调用者信息体体现在 ()外的 .点运算符号 即 B.XX(A.kk)
				这里清晰地传递了 调用者是 B
				但是注意在 () 里, 是可以使用 .bind()函数 来设置传递调用者信息
		react 设置事件函数,本质上就是 上述讨论的 cb() 的问题,事件函数需要指定的 调用者,
			例如 直接 onclick={aaa}, aaa只是一个函数指针,没有指定调用者
			要遵循 js this指针和函数调用的这些特殊规则, 所以就需要 添加 bind(this)定位!!
			jsx 的{}填充的本质上跟js 函数传递实参数到形参数一个道理!
		当然还有箭头函数的定义 !!!!!! (略)  
			(js es6 添加的好多新特性就是,什么 class 箭头函数什么的,,)

	react 简化的 if语句 使用  && 符号!!
	react 使用 mao() key value 列表 的一个综合例子:
		function Blog(props) {
		  const sidebar = (
		    <ul>
		      {props.posts.map((post) =>	//map 循环的使用
		        <li key={post.id}>
		          {post.title}
		        </li>
		      )}
		    </ul>
		  );
		  const content = props.posts.map((post) =>
		    <div key={post.id}>
		      <h3>{post.title}</h3>
		      <p>{post.content}</p>
		    </div>
		  );
		  return (
		    <div>
		      {sidebar}
		      <hr />
		      {content}
		    </div>
		  );
		}
		 
		const posts = [
		  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},
		  {id: 2, title: 'Installation', content: 'You can install React from npm.'}
		];
		ReactDOM.render(
		  <Blog posts={posts} />,
		  document.getElementById('example')
		);
	react使用 ajax 还是使用jquery的模块
		一个典型的例子!!
		class UserGist extends React.Component {
		  constructor(props) {
		      super(props);
		      this.state = {username: '', lastGistUrl: ''};
		  }
		 
		 
		  componentDidMount() {
		    this.serverRequest = $.get(this.props.source, function (result) {
		      var lastGist = result[0];
		      this.setState({
		        username: lastGist.owner.login,
		        lastGistUrl: lastGist.html_url
		      });
		    }.bind(this));	//这里之所以 bind(this),因为 function (result) {..},本身只是一个单纯函数指针变量,没有强调用者
		  }			//如果没有调用者, 函数里的 this.setstate 的this就是并没有指代.
		 			//这里 bind(this) 本质是bind( 当前的 UserGist ) (因为可以有多个相互独立的个体 UserGist)
		  componentWillUnmount() {
		    this.serverRequest.abort();
		  }
		 
		  render() {
		    return (
		      <div>
		        {this.state.username} 用户最新的 Gist 共享地址：
		        <a href={this.state.lastGistUrl}>{this.state.lastGistUrl}</a>
		      </div>
		    );
		  }
		}
		 
		ReactDOM.render(
		  <UserGist source="https://api.github.com/users/octocat/gists" />,
		  document.getElementById('example')
		);
		先从 https://api.github.com/users/octocat/gists 获得信息,(并没有跳转页面,就是ajax 方式获得)
		然后渲染出一个局部显示部分:
		<div>octocat 用户最新的 Gist 共享地址：
			<a href="https://gist.github.com/6cad326836d38bd3a7ae">https://gist.github.com/6cad326836d38bd3a7ae</a>
		</div>	
	react refs 的使用!!!
		例子:
		<div id="example"></div>
		
		<script type="text/babel">
		class MyComponent extends React.Component {
		  handleClick() {
		    // 使用原生的 DOM API 获取焦点
		    this.refs.myInput.focus();			//直接就可以操作实体DOM <input>
		  }
		  render() {
		    //  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs
		    return (
		      <div>
		        <input type="text" ref="myInput" />	//添加的 ref属性
		        <input
		          type="button"
		          value="点我输入框获取焦点"
		          onClick={this.handleClick.bind(this)}
		        />
		      </div>
		    );
		  }
		}
		 
		ReactDOM.render(
		  <MyComponent />,
		  document.getElementById('example')
		);
		</script>

http://www.ruanyifeng.com/blog/2015/03/react.html	//react主要概念参考
https://blog.csdn.net/xiangzhihong8/article/details/81812418   //react naive 3方库
wepack 打包前端业务 js  利器
https://www.v2ex.com/t/237501 	//第三方 和 dom vdom 的操作!!











20190501
bootstrap
注意 bootstrap是一个 显示样式库, 使得通过设定好的 class就可以 简单定义样式!!
但是 这些加载的样式,最后还是经过一遍 js 才能成功初始化成功 !! ,
所以要么在 body 的最后加载 bootstrap 的实实例化 js ,或者在 <head>上加上,不然,bootstrap加载不会成功 !!!!
加载 <body> 底 可以加快加载速度!!
还有注意避免和 bootstrap 共用 class 名字,
bootstrap 只适合对 有限的 内容使用bs样式, 对于递增的,数量变化的内容做bs样式, 
	bootstrap 监视资源和压力可能会增大,影响性能所以不适合!!! 

bootstrap 4 用到的 头:
	<!-- 新 Bootstrap4 核心 CSS 文件 -->
	<link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.1.0/css/bootstrap.min.css">
	  
	<!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
	<script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
	
	<!-- popper.min.js 用于弹窗、提示、下拉菜单 -->
	<script src="https://cdn.staticfile.org/popper.js/1.12.5/umd/popper.min.js"></script>
	
	<!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
	<script src="https://cdn.staticfile.org/twitter-bootstrap/4.1.0/js/bootstrap.min.js"></script> 
	bootstrap.js 会对指定的模块实现监视并实时响应,所以 其他库例如 jquery 改变了 本来节点的 bootstrap样式,
	bootstrap也会自动更新!!! 
bootstrap 网格
	row col
bootstrap 文本处理:
	特定的 <tag> 或者 特定的 class 拼合渲染文本样式,排版 
bootstrap 一些代表意义的颜色:
	.text-muted, .text-primary, .text-success, .text-info, .text-warning, 
	.text-danger, .text-secondary, .text-white, .text-dark and .text-light:
比较大几率会用上的有:
	bootstrap 按钮,比较实用
	Bootstrap4 进度条
https://www.runoob.com/try/bootstrap/layoutit/    // bootstrap 可视化页面样式编辑工具
http://www.360doc.com/content/16/0129/07/13518188_531384175.shtml   //会考虑到的 组件库



20190503
react 插件? vue插件?  实验!!!
使用node.js组建前后端测试环境
	先建立 nodejs 文件目录作为测试目录
然后安装更新 nodejs 等等....  各种问题,百度就不记录了!!
npm install -g cnpm --registry=https://registry.npm.taobao.org	 //使用国内镜像
cnpm install npm -g --registry=https://registry.npm.taobao.org

william@william-HP:~/full_stack/nodejs$ cnpm
/usr/bin/env: "node": 没有那个文件或目录
william@william-HP:~/full_stack/nodejs$ sudo ln -s /usr/bin/nodejs /usr/bin/node

npm set registry https://registry.npm.taobao.org # 注册模块镜像
npm set disturl https://npm.taobao.org/dist # node-gyp 编译依赖的 node 源码镜像
npm cache clean # 清空缓存

然后分别建立 vue 工程 实验 和react工程实验,
发现,搜是node后端先渲染好 vue 和 react 发客户端, 并不是都发客户端,让客户端处理!!
my_app react 项目
my_project vue 项目
hello   vue cordova构造多平台 项目!!

测试 cordova 需要 android sdk  Gradle  java1.8
gradle 根据官方推荐 使用 sdkmen 工具安装,详细看官方


需要 android sdk, 所以需要安装了 android studio 后,
安装 android studio, 官网下载,然后解压到 /opt/ 目录下
第一次打开,通过 sdk manager 添加需要的 
	sdk platform, sdk build-tools, sdk emulator, sdk platform-tools, sdk tools
	android support Repository
然后 ~/.bashrc 添加环境参数: 并更新
# android studio
export PATH=/opt/android-studio/bin:$PATH
export ANDROID_HOME=/home/william/Android/Sdk/
export PATH=$ANDROID_HOME/platform-tools:$PATH 
export PATH=$ANDROID_HOME/tools:$PATH
export PATH=$ANDROID_HOME/tools/bin:$PATH
装好 可以直接使用 paltform-tools  adb
小米6s 打开调试 并接通 adb!!
	进入开发者模式 位置：设置->我的设备->全部参数 连续点击五次MIUI版本，进入开发者模式 (这时才会出现开发者选项!!)
	enable Diag usb port
	拨号键盘，输入*#*#717717#*#*即可启用USB调试口，再次输入就可关闭USB调试口	(或者会open dia failed,但是没有影响) 
	在电脑Ubuntu端，正确设置udev权限，通过adb devices能够看见Android设备
	设置开发者选项
	位置：设置->更多设置->开发者选项
		打开USB调试
		打开USB安装
		打开USB调试(安全设置)
		关闭启用MIUI优化
然后 adb devices 发现 设备 no permissions   需要设置 udev
	lsusb: 发现  Bus 001 Device 017: ID 18d1:8xxx Google Inc.  //是小米6
	sudo vim /etc/udev/rules.d/70-android.rules //添加
 		SUBSYSTEM=="usb",ATTRS{idVendor}=="18d1",ATTRS{idProduct}=="8xxx",MODE="0666"
	sudo chmod a+rx /etc/udev/rules.d/70-android.rules
	sudo service udev restart重启udev
	重启 adb server
		adb kill-server
		adb start-server
	重新插入小米6
adb devices  unauthorized 问题:
	小米6点击弹出窗口 允许密钥链接调试
	

然后就是测试 vue 的手机app 
	sudo npm install -g cordova	//安装 cordova
	cordova create hello com.example.hello HelloWorld  //新建helloworld 项目	
	cd hello
	cordova platform add android	//添加 android 平台
	cordova platform ls		//可以看到此项目都支持哪些平台!!
	cordova build android		//为 android 平台,编译出安装包
	然后就是使用adb 安装手机上面!!








20190504
备注: git clone --depth 1 https://.....      //获得最新分支!!!,而不是所有内容都下载!!!

必须对 vue 或者 react 做详细的测试评估, 特别是结合 bootstrap jquery 复合使用!!
分别建立的 vue react 的实验页面,验证多库的冲突问题!
先处理vue:
首先是 vue + bootstrap 
	head 的时候就分别先后添加 css:bootstrap,  js:jquery,popper,bootstrap,vue 实现各种初始化,
	bootstrap提供了 多种样式,使用 class 选择,
	而vue 可以控制是否使用指定的 bootstrap class:
	比如:
	<body>
	<div id="app">
		<div class="container">		
		  <h2>按钮样式</h2>
		  <button type="button" v-bind:class="{btn: isactive, 'btn-primary': iscolor}" >基本按钮</button>
		</div>
	</div>
	<script>
		new Vue({
		  el: '#app',
		  data: {
		    isactive: true,
		    iscolor: true
		  }
		})
	</script>
	</body>
	其中 container btn btn-primary 是 bootstrap 的样式, 
	v-bind:class="{btn: isactive, 'btn-primary': iscolor}" 本身就不被 html 识别
	通过 new vue 解析成 class="btn btn-primary" 然后被识别,才能挂上 bootstrap的样式
另外最为合适的 vue+bootstrap组件库 : https://bootstrap-vue.js.org/docs/components/form-radio

按钮弹窗,抽屉弹窗 :
	按钮弹窗直接用 show hide 功能, 或者toogle 显示在指定 zindex上. 同样是 absolute 的位置
	注意这种弹窗就不要使用

搜索框:
	遇到了 this.$http.jsonp... 这是插件 vue-resource 的内容!!需要加载 vue-resource.js
	this.$http.jsonp  使用了 $ 符号,而我们又跟 jquery的 $ 同框,所以似乎并不冲突!!
	<li v-for="(value,index) in okl" >{{ value }}</li> 出现了不能解析内容到 {{}}里情况
		具体是在于 使用 conponent 无法 解析数据到 {{}} ???
		卧操, {{ }} 根本就没有渲染出来!!!
		原因是 和 django 的 {{ }} 冲突了 !!!!
		使用:
			<div id="app1">
			{% verbatim myblock %}
			{{ message1 }}
			{% endverbatim myblock %}
			</div>
		这样django 就不会 分析 {{}}, 而是把中间的代码不处理全部发出 !!
		注意不管你 {{}} 卸载 html上 还是 <script> 还是某个 字符串变量 aa="this is {{}}",
		django都会 识别出来替换掉,所以,必须处处都 加上 免解析处理
		注意,这 {{}} django只是检测 html 文件上的 , 独立的js文件输出时候,不会检查{{}}
		
	需要列表 去掉黑点, 左对齐!! 这样设置 css
		#li {list-style-type:none; color:#000000;}
		#ul {margin:0; padding:0; text-align:left;}
	还有发现 <li v-for="(value,index) in myData" .... <li>会根据 myData 的变化及时更新增删多行内容,
		不需要自己写个函数 手动更新 <li>
收藏目录:
	使用滑入抽屉的形式!!! 参考 : https://blog.csdn.net/sinat_30122989/article/details/78172479
	位置一般要 absolute + zindex !!!  relative + zindex 不管用!!!
	目录树模块 vue-ztree


			 	
	









20190514
这里处理了一下 react 的方案:
使用 ant design 可以解决大部分ui 样式问题:https://ant.design/components/auto-complete-cn/
	搜索框:可以参考 ant design : autocomplete
	行号跳转可以参考: ant design : InputNumber 
	缩略树展示框 卡片 card 方式
	tree 也有,,,, ant design
	tab 适合做 用户资料页面
	drawer 抽屉 也合适做 右下角弹出选项卡!!!!! 和 搜索的下拉框
	Message全局提示  感觉有用!!
	还有通知提醒框!!!
	进度条
	弹出气泡确认框
	锚点可能也有用
	backtop 这种快速定位可能有用
注意 antd 网上大多数是 npm 加载 配合node.js使用!!
	就是说样式什么的 都在后端处理后 把结果发到前端
	但是我们使用 django, 不希望再配合一个关于app渲染的node后端.
	所以希望 react antd 的渲染工作,全部在浏览器上完成!!
	因此关于 node 后端的一些写法就完全不适合了!!比如 import 什么的 !!!
	以下是一个完全在浏览器渲染的页面 例子 :https://segmentfault.com/q/1010000014591841/a-1020000014629140
	<!DOCTYPE html>
	<html>	
	<head>
	  <meta charset="UTF-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no" />
	  <title>Antd</title>
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/16.3.2/umd/react.production.min.js"></script>
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.3.2/umd/react-dom.production.min.js"></script>
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
	  <!-- monent 必须在 antd 之前,否则 babel解析后面 <script>文本 会指出 antd not defined -->
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.1/moment.min.js"></script>
	  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/antd/3.4.3/antd.min.css" />
	  <script src="https://cdnjs.cloudflare.com/ajax/libs/antd/3.4.3/antd.min.js"></script>
	</head>
	<body>
	  <div id="message1">xx</div>
	  <script type="text/babel">
	    ReactDOM.render(
	      <div>
	        <antd.Button type="primary">Primary</antd.Button>
	        <antd.Button>Default</antd.Button>
	        <antd.Button type="dashed">Dashed</antd.Button>
	        <antd.Button type="danger">Danger</antd.Button>
	        <antd.Input placeholder="Basic usage" />
	        <antd.Switch defaultChecked />
	        <antd.TimePicker defaultOpenValue={moment('00:00:00', 'HH:mm:ss')} />
	      </div>
	    , document.getElementById('message1'));
	  </script>
	</body>	
	</html>
关于 react 的 样式设置:
	方式一, 直接写到 jsx
	如何自定义设置样式!!!! 	注意jsx 设置样式问题 , 所有jsx 内部设置 样式设置都差不多这样!!
            style={{
              position: 'absolute',
              bottom: 0,
              width: '100%',
              borderTop: '1px solid #e8e8e8',
              padding: '10px 16px',
              textAlign: 'right',
              left: 0,
              background: '#fff',
              borderRadius: '0 0 4px 4px',
            }}
	方式二. 写成全局变量被 jsx使用
	const uio= {color: '#eee',}
	class...{
	....
	   <button style={uio}>
	...
	}
	方式三, 使用css的, 即 react渲染完, html css 再渲染一次

	<style>	#bbb {color:#eee; }  </style>
	
	class...{
	....
	   <button id="bbb">
	...
	}
注意插入人家的代码, 也要对应取得人家的 css, 不然无法工作!!!
jsx 对应的 css 属性名称:
"alignItems",			"alignSelf",			"backfaceVisibility",		"backgroundColor",		
"borderBottomColor",		"borderBottomLeftRadius",	"borderBottomRightRadius",	"borderBottomWidth",
"borderColor",			"borderLeftColor",		"borderLeftWidth",		"borderRadius",
"borderRightColor",		"borderRightWidth",		"borderStyle",			"borderTopColor",
"borderTopLeftRadius",		"borderTopRightRadius",		"borderTopWidth",		"borderWidth",
"bottom",			"color",			"flex",				"flexDirection",
"flexWrap",			"fontFamily",			"fontSize",			"fontStyle",
"fontWeight",			"height",			"justifyContent",		"left",
"letterSpacing",		"lineHeight",			"margin",			"marginBottom",
"marginHorizontal",		"marginLeft",			"marginRight",			"marginTop",
"marginVertical",		"opacity",			"overflow",			"padding",
"paddingBottom",		"paddingHorizontal",		"paddingLeft",			"paddingRight",
"paddingTop",			"paddingVertical",		"position",			"resizeMode",
"right",			"rotation",			"scaleX",			"scaleY",
"shadowColor",			"shadowOffset",			"shadowOpacity",		"shadowRadius",	
"textAlign",			"textDecorationColor",		"textDecorationLine",		"textDecorationStyle",
"tintColor",			"top",				"transform",			"transformMatrix",
"translateX",			"translateY",			"width",			"writingDirection"
不会组动加 px 的属性:
columnCount  			fillOpacity  			flex  				flexGrow  
flexShrink  			fontWeight  			lineClamp  			lineHeight  
opacity  			order  				orphans  			strokeOpacity  
widows  			zIndex  			zoom 

abt 按钮的 颜色是默认的 官方开放改变!!!, 如果需要自定颜色的话,需要自己加上一层封装来改变, 不过测试结果是,动画效果稍慢:
	例如:
	jsx:
	    <a ID="JumpLine" style={{ marginRight:25, }}>
	      <antd.Button size='large' style={{ width:100,  }} type="primary" >
		Jump</antd.Button>
	    </a>
	css:
		#JumpLine button {
		  border-color: #5f8;
		  background-color: #5f8;
		}
		#JumpLine button:hover , #JumpLine button:focus {
		  border-color: #0f3;
		  background-color: #0f3;
		}
		#JumpLine button:active, #JumpLine button.active {
		  border-color: #0b0;
		  background-color: #0b0;
		}
动态显示 和隐藏组件
	因为按需求,遮罩一个组件的操作相当复杂和需要花时间去研究,所以,建议直接去掉整个组件比较实际!!
	使用&&条件函数  {this.state.showSearch && <> </>}
	如果 && 左侧条件为真,就显示右侧的 jsx 部分  <></> 注意,右侧的jsx 必须是一个总节点,而不是多个分散节点
	{this.state.showSearch && <sradfg/>}  正确
	{this.state.showSearch && <div> <aa/> <ui></ui> </div>} 正确
	{this.state.showSearch && <aa/> <ui></ui> } 错误!
	{this.state.showSearch && <div><Complete /><br/></div> } 正确
	但是这种做法不提倡,因为不是真的隐藏,而是删掉,重新新建一个的方式!!!
	
react 操作不同的 实例化组件 的行为!!
	第一个 通过父子关系: props  父向子传递参数,传递函数
		class App extends React.Component {
		....
		  closeDrawer = () =>{
		    this.setState({
		      visible: false,
		    });
		  };
		  render() {
			  <SaveEdit CloseDrawer={this.closeDrawer} />		//传递一个函数指针
		  }
		}
		class SaveEdit extends React.Component {
		...
		  render() {
			    <antd.Button size='large' icon='close' type="danger"
				onClick={
				  () => {
				    //console.log('this is:', this.state.name);
				    this.props.CloseDrawer();		//执行了这个函数指针
		 		}}
			    ></antd.Button>
		....
		}	
		有趣的是, 传递一个函数指针时的写法仅仅是传递指针而已, 应该是没有指定调用者的
		但是 函数本身使用大量this 指针,所以需要指定调用者,而实际上,调用者也被正确指出
		但是,this.props.CloseDrawer(); 执行, this.props. 的行为除了取出指针外,还指定了调用者
	第二个 通过父子关系: props  子向父传递参数, (父给子一个函数指针,子给这个函数提供自己的内容数据)
		class Parent extends Component{
		  state = {
		    msg: 'start'	//父本身数据
		  };
  
		  transferMsg(msg) {
		    this.setState({
		      msg		//父给子的 函数
		    });
		  }
		
		  render() {
		    return <div>
		        <p>child msg: {this.state.msg}</p>
		        <Child_1 transferMsg = {msg => this.transferMsg(msg)} />
		      </div>;
		  }
		}
		
		class Child_1 extends Component{
		  componentDidMount() {
		    setTimeout(() => {
		      this.props.transferMsg('end')	//子修改了父的数据
		    }, 1000);
		  }
		
		  render() {
		    return <div>
		      <p>child_1 component</p>
		    </div>
		  }
		}	
	第三个就是跨层级通讯, 通过 层层相传,或者官方不推荐的全局变量content
	第四个就是 订阅模式!! 使用 event.js ??

关于 react 和 原生js html dom 混合使用的 拓展!!!
	首次发现 react 是异步更新的,就好像是弄了一个额外线程来解析的样子,
		主程序把react的内容扔给线程就接着后面的工作.
		所以 发现,react的内容还没有渲染出来, 主程序却跑到后面的 js代码想操作还不存在的实体 DOM 是失败的!!!
	此外各自组件只能 修改自己的 state 数据!! 父组件传递过来的 props 数据,是无法修改的.
		只能获得 一般参与处理自己的 state 数据!!
		同样,子组件传到 父组件的 数据, 父组件也无法修改,只能获得来参与处理父组件自己的state 数据!!
		而且修改组件的数据 也很讲究 this.setstate({}),才可以改 !!!, 并不是简单的 = 赋值!!
	state 数据一般联系 着 jsx ,一旦 state数据改变,相关的 jsx 部分会重新渲染,最终修改实体 DOM
		注意到 jsx 改变,一般只是更改与  state 变化的部分, 并不一定就是重新渲染生成实体 DOM 来代替旧的!!
		比如一个react 渲染出 input:
			<div id='ddd' style="display:block;">
			  <input type="text" placehold="input here " class="ant-input" value=''>
  			</div>
		但我们输入: william好帅
		实际DOm 被改为:
			<div id='ddd' style="display:block;">
			  <input type="text" placehold="input here " class="ant-input" value='william好帅'>
  			</div>
		但通过 react 修改 state 来改变 placehold 为 : ilovryou
		react会 渲染并修改 这个input的placehold, 所以 imput其他地方都没有改变 我们输入的 value='william好帅' 没有删掉
		假如 react会 渲染重新生成替换 input, 那么 我们输入的 value='william好帅' 就不再存在!!.
		在这里, react 没有重新生成替换, 只是针对性地改掉 placehold 这一小属性!!
	关于 js 和 react 混合使用, 注意, react 本身的 js 程序, 
		在 react 组件里的事件函数,不一定就是操作 state 数据, 操作实体 DOM 内容没有问题!!
		这里操作的实体DOM 就是直接实体操作,不绕进jsx的虚拟DOM操作
		例如:
		  ShSearch = (phld) => {
			var ff = document.getElementById('Dsch');
			if (ff.style.display =='none' ){
			    ff.style.display ='block';	
			}else{
			    ff.style.display ='none';	
			}
		  }; 
		这里就是 操作 react 渲染出来的 实体 DOM, 当然只要是实体DOM,不管是不是react渲染出来的都可以这样操作!!
		然后 也可以是 jsx 声明的 事件函数, 也可以链接到 原生的js函数:
		例如:
		jsx:     <antd.Button type="primary" onClick={thu} >Primary</antd.Button>
		<script>
			function thu (){
				console.log('huij');
				var jj = document.getElementById('originandjsx')
				jj.setAttribute("contenteditable", "true");
				jj.innerHTML = "hello world!!"	
			};
		</script>
		前提是,实体DOM完全渲染出来了, 事件函数 和 DOM 的链接关系才生效

做搜索框遇到的一些坑!!!!
position 和 zindex 
	首先,注意复习 position , 一般的节点是 static流, static流的 z-index 等是不生效的
		特别注意嵌套关系的理解:
		例如
		    <div id='1'>
		        <div id='2'>
		            <div id='3'>   </div>
		        </div>
		        <div id='4'>
		        </div>
		    </div>
		假如只有 div1 定义了 position:fixed, top:10 px, zindex=10 那么只是 div1 是 flex 定位!!
			而相对位置 top 取自设定, 其他取自 div1 本来相对<body> static定位应该所在的位置	
			div234 是 static定位 !!!, 注意, 不过,div234是 以 div1为参考点,的 static 定位!!!
			而且依然处于 z-index:10 层
			而不是以原来 <body> 为参考点的 static 定位,
		如果这时, div3 又定义了 position:fixed, top:13 px, zindex=20 那么 div3 也是 flex 定位!!
			而相对位置 top 取自设定, 其他取自 div3 本来相对<div1> static定位应该所在的位置
		像这样子的 位置嵌套关系,同样适应于 relative, absolute,!!
		还有一个 特别 严重的问题 zIndex 层概念 是 相对
			div1 z-index=10 相对 body 的第 10 层,
			div3 z-index=20 相对 div1 的第 20 层, 意味着相对 body的第 30 层 吧.
			
	然后是 发现 行内元素, span, a 什么的, 
		overflow: hidden 无效 	超出显示
		verticalAlign: 'bottom',  无效  文字向下对齐
		textOverflow: 'ellipsis',  无效  超出的文字 以... 显示
		这些无效的操作,都需要使用一个块元素封装并设置在块元素上,才生效!! 例如 <div><span></span></div>
		
ant-design 的一些坑, 
autocomplete 生成的 下拉栏在 body底部的位置, 独立出 autocomplete,相关节点!!
	而且 position 是absolute, 我的搜索框是 fixed 定位, 所以 一滑动鼠标, 对应的下拉栏便被滑走!!!
	如何 使得 下拉栏也是flxed 不被滑走. autocomplete 设置 dropdownClassName="dsds" 属性,
	然后 css 加入  body .dsds { position: fixed, } 便可以!!
	注意 .dsds { position: fixed, } 这样不行!!, 
	例如 
		<div class="aa bb cc">
		.aa { position: fixed; }
		.bb { position: absolute; }
		究竟选.aa 还是 .bb ,并不确定,一般选最新设置的!!但谁是最新的,在 react 渲染框架来看,并不知道
		但是  body .aa { position: fixed; } 比以上优先级都高 !!!, 所以最后是 fixed 
	很骚的 react 换 style方式: 目的认清 react 函数调用 和 jsx 互用关系
		class Topsearch extends React.Component {
		  state = { ......
			    schrlt:true,	//state变量
			    winstyle: 1,	//state变量
		  	  };
		  schrltdisplay = () =>{		//定义函数 (注意是 箭头函数的定义方式)
		    if (this.state.schrlt == true){
		        this.setState({ schrlt:false, });
		    }else{
		        this.setState({ schrlt:true, });
		    };
		    console.log(this.state);
		  };
		
		  changewin = () =>{			//定义函数.
		    if (this.state.winstyle == 1){
		        this.setState({ winstyle: 2, });
		    }else if (this.state.winstyle == 2) {
		        this.setState({ winstyle: 3, });
		    }else{
		        this.setState({ winstyle: 1, });
		    }
		    console.log(this.state);
		  };
		
		  ......
		
		  render() {
		    const Style1 = {
		       display: this.state.schrlt?'block':'none', width: '100%', background: '#5b6',
		       overflow: 'auto',
		       height: (this.state.winstyle ==1 )?'50px':((this.state.winstyle == 2 )?'500px':'1000px'),
		    };
		
		    return (
		      <div style={{width:'100%',}}>
		      ......
		         <div style={{ ...}} onClick={this.changewin} ><span  style={{ }}> 第 45 个结果, 共 156703918332231312312312414131 个结果</span></div>	
			            <antd.Button  size="large" style={{width: 40, }} type="primary" icon="down" onClick=		{this.schrltdisplay}/>
				    
		      ......
		      <div contenteditable='true' style={Style1} > helloeworkd  </div>
		      {/* <div>jsx 的注释长这样子通过插入大括号符号,在里面注释 </div>*/}
		      </div>
		    );
		  }
		这里定义的 onClick={this.schrltdisplay} onClick={this.changewin} 都没有 bind(this),是因为使用箭头函数有同样效果!!
		特别注意 const Style1 设置 变量 (不是state变量),使用了 ? : 运算, 就是说,可以使用运算

	接着就是 react 上 使用 js 的 const 变量 与 继承 的骚规则!!,特别是用在递归函数上...

javascript 语法:
	a || b，如果a不存在，则返回b。a && b，如果a存在，则返回b，否则返回a。
	以下内容会被当成false处理："" , false , 0 , null , undefined , NaN ,  注意：字符串"false"也会被当做true处理
	例子:
		b=0,c=Number.NaN,d=1,e="Hello"  a || b && c || d && e  
		表达式从左往右执行，先&&后||
		(b && c) 得到 b 变成 a || b || d %% e 
		(a || b) 得到 a 变成 a || d && e
		(d && e) 得到 e 斌成 a || e  返回 a
	关于变量  var let const   ES6标准
		var 通用的变量, 存在变量提升:即之后声明定义的变量,在之前的函数也可以调用!!
		let 定义的变量 是 {} 区域性特质的, 在一个函数里定义的let, 只能在该函数生效,
			同 {}区域 不允许重复声明
			不存在变量提升, 区域内,let 定义的变量与区域外 var定义的变量同名, 区域内值认可 let 变量
			var tmp = 123;
			if (true) {
			  tmp = 'abc'; // 出错,因为 {} 区域定义了 let tmp, 所以不会调用 var tmp,而 let tmp 不存在变量提升!!
			  let tmp;
			}
			es6 规定 区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
			凡是在声明之前就使用这些变量，就会报错。
			if (true) {
			  // TDZ开始
			  tmp = 'abc'; // ReferenceError	//此区域只认 let tmp,  let tmp 声明前使用会报错
			  console.log(tmp); // ReferenceError	
			
			  let tmp; // TDZ结束
			  console.log(tmp); // undefined	//虽然声明 let tmp ,但 tmo 未赋值!!
			
			  tmp = 123;
			  console.log(tmp); // 123
			}
			还有: let x = x; //报错, =后面使用了x, 这里算 let x 未声明前使用x
		const 声明一个只读的常量。一旦声明，常量的值就不能改变。
			所以const一旦声明变量，就必须立即初始化，不能留到以后赋值,
				const foo; 报错!! 
			const 只在声明所在的块级作用域内有效
			const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
			对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。
			对于复合类型的数据（主要是 对象 和 数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，
			const只能保证这个指针是固定的（即总是指向另一个固定的地址），
			至于它指向的数据结构是不是可变的，就完全不能控制了 ! !
				const foo = {};

				// 为 foo 添加一个属性，可以成功
				foo.prop = 123;
				foo.prop // 123

				// 将 foo 指向另一个对象，就会报错
				foo = {}; // TypeError: "foo" is read-only
			如果真的想将对象冻结, 应该使用 Object.freeze 方法。
				对象冻结,只是 不能添加或者删除属性, 但是属性还是可以修改的
				const foo = Object.freeze({ prop:123, bell:345});
				// 常规模式时，下面一行不起作用；
				// 严格模式时，该行会报错
				foo.font = 123;		//添加 font 属性不起作用, 或者报错
				foo.prop = 100;		//起作用
			将对象彻底冻结的函数, 对象成为真正意义上的 常量对象:
				var constantize = (obj) => {
				  Object.freeze(obj);
				  Object.keys(obj).forEach( (key, i) => {
				    if ( typeof obj[key] === 'object' ) {
				      constantize( obj[key] );
				    }
				  });
				};
		关于 变量 和 {} 拓展:
			var ui = {qw:123, qe:456, qr:789, ii:{qew:1231, qee:4561, qer:7891 } }
			var { qe, ev, ii } = ui
				//注意第二行, {} 相当于 让 ui的qe 传递给{}的 qe, ui的ii传递给{} ii, ui没有ev,所以就没有传递
				//注意名字一定要 一样才可以 传递!!
			qe = 9
				//ui.qe是一个数, 所以拷贝了一个数到 {}的qe, ui.qe 和 qe 其实是两个不一样的变量
				//{}的 qe = 9 , 并不影响 ui.qe,
			console.log( ui.qe, qe  )   // 456 9
			
			ii.qer = 999
				//ui.ii是一个数组/对象, 所以拷贝了这个数组/对象的指针 到 {}的ii, ui.ii 和 ii 虽然是两个不一样的变量
				//但是两者内容都是指向同一个 数组/对象 的指针!!
			console.log( ui.ii.qer,  ii.qer  )   // 999 999

			ii.ppp = 1000
				//ui.ii 和 ii 的内容都是指向同一个 数组/对象 的指针!!
				//所以通过其中一方增加这个对象的一个属性, 另一方也可以看到!!!
			console.log( ui.ii.ppp,  ii.ppp  )   // 1000  1000
			当然, 这些关系 不止体现在 var , const let, 同样道理, 只是使用 const/let 定义,还得遵守 const/let 的规则 !!
			

	
		关于 一个复合例子!!!
			const x = 3;			//全局的 x 常量
			const gData = [];		//gData 存放 一个数组/对象位置指针,这个位置是不改变
			var use = 5;			//一个 全局变量
			const generateData = () => {
			  const tns = gData;		//一个区域常量tns, 是 gDAta 的内容不变,即固定指向同一个位置
			  for (let i = 0; i < x; i++) {		//其实每次循环,都打开一个新的 {}区域,而 i 也是新建的,只属于这个区域
			    const key = 3;			//仅这次循环建立的新区域建立一个常量 key 3
			    tns.push({ title: key, key, use }); //注意 这里 push, 是把 key 的内容拷贝到一个新的变量然后压入 数组里
				tns[0].title = 11		//所以 数组里的新的 普通变量 key,title, use都是可更改的 
				tns[0].key = 77			//不可更改是只是数组的 位置!!
			  }					//通过 const,发现 gData,跟 tns 其实共同 指向 同一个数组
			  tns[1].title = 22
			  tns[1].key = 88
			  tns[1].use =555
			};
			generateData(z);
			console.log(gData);
			gData[2].title = 34;
			gData[2].key = 99;
			console.log(gData[2].title);
		另一个:
			var obj = {
		            id: null,
		            name: '',
		        };
			var str = [];
			for (var i = 0; i < 5; i++) {
			    obj.id = i;
			    obj.name = 'name_' + i;
			    str.push(obj);		//特别注意是 push 例子, 建立一个新变量,保存 obj的 地址 
			    console.info(obj);		//所以虽然 最后 str 里有三个变量,但都是指向同一个obj 的指针!
			}
			console.info(str);

		ES6 一共有 6 种声明变量的方法: var命令和function命令。let和const命令，import命令和class命令。
		

 








20190521
react 的 优化:
	首先要认识到, 每一次 setstate, class 的render 都会执行一次, 最后生成实体内容填充/替代rom 相关内容!!!
	注意,并不是生成的实体dom完全替换现有实体DOM全部,而是只替换当中的被涉及的部分,
	但是 每次都得执行一次 render 的内容,所以 对react 的优化主要还是减少render 的运算!!
		首先 render 里 jsx 调用函数问题,三种方式:
		第一种
		constructor() {
			handleAA = this.handleA.bind(this)	//这种可以
		}
		handleA(){.....}
		handleAAA = this.handleA.bind(this)	//这种也可以
		render (....
		  onClick= {this.handleAA}	// bind()在 render 外 执行了, 之后每次 render 都不需要执行 bind(), 提高效率
		  onClick= {this.handleAAA}	// bind()在 render 外 执行了, 之后每次 render 都不需要执行 bind(), 提高效率
		第二种
		  onClick= {this.handleA.bind(this)} // bind() 都在 render里执行一次, 效率不高!!
		第三种:
		handleB = () => {.....}
		render (....
		  onClick= {this.handleB}   //这里是直接为这次render新建一个函数 handleB 然后执行, 所以降低效率
		  onClick= {()=>this.handleA()}   //这里是直接为这次render新建一个函数 handleA 然后执行,而不是指向已存在的函数执行, 所以降低效率	
 	除了 优化事件函数色执行, 在render里头 , 应该尽可能地减少变量的定义,因为每次render 都会重新生成新变量!!
	使用 key 识别 同类组件, react 这样可以减少 render 的计算量, 只计算识别的组件,其他组件不变!! key是唯一的,注意!!!!!
	使用 redux 时,使用上 reselect 处理
	由于 react 遵随 父子通讯, 跨组件通讯 需要使用 
		redux https://juejin.im/post/5b755537e51d45661d27cdc3
		http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html 



浏览问题:
<div id="blockmenu" style="position:fixed; top:0px; left:0px; width:1%; height:100%; background-color:#f1e; overflow:hidden; ">
  <div id="blockmenu4" style="width:170%; height:100%; background-color:#f1e; overflow-y:scroll; ">
    <div style="width:100%; height:100px; background-color:#a39; border-bottom: 2px solid #eee; "></div>
    <div style="width:100%; height:100px; background-color:#a39; border-bottom: 2px solid #eee; "></div>
  </div>
</div>

<div id="viewblock" style="position:fixed; top:0px; left:2%; width:98%; height:100%; background-color:#cdc; overflow:auto; ">

<div class="main" onmousedown="mousd(event)" onmousemove="mousm(event)" onmouseup="mousu(event)" onkeypress="keypress(event)" onkeydown="keydown(event)" onkeyup="keyup(event)" contenteditable="true" style="background-color:#ccc">
这里的 特点是 侧栏只永远只不论伸缩占据 1% 屏幕空间, 而 viewblock 也是,不论伸缩,永远占据 98%
但是 侧栏里的块边框和 scrollbars隐藏做得并不是太好. 不同 pc 屏幕和浏览器,效果可能就不一样!!
还有 border 使用有规则!! 用border的时候,用不了 border-bottom 等单边设置!!
对于特殊屏幕, 16:9 什么的, 1% 的或者显得特别宽,所以需要使用 px 尺度, 
而 px 尺度, 需要有以下要求:
	侧栏隐藏 scrollbar	
	视窗 width 沾满屏幕! 不论是什么程度的 伸缩 
	ctrl+滑轮 -> 触发一个document 监听事件 -> dedux传递 -> block this.setstate
还有 vhvw的尺度,但是跟 % 尺度没有什么区别!!
总之,我们要处理复杂的 div尺寸变化问题!!!
当 ctrl + 滑轮时候, div 可以及时调整, 这时我们可以使用 calc css3属性
例如 width: calc(100vw - 20px + 0.75vw);	//参数和符号之间必须有一个空格!!
我的浏览器 一般 滑动条是 0.75 vw,
还有一个的就是子 div 自动撑开父div的行行为!!  使用 float??
onresize ,, 貌似只对窗口,,body有效, div不是窗口,所以无效??
 document.getElementById('viewblock').scrollWidth 可能就是我们需要 内容总宽度
如何 替换 width , 才是我们这个问题的解决方案!!
子元素撑开父元素的参考: https://my.oschina.net/jingyao/blog/777252 似乎把嗯没有什么用!!
	知道了一个可能的方案, 补充添加一个子节点  <div style="clear: both;"></div>
目前认为可以不resize,就不resize,实现填充溢出 width ,不过好像不可能!!
 

需要攻克 redux, 还有 css 的layout 问题!!!!













20190526
重点 css 补充: overflow 与 scroll 与 width 与 XXXWidth
关于 隐藏 显示 和 边界 和 溢出 的概念:
例子1: 
	div2 是 div1 的内容嗯,
	div3, div4 是 div2 的内容,
	以下图表示当 div1.style.width = div2.style.width = div3.style.width = div4.style.width
	假如 div1.style.width:250px, 
	那么 div2.style.width:100% / 250px, (这里的100% 相当于 100% X div1.style.width)
	     div3.style.width:100% / 250px, (这里的100% 相当于 100% X div2.style.width)
	     div4.style.width:100% / 250px, (这里的100% 相当于 100% X div2.style.width)
------------------div1--------------------------------
|-------------------div2-----------------------------|
||---------------------div3-------------------------||
|||                                                |||
||--------------------------------------------------||
||                                                  ||
||---------------------div4-------------------------||
|||                                                |||
|||                                                |||
||--------------------------------------------------||
||                                                  ||
||                                                  ||
||                                                  ||
||                                                  ||
||                                                  ||
|----------------------------------------------------|
------------------------------------------------------

例子2: 
	div1.style.width = div2.style.width
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow = div1.overflow = none
	由于, div2.overflow:none；div2 对溢出不处理, 所以 div3 直接溢出到 div1, 
	由于, div1.overflow:none；div1也对溢出不处理. 所以div3 溢出的内容, 继续溢出到 body,
	所以 body 上能看到 div1, 和 div3 溢出在 body上的内容 !!
------------------div1--------------------------------
|-------------------div2-----------------------------|
||---------------------div3-------------------------||-----------------
|||                                                 ||                |
||--------------------------------------------------||-----------------
||                                                  ||
||---------------------div4--------------------     ||
|||                                           |     ||
|||                                           |     ||
||---------------------------------------------     ||
||                                                  ||
||                                                  ||
||                                                  ||
||                                                  ||
||                                                  ||
|----------------------------------------------------|
------------------------------------------------------

例子3:
	div1.style.width = div2.style.width
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow:auto, div1.overflow = none
	由于, div2.overflow:auto；所以 div3 没有直接溢出,而是隐藏在 div2 未显示的区域,
	div2会多出一个 scrollbar, 滑动可以继续看到div3未显示的内容.,div2隐藏的区域的 background 依然是 div2 的background
	div3 没有直接溢出,所以不会溢出到 div1  
	所以 div1 上的内容 只有等尺寸的div2, 没有其他, 所以没有内容溢出 
	不管 div1.overflow:none 还是 auto, 都无所谓 
	所以 body上 只看到 div1 
------------------div1--------------------------------
|-------------------div2-----------------------------| - - - - - - - - -
||---------------------div3-------------------------||-----------------|
|||                                                 ||                |
||--------------------------------------------------||-----------------|
||                                                  ||
||---------------------div4--------------------     ||                 |
|||                                           |     ||
|||                                           |     ||                 |
||---------------------------------------------     ||
||                                                  ||                 |
||                                                  ||
||                                                  ||                 |
||                                                  ||
|| ===========div2scroll===========                 ||                 |
|----------------------------------------------------| - - - - - - - - -
------------------------------------------------------


例子4:
	div1.style.width = div2.style.width
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow:none, div1.overflow = auto
	由于, div1.overflow:none；所以 div3 直接溢出到 div1
	由于, div1.overflow:auto；所以 div3 没有继续从 div1 溢出,而是显示在 div1 的隐藏区域
	div1 多了一个 scrollbar, 滑动可以看到 显示在 div1 上的  div3溢出内容.
	div1 隐藏区域的 background 依然是 div1 的background
	div3 没有直接溢出,所以不会溢出到 div1  
	所以 div1 上的内容 只有等尺寸的div2, 还有溢出的 div3 内容 
	div3 溢出内容没有溢出到 body,
	所以 body上 只看到 div1 , 滑动 div1 的 scrollbar 才能看到溢出的 div3

------------------div1-------------------------------- - - - - - - - - -
|-------------------div2-----------------------------|
||---------------------div3-------------------------||-----------------|
|||                                                 ||                |
||--------------------------------------------------||-----------------|
||                                                  ||
||---------------------div4--------------------     ||                 |
|||                                           |     ||
|||                                           |     ||                 |
||---------------------------------------------     ||
||                                                  ||                 |
||                                                  ||
||                                                  ||                 |
||                                                  ||
||                                                  ||                 |
|----------------------------------------------------|
|  ===========div2scroll===========                  |                 |
------------------------------------------------------ - - - - - - - - -

例子5:
	div1.style.width = div2.style.width
	div1.style.height > div1.style.height
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow:auto, div1.overflow = auto
	由于, div2.overflow:auto；所以 div3 没有直接溢出,而是隐藏在 div2 未显示的区域,
	div2会多出一个 scrollbar, 滑动可以继续看到div3未显示的内容.,div2隐藏的区域的 background 依然是 div2 的background
	然而 div2 比 div1 高,div2 的 scrollbar 在 div2底部, 属于是溢出的部分
	div3 溢出但处在div2的 隐藏区,所以没有溢出到 div1
	div2 溢出, 但是 div1.overflow = auto ,所以, div2溢出部分显示在 div1 的隐藏区, 
	div1会多出一个scrollbar, 滑动可看 div2 的隐藏部分! 
	所以 div1 的隐藏区只用 div2的溢出部分, 没有div3 的 !!!
	所以 body上 只看到 div1 ,
	但是 滑动 div1 的scroll 才可以看到 div2 的scroll, 滑动 div2的 scroll, 才可以看到隐藏的 div3 部分
------------------div1----------------------------------
|-------------------div2-----------------------------  | - - - - - - - - -
||---------------------div3-------------------------|--|----------------- |
|||                                                 |  |                |
||--------------------------------------------------|--|----------------- |
||                                                  | d|
||---------------------div4--------------------     | i|                  |
|||                                           |     | v|
|||                                           |     | 1|                  |
||---------------------------------------------     | s|
||                                                  | c|                  |
||                                                  | r|
||                                                  | o|                  |
||                                                  | l|
||                                                  | l|                  |
||                                                  |  |
--------------------------------------------------------                  |
 |                                                  |  |
||                                                  |                     |
 |                                                  |  |
||                                                  |                     |
 | ===========div2scroll===========                 |  |
|---------------------------------------------------- - - - - - - - - - - -
                                                       |
- - - - - - - - - - - - - - - - - - - - - - - - - - - -

例子6:
	div1.style.width = div2.style.width
	div1.style.height > div1.style.height
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow:auto, div1.overflow = none
	由于, div2.overflow:auto；所以 div3 没有直接溢出,而是隐藏在 div2 未显示的区域,
	div2会多出一个 scrollbar, 滑动可以继续看到div3未显示的内容.,div2隐藏的区域的 background 依然是 div2 的background
	然而 div2 比 div1 高,div2 的 scrollbar 在 div2底部, 属于是溢出的部分
	div3 溢出但处在div2的 隐藏区,所以没有溢出到 div1
	div2 溢出, div1.overflow = none ,所以, div2 直接溢出到 body  
	所以 body上 能看到 div1 , 还能看到 溢出的 div2
	但是 直接滑动溢出显示 div2 的scroll 可以看到隐藏的 div3 部分
------------------div1--------------------------------
|-------------------div2-----------------------------| - - - - - - - - -
||---------------------div3-------------------------||----------------- |
|||                                                 ||                |
||--------------------------------------------------||----------------- |
||                                                  ||
||---------------------div4--------------------     ||                  |
|||                                           |     ||
|||                                           |     ||                  |
||---------------------------------------------     ||
||                                                  ||                  |
||                                                  ||
||                                                  ||                  |
||                                                  ||
||                                                  ||                  |
||                                                  ||
------------------------------------------------------                  |
 |                                                  |
 |                                                  |                   |
 |                                                  |
 |                                                  |                   |
 | ===========div2scroll===========                 |
 ---------------------------------------------------- - - - - - - - - - -

例子7: (最后讨论下 hidden, hidden 和 auto 就差是否多了个scrollbar的问题!!) 
	div1.style.width = div2.style.width
	div3.style.width = 400px > div2.style.width
	div4.style.width = 200px < div2.style.width
	div2.overflow:hidden, div1.overflow = none
	由于, div2.overflow:hidden；所以 div3 没有直接溢出,而是隐藏在 div2 未显示的区域,
	div2并不会多出一个 scrollbar, 所以永远无法看到 div2 的隐藏区, 永远无法看到 div3 隐藏在 div2 的溢出内容
	div3 没有直接溢出,所以不会溢出到 div1  
	所以 div1 上的内容 只有等尺寸的div2, 没有其他, 所以没有内容溢出 
	不管 div1.overflow:none 还是 auto, 都无所谓 
	所以 body上 只看到 div1 
	并且再无可能看到 div3 的隐藏的溢出内容
------------------div1--------------------------------
|-------------------div2-----------------------------| - - - - - - - - - 
||---------------------div3-------------------------||----------------- |
|||                                                 ||                | 
||--------------------------------------------------||----------------- |
||                                                  ||
||---------------------div4--------------------     ||                  |
|||                                           |     ||
|||                                           |     ||                  |
||---------------------------------------------     ||
||                                                  ||                  |
||                                                  ||
||                                                  ||                  |
||                                                  ||
||                                                  ||                  |
|----------------------------------------------------| - - - - - - - - -
------------------------------------------------------

最后:
	width 是 我们设置 的div 的 宽度
	scrollWidth : 是 div 还有隐藏内容的情况下, 所以内容,堆加所得到的 div 应该需要的 宽度!!

现在需要监视每一行, 当行内容太大,我们需要自动扩展行长度,而且所有行长度都需要一样!!
	onresize() 不行,只能监听窗口, window, body, 对 div 无动于衷
	MutationObserver : 好像对于 scrollWidth 什么的不起作用,只对可以显性的修改有感应!!, 甚至对 style的改变无动于衷.
	好像没有什么简单方法监听 scrollwidth ,
	所以目前 折中方法是 使用 body onresize  先设置一下style.width = 600px, 然后在设置成 可获得的 scrollWidth
	之所以 先 style.width = 600px 是因为, width永远只会 >= scrollWidth 如果直接设 scrollWidth,后面的width只会越来越大,不会变小.

最后 附加内容:
	如何隐藏 滑动条 又可以滑动:
	css{  scrollbar-width:none; } 可以实现
	此外: scrollbar-width:thin; 滚动条变细

position 和 zindex: 层遮罩问题: 层遮罩关系 与 index 和 元素所在的 父子关系有关
	例子
	<style>
		.gg{width:40px; height:40px; padding:5px;}
		.ww{width:40px; height:60px; padding:5px;}
		.oo{position:relative; z-index:10;}
		.pp{position:relative; z-index:11;}
	</style>	
	<body>
	<div id='1' class='gg' style="background:red;">
	  <div id='2' class='gg' style="background:green;">
	    <div id='3' class='gg ' style="background:yellow;">
	      <div id='4' class='gg ' style="background:gray;"></div>
	    </div>
	  </div>
	</div>
	<div id='5' class='gg' style="background:blue;">
	  <div id='6' class='gg' style="background:pink;">
	    <div id='7' class='gg' style="background:orange;"></div>
	  </div>
	</div>
	<div id='8' class='gg' style="background:purple;"></div>
	<div id='9' class='gg' style="background:brown;"></div>
	</body>	
	没有 设置zindex! 对应 层遮关系!!  先弟层遮兄层, 再子层遮父层,
         ----------
         |1 ----------
         |  |2 ----------
         |  |  |3 ----------
         |  |  |  |4       |
         |  |  |  |        |
         ----------        |
         |5 ----------     |
         |  |6 ----------  |
         |  |  |7       |---
         |  |  |        |
         |  |  |        |       
         ----------     |
         |8       |     |
         |        |------
         |        |      
         |        |
         |        |
         ----------
         |9       |
         |        |
         |        |      
         |        |
         |        |
         ----------
	如果 id:2 => class='gg oo'
         ----------
         |1 ----------
         |  |2 ----------
         |  |  |3 ----------
         |  |  |  |4       |
         |  |  |  |        |
         ---|  |  |        |
         |5 ---|  |        |
         |  |6 ---|        |
         |  |  |7 ----------
         |  |  |        |
         |  |  |        |       
         ----------     |
         |8       |     |
         |        |------
         |        |      
         |        |
         |        |
         ----------
         |9       |
         |        |
         |        |      
         |        |
         |        |
         ----------
		此时, 2层如果面积足够大,会发现其在 56789 层之上,即遮住了56789, 
		而 34 在 2之上
	如果 id:2,6 => class='gg oo'
	或者: 如果 id:2,6,3,4 => class='gg oo'
         ----------
         |1 ----------
         |  |2 ----------
         |  |  |3 ----------
         |  |  |  |4       |
         |  |  |  |        |
         ---|  |  |        |
         |5 ----------     |
         |  |6 ----------  |
         |  |  |7       |---
         |  |  |        |
         |  |  |        |       
         ---|  |        |
         |8 ---|        |
         |     ----------
         |        |      
         |        |
         |        |
         ----------
         |9       |
         |        |
         |        |      
         |        |
         |        |
         ----------	 
		id:2,6 => class='gg oo' :
			6 和 2 同一阶zindex:10, 但是<body> 中 6晚于2的位置, 所以 6 遮住 2,
			注意: 6遮住了整个2, 即 6也遮住了34, 自然 7 也遮住了 34
		id:2,6,3,4 => class='gg oo'
			6 和 2 同一阶zindex:10, 但是<body> 中 6晚于2的位置, 所以 6 遮住 2,
			3 是在 2 的基础上的二阶 zindex:10, 4 是在3 的基础上的三阶 zindex:10
			即使这样, 34依然是 2 的范畴, 6 遮住整个2 即 6依然遮住了34,

	如果 id:2,7 => class='gg oo'
	或者:如果 id:2,7,3,4 => class='gg oo'   
         ----------
         |1 ----------
         |  |2 ----------
         |  |  |3 ----------
         |  |  |  |4       |
         |  |  |  |        |
         ---|  |  |        |
         |5 ---|  |        |
         |  |6 ----------  |
         |  |  |7       |---
         |  |  |        |
         |  |  |        |       
         ----------     |
         |8       |     |
         |        |------
         |        |      
         |        |
         |        |
         ----------
         |9       |
         |        |
         |        |      
         |        |
         |        |
         ----------	
		id:2,7 => class='gg oo'   	
			注意: 此刻 7 和 2 也是同一阶 zindex:10, 因为他们是在 <body> 的基础上的,
			7 晚于 2 出现
			尽管 234 遮住了 6, 但是 7 还是遮住了234 
		id:2,7,3,4 => class='gg oo'   
			此刻 7 和 2 也是同一阶 zindex:10, 因为他们是在 <body> 的基础上的, 7 晚于 2 出现
			3 是在 2 的基础上的二阶 zindex:10, 4 是在3 的基础上的三阶 zindex:10
			但是 7 是遮住整个 2的
			所以即使 234 遮住了 6, 但是 7 还是遮住了234 
	如果 id:2 => class='gg pp' id:7 => class='gg oo'
         ----------
         |1 ----------
         |  |2 ----------
         |  |  |3 ----------
         |  |  |  |4       |
         |  |  |  |        |
         ---|  |  |        |
         |5 ---|  |        |
         |  |6 ---|        |
         |  |  |7 ----------
         |  |  |        |
         |  |  |        |       
         ------|        |
         |8    |        |
         |     ----------
         |        |      
         |        |
         |        |
         ----------
         |9       |
         |        |
         |        |      
         |        |
         |        |
         ----------	
		注意: 此刻 7 和 2 也是同一阶, 因为他们是在 <body> 的基础上的, 7:zindex10 2:zindex11
		虽然同阶 zindex, 但是 2的zindex11 > 7的zindex10,
		所以 2 遮住了 7 , 自然, 34 也遮住了 7

	层遮关系与 position = fixed relative absolute 没有关系,而是与 zindex 和设置zindex的位置有关,
	不过要设置 zindex, 就得指定一个 position 先
	复杂的关系,如果难以观察,可以把上述代码放入在线编辑器做实验测试










20190528
瀑布流加载: 下拉滑动加载!!! 这个也是重点!!!
网上的都不可用,还是自己处理一下,
合并性能测试, 加载 36个块, 使用动态js加载!!!, 不直接写静态代码了!!
36个同时 resize!!

下一步,都扩张到一页含有 20000行数据 其中可编辑的3000行 !! 
测试 30000 行 30个块 resize 超有压力,即使没有加上自己的设置,运行起来超有压力!!
还要优化 按行跳转问题!! 输入一行号, 如何快速跳转到指定行!!
一个人速读3万行 最快需要34分钟!!

添加 tooltip 首先,不使用 react 的 tooltip!!!
使用仅 css 的 tooltip, 但是 由于 position 和 overflow 显示冲突问题总是无法解决!!
使用 js tooltip,看来层级解构超级麻烦, 程序员都推荐 popper 轻量级架构

去你妹 popper 没有使用案例都不知到怎么使用:
https://www.cnblogs.com/WhiteHorseIsNotHorse/p/7739267.html
https://github.com/FezVrasta/popper.js
https://popper.js.org/popper-documentation.html#Popper.enableEventListeners
popper 这个插件相当的不友好!! 没有案例 根本不知道如何入手,只有一堆不知道怎么用的 api 说明问道
所以以下是相当值得参考的常用经验:
	主要到 由于复杂的 position 和 z-Index 造成 便签不一定嫩够显示在顶层, 所以 便签 一般要 写到最外层,
	<body>
	.... 
	<div class="mypopper" onClick="hidd()" style="margin-left:20px; width:100px; height:100px; border-style: dotted; border-color: white;  border-width: medium; background:#444; display:block;" > helloworld </div>
	....
	</body>
	当一个标签绑到一个锚点时候, 标签所在层不变,即所在的显示层不变,只是标签绑到与 锚点的相对位置上来.
	然后是添加便签的猫点 reference 可以随便哪层,随便position和zindex都没有关系, 不会影响便签的顶层显示
	然后写js
	<script>
	var ptu		//设置一个全局变量
	(function tooltipinit(){	//初始化一个 popper ,通过局部函数来执行!! 并立即执行的

		var refel = document.querySelector('.mytooltip')	//获得猫点
		var popper = document.querySelector('.mypopper')	//获得 popper 标签块
		ptu = new Popper(refel, popper,{			//新建一个popper obj 
			placement: 'right',				//标签在锚点右侧
			removeOnDestroy: true,   // 去掉popper 顺便把对应div也去掉了!!	//删除 这个obj时,是否把 标签块div.mypopper也删掉
			offset: '30px',		 // 其实不知道是否这样用,貌似没有效果
			modifiers: {
	    			preventOverflow: { enabled: true},	//拖动的时候, 标签块不超出所在层边界!!
				offset: {offset:0, enabled: true},	//如果placement是left,right,这里设置的是上下偏移
				computeStyle: {enabled:true, }		//不会用,貌似没有效果
	 		},
		})
		//console.log(uiy);
	  	  //sleep(10000);
		//ptu.destory()
	})();
			
	function hidd (){
		ptu.destroy()	//这个是一个按钮的事件函数 去除popper obj ,连绑定的popper标签块也去掉
	}
	</script>
	关于 ptu.destroy() 应该说关于 popper.destory 的设定都很奇怪,如果ptu = new popper() 是在全局空间执行的初始化
	那么,就不一定 后面那个地方要执行 ptu.destroy()会出现各种问题, 要么是 ptu undefinded, 要么是ptu.destroy not a function!!	
tooltip的问题勉强算是解决了

deepfake 训练: (ai_learn) ~/AI/deepfate/faceswap$ python faceswap.py train -A ../qiaobenhuannai/data -B ../xinyuanjieyi/data -m ../q2x -p













20190531
接下来是 定位问题!!
按某按键, scroll到某地方, 首先对 scrollWidth, clientWidth, offsetWidth的区别:
-----------------------------------
|                               |^|
|                               |#|
|abcdefghijklmnopqrstuvwxyz,1234|#|
|                               |#|
|                               |#|
|                               | |
|                               | |
|                               | |
|                               | |
|-------------------------------| |
|<    #########                >|v|
-----------------------------------

|        clientWidth            | |
|                                 | 
|            offsetWidth          |
|                                 |                          
|abcdefghijklmnopqrstuvwxyz,1234567890,一二三四五六七八九是十| 
|                                                           |
|                       scrollWidth                         |

但是当内容 没有超出框外,水平滑动条没有生效, scrollWidth 等于 clientWidth 那样短
同理 应用于 scrollHeight, clientHeight, offsetHeight,


不过有新的解读!!!!! width height

	---------------------------------------------------------      
	|                  外边距 margin (空白透明)              |       
	|      ------ 边框 border (线,点,透明)--------------     | ---------------------------------------------------------- 
	|      |           内边距 padding (空白透明)       |     |                       
	|      |      ----------宽 width -----------      |     |                                     scrollHeight：      可
	|      |      |                            |      |     |                                   获取指定标签内容层     视
	|      |      |                            高     |     |  clientHeigh     offsetHeith         的真实高度          化
	|      |      |         element          height   |     |      =                =           （可视区域高度）       高
	|      |      |                            |      |     |    height        clientHeigh       +被隐藏区域高度       度
	|      |      |                            |      |     |      +                +
	|      |      |                            |      |     |  U.D padding     上下boder厚度
	|      |      ------------------------------      |     |
	|      |                                          |     |
	|      |                                          |     |
	|      --------------------------------------------     | -----------------------------                -------------
	|                                                       |                                                         被
	|                                                       |                                                         隐
        ---------------------------------------------------------                                                         藏
               |                                          |                                                               区
               |     clientWidth = width + L.R padding    |                                                               域
               | offsetWidth = clientWidth + 左右boder厚度 |                                                               高             
               |                                                                                                          度
               |                                                                                -----------------------------
               |                                           
	       | scrollWidth：获取指定标签内容层的真实宽度, 可视区域宽度 + 被隐藏区域宽度 |
               |          可视区域宽度                     |     被隐藏区域宽度          |
clientXXXX 其实就是 border 内所有可视区域,如果有滑动条,并不算入滑动条!!!, (不要被padding 和 滑动条疑惑 的冲突所迷惑)
注意到如果出现滑动条, width height padding 并没有改变,所以border也没有改变, 滑动条存在与可视区域的右方,下方,
因为要扣除滑动条宽度!!,使得可视区域有所缩小,所以 clientXXXX 也变小!!!

继续上图解释 clientLeft  offsetTop clientLeft clientTop

              --------------父border----------------------      ----------
              |                                          |        子div offsetTop = 子 div 上边框外边缘
              |      父div                               |	     到 最近的已定位父级（offsetParent)
              |                                          |           的上边框 内边缘的 距离
              |        --------子border---------         |	---- -----
              |        |                       |         |         |
              |        |                       |         |         v
              |        |                       |         |     clientTop = boder.top(上边框的宽度)
              |        |                       |         |
              |        |                       |         |
              |        |                       |         |
              |        -------------------------         |
              |                                          |
              |                                          |
              |                                          |
              --------------------------------------------

                       |
                       |
                  (clientLeft = boder.left(左边框的宽度) )                                     
              |        |
              |        |
            子div offsetLeft = 当前元素 左边框外边缘 到 最近的已定位父级（offsetParent）左边框 内边缘的 距离

	特别注意: 实际上 子div offsetTop offsetLeft 是固定值!!! 实际上,是跟真实内容的位置有关
	如果完全跟 父div border有关,那么  的 offsetTop offsetLeft 是一个变量, 因为滑动时, 父子div的border距离在变化 
	再次强调 子div offsetTop offsetLeft 是固定值!! 上图是特例情况 !
	如下图解析:


             ------------------------------------------------------------------------------ --------
             |                                                                            |
             |     父div的真实内容 paddding + width + height                               |	   子div offsetTop =
             |                                                                            |    已定位父级（offsetParent）的父div 
             |                       ------------父div border------------------           |	   真实内容层顶部下边缘
             |     这时被隐藏         |          父div的真实内容               |           |              到
             |                       |            显示的区域                   |           |	子 div 上边框外边缘 的距离       
             |                       |                                        |           |
             |     未显示的区域       |         --------------------------     |           | ------->子div在父div真实内容具体Y位置
             |                       |         |    子div 内容          |     |           |
             |                       |         |                        |     |           |
             |                       |         |                        |     |           |
             |                       |         |                        |     |           |
             |                       |         |                        |     |           |
             |                       |         |                        |     |           |
             |                       |         ------子div border--------     |           |
             |                       |                                        |           |
             |                       |                                        |           |
             |                       |                                        |           |
             |                       ------------------------------------------           |
             |                                                                            |
             |                                                                            |
             |                                                                            |
             ------------------------------------------------------------------------------
             |                                 |
	     |                                 |
                    子div  offsetLeft =  
             最近的已定位父级（offsetParent）真实内容层左部分 内边缘的 
			   到
		      子div 左边框外边缘
			 的距离




最后 还有 scrollTop   scrollleft


              ------------------------------------------------  ------
              |                                              |		内容层顶部 到 
              |                                              |         可视区域顶部的距离。
              |                                              |  
              |                                              |
              |                     -----------border---------  ------
              |                     |                        |
              |                     |                        |
              |      真实内容       |                        |
              |                     |                        |
              |                     |                        |
              |                     |                        |
              |                     |                        |
              |                     |                        |
              |                     --------------------------
              |                                              |
              |                                              |
              |                                              |
              |                                              |
              ------------------------------------------------
              |                     |
              |                     |
	 scrollLeft:内容层左端 到 可视区域左端的距离.
注意,内容层包括 psdding + 真实width,真实height
可视区是 border内, 扣除滑动条宽度!!!!! 即clientWidth*clientHeight



然后 滑动问题: 
	scrollTo (x,y)	滑到指定位置, 没有滑动效果,主要是闪到
	scrollTo ({top: 500,  behavior: "smooth" }) 滑到 y 指定位置,有滑动动画
	scrollTo ({left: 100,  behavior: "smooth" }) 滑到 x 指定位置,有滑动动画

https://blog.csdn.net/rickykay/article/details/51094745 直滚动条定位到子 Div 的位置 jquery,
<html>
    /* 头部代码 */
    <body>
        <div id="divBox">
            <div id="test1"></div>
            <div id="test2"></div>
            <div id="test3"></div>
            <div id="test4"></div>
            <div id="test5"></div>
            <div id="test6"></div>
            <div id="test7"></div>
        </div>
    </body>
</html>

$('#divBox').scrollTop($('#test6').offset().top);

根据上述知识,scrollTo 到指定位置不是什么难事: 
		let vblk
                let blk
		vblk = document.getElementById('viewblock')	//获得 父div
		//blk = document.getElementById('BrowseBlock-10')   
		blk = document.getElementById('EditBlock')     //获得 子div
		//console.log( blk.offsetParent)	//查看 子div 的 offsetParent 是不是 viewblock 父div
		//blk.offsetParent = vblk		//一般直接在父div 下的子div,没有特变position设定 offsetParent默认是这个最近父div
		let leth = blk.offsetTop
		console.log (leth, vblk.scrollTop, e.offsetX, e.offsetY)
		vblk.scrollTo ({top: leth, behavior: "smooth"})
			//这时 子div的 offsetTop 是 A, 父div的scrollTop 为 A 的地方存在的就是子div
			//所以父div scrollTo 到 A 就是 滑到了 子div

点击 一个 div , 点击位置处于这个div 上,
	相对于这个div左上角的 width:0 height:0 为原点 
	的坐标为 event.offsetX  event.offsetY 可以直接读出,
	并不需要额外 计算获取
	注意坐标原点, 是div width:0 height:0 处,
	不是padding上,不是padding左上角,
	不是bodder上,不是border左上角!!!!

发现 scrollTo 一样触发 onscroll!!, 这就比较讨厌了
	如何兼容  上下拉都不过底,是重点问题!!
	如果通过scrollTop来判断,当 browseblk 高度小于屏幕又如何处理,,,, 













20190608
popper 的 protptype 的函数 问题
destory 无法运行, 这个问题 需要重视并解决
还有 react 的 jsx 传递event 到事件函数的方法!!
jsx 传递 event参数:
	<antd.Button type="primary" onClick={thu.bind(this)} >Primary</antd.Button>
	注意这个 thu 不是 react 模块本身的函数 ,而是全局的函数
	这样翻译成 html就变成:
	<antd.Button type="primary" onClick="thu(event)" >Primary</antd.Button>
至于popper 的 protptype 的函数 问题:
	一开始以为缺少 popper.min.js.map, 结果补上了还是错
	不知道为什么就是找不到 destory, 很肯定 这个 prototype 函数是 popper.js 里就有的
	没有办法,用粗暴的手段: 不管 destory 方法了!!
	对应的 popper 对象, delete ptu['bblktt'+ num]  直接删掉 字典对象
	然后 document.getElementById('bblk-t-'+num).remove() 直接删掉对应的 html <div>块
然后也做了验证 prototype 浏览器的确能用, 真的不知道 popper 的destory 为什么弄不了

	function Person(name)
	{
		this.name = name;
	}
	
	Person.prototype.say = function()
	{
		alert(this.name);
	}	

	var tom = new Person("tom");
	tom.say();
	var tmp = Person.prototype;
	tmp.boss="dived";
	alert(tom.boss);
	tom.say();
	tom.hasCar = "Andi";
	tom.sayCar = function()
	{
		alert(this.name+this.hasCar);
	};
	tom.sayCar(); 














20190610
重整 react 架构,及继续深入 react 学习:
首先是 jxs render(算是虚拟DOM技术) 和 实体 DOM 混用的 较量!!!
	不要同时 使用 实体DOM方法 和 虚拟DOM方法 混合修改 实体DOM同一属性
	例子:
	class Topsearch extends React.Component {
	.....
		closeS = () =>{
			this.setState({ visible: false, });
		};

		const visibleStyle = {
		width:'100%', 
		display: this.state.visible ? 'block' : 'none',
		};

		const { dataSource } = this.state;
		return (
			<div id='topsch' style={visibleStyle}>
				.....
				<antd.Button  size="large" style={{width: 40, }} type="primary" icon="close" onClick={this.closeS}/>
			.....
			</div>
	}
	以上 是一个 react 虚拟DOM例子, onclick,通过 setstate, 影响 css 改变 display 的值!!!  
	但当 某个js 实体DOM修改 这个对象的函数时, 
		document.getElementById('topsch').style.display = 'none'
	再次 使用 react 虚拟DOM 来修改,就不行了.
	因为, 实体DOM 的修改污染了这个react渲染的模块,之后只能一直使用实体DOM 修改,而无法使用 虚拟DOM修改!!!
虚拟DOM 实现 事件函数即参数的传递!!
	function thu (e) {
	......	
	}

	jxs:
    	<antd.Button type="primary" onClick={thu.bind(this)} >Primary</antd.Button>
	
	事实上,通过 bind(this) 后 就可以传递 event 参数 






?????????????????????????????????????
工作小结:
	写出了html范本,基本构建富文本内容方式(未完善),(test1.html, base.js, body.css)
	第一版,纯文本 test1.js 搭配 test1.html 这句
<body>
	<div Id="editor" contenteditable="true" onKeypress="ifenter(event)" onKeydown="ifdown(event)" onKeyUp="ifup(event)"><div>1:</div></div>
</body>
	第二版,加入媒体行!!
	后来发现超过1000行,处理速度就开始卡了, 先尝试优化,不行的话,就使用框选编译方式,
	开始设计数据库和表单!!!
		发现还要添加的内容:
		spac 禁止中文输入问题!!
		关于上传文件的规范,要筛选处理,涉及安全,不能什么文件都能传
	第三版,(未开始)
	所谓框选:
			--------------
			.            .
			.            .
			|            |
			|            |
			|            |
		      ------------------
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      |                |
		      ------------------
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			|            |
			.            .
			.            .
			--------------


设计:
1,每行都有行号,行号前有标记色 
	每一行前的标记色,新建, 修改, 换行! 无操作, 某行内容既换行,又修改时,设为修改色 
	行号标记色点击可以选择该行的编辑内容,即行内容变换填充!!
	前端显示: cnteid 和 oid 的分配就是不用在前端做了,放到后端 !!
	orgl : transparency cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	newl : yellow cnteid:0, oid:0
	svdl : green cnteid:0(空行)/cnteid:xx(非空行), oid:yy  (>=0)
	wrpl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
	fixl : orange cnteid:0(空行)/cnteid:xx(非空行), oid:yy (>=0)
2,回车, 退格键,方向键, 粘贴组合键, tab键, 方向左键, 还有鼠标点击  
	回车要自动添加新行号,转行,回车后字符串处理, 修改标记色和id,
		注意多媒体行无法使用回车, 相邻多媒体行中间插入行操作放入cntebar里
	tab按键:当在一个div里只有文字才能完美实现距离问题,和缩进!!
	退格键:不能退到行号处!!
	方向键, 上下左右都要处理!!(只能捕捉并跳到 edtx 区!!,禁止出现在其他区域!!)
3,公式编写,使用的一个开源库: JMEditor: http://www.html580.com/11952
4,五线谱
	使用 vextab 掌握 多段谱,而不是一段谱

??,显示尺寸问题!!缩放网页时,
	公式 直接设置 style="font-size:80px;"
	五线谱:  artist = new Artist(10, 10, 1000, {scale: 0.8});
		10 和 10 都是位置偏移
		1000是长度
		{scale: 0.8} 是 高度 0 ~ 无穷

?? 多媒体行的间隔问题处理, spec 除了只允许输入空格,允许左右方向键 和上下方向按键 但是中文输入法可以突破输入的问题(未解决)
	
??,定时 触发事件!!! 还有流文件上传事件!! 浮动按钮 ,	

??,输入日期格式 例如 20180819 ,自动成为标题数据.可以手动改回文本数据

??,批量 定位 增删内容
	保守加载的内容有10万行内容,浏览器压力会非常大,所以,应该提供批量功能
	另外,提供右下角统计数据 滑动鼠标时显示已经加载的 行数据数 起始行-结束行:一共行数
??,页面
	用户主页是编辑页面
	搜索主页可调,一般是详细博客或者关键字博客嵌套页面
	关注人页面是,详细博客嵌套页面
	其他页面!!(科研小说教育..)
	主题发展
3,行号数据表 与 数据实体数据表
	具体 数据条放在独立的数据表里, 每条数据条都有独立的序号 conteid
	行号 放在独立的数据表里, 行号数据保存 对应的conteid 指向具体数据
	流媒体数据 放在另外独立的数据表里. 提供url访问 当
		流媒体数据先上传到数据库,生成链接供行号指向,没有行号指向的流媒体文件,一个月后会被物理清除,不可修复!! 
	数据条类型:
		空数据(特殊的文本数据 cntety:1), cnteid 指定为0 (其他每行用户数据各占一个独立的cnteid)
		另外前 256 个 cnteid 保留 为各种衍生功能标记做预留,例如识别代码段实时调试
		文本数据, cntety:1 
		图片数据, cntety:2 可以多个 ( 图片url + 图片加密编码字符串 + 缩略图 + 间隔数) 多个之间可以添加空格手动控制间隔
		数学公式, cntety:3 可以多个 ( 文本数据 + 间隔数 )  多个之间可以添加空格手动控制间隔 
		音频数据, cntety:4 单个 (音频url + 音频加密编码字符串 + 音频片段/降码音频)
		视频数据, cntety:5 单个 (视频url + 视频加密编码字符串 + 视频裁剪缩略采样)
		五线谱,   cntety:6 其实是纯文本,就是 vextab 语言纯文本
	 	主题,     cntety:7 数据(推荐时间日期 + 简单标题 + 收藏数/注水数 间隔数 )
			前端显示 推荐时间日期 + 间隔 + 简单标题 + 收藏数/注水数星号(收藏数/注水数) + 扩展按钮
		(扩展文本数据,可以标记超链接和 v2.0再考虑如何改,)
	mmedl:生成数据行
		如果该行为 newl, 则 更改时  cnteid 不改
		如果 其他xxxl 行数据变其他类型数据时 cnteid 设新id
		这种修改机制会 很容易 浪费许多孤立cnteid 即么中间的一些cnteid没有内容,没有行号指向
		所以(后期要做一个回收表!!) 
??,时间信任保存
	所有流媒体内容 经过sha加密  行数据内容是 缩略图/音频片段 + 链接 + 256位加密码,
		其中   缩略图/音频片段 + 256位加密码, 计入保存时间加密, 链接不计入!!
	文本类内容(包括五线谱编码) 经过sha加密  行数据内容就是 文本内容!! 直接计入保存时间加密,
	每行内容都有最后的修改日期!! 不过这条信息只有作者可看,运营方可看.
	依照政策删除敏感内容后造成 保存链断裂 导致的 发布事件时间信任度问题
	五线谱内容可以显示每次更新的内容!!状态!!
	先不考虑完美的 保存链算法, 先简单实现产品,所以重点先在于确定哪些内容才是需要写进数据库的内容!!!!
??,收藏推广
	可以关注别人,不设立粉丝
	星号是 实名收藏为收藏数, 匿名收藏为注水数,注水数每季度清零一清,
	用户实名收藏记录永久, 匿名收藏记录 半年一清
??,举报 与 依照政策删除敏感内容
	初步通知 出版者 让其主动修改或删除或不作为
	若鉴别为真犯规,
		方案一,要求主动删除,替换内容,不然,强制注销账户
		方案二,运营方直接删除
		这些删除涉及真正的物理删除, 会造成其他用户的时间信任保存链断裂
		所以运营方应该设计并仅运营方拥有的一个特殊的亢余数据库来修补 其他用户的时间信任保存链断裂的 问题!
		当亢余数据库非常大,必须做修正工作,记录每一位涉及的用户!! 给出他们一个重新编排时间信任保存链的权利
??,首先做一个网页模板方案一:
	/////////////////////////////////////////文本
	<div class="edit" cnteid="0" cntety="1"><span class="newl">&nbsp;</span><span class="lid" oid="0">1087:</span><div class="edtx">	我有一只船<br></div></div>
	/////////////////////////////////////////标题
	<div class="hdty" cnteid="0" cntety="7"><span class="newl">&nbsp;</span><span class="lid" oid="0" style="font-size:0.84em; font-weight:normal;">1085:</span>
		<div class="hdda">20181001</div>
		<div class="spac">          </div>
		<div class="hdti">今天我背了一首诗</div>
		<div class="hdcr" contenteditable="false">
			<div class="rlik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:yellow;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>			
			</div>
			<div class="rlikn">0</div>
			<div class="flik">
				<svg class="hdcr-svg" viewBox="0 0 14 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:grey;stroke:white;" d="M14 6l-4.9-.64L7 1 4.9 5.36 0 6l3.6 3.26L2.67 14 7 11.67 11.33 14l-.93-4.74L14 6z"></path></svg>
			</div>
			<div class="flikn">0</div>
			<div class="othrc">
				<svg class="hdcr-svg" viewBox="0 0 12 16" version="1.1" width="60px" height="60px" aria-hidden="true"><path fill-rule="evenodd" style="fill:#aaa;stroke:white;" d="M12 9H7v5H5V9H0V7h5V2h2v5h5v2z"></path></svg>		
			</div>
		</div>
	</div>
	/////////////////////////////////////////图片
	<div class="imgt" cnteid="432" cntety="2" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="16">1064:</span>
		<div class="imgd">
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/eye_expression.gif" alt="pic error">
				<div class="imgi" contenteditable="true">sharp
eye</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="igdd">
				<img class="imgs" src="/static/img/child.gif" alt="pic error">
				<div class="imgi" contenteditable="true">child</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////视频
	<div class="vido" cnteid="600" cntety="5" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="19">1070:</span>
		<div class="vidd">
			<video controls="" width="320" height="240">
				<source src="/static/video/movie.mp4" type="video/mp4">
			</video>
			<div class="vidi" contenteditable="true">amimal</div>		
		</div>
	</div>
	/////////////////////////////////////////音频
	<div class="adio" cnteid="0" cntety="4" contenteditable="false"><span class="newl">&nbsp;</span><span class="lid" oid="0">1068:</span>
		<div class="adod">
			<audio src="/static/music/yuxuanji.mp3" controls=""></audio>
			<div class="adoi" contenteditable="true">Hanser-鱼玄机</div>		
		</div>
	</div>
	/////////////////////////////////////////乐谱
	<div class="stav" cnteid="694" cntety="6" contenteditable="false"><span class="wrpl">&nbsp;</span><span class="lid" oid="23">1074:</span>
		<div class="stad">
			<div style="white-space:pre; display:none;">
<textarea class="vex-tab-editor">options space=20 player=true  tempo=80
tabstave
  notation=true
  key=A time=4/4

  notes :q =|: (5/2.5/3.7/4) :8 7-5h6/3 ^3^ 5h6-7/5 ^3^ :q 7V/4 |
  notes :8 t12p7/4 s5s3/4 :8 3s:16:5-7/5 :h p5/4
  text :w, |#segno, ,|, :hd, , #tr

</textarea>
        			<p id="errorTip" class="text-danger"></p>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div>
				<div class="tab-preview-container" style="margin-left:50px;">
					<canvas class="tabPreviewer"></canvas>
				</div>
			</div>
		</div>
	</div>
	/////////////////////////////////////////公式
	<div class="math" cnteid="683" cntety="3" contenteditable="false"><span class="fixl">&nbsp;</span><span class="lid" oid="18">1066:</span>
		<div class="matd">
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><big mathquill-command-id="43">∫</big><sub class="non-leaf limit" mathquill-command-id="45" mathquill-block-id="46" style="left: -0.25em;"><var mathquill-command-id="51">x</var><span mathquill-command-id="52" class="binary-operator">+</span><var mathquill-command-id="53">y</var></sub><sup class="non-leaf limit" mathquill-command-id="48" mathquill-block-id="49" style="left: -1.8125em; margin-right: -0.775em;"><var mathquill-command-id="55">x</var><sup class="non-leaf" mathquill-command-id="57" mathquill-block-id="58"><span mathquill-command-id="60">2</span></sup></sup><span class="fraction non-leaf" mathquill-command-id="61"><span class="numerator" mathquill-block-id="62"><var mathquill-command-id="73">y</var><sup class="non-leaf" mathquill-command-id="68" mathquill-block-id="69"><span mathquill-command-id="74">4</span><span mathquill-command-id="75" class="binary-operator">+</span><var mathquill-command-id="76">x</var></sup></span><span class="denominator" mathquill-block-id="63"><var mathquill-command-id="83">x</var><sub class="non-leaf" mathquill-command-id="85" mathquill-block-id="86"><var mathquill-command-id="89">i</var></sub></span><span style="display:inline-block;width:0">&nbsp;</span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function A</div>
			</div>
			<div class="spac" contenteditable="true">          </div>
			<div class="mtdd">
				<p><span class="mathquill-rendered-math" style="font-size:80px;"><span class="textarea"><textarea data-cke-editable="1" contenteditable="false"></textarea></span><sup class="nthroot non-leaf" mathquill-command-id="90" mathquill-block-id="91"><sup class="non-leaf" mathquill-command-id="127" mathquill-block-id="128"><var mathquill-command-id="135">x</var></sup><span mathquill-command-id="130">/</span><sub class="non-leaf" mathquill-command-id="132" mathquill-block-id="133"><var mathquill-command-id="136">y</var></sub></sup><span class="scaled" mathquill-command-id="90"><span class="sqrt-prefix scaled" style="transform: scale(1, 2.4);">√</span><span class="sqrt-stem non-leaf" mathquill-block-id="92"><span class="fraction non-leaf" mathquill-command-id="108"><span class="numerator" mathquill-block-id="109"><var mathquill-command-id="117">y</var><sup class="non-leaf" mathquill-command-id="114" mathquill-block-id="115"><var mathquill-command-id="118">x</var></sup></span><span class="denominator" mathquill-block-id="110"><var mathquill-command-id="125">z</var><sup class="non-leaf" mathquill-command-id="122" mathquill-block-id="123"><var mathquill-command-id="126">y</var></sup></span><span style="display:inline-block;width:0">&nbsp;</span></span></span></span></span><span>&nbsp;</span><br></p>
				<div class="mati" contenteditable="true">function B</div>		
			</div>
		</div>	
	</div>


stattb日更新与新用户驻点注册的并发问题:
	19号累计 100个用户注册
	比如20号前一刻 A用户注册 19号的用户,
	20号到的那刻 statetb更新 20号 ,显示累计100个用户,
	而 A 注册成功后 19号实际上 是累计 101 个 用户, 但新的20号却漏了A,只统计出100个
	想到的办法有:
		比如 设计 0点 到0点15分,禁止用户注册, 在 3分到 10分处才开始更新statetb!
 	或者,0点时,键 20号数据时,不统计累计用户数,
		0点一刻时才统计累计用户数!!

??点星需要新表, 
	hdty 自身需要添加一个唯一识别串
	然后添加一张点赞表,保存 每条 hdty 的点赞数!!!
	hdty内容更改,点赞数数据重置 !!! 

??修要重构通过显示框架,显示发展过程中变化的结构!!1
	比如说,为了点星,突然添加 数据条需要增加新内容,跟旧版内容格式就冲突了!!!
	需要构思通用架构 满足 内容演变!!
	
??建立 浏览和编辑两区域!!
	编辑区默认显示1000行,并可以扩展到 5000行!!!
	浏览区一般不显示,除非拉伸到了,自动补充!!
	一人一生有 30000 X 1000 = 3000 0000 万行经验传世
	一年 有 365 X 1000 = 365000 万行
	超过100 0000行的省略百万行以后数字, 比如 712 3454
	


??,有待加入的功能:
	代码高亮识别!!(以后再说!!)




<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
开发_web_log 重要内容,因为涉及多机上传问题!!,所以未充分测试前不贸然实施
full_stack_note 暂时 通过 hp机 备份到 selfweb 项目上去
20180726
尝试使用第二部电脑 git 备份同一个项目!!
	例如之前再二手thinkpad做的 selfweb,整个文件夹拷贝到现在的 hp 上!!
	这时相当于把整个 git 配置也拷贝过来了,
	所以直接在 selfweb 输入命令:
		git add xxxx
		git commit -m "xxxx"
		git push origin master
		直接成功上传
不过注意!!!!!!!!!!
	注意 由于并没有完全尝试用两部电脑交替上传文件,
	因为,Apc 上传后得到的新节点, Bpc并不知道, bpc又上传时,因为不知情Apc的修改的内容而导致冲突!!!
	所以,只能在 不重要的 selfweb 项目上做好充分的交替上传测试,才允许其他大型项目的实施























